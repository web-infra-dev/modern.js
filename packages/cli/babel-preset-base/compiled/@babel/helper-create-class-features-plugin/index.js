(()=>{"use strict";var e={764:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t["default"]=annotateAsPure;var i=s(740);const{addComment:r}=i;const n="#__PURE__";const isPureAnnotated=({leadingComments:e})=>!!e&&e.some((e=>/[@#]__PURE__/.test(e.value)));function annotateAsPure(e){const t=e["node"]||e;if(isPureAnnotated(t)){return}r(t,"leading",n)}},922:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t.buildDecoratedClass=buildDecoratedClass;t.hasDecorators=hasDecorators;t.hasOwnDecorators=hasOwnDecorators;var i=s(718);var r=s(949);var n=s(988);function hasOwnDecorators(e){return!!(e.decorators&&e.decorators.length)}function hasDecorators(e){return hasOwnDecorators(e)||e.body.body.some(hasOwnDecorators)}function prop(e,t){if(!t)return null;return i.types.objectProperty(i.types.identifier(e),t)}function method(e,t){return i.types.objectMethod("method",i.types.identifier(e),[],i.types.blockStatement(t))}function takeDecorators(e){let t;if(e.decorators&&e.decorators.length>0){t=i.types.arrayExpression(e.decorators.map((e=>e.expression)))}e.decorators=undefined;return t}function getKey(e){if(e.computed){return e.key}else if(i.types.isIdentifier(e.key)){return i.types.stringLiteral(e.key.name)}else{return i.types.stringLiteral(String(e.key.value))}}function extractElementDescriptor(e,t,s,o){const a=o.isClassMethod();if(o.isPrivate()){throw o.buildCodeFrameError(`Private ${a?"methods":"fields"} in decorated classes are not supported yet.`)}if(o.node.type==="ClassAccessorProperty"){throw o.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`)}if(o.node.type==="StaticBlock"){throw o.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`)}const{node:l,scope:d}=o;new r.default({methodPath:o,objectRef:t,superRef:s,file:e,refToPreserve:t}).replace();const c=[prop("kind",i.types.stringLiteral(i.types.isClassMethod(l)?l.kind:"field")),prop("decorators",takeDecorators(l)),prop("static",l.static&&i.types.booleanLiteral(true)),prop("key",getKey(l))].filter(Boolean);if(i.types.isClassMethod(l)){const e=l.computed?null:l.key;i.types.toExpression(l);c.push(prop("value",(0,n.default)({node:l,id:e,scope:d})||l))}else if(i.types.isClassProperty(l)&&l.value){c.push(method("value",i.template.statements.ast`return ${l.value}`))}else{c.push(prop("value",d.buildUndefinedNode()))}o.remove();return i.types.objectExpression(c)}function addDecorateHelper(e){try{return e.addHelper("decorate")}catch(e){if(e.code==="BABEL_HELPER_UNKNOWN"){e.message+="\n  '@babel/plugin-transform-decorators' in non-legacy mode"+" requires '@babel/core' version ^7.0.2 and you appear to be using"+" an older version."}throw e}}function buildDecoratedClass(e,t,s,r){const{node:n,scope:o}=t;const a=o.generateUidIdentifier("initialize");const l=n.id&&t.isDeclaration();const d=t.isInStrictMode();const{superClass:c}=n;n.type="ClassDeclaration";if(!n.id)n.id=i.types.cloneNode(e);let p;if(c){p=o.generateUidIdentifierBasedOnNode(n.superClass,"super");n.superClass=p}const u=takeDecorators(n);const f=i.types.arrayExpression(s.filter((e=>!e.node.abstract&&e.node.type!=="TSIndexSignature")).map((e=>extractElementDescriptor(r,n.id,p,e))));const m=i.template.expression.ast`
    ${addDecorateHelper(r)}(
      ${u||i.types.nullLiteral()},
      function (${a}, ${c?i.types.cloneNode(p):null}) {
        ${n}
        return { F: ${i.types.cloneNode(n.id)}, d: ${f} };
      },
      ${c}
    )
  `;if(!d){m.arguments[1].body.directives.push(i.types.directive(i.types.directiveLiteral("use strict")))}let h=m;let b="arguments.1.body.body.0";if(l){h=i.template.statement.ast`let ${e} = ${m}`;b="declarations.0.init."+b}return{instanceNodes:[i.template.statement.ast`${i.types.cloneNode(a)}(this)`],wrapClass(e){e.replaceWith(h);return e.get(b)}}}},836:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t.FEATURES=void 0;t.enableFeature=enableFeature;t.isLoose=isLoose;t.shouldTransform=shouldTransform;var i=s(922);const r=Object.freeze({fields:1<<1,privateMethods:1<<2,decorators:1<<3,privateIn:1<<4,staticBlocks:1<<5});t.FEATURES=r;const n=new Map([[r.fields,"@babel/plugin-proposal-class-properties"],[r.privateMethods,"@babel/plugin-proposal-private-methods"],[r.privateIn,"@babel/plugin-proposal-private-property-in-object"]]);const o="@babel/plugin-class-features/featuresKey";const a="@babel/plugin-class-features/looseKey";const l="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function enableFeature(e,t,s){if(!hasFeature(e,t)||canIgnoreLoose(e,t)){e.set(o,e.get(o)|t);if(s==="#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"){setLoose(e,t,true);e.set(l,e.get(l)|t)}else if(s==="#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"){setLoose(e,t,false);e.set(l,e.get(l)|t)}else{setLoose(e,t,s)}}let i;let r;for(const[t,s]of n){if(!hasFeature(e,t))continue;const n=isLoose(e,t);if(canIgnoreLoose(e,t)){continue}else if(i===!n){throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, "+"@babel/plugin-proposal-private-methods and "+"@babel/plugin-proposal-private-property-in-object (when they are enabled).")}else{i=n;r=s}}if(i!==undefined){for(const[t,s]of n){if(hasFeature(e,t)&&isLoose(e,t)!==i){setLoose(e,t,i);console.warn(`Though the "loose" option was set to "${!i}" in your @babel/preset-env `+`config, it will not be used for ${s} since the "loose" mode option was set to `+`"${i}" for ${r}.\nThe "loose" option must be the `+`same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods `+`and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can `+`silence this warning by explicitly adding\n`+`\t["${s}", { "loose": ${i} }]\n`+`to the "plugins" section of your Babel config.`)}}}}function hasFeature(e,t){return!!(e.get(o)&t)}function isLoose(e,t){return!!(e.get(a)&t)}function setLoose(e,t,s){if(s)e.set(a,e.get(a)|t);else e.set(a,e.get(a)&~t);e.set(l,e.get(l)&~t)}function canIgnoreLoose(e,t){return!!(e.get(l)&t)}function shouldTransform(e,t){let s=null;let n=null;let o=null;let a=null;let l=null;if((0,i.hasOwnDecorators)(e.node)){s=e.get("decorators.0")}for(const t of e.get("body.body")){if(!s&&(0,i.hasOwnDecorators)(t.node)){s=t.get("decorators.0")}if(!n&&t.isClassProperty()){n=t}if(!o&&t.isClassPrivateProperty()){o=t}if(!a&&t.isClassPrivateMethod!=null&&t.isClassPrivateMethod()){a=t}if(!l&&t.isStaticBlock!=null&&t.isStaticBlock()){l=t}}if(s&&o){throw o.buildCodeFrameError("Private fields in decorated classes are not supported yet.")}if(s&&a){throw a.buildCodeFrameError("Private methods in decorated classes are not supported yet.")}if(s&&!hasFeature(t,r.decorators)){throw e.buildCodeFrameError("Decorators are not enabled."+"\nIf you are using "+'["@babel/plugin-proposal-decorators", { "legacy": true }], '+'make sure it comes *before* "@babel/plugin-proposal-class-properties" '+"and enable loose mode, like so:\n"+'\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n'+'\t["@babel/plugin-proposal-class-properties", { "loose": true }]')}if(a&&!hasFeature(t,r.privateMethods)){throw a.buildCodeFrameError("Class private methods are not enabled. "+"Please add `@babel/plugin-proposal-private-methods` to your configuration.")}if((n||o)&&!hasFeature(t,r.fields)&&!hasFeature(t,r.privateMethods)){throw e.buildCodeFrameError("Class fields are not enabled. "+"Please add `@babel/plugin-proposal-class-properties` to your configuration.")}if(l&&!hasFeature(t,r.staticBlocks)){throw e.buildCodeFrameError("Static class blocks are not enabled. "+"Please add `@babel/plugin-proposal-class-static-block` to your configuration.")}if(s||a||l){return true}if((n||o)&&hasFeature(t,r.fields)){return true}return false}},794:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t.buildFieldsInitNodes=buildFieldsInitNodes;t.buildPrivateNamesMap=buildPrivateNamesMap;t.buildPrivateNamesNodes=buildPrivateNamesNodes;t.transformPrivateNamesUsage=transformPrivateNamesUsage;var i=s(718);var r=s(949);var n=s(371);var o=s(571);var a=s(691);var l=s(764);var d=s(598);function buildPrivateNamesMap(e){const t=new Map;for(const s of e){if(s.isPrivate()){const{name:e}=s.node.key.id;const i=t.has(e)?t.get(e):{id:s.scope.generateUidIdentifier(e),static:s.node.static,method:!s.isProperty()};if(s.isClassPrivateMethod()){if(s.node.kind==="get"){i.getId=s.scope.generateUidIdentifier(`get_${e}`)}else if(s.node.kind==="set"){i.setId=s.scope.generateUidIdentifier(`set_${e}`)}else if(s.node.kind==="method"){i.methodId=s.scope.generateUidIdentifier(e)}}t.set(e,i)}}return t}function buildPrivateNamesNodes(e,t,s){const r=[];for(const[n,o]of e){const{static:e,method:a,getId:d,setId:c}=o;const p=d||c;const u=i.types.cloneNode(o.id);let f;if(t){f=i.types.callExpression(s.addHelper("classPrivateFieldLooseKey"),[i.types.stringLiteral(n)])}else if(!e){f=i.types.newExpression(i.types.identifier(!a||p?"WeakMap":"WeakSet"),[])}if(f){(0,l.default)(f);r.push(i.template.statement.ast`var ${u} = ${f}`)}}return r}function privateNameVisitorFactory(e){const t=Object.assign({},e,{Class(e){const{privateNamesMap:i}=this;const r=e.get("body.body");const n=new Map(i);const o=[];for(const e of r){if(!e.isPrivate())continue;const{name:t}=e.node.key.id;n.delete(t);o.push(t)}if(!o.length){return}e.get("body").traverse(s,Object.assign({},this,{redeclared:o}));e.traverse(t,Object.assign({},this,{privateNamesMap:n}));e.skipKey("body")}});const s=i.traverse.visitors.merge([Object.assign({},e),n.default]);return t}const c=privateNameVisitorFactory({PrivateName(e,{noDocumentAll:t}){const{privateNamesMap:s,redeclared:i}=this;const{node:r,parentPath:n}=e;if(!n.isMemberExpression({property:r})&&!n.isOptionalMemberExpression({property:r})){return}const{name:o}=r.id;if(!s.has(o))return;if(i&&i.includes(o))return;this.handle(n,t)}});function unshadow(e,t,s){while((i=t)!=null&&i.hasBinding(e)&&!t.bindingIdentifierEquals(e,s)){var i;t.rename(e);t=t.parent}}const p=privateNameVisitorFactory({BinaryExpression(e){const{operator:t,left:s,right:r}=e.node;if(t!=="in")return;if(!i.types.isPrivateName(s))return;const{privateFieldsAsProperties:n,privateNamesMap:o,redeclared:a}=this;const{name:l}=s.id;if(!o.has(l))return;if(a&&a.includes(l))return;unshadow(this.classRef.name,e.scope,this.innerBinding);if(n){const{id:t}=o.get(l);e.replaceWith(i.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${r}, ${i.types.cloneNode(t)})
      `);return}const{id:d,static:c}=o.get(l);if(c){e.replaceWith(i.template.expression.ast`${r} === ${this.classRef}`);return}e.replaceWith(i.template.expression.ast`${i.types.cloneNode(d)}.has(${r})`)}});const u={memoise(e,t){const{scope:s}=e;const{object:i}=e.node;const r=s.maybeGenerateMemoised(i);if(!r){return}this.memoiser.set(i,r,t)},receiver(e){const{object:t}=e.node;if(this.memoiser.has(t)){return i.types.cloneNode(this.memoiser.get(t))}return i.types.cloneNode(t)},get(e){const{classRef:t,privateNamesMap:s,file:r,innerBinding:n}=this;const{name:o}=e.node.property.id;const{id:a,static:l,method:d,methodId:c,getId:p,setId:u}=s.get(o);const f=p||u;if(l){const s=d&&!f?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";unshadow(t.name,e.scope,n);return i.types.callExpression(r.addHelper(s),[this.receiver(e),i.types.cloneNode(t),i.types.cloneNode(a)])}if(d){if(f){if(!p&&u){if(r.availableHelper("writeOnlyError")){return i.types.sequenceExpression([this.receiver(e),i.types.callExpression(r.addHelper("writeOnlyError"),[i.types.stringLiteral(`#${o}`)])])}console.warn(`@babel/helpers is outdated, update it to silence this warning.`)}return i.types.callExpression(r.addHelper("classPrivateFieldGet"),[this.receiver(e),i.types.cloneNode(a)])}return i.types.callExpression(r.addHelper("classPrivateMethodGet"),[this.receiver(e),i.types.cloneNode(a),i.types.cloneNode(c)])}return i.types.callExpression(r.addHelper("classPrivateFieldGet"),[this.receiver(e),i.types.cloneNode(a)])},boundGet(e){this.memoise(e,1);return i.types.callExpression(i.types.memberExpression(this.get(e),i.types.identifier("bind")),[this.receiver(e)])},set(e,t){const{classRef:s,privateNamesMap:r,file:n}=this;const{name:o}=e.node.property.id;const{id:a,static:l,method:d,setId:c,getId:p}=r.get(o);const u=p||c;if(l){const r=d&&!u?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return i.types.callExpression(n.addHelper(r),[this.receiver(e),i.types.cloneNode(s),i.types.cloneNode(a),t])}if(d){if(c){return i.types.callExpression(n.addHelper("classPrivateFieldSet"),[this.receiver(e),i.types.cloneNode(a),t])}return i.types.sequenceExpression([this.receiver(e),t,i.types.callExpression(n.addHelper("readOnlyError"),[i.types.stringLiteral(`#${o}`)])])}return i.types.callExpression(n.addHelper("classPrivateFieldSet"),[this.receiver(e),i.types.cloneNode(a),t])},destructureSet(e){const{classRef:t,privateNamesMap:s,file:r}=this;const{name:n}=e.node.property.id;const{id:o,static:a}=s.get(n);if(a){try{var l=r.addHelper("classStaticPrivateFieldDestructureSet")}catch(e){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n"+"please update @babel/helpers to the latest version.")}return i.types.memberExpression(i.types.callExpression(l,[this.receiver(e),i.types.cloneNode(t),i.types.cloneNode(o)]),i.types.identifier("value"))}return i.types.memberExpression(i.types.callExpression(r.addHelper("classPrivateFieldDestructureSet"),[this.receiver(e),i.types.cloneNode(o)]),i.types.identifier("value"))},call(e,t){this.memoise(e,1);return(0,a.default)(this.get(e),this.receiver(e),t,false)},optionalCall(e,t){this.memoise(e,1);return(0,a.default)(this.get(e),this.receiver(e),t,true)}};const f={get(e){const{privateNamesMap:t,file:s}=this;const{object:r}=e.node;const{name:n}=e.node.property.id;return i.template.expression`BASE(REF, PROP)[PROP]`({BASE:s.addHelper("classPrivateFieldLooseBase"),REF:i.types.cloneNode(r),PROP:i.types.cloneNode(t.get(n).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(e){return i.types.callExpression(i.types.memberExpression(this.get(e),i.types.identifier("bind")),[i.types.cloneNode(e.node.object)])},simpleSet(e){return this.get(e)},destructureSet(e){return this.get(e)},call(e,t){return i.types.callExpression(this.get(e),t)},optionalCall(e,t){return i.types.optionalCallExpression(this.get(e),t,true)}};function transformPrivateNamesUsage(e,t,s,{privateFieldsAsProperties:i,noDocumentAll:r,innerBinding:n},a){if(!s.size)return;const l=t.get("body");const d=i?f:u;(0,o.default)(l,c,Object.assign({privateNamesMap:s,classRef:e,file:a},d,{noDocumentAll:r,innerBinding:n}));l.traverse(p,{privateNamesMap:s,classRef:e,file:a,privateFieldsAsProperties:i,innerBinding:n})}function buildPrivateFieldInitLoose(e,t,s){const{id:r}=s.get(t.node.key.id.name);const n=t.node.value||t.scope.buildUndefinedNode();return i.template.statement.ast`
    Object.defineProperty(${e}, ${i.types.cloneNode(r)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${n}
    });
  `}function buildPrivateInstanceFieldInitSpec(e,t,s,r){const{id:n}=s.get(t.node.key.id.name);const o=t.node.value||t.scope.buildUndefinedNode();{if(!r.availableHelper("classPrivateFieldInitSpec")){return i.template.statement.ast`${i.types.cloneNode(n)}.set(${e}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${o},
      })`}}const a=r.addHelper("classPrivateFieldInitSpec");return i.template.statement.ast`${a}(
    ${i.types.thisExpression()},
    ${i.types.cloneNode(n)},
    {
      writable: true,
      value: ${o}
    },
  )`}function buildPrivateStaticFieldInitSpec(e,t){const s=t.get(e.node.key.id.name);const{id:r,getId:n,setId:o,initAdded:a}=s;const l=n||o;if(!e.isProperty()&&(a||!l))return;if(l){t.set(e.node.key.id.name,Object.assign({},s,{initAdded:true}));return i.template.statement.ast`
      var ${i.types.cloneNode(r)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${n?n.name:e.scope.buildUndefinedNode()},
        set: ${o?o.name:e.scope.buildUndefinedNode()}
      }
    `}const d=e.node.value||e.scope.buildUndefinedNode();return i.template.statement.ast`
    var ${i.types.cloneNode(r)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${d}
    };
  `}function buildPrivateMethodInitLoose(e,t,s){const r=s.get(t.node.key.id.name);const{methodId:n,id:o,getId:a,setId:l,initAdded:d}=r;if(d)return;if(n){return i.template.statement.ast`
        Object.defineProperty(${e}, ${o}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${n.name}
        });
      `}const c=a||l;if(c){s.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));return i.template.statement.ast`
      Object.defineProperty(${e}, ${o}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${a?a.name:t.scope.buildUndefinedNode()},
        set: ${l?l.name:t.scope.buildUndefinedNode()}
      });
    `}}function buildPrivateInstanceMethodInitSpec(e,t,s,i){const r=s.get(t.node.key.id.name);const{getId:n,setId:o,initAdded:a}=r;if(a)return;const l=n||o;if(l){return buildPrivateAccessorInitialization(e,t,s,i)}return buildPrivateInstanceMethodInitalization(e,t,s,i)}function buildPrivateAccessorInitialization(e,t,s,r){const n=s.get(t.node.key.id.name);const{id:o,getId:a,setId:l}=n;s.set(t.node.key.id.name,Object.assign({},n,{initAdded:true}));{if(!r.availableHelper("classPrivateFieldInitSpec")){return i.template.statement.ast`
      ${o}.set(${e}, {
        get: ${a?a.name:t.scope.buildUndefinedNode()},
        set: ${l?l.name:t.scope.buildUndefinedNode()}
      });
    `}}const d=r.addHelper("classPrivateFieldInitSpec");return i.template.statement.ast`${d}(
    ${i.types.thisExpression()},
    ${i.types.cloneNode(o)},
    {
      get: ${a?a.name:t.scope.buildUndefinedNode()},
      set: ${l?l.name:t.scope.buildUndefinedNode()}
    },
  )`}function buildPrivateInstanceMethodInitalization(e,t,s,r){const n=s.get(t.node.key.id.name);const{id:o}=n;{if(!r.availableHelper("classPrivateMethodInitSpec")){return i.template.statement.ast`${o}.add(${e})`}}const a=r.addHelper("classPrivateMethodInitSpec");return i.template.statement.ast`${a}(
    ${i.types.thisExpression()},
    ${i.types.cloneNode(o)}
  )`}function buildPublicFieldInitLoose(e,t){const{key:s,computed:r}=t.node;const n=t.node.value||t.scope.buildUndefinedNode();return i.types.expressionStatement(i.types.assignmentExpression("=",i.types.memberExpression(e,s,r||i.types.isLiteral(s)),n))}function buildPublicFieldInitSpec(e,t,s){const{key:r,computed:n}=t.node;const o=t.node.value||t.scope.buildUndefinedNode();return i.types.expressionStatement(i.types.callExpression(s.addHelper("defineProperty"),[e,n||i.types.isLiteral(r)?r:i.types.stringLiteral(r.name),o]))}function buildPrivateStaticMethodInitLoose(e,t,s,r){const n=r.get(t.node.key.id.name);const{id:o,methodId:a,getId:l,setId:d,initAdded:c}=n;if(c)return;const p=l||d;if(p){r.set(t.node.key.id.name,Object.assign({},n,{initAdded:true}));return i.template.statement.ast`
      Object.defineProperty(${e}, ${o}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${l?l.name:t.scope.buildUndefinedNode()},
        set: ${d?d.name:t.scope.buildUndefinedNode()}
      })
    `}return i.template.statement.ast`
    Object.defineProperty(${e}, ${o}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${a.name}
    });
  `}function buildPrivateMethodDeclaration(e,t,s=false){const r=t.get(e.node.key.id.name);const{id:n,methodId:o,getId:a,setId:l,getterDeclared:d,setterDeclared:c,static:p}=r;const{params:u,body:f,generator:m,async:h}=e.node;const b=a&&!d&&u.length===0;const y=l&&!c&&u.length>0;let g=o;if(b){t.set(e.node.key.id.name,Object.assign({},r,{getterDeclared:true}));g=a}else if(y){t.set(e.node.key.id.name,Object.assign({},r,{setterDeclared:true}));g=l}else if(p&&!s){g=n}return i.types.functionDeclaration(i.types.cloneNode(g),u,f,m,h)}const m=i.traverse.visitors.merge([{ThisExpression(e,t){t.needsClassRef=true;e.replaceWith(i.types.cloneNode(t.classRef))},MetaProperty(e){const t=e.get("meta");const s=e.get("property");const{scope:i}=e;if(t.isIdentifier({name:"new"})&&s.isIdentifier({name:"target"})){e.replaceWith(i.buildUndefinedNode())}}},n.default]);const h={ReferencedIdentifier(e,t){if(e.scope.bindingIdentifierEquals(e.node.name,t.innerBinding)){t.needsClassRef=true;e.node.name=t.classRef.name}}};function replaceThisContext(e,t,s,n,o,a,l){var d;const c={classRef:t,needsClassRef:false,innerBinding:l};const p=new r.default({methodPath:e,constantSuper:a,file:n,refToPreserve:t,getSuperRef:s,getObjectRef(){c.needsClassRef=true;return i.types.isStaticBlock!=null&&i.types.isStaticBlock(e.node)||e.node.static?t:i.types.memberExpression(t,i.types.identifier("prototype"))}});p.replace();if(o||e.isProperty()){e.traverse(m,c)}if(l!=null&&(d=c.classRef)!=null&&d.name&&c.classRef.name!==(l==null?void 0:l.name)){e.traverse(h,c)}return c.needsClassRef}function isNameOrLength({key:e,computed:t}){if(e.type==="Identifier"){return!t&&(e.name==="name"||e.name==="length")}if(e.type==="StringLiteral"){return e.value==="name"||e.value==="length"}return false}function buildFieldsInitNodes(e,t,s,r,n,o,a,l,c){let p=false;let u;const f=[];const m=[];const h=[];const b=i.types.isIdentifier(t)?()=>t:()=>{var e;(e=u)!=null?e:u=s[0].scope.generateUidIdentifierBasedOnNode(t);return u};for(const t of s){t.isClassProperty()&&d.assertFieldTransformed(t);const s=!(i.types.isStaticBlock!=null&&i.types.isStaticBlock(t.node))&&t.node.static;const u=!s;const y=t.isPrivate();const g=!y;const v=t.isProperty();const P=!v;const E=t.isStaticBlock==null?void 0:t.isStaticBlock();if(s||P&&y||E){const s=replaceThisContext(t,e,b,n,E,l,c);p=p||s}switch(true){case E:{const e=t.node.body;if(e.length===1&&i.types.isExpressionStatement(e[0])){f.push(e[0])}else{f.push(i.template.statement.ast`(() => { ${e} })()`)}break}case s&&y&&v&&a:p=true;f.push(buildPrivateFieldInitLoose(i.types.cloneNode(e),t,r));break;case s&&y&&v&&!a:p=true;f.push(buildPrivateStaticFieldInitSpec(t,r));break;case s&&g&&v&&o:if(!isNameOrLength(t.node)){p=true;f.push(buildPublicFieldInitLoose(i.types.cloneNode(e),t));break}case s&&g&&v&&!o:p=true;f.push(buildPublicFieldInitSpec(i.types.cloneNode(e),t,n));break;case u&&y&&v&&a:m.push(buildPrivateFieldInitLoose(i.types.thisExpression(),t,r));break;case u&&y&&v&&!a:m.push(buildPrivateInstanceFieldInitSpec(i.types.thisExpression(),t,r,n));break;case u&&y&&P&&a:m.unshift(buildPrivateMethodInitLoose(i.types.thisExpression(),t,r));h.push(buildPrivateMethodDeclaration(t,r,a));break;case u&&y&&P&&!a:m.unshift(buildPrivateInstanceMethodInitSpec(i.types.thisExpression(),t,r,n));h.push(buildPrivateMethodDeclaration(t,r,a));break;case s&&y&&P&&!a:p=true;f.unshift(buildPrivateStaticFieldInitSpec(t,r));h.push(buildPrivateMethodDeclaration(t,r,a));break;case s&&y&&P&&a:p=true;f.unshift(buildPrivateStaticMethodInitLoose(i.types.cloneNode(e),t,n,r));h.push(buildPrivateMethodDeclaration(t,r,a));break;case u&&g&&v&&o:m.push(buildPublicFieldInitLoose(i.types.thisExpression(),t));break;case u&&g&&v&&!o:m.push(buildPublicFieldInitSpec(i.types.thisExpression(),t,n));break;default:throw new Error("Unreachable.")}}return{staticNodes:f.filter(Boolean),instanceNodes:m.filter(Boolean),pureStaticNodes:h.filter(Boolean),wrapClass(t){for(const e of s){e.remove()}if(u){t.scope.push({id:i.types.cloneNode(u)});t.set("superClass",i.types.assignmentExpression("=",u,t.node.superClass))}if(!p)return t;if(t.isClassExpression()){t.scope.push({id:e});t.replaceWith(i.types.assignmentExpression("=",i.types.cloneNode(e),t.node))}else if(!t.node.id){t.node.id=e}return t}}}},213:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t.extractComputedKeys=extractComputedKeys;t.injectInitialization=injectInitialization;var i=s(718);var r=s(371);const n=i.traverse.visitors.merge([{Super(e){const{node:t,parentPath:s}=e;if(s.isCallExpression({callee:t})){this.push(s)}}},r.default]);const o={"TSTypeAnnotation|TypeAnnotation"(e){e.skip()},ReferencedIdentifier(e,{scope:t}){if(t.hasOwnBinding(e.node.name)){t.rename(e.node.name);e.skip()}}};function handleClassTDZ(e,t){if(t.classBinding&&t.classBinding===e.scope.getBinding(e.node.name)){const s=t.file.addHelper("classNameTDZError");const r=i.types.callExpression(s,[i.types.stringLiteral(e.node.name)]);e.replaceWith(i.types.sequenceExpression([r,e.node]));e.skip()}}const a={ReferencedIdentifier:handleClassTDZ};function injectInitialization(e,t,s,r){if(!s.length)return;const a=!!e.node.superClass;if(!t){const s=i.types.classMethod("constructor",i.types.identifier("constructor"),[],i.types.blockStatement([]));if(a){s.params=[i.types.restElement(i.types.identifier("args"))];s.body.body.push(i.template.statement.ast`super(...args)`)}[t]=e.get("body").unshiftContainer("body",s)}if(r){r(o,{scope:t.scope})}if(a){const e=[];t.traverse(n,e);let r=true;for(const t of e){if(r){t.insertAfter(s);r=false}else{t.insertAfter(s.map((e=>i.types.cloneNode(e))))}}}else{t.get("body").unshiftContainer("body",s)}}function extractComputedKeys(e,t,s){const r=[];const n={classBinding:e.node.id&&e.scope.getBinding(e.node.id.name),file:s};for(const s of t){const t=s.get("key");if(t.isReferencedIdentifier()){handleClassTDZ(t,n)}else{t.traverse(a,n)}const o=s.node;if(!t.isConstantExpression()){const t=e.scope.generateUidIdentifierBasedOnNode(o.key);e.scope.push({id:t,kind:"let"});r.push(i.types.expressionStatement(i.types.assignmentExpression("=",i.types.cloneNode(t),o.key)));o.key=i.types.cloneNode(t)}}return r}},598:(e,t)=>{Object.defineProperty(t,"__esModule",{value:true});t.assertFieldTransformed=assertFieldTransformed;function assertFieldTransformed(e){if(e.node.declare){throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by `+`@babel/plugin-transform-typescript.\n`+`If you have already enabled that plugin (or '@babel/preset-typescript'), make sure `+`that it runs before any plugin related to additional class features:\n`+` - @babel/plugin-proposal-class-properties\n`+` - @babel/plugin-proposal-private-methods\n`+` - @babel/plugin-proposal-decorators`)}}},666:e=>{e.exports=require("../template")},303:e=>{e.exports=require("../traverse")},740:e=>{e.exports=require("../types")},718:e=>{e.exports=require("@babel/core")},371:(e,t)=>{Object.defineProperty(t,"__esModule",{value:true});t["default"]=void 0;t.requeueComputedKeyAndDecorators=requeueComputedKeyAndDecorators;t.skipAllButComputedKey=skipAllButComputedKey;function skipAllButComputedKey(e){e.skip();if(e.node.computed){e.context.maybeQueue(e.get("key"))}}function requeueComputedKeyAndDecorators(e){const{context:t,node:s}=e;if(s.computed){t.maybeQueue(e.get("key"))}if(s.decorators){for(const s of e.get("decorators")){t.maybeQueue(s)}}}const s={FunctionParent(e){if(e.isArrowFunctionExpression()){return}else{e.skip();if(e.isMethod()){requeueComputedKeyAndDecorators(e)}}},Property(e){if(e.isObjectProperty()){return}e.skip();requeueComputedKeyAndDecorators(e)}};var i=s;t["default"]=i},988:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t["default"]=_default;var i=s(666);var r=s(740);const{NOT_LOCAL_BINDING:n,cloneNode:o,identifier:a,isAssignmentExpression:l,isAssignmentPattern:d,isFunction:c,isIdentifier:p,isLiteral:u,isNullLiteral:f,isObjectMethod:m,isObjectProperty:h,isRegExpLiteral:b,isRestElement:y,isTemplateLiteral:g,isVariableDeclarator:v,toBindingIdentifierName:P}=r;function getFunctionArity(e){const t=e.params.findIndex((e=>d(e)||y(e)));return t===-1?e.params.length:t}const E=i.default.statement(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);const N=i.default.statement(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);const x={"ReferencedIdentifier|BindingIdentifier"(e,t){if(e.node.name!==t.name)return;const s=e.scope.getBindingIdentifier(t.name);if(s!==t.outerDeclar)return;t.selfReference=true;e.stop()}};function getNameFromLiteralId(e){if(f(e)){return"null"}if(b(e)){return`_${e.pattern}_${e.flags}`}if(g(e)){return e.quasis.map((e=>e.value.raw)).join("")}if(e.value!==undefined){return e.value+""}return""}function wrap(e,t,s,i){if(e.selfReference){if(i.hasBinding(s.name)&&!i.hasGlobal(s.name)){i.rename(s.name)}else{if(!c(t))return;let e=E;if(t.generator){e=N}const r=e({FUNCTION:t,FUNCTION_ID:s,FUNCTION_KEY:i.generateUidIdentifier(s.name)}).expression;const n=r.callee.body.body[0].params;for(let e=0,s=getFunctionArity(t);e<s;e++){n.push(i.generateUidIdentifier("x"))}return r}}t.id=s;i.getProgramParent().references[s.name]=true}function visit(e,t,s){const i={selfAssignment:false,selfReference:false,outerDeclar:s.getBindingIdentifier(t),name:t};const r=s.getOwnBinding(t);if(r){if(r.kind==="param"){i.selfReference=true}else{}}else if(i.outerDeclar||s.hasGlobal(t)){s.traverse(e,x,i)}return i}function _default({node:e,parent:t,scope:s,id:i},r=false,d=false){if(e.id)return;if((h(t)||m(t,{kind:"method"}))&&(!t.computed||u(t.key))){i=t.key}else if(v(t)){i=t.id;if(p(i)&&!r){const t=s.parent.getBinding(i.name);if(t&&t.constant&&s.getBinding(i.name)===t){e.id=o(i);e.id[n]=true;return}}}else if(l(t,{operator:"="})){i=t.left}else if(!i){return}let f;if(i&&u(i)){f=getNameFromLiteralId(i)}else if(i&&p(i)){f=i.name}if(f===undefined){return}if(!d&&c(e)&&/[\uD800-\uDFFF]/.test(f)){return}f=P(f);const b=a(f);b[n]=true;const y=visit(e,f,s);return wrap(y,e,b,s)||e}},571:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});var i=s(740);function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);if(e){Object.keys(e).forEach((function(s){if(s!=="default"){var i=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(t,s,i.get?i:{enumerable:true,get:function(){return e[s]}})}}))}t["default"]=e;return Object.freeze(t)}var r=_interopNamespace(i);function willPathCastToBoolean(e){const t=e;const{node:s,parentPath:i}=t;if(i.isLogicalExpression()){const{operator:e,right:t}=i.node;if(e==="&&"||e==="||"||e==="??"&&s===t){return willPathCastToBoolean(i)}}if(i.isSequenceExpression()){const{expressions:e}=i.node;if(e[e.length-1]===s){return willPathCastToBoolean(i)}else{return true}}return i.isConditional({test:s})||i.isUnaryExpression({operator:"!"})||i.isLoop({test:s})}const{LOGICAL_OPERATORS:n,arrowFunctionExpression:o,assignmentExpression:a,binaryExpression:l,booleanLiteral:d,callExpression:c,cloneNode:p,conditionalExpression:u,identifier:f,isMemberExpression:m,isOptionalCallExpression:h,isOptionalMemberExpression:b,isUpdateExpression:y,logicalExpression:g,memberExpression:v,nullLiteral:P,optionalCallExpression:E,optionalMemberExpression:N,sequenceExpression:x,updateExpression:_}=r;class AssignmentMemoiser{constructor(){this._map=void 0;this._map=new WeakMap}has(e){return this._map.has(e)}get(e){if(!this.has(e))return;const t=this._map.get(e);const{value:s}=t;t.count--;if(t.count===0){return a("=",s,e)}return s}set(e,t,s){return this._map.set(e,{count:s,value:t})}}function toNonOptional(e,t){const{node:s}=e;if(b(s)){return v(t,s.property,s.computed)}if(e.isOptionalCallExpression()){const s=e.get("callee");if(e.node.optional&&s.isOptionalMemberExpression()){const i=s.node.object;const r=e.scope.maybeGenerateMemoised(i);s.get("object").replaceWith(a("=",r,i));return c(v(t,f("call")),[r,...e.node.arguments])}return c(t,e.node.arguments)}return e.node}function isInDetachedTree(e){while(e){if(e.isProgram())break;const{parentPath:t,container:s,listKey:i}=e;const r=t.node;if(i){if(s!==r[i]){return true}}else{if(s!==r)return true}e=t}return false}const I={memoise(){},handle(e,t){const{node:s,parent:i,parentPath:r,scope:v}=e;if(e.isOptionalMemberExpression()){if(isInDetachedTree(e))return;const n=e.find((({node:t,parent:s})=>{if(b(s)){return s.optional||s.object!==t}if(h(s)){return t!==e.node&&s.optional||s.callee!==t}return true}));if(v.path.isPattern()){n.replaceWith(c(o([],n.node),[]));return}const y=willPathCastToBoolean(n);const x=n.parentPath;if(x.isUpdateExpression({argument:s})||x.isAssignmentExpression({left:s})){throw e.buildCodeFrameError(`can't handle assignment`)}const _=x.isUnaryExpression({operator:"delete"});if(_&&n.isOptionalMemberExpression()&&n.get("property").isPrivateName()){throw e.buildCodeFrameError(`can't delete a private class element`)}let I=e;for(;;){if(I.isOptionalMemberExpression()){if(I.node.optional)break;I=I.get("object");continue}else if(I.isOptionalCallExpression()){if(I.node.optional)break;I=I.get("callee");continue}throw new Error(`Internal error: unexpected ${I.node.type}`)}const C=I.isOptionalMemberExpression()?I.node.object:I.node.callee;const O=v.maybeGenerateMemoised(C);const F=O!=null?O:C;const k=r.isOptionalCallExpression({callee:s});const isOptionalCall=e=>k;const S=r.isCallExpression({callee:s});I.replaceWith(toNonOptional(I,F));if(isOptionalCall()){if(i.optional){r.replaceWith(this.optionalCall(e,i.arguments))}else{r.replaceWith(this.call(e,i.arguments))}}else if(S){e.replaceWith(this.boundGet(e))}else{e.replaceWith(this.get(e))}let w=e.node;for(let t=e;t!==n;){const e=t.parentPath;if(e===n&&isOptionalCall()&&i.optional){w=e.node;break}w=toNonOptional(e,w);t=e}let M;const D=n.parentPath;if(m(w)&&D.isOptionalCallExpression({callee:n.node,optional:true})){const{object:t}=w;M=e.scope.maybeGenerateMemoised(t);if(M){w.object=a("=",M,t)}}let j=n;if(_){j=D;w=D.node}const $=O?a("=",p(F),p(C)):p(F);if(y){let e;if(t){e=l("!=",$,P())}else{e=g("&&",l("!==",$,P()),l("!==",p(F),v.buildUndefinedNode()))}j.replaceWith(g("&&",e,w))}else{let e;if(t){e=l("==",$,P())}else{e=g("||",l("===",$,P()),l("===",p(F),v.buildUndefinedNode()))}j.replaceWith(u(e,_?d(true):v.buildUndefinedNode(),w))}if(M){const e=D.node;D.replaceWith(E(N(e.callee,f("call"),false,true),[p(M),...e.arguments],false))}return}if(y(i,{argument:s})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}const{operator:t,prefix:n}=i;this.memoise(e,2);const o=v.generateUidIdentifierBasedOnNode(s);v.push({id:o});const l=[a("=",p(o),this.get(e))];if(n){l.push(_(t,p(o),n));const s=x(l);r.replaceWith(this.set(e,s));return}else{const i=v.generateUidIdentifierBasedOnNode(s);v.push({id:i});l.push(a("=",p(i),_(t,p(o),n)),p(o));const d=x(l);r.replaceWith(x([this.set(e,d),p(i)]));return}}if(r.isAssignmentExpression({left:s})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}const{operator:t,right:s}=r.node;if(t==="="){r.replaceWith(this.set(e,s))}else{const i=t.slice(0,-1);if(n.includes(i)){this.memoise(e,1);r.replaceWith(g(i,this.get(e),this.set(e,s)))}else{this.memoise(e,2);r.replaceWith(this.set(e,l(i,this.get(e),s)))}}return}if(r.isCallExpression({callee:s})){r.replaceWith(this.call(e,r.node.arguments));return}if(r.isOptionalCallExpression({callee:s})){if(v.path.isPattern()){r.replaceWith(c(o([],r.node),[]));return}r.replaceWith(this.optionalCall(e,r.node.arguments));return}if(r.isForXStatement({left:s})||r.isObjectProperty({value:s})&&r.parentPath.isObjectPattern()||r.isAssignmentPattern({left:s})&&r.parentPath.isObjectProperty({value:i})&&r.parentPath.parentPath.isObjectPattern()||r.isArrayPattern()||r.isAssignmentPattern({left:s})&&r.parentPath.isArrayPattern()||r.isRestElement()){e.replaceWith(this.destructureSet(e));return}if(r.isTaggedTemplateExpression()){e.replaceWith(this.boundGet(e))}else{e.replaceWith(this.get(e))}}};function memberExpressionToFunctions(e,t,s){e.traverse(t,Object.assign({},I,s,{memoiser:new AssignmentMemoiser}))}t["default"]=memberExpressionToFunctions},691:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t["default"]=optimiseCallExpression;var i=s(740);const{callExpression:r,identifier:n,isIdentifier:o,isSpreadElement:a,memberExpression:l,optionalCallExpression:d,optionalMemberExpression:c}=i;function optimiseCallExpression(e,t,s,i){if(s.length===1&&a(s[0])&&o(s[0].argument,{name:"arguments"})){if(i){return d(c(e,n("apply"),false,true),[t,s[0].argument],false)}return r(l(e,n("apply")),[t,s[0].argument])}else{if(i){return d(c(e,n("call"),false,true),[t,...s],false)}return r(l(e,n("call")),[t,...s])}}},949:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t["default"]=void 0;Object.defineProperty(t,"environmentVisitor",{enumerable:true,get:function(){return o.default}});Object.defineProperty(t,"skipAllButComputedKey",{enumerable:true,get:function(){return o.skipAllButComputedKey}});var i=s(303);var r=s(571);var n=s(691);var o=s(371);var a=s(740);const{assignmentExpression:l,booleanLiteral:d,callExpression:c,cloneNode:p,identifier:u,memberExpression:f,sequenceExpression:m,stringLiteral:h,thisExpression:b}=a;function getPrototypeOfExpression(e,t,s,i){e=p(e);const r=t||i?e:f(e,u("prototype"));return c(s.addHelper("getPrototypeOf"),[r])}const y=i.default.visitors.merge([o.default,{Super(e,t){const{node:s,parentPath:i}=e;if(!i.isMemberExpression({object:s}))return;t.handle(i)}}]);const g=i.default.visitors.merge([o.default,{Scopable(e,{refName:t}){const s=e.scope.getOwnBinding(t);if(s&&s.identifier.name===t){e.scope.rename(t)}}}]);const v={memoise(e,t){const{scope:s,node:i}=e;const{computed:r,property:n}=i;if(!r){return}const o=s.maybeGenerateMemoised(n);if(!o){return}this.memoiser.set(n,o,t)},prop(e){const{computed:t,property:s}=e.node;if(this.memoiser.has(s)){return p(this.memoiser.get(s))}if(t){return p(s)}return h(s.name)},get(e){return this._get(e,this._getThisRefs())},_get(e,t){const s=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return c(this.file.addHelper("get"),[t.memo?m([t.memo,s]):s,this.prop(e),t.this])},_getThisRefs(){if(!this.isDerivedConstructor){return{this:b()}}const e=this.scope.generateDeclaredUidIdentifier("thisSuper");return{memo:l("=",e,b()),this:p(e)}},set(e,t){const s=this._getThisRefs();const i=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return c(this.file.addHelper("set"),[s.memo?m([s.memo,i]):i,this.prop(e),t,s.this,d(e.isInStrictMode())])},destructureSet(e){throw e.buildCodeFrameError(`Destructuring to a super field is not supported yet.`)},call(e,t){const s=this._getThisRefs();return(0,n.default)(this._get(e,s),p(s.this),t,false)},optionalCall(e,t){const s=this._getThisRefs();return(0,n.default)(this._get(e,s),p(s.this),t,true)}};const P=Object.assign({},v,{prop(e){const{property:t}=e.node;if(this.memoiser.has(t)){return p(this.memoiser.get(t))}return p(t)},get(e){const{isStatic:t,getSuperRef:s}=this;const{computed:i}=e.node;const r=this.prop(e);let n;if(t){var o;n=(o=s())!=null?o:f(u("Function"),u("prototype"))}else{var a;n=f((a=s())!=null?a:u("Object"),u("prototype"))}return f(n,r,i)},set(e,t){const{computed:s}=e.node;const i=this.prop(e);return l("=",f(b(),i,s),t)},destructureSet(e){const{computed:t}=e.node;const s=this.prop(e);return f(b(),s,t)},call(e,t){return(0,n.default)(this.get(e),b(),t,false)},optionalCall(e,t){return(0,n.default)(this.get(e),b(),t,true)}});class ReplaceSupers{constructor(e){var t;const s=e.methodPath;this.methodPath=s;this.isDerivedConstructor=s.isClassMethod({kind:"constructor"})&&!!e.superRef;this.isStatic=s.isObjectMethod()||s.node.static||(s.isStaticBlock==null?void 0:s.isStaticBlock());this.isPrivateMethod=s.isPrivate()&&s.isMethod();this.file=e.file;this.constantSuper=(t=e.constantSuper)!=null?t:e.isLoose;this.opts=e}getObjectRef(){return p(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){if(this.opts.superRef)return p(this.opts.superRef);if(this.opts.getSuperRef){return p(this.opts.getSuperRef())}}replace(){if(this.opts.refToPreserve){this.methodPath.traverse(g,{refName:this.opts.refToPreserve.name})}const e=this.constantSuper?P:v;(0,r.default)(this.methodPath,y,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:e.get},e))}}t["default"]=ReplaceSupers},254:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:true});t["default"]=splitExportDeclaration;var i=s(740);const{cloneNode:r,exportNamedDeclaration:n,exportSpecifier:o,identifier:a,variableDeclaration:l,variableDeclarator:d}=i;function splitExportDeclaration(e){if(!e.isExportDeclaration()||e.isExportAllDeclaration()){throw new Error("Only default and named export declarations can be split.")}if(e.isExportDefaultDeclaration()){const t=e.get("declaration");const s=t.isFunctionDeclaration()||t.isClassDeclaration();const i=t.isScope()?t.scope.parent:t.scope;let c=t.node.id;let p=false;if(!c){p=true;c=i.generateUidIdentifier("default");if(s||t.isFunctionExpression()||t.isClassExpression()){t.node.id=r(c)}}const u=s?t.node:l("var",[d(r(c),t.node)]);const f=n(null,[o(r(c),a("default"))]);e.insertAfter(f);e.replaceWith(u);if(p){i.registerDeclaration(e)}return e}else if(e.get("specifiers").length>0){throw new Error("It doesn't make sense to split exported specifiers.")}const t=e.get("declaration");const s=t.getOuterBindingIdentifiers();const i=Object.keys(s).map((e=>o(a(e),a(e))));const c=n(null,i);e.insertAfter(c);e.replaceWith(t.node);return e}}};var t={};function __nccwpck_require__(s){var i=t[s];if(i!==undefined){return i.exports}var r=t[s]={exports:{}};var n=true;try{e[s](r,r.exports,__nccwpck_require__);n=false}finally{if(n)delete t[s]}return r.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var s={};(()=>{var e=s;Object.defineProperty(e,"__esModule",{value:true});Object.defineProperty(e,"FEATURES",{enumerable:true,get:function(){return l.FEATURES}});e.createClassFeaturePlugin=createClassFeaturePlugin;Object.defineProperty(e,"enableFeature",{enumerable:true,get:function(){return l.enableFeature}});Object.defineProperty(e,"injectInitialization",{enumerable:true,get:function(){return a.injectInitialization}});var t=__nccwpck_require__(718);var i=__nccwpck_require__(988);var r=__nccwpck_require__(254);var n=__nccwpck_require__(794);var o=__nccwpck_require__(922);var a=__nccwpck_require__(213);var l=__nccwpck_require__(836);var d=__nccwpck_require__(598);const c="7.18.0".split(".").reduce(((e,t)=>e*1e5+ +t),0);const p="@babel/plugin-class-features/version";function createClassFeaturePlugin({name:e,feature:s,loose:u,manipulateOptions:f,api:m={assumption:()=>void 0},inherits:h}){const b=m.assumption("setPublicClassFields");const y=m.assumption("privateFieldsAsProperties");const g=m.assumption("constantSuper");const v=m.assumption("noDocumentAll");if(u===true){const t=[];if(b!==undefined){t.push(`"setPublicClassFields"`)}if(y!==undefined){t.push(`"privateFieldsAsProperties"`)}if(t.length!==0){console.warn(`[${e}]: You are using the "loose: true" option and you are`+` explicitly setting a value for the ${t.join(" and ")}`+` assumption${t.length>1?"s":""}. The "loose" option`+` can cause incompatibilities with the other class features`+` plugins, so it's recommended that you replace it with the`+` following top-level option:\n`+`\t"assumptions": {\n`+`\t\t"setPublicClassFields": true,\n`+`\t\t"privateFieldsAsProperties": true\n`+`\t}`)}}return{name:e,manipulateOptions:f,inherits:h,pre(e){(0,l.enableFeature)(e,s,u);if(!e.get(p)||e.get(p)<c){e.set(p,c)}},visitor:{Class(e,{file:r}){if(r.get(p)!==c)return;if(!(0,l.shouldTransform)(e,r))return;if(e.isClassDeclaration())(0,d.assertFieldTransformed)(e);const u=(0,l.isLoose)(r,s);let f;const m=(0,o.hasDecorators)(e.node);const h=[];const P=[];const E=[];const N=new Set;const x=e.get("body");for(const e of x.get("body")){if((e.isClassProperty()||e.isClassMethod())&&e.node.computed){E.push(e)}if(e.isPrivate()){const{name:t}=e.node.key.id;const s=`get ${t}`;const i=`set ${t}`;if(e.isClassPrivateMethod()){if(e.node.kind==="get"){if(N.has(s)||N.has(t)&&!N.has(i)){throw e.buildCodeFrameError("Duplicate private field")}N.add(s).add(t)}else if(e.node.kind==="set"){if(N.has(i)||N.has(t)&&!N.has(s)){throw e.buildCodeFrameError("Duplicate private field")}N.add(i).add(t)}}else{if(N.has(t)&&!N.has(s)&&!N.has(i)||N.has(t)&&(N.has(s)||N.has(i))){throw e.buildCodeFrameError("Duplicate private field")}N.add(t)}}if(e.isClassMethod({kind:"constructor"})){f=e}else{P.push(e);if(e.isProperty()||e.isPrivate()||e.isStaticBlock!=null&&e.isStaticBlock()){h.push(e)}}}if(!h.length&&!m)return;const _=e.node.id;let I;if(!_||e.isClassExpression()){(0,i.default)(e);I=e.scope.generateUidIdentifier("class")}else{I=t.types.cloneNode(e.node.id)}const C=(0,n.buildPrivateNamesMap)(h);const O=(0,n.buildPrivateNamesNodes)(C,y!=null?y:u,r);(0,n.transformPrivateNamesUsage)(I,e,C,{privateFieldsAsProperties:y!=null?y:u,noDocumentAll:v,innerBinding:_},r);let F,k,S,w,M;if(m){k=w=F=[];({instanceNodes:S,wrapClass:M}=(0,o.buildDecoratedClass)(I,e,P,r))}else{F=(0,a.extractComputedKeys)(e,E,r);({staticNodes:k,pureStaticNodes:w,instanceNodes:S,wrapClass:M}=(0,n.buildFieldsInitNodes)(I,e.node.superClass,h,C,r,b!=null?b:u,y!=null?y:u,g!=null?g:u,_))}if(S.length>0){(0,a.injectInitialization)(e,f,S,((e,s)=>{if(m)return;for(const i of h){if(t.types.isStaticBlock!=null&&t.types.isStaticBlock(i.node)||i.node.static)continue;i.traverse(e,s)}}))}const D=M(e);D.insertBefore([...O,...F]);if(k.length>0){D.insertAfter(k)}if(w.length>0){D.find((e=>e.isStatement()||e.isDeclaration())).insertAfter(w)}},ExportDefaultDeclaration(e,{file:t}){if(t.get(p)!==c)return;const s=e.get("declaration");if(s.isClassDeclaration()&&(0,o.hasDecorators)(s.node)){if(s.node.id){(0,r.default)(e)}else{s.node.type="ClassExpression"}}}}}}})();module.exports=s})();