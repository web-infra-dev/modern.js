### Getting Request Context

Sometimes in BFF functions, it's necessary to obtain the request context to handle more logic. In such cases, you can use `useHonoContext` to get it:

```ts title="api/lambda/hello.ts"
import { useHonoContext } from '@modern-js/plugin-bff/server';

export const get = async () => {
  const c = useHonoContext();
  console.info(`access url: ${c.req.url}`);
  return 'Hello Modern.js';
};
```

:::info
For more details, refer to [useHonoContext](/apis/app/runtime/bff/use-hono-context).
:::

### Getting Cookies

When getting cookies in BFF functions, you need to get the request context through `useHonoContext`, then use `c.req.header('cookie')` to get the Cookie string and parse it manually:

```ts title="api/lambda/cookies.ts"
import { Api, Get, useHonoContext } from '@modern-js/plugin-bff/server';

// Helper function to parse Cookie string
function parseCookies(
  cookieHeader: string | undefined,
): Record<string, string> {
  const cookies: Record<string, string> = {};
  if (!cookieHeader) return cookies;

  cookieHeader.split(';').forEach(cookie => {
    const [name, ...rest] = cookie.trim().split('=');
    if (name) {
      cookies[name] = rest.join('=');
    }
  });

  return cookies;
}

export const getCookies = Api(Get('/cookies'), async () => {
  const c = useHonoContext();
  const cookieHeader = c.req.header('cookie');
  const cookies = parseCookies(cookieHeader);
  const token = cookies.token;
  const sessionId = cookies.sessionId;
  return {
    hasToken: !!token,
    token: token || null,
    sessionId: sessionId || null,
  };
});
```

:::caution Note
The `c.req.cookie()` method does not exist in the current version. You need to use `c.req.header('cookie')` to get the Cookie string and parse it manually.
:::

### Defining BFF Functions

When using Hono as the runtime framework, you can define interfaces through [BFF Functions](/guides/advanced-features/bff/function.html#bff-functions):

```ts title="api/lambda/user.ts"
import { Api, Get, Query } from '@modern-js/plugin-bff/server';
import { z } from 'zod';

const QuerySchema = z.object({
  id: z.string(),
});

export const getUser = Api(
  Get('/user'),
  Query(QuerySchema),
  async ({ query }) => {
    return {
      id: query.id,
      name: 'Modern.js',
      email: 'modernjs@bytedance.com',
    };
  },
);
```

### Query Parameter Type Conversion

URL query parameters are strings by default. If you need numeric types, you need to use `z.coerce.number()` for type conversion:

```ts title="api/lambda/user.ts"
import { Api, Get, Query } from '@modern-js/plugin-bff/server';
import { z } from 'zod';

const QuerySchema = z.object({
  id: z.string(),
  page: z.coerce.number().min(1).max(100), // Use z.coerce.number() to convert string to number
  status: z.enum(['active', 'inactive']),
});

export const getUser = Api(
  Get('/user'),
  Query(QuerySchema),
  async ({ query }) => {
    return {
      id: query.id,
      page: query.page, // page is a number type
      status: query.status,
    };
  },
);
```

:::caution Note
URL query parameters are all string types. If you need numeric types, you need to use `z.coerce.number()` for conversion, not `z.number()` directly.
:::

### Dynamic Route Parameter Passing

When using Hono, there are two routing methods with different parameter passing approaches:

#### Simple File System Routes

When using file system routes, dynamic route parameters are passed directly as function parameters:

```ts title="api/lambda/user/[id].ts"
export default async (id: string) => {
  return { path: `/api/user/${id}`, id };
};
```

When calling from the frontend, pass parameters directly:

```tsx
import userById from '@api/user/[id]';
const result = await userById('123');
```

#### Api Function Routes

When using Api functions to define routes, you need to define parameters through the `Params` operator and access them through the `params` object in the function:

```ts title="api/lambda/user-api.ts"
import { Api, Get, Params } from '@modern-js/plugin-bff/server';
import { z } from 'zod';

const ParamsSchema = z.object({
  id: z.string(),
});

export const getUserByIdApi = Api(
  Get('/user/api/:id'),
  Params(ParamsSchema),
  async ({ params }) => {
    return { id: params.id };
  },
);
```

When calling from the frontend, you need to pass the `params` object:

```tsx
import { getUserByIdApi } from '@api/user-api';
const result = await getUserByIdApi({ params: { id: '123' } });
```

:::info
Simple file system routes and Api function routes have different parameter passing methods. Please pay attention to the distinction when using them.
:::

### Using Middleware

Hono supports a rich middleware ecosystem, and you can use middleware in BFF functions:

```ts title="api/lambda/user.ts"
import { Api, Get, Middleware } from '@modern-js/plugin-bff/server';

export const getUser = Api(
  Get('/user'),
  Middleware(async (c, next) => {
    // You can access Hono's Context in middleware
    c.res.headers.set('X-Powered-By', 'Modern.js');
    await next();
  }),
  async () => {
    return {
      name: 'Modern.js',
      email: 'modernjs@bytedance.com',
    };
  },
);
```

### Pipe Operator Custom Response Status Code

When you need to set a custom response status code, it is recommended to use the `HttpCode` operator:

```ts title="api/lambda/user.ts"
import { Api, Post, HttpCode } from '@modern-js/plugin-bff/server';

export const createUser = Api(Post('/user'), HttpCode(201), async () => {
  return { id: '123' };
});
```

:::caution Note
The status code set through the `end` function in the Pipe operator may not take effect. It is recommended to use the `HttpCode` operator to set the status code.
:::

If you need to perform custom validation in the Pipe operator, you can refer to the following example:

```ts title="api/lambda/user.ts"
import { Api, Query, Pipe } from '@modern-js/plugin-bff/server';
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string().min(2).max(10),
  email: z.string().email(),
});

export const get = Api(
  Query(UserSchema),
  Pipe<{
    query: z.infer<typeof UserSchema>;
  }>((input, end) => {
    const { query } = input;
    const { name, email } = query;
    // Use case-insensitive comparison
    if (!email.toLowerCase().startsWith(name.toLowerCase())) {
      return end({
        message: 'email must start with name',
      });
    }
    return input;
  }),
  async ({ query }) => ({
    name: query.name,
  }),
);
```

:::tip
When performing string comparisons, it is recommended to use case-insensitive comparison methods to avoid issues caused by case differences.
:::

### Interceptor Return Type Handling

When using interceptors, note that interceptors may return Response objects, which need to be manually parsed as JSON:

```tsx title="routes/page.tsx"
import { configure } from '@modern-js/plugin-bff/client';

configure({
  interceptor(request) {
    return async (url, params) => {
      // Add authentication information before request
      const token = localStorage.getItem('token');
      if (token) {
        params.headers = {
          ...params.headers,
          Authorization: `Bearer ${token}`,
        };
      }

      const res = await request(url, params);

      // Unified processing after response
      // Interceptors may return Response objects, which need to be parsed as JSON
      if (res instanceof Response) {
        const data = await res.json();
        if (data.code !== 0) {
          throw new Error(data.message);
        }
        return data.data;
      }

      // If it's already parsed data
      if (res.code !== 0) {
        throw new Error(res.message);
      }

      return res.data;
    };
  },
});
```

### Route Conflict Issues

If both file system routes and Api function routes map to the same path, conflicts may occur. For example:

```ts
// api/lambda/user.ts
export const get = async () => { ... };

// api/lambda/user-api.ts
export const getUser = Api(Get('/user'), ...);
```

Both will map to the `/api/user` GET route, which may cause conflicts.

You can avoid conflicts in the following ways:

1. **Use different paths**:

   ```ts
   // api/lambda/user-api.ts
   export const getUser = Api(Get('/user/query'), ...);
   ```

2. **Unify to use Api functions**: It is recommended to unify the use of Api functions and avoid mixing file system routes with Api function routes.

### More Hono Documentation

For more detailed information about Hono, please refer to the [Hono official documentation](https://hono.dev/).
