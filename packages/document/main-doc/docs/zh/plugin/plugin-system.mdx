# 插件系统

Modern.js 提供了一套轻量强大的插件系统，用以实现自身的大多数功能，并允许用户进行扩展。

Modern.js 从框架的构建、运行时和服务端三个维度提供了插件系统，分别对应 CLI 插件、Runtime 插件和 Server 插件。

开发者可以通过编写插件来修改 Modern.js 的默认行为，扩展 Modern.js 功能，从而实现自定义的需求。

插件能够提供的能力包括但不限于：

- 注册命令
- 修改 Modern.js 配置、配置校验 Schema
- 修改编译时的 Webpack/Babel/Less/Sass/Tailwind CSS/... 配置
- 修改运行时需要渲染的 React 组件、Element
- 修改页面路由
- 修改服务器路由
- 自定义控制台输出
- 自定义动态 HTML 模版
- 自定义 Node.js 服务器框架
- 自定义 React 组件客户端/服务器端渲染

## 插件结构

Modern.js 三种类型的插件都遵循相同的结构，即：

```ts
import type { Plugin } from '@modern-js/plugin-v2';

const myPlugin = (): Plugin => ({
  name: 'example',
  setup(api) {
    api.xxx(() => {
      // do something
    });
  },
});
```

其中各部分的作用分别为：

##### `name`

- 类型： `string`
- 用途： 用于标识插件的名称，在插件体系中要求这个名称必须是唯一的，否则会导致插件加载失败。

##### `setup`
- 类型： `(api: PluginAPI) => MaybePromise<void>`
- 用途： 插件逻辑的主入口。

##### `api`
- 类型： `PluginAPI`
- 用途： 插件的 API，包含了插件支持的 Hooks 和工具函数。

##### `pre`
- 类型： `string[]`
- 用途： 用于标注插件顺序，在 pre 中声明的插件都会在当前插件之前执行

##### `post`
- 类型： `string[]`
- 用途： 用于标注插件顺序，在 post 中声明的插件都会在当前插件之后执行

##### `required`
- 类型： `string[]`
- 用途： 用于标注当前插件依赖哪些插件，在插件运行前会进行校验依赖插件是否已经注册

##### `usePlugins`
- 类型： `Plugin`
- 用途： 在插件中主动注册其他相同类型的插件插件

:::info
`usePlugins` 声明的插件默认会在当前插件之前执行，如果需要在当前插件之后执行，可以使用 `post` 声明
:::

##### `registryHooks`
- 类型： `Record<string, PluginHook<(...args: any[]) => any>>`
- 用途： 扩展当前支持的 Hook 函数，用于实现自定义功能

## 插件系统的组成

Modern.js 插件系统由以下几个部分组成：

### 插件管理器

插件管理器是系统的核心协调者，负责插件的注册、依赖关系处理和执行排序，确保各插件按正确顺序初始化。

```ts
import { createPluginManager } from '@modern-js/plugin-v2';

// 创建插件管理器
const pluginManager = createPluginManager();
// 注册插件
pluginManager.addPlugins(allPlugins);
//  获取拓扑排序后的插件列表
const plugins = pluginManager.getPlugins() as RuntimePlugin<Extends>[];
// 检查特定插件是否存在
const isPluginExists = pluginManager.isPluginExists('myPlugin');
```

### 插件 Hook 模型

插件 Hook 模型是插件系统的核心组成部分，用于定义插件之间的通信接口。

Modern.js 的插件系统主要提供了两类 Hook 模型

#### Async Hook

Async Hook 是一种异步的 Hook 模型，它允许插件在执行时异步地等待其他插件的执行结果。


Async Hook 会依次执行每一个注册的 Hook 函数，函数为 Async 函数，并且当前 Hook 函数的返回值会被当做下一个 Hook 的第一个参数，并最终返回最后一个 Hook 函数的返回值。

示例：
```ts
// 定义 Hooks
import { createAsyncHook } from '@modern-js/plugin-v2';

export type AfterPrepareFn = () => Promise<void> | void;
export onAfterPrepare = createAsyncHook<AfterPrepareFn>(),

// 插件中注册 Hooks
const myPlugin = () => {
    name: "my-plugin",
    registryHooks: {
        onAfterPrepare,
    },
    setup: (api) => {
        api.onPrepare(async () => {
          // 插件中使用注册的 hooks
          const hooks = api.getHooks();
          await hooks.onAfterPrepare.call();
        })
    }
}

// 在其他插件中使用 Hook
const myPlugin2 = () => {
    name: "my-plugin-2",
    setup: (api) => {
        api.onAfterPrepare(async () => {
          // TOOD
        })
    }
}
```

#### Sync Hook

Sync Hook 是一种同步的 Hook 模型，它允许插件在执行时同步地等待其他插件的执行结果。

Sync Hook 会依次执行每一个注册的 Hook 函数，函数为 Sync 函数，并且当前 Hook 函数的返回值会被当做下一个 Hook 的第一个参数，并最终返回最后一个 Hook 函数的返回值。

示例：

```ts
// 定义 Hooks
import { createSyncHook } from '@modern-js/plugin-v2';

type RouteObject = {/** TODO **/};
const modifyRoutes = createSyncHook<(routes: RouteObject[]) => RouteObject[]>();

// 插件中注册 Hooks
const myPlugin = () => {
    name: "my-plugin",
    registryHooks: {
        modifyRoutes,
    },
    setup: (api) => {
        api.onPrepare(async () => {
          const routes = {}
          // 插件中使用注册的 hooks
          const hooks = api.getHooks();
          const routesResult = hooks.modifyRoutes.call(routes);
        })
    }
}

// 其他插件使用 Hooks
const myPlugin2 = () => {
    name: "my-plugin",
    setup: (api) => {
        api.modifyRoutes(async (routes) => {
          // 操作 routes
          return routes;
        })
    }
}
```
