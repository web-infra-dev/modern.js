import { join, dirname, isAbsolute } from 'path';
import { chalk, fs, globby, json5, logger } from '@modern-js/utils';
import MagicString from 'magic-string';
import type {
  ITsconfig,
  GeneratorDtsConfig,
  BuildType,
  TsTarget,
} from '../types';

export const getProjectTsconfig = async (
  tsconfigPath: string,
): Promise<ITsconfig> => {
  if (!fs.existsSync(tsconfigPath)) {
    return {};
  }

  return json5.parse(fs.readFileSync(tsconfigPath, 'utf-8'));
};

export const getTscBinPath = async (appDirectory: string) => {
  const { default: findUp, exists: pathExists } = await import(
    '../../compiled/find-up'
  );
  const tscBinFile = await findUp(
    async (directory: string) => {
      const targetFilePath = join(directory, './node_modules/.bin/tsc');
      const hasTscBinFile = await pathExists(targetFilePath);
      if (hasTscBinFile) {
        return targetFilePath;
      }
      return undefined;
    },
    { cwd: appDirectory },
  );

  if (!tscBinFile || !fs.existsSync(tscBinFile)) {
    throw new Error(
      'Failed to excute the `tsc` command, please check if `typescript` is installed correctly in the current directory.',
    );
  }

  return tscBinFile;
};

export const resolveAlias = async (config: GeneratorDtsConfig) => {
  const { userTsconfig, distPath, tsconfigPath } = config;
  const { transformDtsAlias } = await import('./tspath');
  const dtsFilenames = await globby('**/*.d.ts', {
    absolute: true,
    cwd: distPath,
  });
  const userBaseUrl = userTsconfig.compilerOptions?.baseUrl;
  const baseUrl = isAbsolute(userBaseUrl || '.')
    ? userBaseUrl!
    : join(dirname(tsconfigPath), userBaseUrl || '.');
  const result = transformDtsAlias({
    filenames: dtsFilenames,
    baseUrl,
    paths: userTsconfig.compilerOptions?.paths ?? {},
  });
  return result;
};

export const writeDtsFiles = async (
  config: GeneratorDtsConfig,
  result: { path: string; content: string }[],
) => {
  const { dtsExtension } = config;
  // write to dist
  await Promise.all(
    result.map(({ path, content }) => {
      const filepath =
        // We confirm that users will not mix ts and c(m)ts files in their projects.
        // If a mix is required, please configure separate buildConfig to handle different inputs.
        // So we don't replace .d.(c|m)ts that generated by tsc directly, this can confirm that
        // users can use c(m)ts directly rather than enable autoExtension, in this condition,
        // users need to set esbuild out-extensions like { '.js': '.mjs' }
        path.replace(/\.d\.ts/, dtsExtension);
      fs.ensureFileSync(filepath);
      return fs.writeFile(
        // only replace .d.ts, if tsc generate .d.m(c)ts, keep.
        filepath,
        content,
      );
    }),
  );
};

export const addBannerAndFooter = (
  result: { path: string; content: string }[],
  banner?: string,
  footer?: string,
) => {
  return result.map(({ path, content }) => {
    const ms = new MagicString(content);
    banner && ms.prepend(`${banner}\n`);
    footer && ms.append(`\n${footer}\n`);
    return {
      path,
      content: ms.toString(),
    };
  });
};

export const printOrThrowDtsErrors = async (
  error: unknown,
  options: { abortOnError?: boolean; buildType: BuildType },
) => {
  const { InternalDTSError } = await import('../error');
  const local = await import('../locale');
  const { abortOnError, buildType } = options ?? {};
  if (error instanceof Error) {
    if (abortOnError) {
      throw new InternalDTSError(error, {
        buildType,
      });
    } else {
      logger.warn(
        chalk.bgYellowBright(
          local.i18n.t(local.localeKeys.warns.dts.abortOnError),
        ),
      );
      logger.error(
        new InternalDTSError(error, {
          buildType,
        }),
      );
    }
  }
};

export const tsTargetAtOrAboveES2022 = (target: TsTarget) =>
  target === 'es2022' || target === 'esnext';
