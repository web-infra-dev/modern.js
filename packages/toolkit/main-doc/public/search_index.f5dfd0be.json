[{"id":0,"title":"build","routePath":"/en/apis/app/commands/build","lang":"en","toc":[{"id":"analyze-bundle","text":"Analyze Bundle","depth":2}],"domain":"","content":"\n\nUsage: modern build [options]\n\nbuild application\n\nOptions:\n  -c --config <config>  configuration file path, which can be a relative path or an absolute path\n  -h, --help            show command help\n  --analyze             analyze the bundle and view size of each module\n\n\nmodern build command will by default build production in dist/.\n\nyou can configure the output.distPath specifies the output directory for the\nproduct.\n\n\nAnalyze Bundle\n\nexecute npx modern build --analyze command，can produce an HTML file that\nanalyzes the volume of the bundle while packaging the production code:\n\nBundle Analyzer saved report to /example/dist/report.html\nFile sizes after production build:\n\n  122.35 KB  dist/static/js/885.1d4fbe5a.js\n  2.3 KB     dist/static/js/main.4b8e8d64.js\n  761 B      dist/static/js/runtime-main.edb7cf35.js\n  645 B      dist/static/css/main.0dd3ecc1.css\n\n\nOpen the above HTML file in the browser, you can see the tile diagram of the\npackaged product, and perform package volume analysis and optimization:\n\n> this features based on webpack-bundle-analyzer.","frontmatter":{"sidebar_position":5}},{"id":1,"title":"dev / start","routePath":"/en/apis/app/commands/dev","lang":"en","toc":[{"id":"compile-partial-pages","text":"Compile Partial Pages","depth":2},{"id":"specify-the-page-by-parameter","text":"Specify the page by parameter","depth":3}],"domain":"","content":"\n\nUsage: modern dev / modern start [options]\n\nDevelopment commands\n\nOptions:\n  -e --entry <entry>    compiler by entry\n  -c --config <config>  configuration file path, which can be a relative path or an absolute path\n  -h, --help            show command help\n  --analyze             analyze the bundle and view size of each module\n  --api-only            only start API service\n\n\nmodern dev start a development server，watch file change，default support React\nFast Refresh:\n\nmodern start is an alias of modern dev command, the usage of the two are exactly\nthe same.\n\n$ modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n\nCompile Partial Pages\n\nIn multi-page (MPA) projects, the --entry option can be added to specify one or\nmore pages to compile. In this way, only part of the code in the project will be\ncompiled, and the dev startup speed will be faster.\n\nFor example, execute modern dev --entry, the entry selector will be displayed in\nthe command line interface:\n\n$ modern dev --entry\n\n? Please select the entry that needs to be built\n❯ ◯ foo\n  ◯ bar\n  ◯ baz\n\n\nFor example, if you select the foo entry, only the code related to the foo entry\nwill be compiled, and the code of other pages will not be compiled.\n\n\nSpecify the page by parameter\n\nYou can also specify the page name through parameters after --entry, and the\nnames of multiple pages can be separated by commas.\n\n# Compile foo page\nmodern dev --entry foo\n\n# Compile foo and bar pages\nmodern dev --entry foo,bar\n","frontmatter":{"sidebar_position":1}},{"id":2,"title":"inspect","routePath":"/en/apis/app/commands/inspect","lang":"en","toc":[{"id":"configuration-env","text":"Configuration Env","depth":2},{"id":"verbose-content","text":"Verbose content","depth":2},{"id":"ssr-configuration","text":"SSR Configuration","depth":3}],"domain":"","content":"\n\nUsage: modern inspect [options]\n\nOptions:\n  --env <env>           view the configuration in the target environment (default: \"development\")\n  --output <output>     Specify the path to output in the dist (default: \"/\")\n  --verbose             Show the full function in the result\n  -c --config <config>  configuration file path, which can be a relative path or an absolute path\n  -h, --help            show command help\n\n\nmodern inspect command used to view the Modern.js Builder config and webpack\nconfig of the project.\n\nAfter executing the command npx modern inspect in the project root directory,\nthe following files will be generated in the dist directory of the project:\n\n * builder.config.js: The Modern.js Builder config to use at build time.\n * webpack.config.web.js: The webpack config used by to use at build time.\n\n➜ npx modern inspect\n\nInspect config succeed, open following files to view the content:\n\n  - Builder Config: /root/my-project/dist/builder.config.js\n  - Webpack Config (web): /root/my-project/dist/webpack.config.web.js\n\n\n\nConfiguration Env\n\nBy default, the inspect command will output the development configs, you can use\nthe --env production option to output the production configs:\n\nmodern inspect --env production\n\n\n\nVerbose content\n\nBy default, the inspect command will omit the function content in the config\nobject, you can use the --verbose option to output the full content of the\nfunction:\n\nmodern inspect --verbose\n\n\n\nSSR Configuration\n\nIf the project has enabled SSR, an additional webpack.config.node.js file will\nbe generated in the dist/, corresponding to the webpack configuration at SSR\nbuild time.\n\n➜ npx modern inspect\n\nInspect config succeed, open following files to view the content:\n\n  - Builder Config: /root/my-project/dist/builder.config.js\n  - Webpack Config (web): /root/my-project/dist/webpack.config.web.js\n  - Webpack Config (node): /root/my-project/dist/webpack.config.node.js\n","frontmatter":{"sidebar_position":7}},{"id":3,"title":"lint","routePath":"/en/apis/app/commands/lint","lang":"en","toc":[],"domain":"","content":"\n\nUsage: modern lint [options] [...files]\n\nlint and fix source files\n\nOptions:\n  --no-fix    disable auto fix source file\n  -h, --help  display help for command\n\n\nRun ESLint to check the syntax of the code. Normally, only the part of the code\nmodified by this commit needs to be checked by lint-staged during the git commit\nphase.\n\n * --no-fix close auto fix by lint.","frontmatter":{"sidebar_position":4,"title":"lint"}},{"id":4,"title":"new","routePath":"/en/apis/app/commands/new","lang":"en","toc":[{"id":"add-entry","text":"Add Entry","depth":3},{"id":"enable-features","text":"Enable Features","depth":3}],"domain":"","content":"\n\nUsage: modern new [options]\n\nExecution Generator in App\n\nOptions:\n  -d, --debug            using debug mode to log something (default: false)\n  -c, --config <config>  set default generator config(json string)\n  --dist-tag <tag>       use specified tag version for its generator\n  --registry             set npm registry url to run npm command\n  -h, --help             show command help\n\n\nThe modern new command is used to enable features to an existing project.\n\nFor example, add application entry, enable some optional features such as\nTailwind CSS, micro frontend, etc.\n\n\nAdd Entry\n\nIn the project, execute the new command to add entries as follows:\n\n$ npx modern new\n? Action Create project element\n? Create project element New \"entry\"\n? Entry name entry\n\n\n\nEnable Features\n\nIn the project, execute the new command to enable features as follows:\n\n$ npx modern new\n? Action Enable features\n? Enable features (Use arrow keys)\n❯ Enable Tailwind CSS\n  Enable BFF\n  Enable SSG\n  Enable Micro Frontend\n  Enable Unit Test / Integration Test\n  Enable Visual Testing (Storybook)\n\n\nCAUTION\n\nThe --config parameter needs to use a JSON string.\n\npnpm does not support the use of JSON strings as parameter values currently. Use\nnpm new to turn on.【Relate Issue】","frontmatter":{"sidebar_position":2}},{"id":5,"title":"serve","routePath":"/en/apis/app/commands/serve","lang":"en","toc":[],"domain":"","content":"\n\nUsage: modern serve [options]\n\nrun server\n\nOptions:\n  -c --config <config>  configuration file path, which can be a relative path or an absolute path\n  -h, --help            show command help\n  --api-only            only run API service\n\n\nUsually use the modern serve command to enable project run in the production\nenvironment, and you need to execute the `build' command in advance to build the\nproduct.\n\nBy default, the project will run in localhost:8080, you can modify the Server\nport number with server.port:\n\nexport default defineConfig({\n  server: {\n    port: 8081,\n  },\n});\n","frontmatter":{"sidebar_position":6}},{"id":6,"title":"test","routePath":"/en/apis/app/commands/test","lang":"en","toc":[],"domain":"","content":"\n\nUsage: modern test [options]\n\nOptions:\n  -h, --help  show command help\n\n\nCAUTION\n\nmodern test command need to execute the new command in advance to enable the\nunit test/integration test.\n\nmodern test command will automatically run the test cases, the effect is as\nfollows:\n\n$ npx modern test\n PASS  src/tests/index.test.ts\n  The add method\n    ✓ should work fine. (2ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.994 s, estimated 1 s\n\n\nINFO\n\nfiles match *.test.(js|ts) in api/ or src/ will be recognized as test cases by\ndefault.","frontmatter":{"sidebar_position":3}},{"id":7,"title":"upgrade","routePath":"/en/apis/app/commands/upgrade","lang":"en","toc":[],"domain":"","content":"\n\nUsage: modern upgrade [options]\n\nupgrade Modern.js to latest version.\n\nOptions:\n  --registry <registry>  specify npm registry (default: \"\")\n  -d,--debug             using debug mode to log something (default: false)\n  --cwd <cwd>            app directory (default: \"\")\n  -h, --help             show command help\n\n\nExecute the command npx modern upgrade in the project, by default, dependencies\nin the package.json are updated to the latest version.","frontmatter":{"sidebar_position":8}},{"id":8,"title":"lambda/*.[tj]s","routePath":"/en/apis/app/hooks/api/framework/lambda","lang":"en","toc":[{"id":"routing-rule","text":"Routing Rule","depth":2},{"id":"default-route","text":"Default Route","depth":3},{"id":"multi-level-route","text":"Multi Level Route","depth":3},{"id":"dynamic-route","text":"Dynamic Route","depth":3},{"id":"allow-list","text":"Allow List","depth":3},{"id":"define-function","text":"Define Function","depth":2}],"domain":"","content":"\n\nDeclaring API routing in BFF framework mode. Except some files，files in api/ are\nregistered as routes.\n\nINFO\n\nuse api/ need execute new command to enable the 「BFF」 feature.\n\nTIP\n\nthis file supports the use js or ts, but the functions must be exported using\nthe ESM syntax.\n\n\nRouting Rule\n\n\nDefault Route\n\nThe files named index will be upper level routing:\n\n * api/lambda/index.ts -> $BASENAME/\n * api/lambda/user/index.ts -> $BASENAME/user\n\n\nMulti Level Route\n\nThe routing system also supports parsing multiple levels of files. and if you\ncreate a folder, the files will still be automatically parsed in the same way.\n\n * api/lambda/hello.ts -> $BASENAME/hello\n * api/lambda/user/list.ts -> $BASENAME/user/list\n\n\nDynamic Route\n\nDynamic named routing parameters can be supported by creating folders or files\nwith [xxx].\n\n * api/lambda/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/lambda/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/lambda/article/[id]/info.ts -> $BASENAME/article/:id/info\n\nthe $BASENAME can be configured in modern.config.js，the default value is /api.\n\n\nAllow List\n\nBy default, all files in the api/ will be parsed as BFF function. but we also\nset a allow list, and these files will not be parsed:\n\n * file name start with _, for example: _utils.ts.\n * files in directory that name start with _, for\n   example：_utils/index.ts、_utils/cp.ts.\n * test files, for example：foo.test.ts.\n * TypeScript define files, for example：hello.d.ts.\n * files in node_module.\n\n\nDefine Function\n\nthe same as Define Function.","frontmatter":{"title":"lambda/*.[tj]s","sidebar_position":1}},{"id":9,"title":"**/*.[tj]s","routePath":"/en/apis/app/hooks/api/functions/api","lang":"en","toc":[{"id":"routing-rule","text":"Routing Rule","depth":2},{"id":"default-route","text":"Default Route","depth":3},{"id":"multi-level-route","text":"Multi Level Route","depth":3},{"id":"dynamic-route","text":"Dynamic Route","depth":3},{"id":"allow-list","text":"Allow List","depth":3},{"id":"define-function","text":"Define Function","depth":2}],"domain":"","content":"\n\nDeclaring API routing in BFF function mode. Except some files，files in api/ are\nregistered as routes.\n\nINFO\n\nuse api/ need execute new command to enable the 「BFF」 feature.\n\nTIP\n\nthis file supports the use js or ts, but the functions must be exported using\nthe ESM syntax.\n\n\nRouting Rule\n\n\nDefault Route\n\nThe files named index will be upper level routing:\n\n * api/index.ts -> $BASENAME/\n * api/user/index.ts -> $BASENAME/user\n\n\nMulti Level Route\n\nThe routing system also supports parsing multiple levels of files. and if you\ncreate a folder, the files will still be automatically parsed in the same way.\n\n * api/hello.ts -> $BASENAME/hello\n * api/user/list.ts -> $BASENAME/user/list\n\n\nDynamic Route\n\nDynamic named routing parameters can be supported by creating folders or files\nwith [xxx].\n\n * api/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/article/[id]/info.ts -> $BASENAME/article/:id/info\n\nthe $BASENAME can be configured in modern.config.js，the default value is /api.\n\n\nAllow List\n\nBy default, all files in the api/ will be parsed as BFF function. but we also\nset a allow list, and these files will not be parsed:\n\n * file name start with _, for example: _utils.ts.\n * files in directory that name start with _, for\n   example：_utils/index.ts、_utils/cp.ts.\n * test files, for example：foo.test.ts.\n * TypeScript define files, for example：hello.d.ts.\n * files in node_module.\n\n\nDefine Function\n\nIn addition to the above routing rules, the function definition and export in\nthe code also have conventions.\n\nfunction need named exports，and the name of the exported function is the HTTP\nMethod:\n\nexport const get = async () => {\n  return {\n    name: 'Modern.js',\n    desc: 'Modern web Solutions',\n  };\n};\n\n\nExport the function like above will generate a POST interface.\n\nApp support 9 Method definitions:\nGET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTION、HEAD. so App can use these name\nas function export nane.\n\nThe name is insensitive, whaterver get、Get、GEt、GET, can be accurately\nidentified. And default export, export default xxx will be Get method.\n\nbecause delete is a keyword in JavaScript, use del or DELETE instead.\n\nMultiple functions of different Methods can be defined in one file, but if\nmultiple functions of the same Method are defined, only the first can work.\n\n:::info It should be noted that the defined functions should be asynchronous,\nwhich is related to the type when the function is called.","frontmatter":{"title":"**/*.[tj]s","sidebar_position":1}},{"id":10,"title":"_app.[tj]s","routePath":"/en/apis/app/hooks/api/functions/app","lang":"en","toc":[],"domain":"","content":"\n\nin BFF function mode，this file can add middleware before BFF 函数.\n\nNOTE\n\nFor detail, see hook","frontmatter":{"title":"_app.[tj]s","sidebar_position":3}},{"id":11,"title":"**/_*.[tj]s, _*/**","routePath":"/en/apis/app/hooks/api/functions/common","lang":"en","toc":[],"domain":"","content":"/_.[tj]s, _/\n\nunder BFF function mode, these files are not registered as routes.\n\nAny files that not routes, but required in the project can be named in this way.","frontmatter":{"title":"**/_*.[tj]s, _*/**","sidebar_position":2}},{"id":12,"title":"test.[tj]s","routePath":"/en/apis/app/hooks/api/test","lang":"en","toc":[],"domain":"","content":"\n\nApp's BFF test file，support for writing test cases in the api/ directory which\nfile with suffix .test.[tj]s.\n\nINFO\n\nTo use unit test and integration test, you need to execute the new command in\nadvance to enable the unit test/integration test.","frontmatter":{"title":"test.[tj]s","sidebar_position":2}},{"id":13,"title":"html/","routePath":"/en/apis/app/hooks/config/html","lang":"en","toc":[],"domain":"","content":"\n\nThe config/html directory allows you to inject custom html snippets in different\nplaces in the default html template.\n\nFor detail, see HTML.","frontmatter":{"title":"html/","sidebar_position":1}},{"id":14,"title":"icon.png","routePath":"/en/apis/app/hooks/config/icon","lang":"en","toc":[],"domain":"","content":"\n\nWhen config/icon.png exist, it can inject app icon information into the html\npage at build time:\n\n.config\n└── icon.png\n\n\nthe app icon link meta will be injected into the html, as follows:\n\n","frontmatter":{"title":"icon.png","sidebar_position":2}},{"id":15,"title":"mock/","routePath":"/en/apis/app/hooks/config/mock","lang":"en","toc":[],"domain":"","content":"\n\nwhen config/mock/index.js exist，Modernjs auto start the Mock service in the\ndevelopment.","frontmatter":{"title":"mock/","sidebar_position":5}},{"id":16,"title":"public/","routePath":"/en/apis/app/hooks/config/public","lang":"en","toc":[{"id":"description","text":"Description","depth":2},{"id":"scene","text":"Scene","depth":2},{"id":"compression","text":"Compression","depth":2}],"domain":"","content":"\n\nStatic resource files in any format can be placed in the public/, and the files\nwill be Served under the web application domain name.\n\n\nDescription\n\nThe routing of files to be served is based on the convention of the file system.\npublic/ is the root directory, which corresponds to the root path of the Web\napplication.\n\nFor example, the config/public/sdk/index.js file will be Served under\n${domain}/sdk/index.js after deployment.\n\n\nScene\n\nFor example, robots.txt, auth.xml and other authentication file.\n\nSDK (requiring the same routing) for other business, or an HTML file for static\nhost.\n\nINFO\n\nFor static resources (such as SVG pictures) that need to be referenced by import\nin the source code, it is recommended to put them in the src/assets/ for\nmanagement.\n\n\nCompression\n\nIf the file is a .js file, it will be automatically compressed when the\nproduction environment is built.\n\nIf the file ends with .min.js, it will not compression.","frontmatter":{"title":"public/","sidebar_position":3}},{"id":17,"title":"storybook/","routePath":"/en/apis/app/hooks/config/storybook","lang":"en","toc":[],"domain":"","content":"\n\nModern.js.js supports debugging with Storybook. When you need to configure\nStorybook, configure it in the config/storybook/.\n\nFor detail, see Storybook.\n\nINFO\n\nDebugging with Storybook requires executing the new command to enable the\n「Visual Testing (Storybook)」 mode feature.","frontmatter":{"title":"storybook/","sidebar_position":7}},{"id":18,"title":"upload/","routePath":"/en/apis/app/hooks/config/upload","lang":"en","toc":[{"id":"description","text":"Description","depth":2},{"id":"scene","text":"Scene","depth":2},{"id":"compression","text":"Compression","depth":2},{"id":"more-usage","text":"More Usage","depth":2}],"domain":"","content":"\n\nStatic resource files in any format can be placed in the upload/.\n\n\nDescription\n\nIn the development environment, the static resource files in this directory will\nbe hosted in the '/upload' path. After building the application product, the\nfiles in this directory will be copied to the dist path.\n\nThis file convention is mainly used for developers to use plugins to upload\nstatic resource files to the CDN.\n\n\nScene\n\nFor example, the SDK used by the project such as google-analysis.js (usually\nrequires http caching).\n\nImages, font files, generic CSS, etc.\n\n\nCompression\n\nIf the file is a .js file, it will be automatically compressed when the\nproduction environment is built.\n\nIf the file ends with .min.js, it will not compression.\n\n\nMore Usage\n\nWhether in custom HTML, or in any HTML file under 'config/public/', you can\ndirectly use the HTML tag to refer to the resources in the config/upload/:\n\n<script src=\"/upload/index.js\"></script>\n\n\nif output.assetPrefix is configured，add this prefix directly using template\nsyntax:\n\n<script src=\"<%=assetPrefix %>/upload/index.js\"></script>\n\n\nINFO\n\nModern.js does not support the use files under upload/ in config/public/*.css\nvia URL.","frontmatter":{"title":"upload/","sidebar_position":4}},{"id":19,"title":"modern.config.js","routePath":"/en/apis/app/hooks/modern-config","lang":"en","toc":[],"domain":"","content":"\n\nModern.js config file, through which you can confiured all aspects of the\ncurrent project.\n\nFor detail, see configure.","frontmatter":{"title":"modern.config.js","sidebar_position":8}},{"id":20,"title":"index.[tj]s","routePath":"/en/apis/app/hooks/server/index_","lang":"en","toc":[],"domain":"","content":"\n\nA file that extends the Modern.js Web Server, to add a Hook or Middleware to the\nWeb Server that the project uses.\n\nIt can intercept requests and responses, authenticate and role, request\npreprocessing, exception bottom-up, etc.;\n\nIt can also be inserted logic into the built-in processing handler (including\nroute matching, resource addressing, header injection, page rendering, static\nweb hosting).\n\nINFO\n\nFor detail, see Hook & Middleware.","frontmatter":{"title":"index.[tj]s","sidebar_position":1}},{"id":21,"title":"test.[tj]s","routePath":"/en/apis/app/hooks/server/test","lang":"en","toc":[],"domain":"","content":"\n\nApp's Web Server test file，support for writing test cases in the server/\ndirectory which file with suffix .test.[tj]s.\n\nINFO\n\nTo use unit test and integration test, you need to execute the new command in\nadvance to enable the unit test/integration test.","frontmatter":{"title":"test.[tj]s","sidebar_position":2}},{"id":22,"title":"shared/","routePath":"/en/apis/app/hooks/shared","lang":"en","toc":[],"domain":"","content":"\n\nShared directory. When the project has common code under api/, server/, src/,\nput the code under this directory rather then import directly.","frontmatter":{"title":"shared/","sidebar_position":5}},{"id":23,"title":"App.[tj]sx","routePath":"/en/apis/app/hooks/src/app","lang":"en","toc":[],"domain":"","content":"\n\nEntry identifier if App want control route by code.\n\nApp.[tj]sx is not the actual App entry, Modern.js will auto generate the entry\nfile, the content is roughly as follows:\n\n\n\n// App.[jt]sx\n\n\nimport {\n  immer,\n  effects,\n  autoActions,\n  devtools,\n} from '@modern-js/runtime/model';\n\nconst createStatePlugins = config => {\n  const plugins = [];\n  plugins.push(immer(config['immer']));\n  plugins.push(effects(config['effects']));\n  plugins.push(autoActions(config['autoActions']));\n  plugins.push(devtools(config['devtools']));\n  return plugins;\n};\nlet AppWrapper = null;\nfunction render() {\n  AppWrapper = createApp({\n    plugins: [\n      state({\n        ...{ plugins: createStatePlugins(true) },\n        ...App?.config?.state,\n      }),\n    ],\n  })(App);\n  if (IS_BROWSER) {\n    bootstrap(AppWrapper, MOUNT_ID);\n  }\n  return AppWrapper;\n}\nAppWrapper = render();\nexport default AppWrapper;\n\n\nNOTE\n\nIn multi-entry App，each entry can have a App.[jt]sx, for detail, see Entry.","frontmatter":{"title":"App.[tj]sx","sidebar_position":1}},{"id":24,"title":"index.[tj]s","routePath":"/en/apis/app/hooks/src/index_","lang":"en","toc":[],"domain":"","content":"\n\nEntry identifier if App want use custom entry. In most case, App.[tj]sx hook\nfile can already meet our needs.\n\nWhen we need to add custom behavior before bootstrap or completely take over the\nwebpack entry, we can place index.[tj]s in src/ or entry directory. The\nfollowing are discussed in two cases:\n\n 1. add custom behavior before bootstrap\n\nJust add default export under src/index.[tj]s:\n\n\n\nexport default App => {\n  // do something before bootstrap...\n  bootstrap(App, 'root');\n};\n\n\n 2. Fully take over the webpack entry\n\nWhen there is no default export function under src/index.[tj]sx?, this file is\nthe real webpack entry file, and the code can be organized such as\ncreate-react-app:\n\n\n\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n","frontmatter":{"title":"index.[tj]s","sidebar_position":4}},{"id":25,"title":"pages/","routePath":"/en/apis/app/hooks/src/pages","lang":"en","toc":[{"id":"dynamic-routing","text":"Dynamic Routing","depth":3},{"id":"global-layout","text":"Global Layout","depth":3},{"id":"partial-layout","text":"Partial Layout","depth":3},{"id":"404-路由","text":"404 路由","depth":3}],"domain":"","content":"\n\nEntry identifier if the application want uses file system-based routing.\n\nWhen the entry is the Pages entry type, the files in the pages/ directory will\nbe analyzed to client side routing.\n\nFor example, the following directory:\n\n.\n└── src\n    └── pages\n        ├── about\n        │   └── index.jsx\n        ├── index.jsx\n        └── info.jsx\n\n\nThe generated route is configured as:\n\n[\n  { path: '/', component: 'pages/index.jsx' },\n  { path: '/info' component: 'pages/info.jsx' },\n  { path: '/about', component: 'pages/about/index.jsx' }\n]\n\n\nFiles match the following conditions will not be treated as routing files:\n\n * suffix is not .(j|t)sx?.\n * .d.ts type definition file.\n * test file suffix like .(test|spec|e2e).(j|t)sx?.\n\nTIP\n\nit is recommended to write only the routing files in the pages/, and write the\nbusiness logic to the independent features directory outside the pages/. In this\nway, most of the files in the pages directory will be routing files, and there\nis no need for additional filtering rules.\n\n\nDynamic Routing\n\nDirectories or files wrapped with [] are considered dynamic routing.\n\nFor example the following directory structure:\n\n.\n└── src\n    └── pages\n        ├── [post]\n        │   ├── detail.jsx\n        │   └── index.js\n        ├── users\n        │   └── [id].jsx\n        ├── index.jsx\n        └── info.jsx\n\n\nThe generated route is configured as:\n\n[\n  { path: '/', component: 'pages/index.jsx' },\n  { path: '/info', component: 'pages/info.jsx' },\n  { path: '/:post/', component: 'pages/[post]/index.js' },\n  { path: '/:post/detail' components: 'pages/[post]/detail.jsx'},\n  { path: '/users/:id', components: 'pages/users/[id].jsx'}\n]\n\n\nBasis dynamic routing, it supports adding special routing suffixes (*、?、+).\n\nFor example: src/pages/users/[id]*.tsx generate route /users/:id*\n\n\nGlobal Layout\n\nWhen the entire App needs a global layout, it can be achieved through\npages/_app.tsx, which as follows:\n\n\n\n\nexport default const App = ({Component, ...pageProps}:{ Component: React.ComponentType}) => {\n  return (\n    <UserLayout>\n      <Component {...pageProps} />\n    </UserLayout>\n  );\n}\n\n\nThe above Component is the component to which the route is accessed.\n\nFor example the following directory structure:\n\n.\n└── pages\n    ├── a\n    │   ├── b\n    │   │   └── index.js\n    │   └── index.js\n    └── index.js\n\n\n * access /, the Component is pages/index.js.\n * access /a, the Component is pages/a/index.js.\n * access /a/b, the Component is pages/a/b/index.js.\n\nAdvantages\n\n * preserve the state of the global layout when the page changes.\n * add global css.\n * handle ComponentDidCatch error\n * use defineConfig(/docs/apis/app/runtime/app/define-config) dynamic\n   configuration runtime.\n\n\nPartial Layout\n\nWhen developing an App, where sub routes under the same route may share the\nlayout.\n\nFor this scene, Modern.js convention, when there is a _layout.js in the\ndirectory, the routes can shared this layout.\n\nFor example the following directory structure:\n\n└── pages\n    ├── a\n    │   ├── b\n    │   │   └── index.js\n    │   ├── _layout.js\n    │   └── index.js\n    └── index.js\n\n\n\n\nconst ALayout = ({ Component, ...pageProps }) => {\n  return <Component {...pageProps} />;\n};\nexport default ALayout;\n\n\nThe Component props is the specific route, for example\n\n * access /a, the Component is pages/a/index.js.\n * 访问 /a/b, the Component is pages/a/b/index.js.\n\nIn this way, you can use pages/a/_layout.js to display the routing common layout\nin the a directory.\n\n\n404 路由\n\nThe convention pages/404.[tj]sx is the default 404 route.\n\nFor example the following directory structure:\n\n.\n└── src\n    └── pages\n        ├── user.js\n        ├── home.js\n        ├── 404.js\n\n\nthe generated route is configured is as:\n\n[\n { path: '/user', component: './pages/user.js'},\n { path: '/home', component: './pages/home.js' },\n { path: '*', component: './pages/404.js'}\n]\n\n\nAll unmatched routes will match to pages/404.[tj]s.","frontmatter":{"title":"pages/","sidebar_position":3}},{"id":26,"title":"routes/","routePath":"/en/apis/app/hooks/src/routes","lang":"en","toc":[{"id":"basic-example","text":"basic example","depth":2},{"id":"dynamic-route","text":"Dynamic Route","depth":2},{"id":"layout-component","text":"Layout component","depth":2}],"domain":"","content":"\n\nThe entry identifier when the application uses file system-based routing.\n\nWhen the project structure is of type Routes directory entry, the files in the\nsrc/routes directory are parsed to get the client-side routing configuration.\nSee Routing by convention for more details on usage.\n\nAny layout.[tj]sx and page.[tj]sx under src/routes will be used as a route to\nthe application：\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n\nbasic example\n\nThe directory names in the routes directory will be used as a mapping of the\nroute url, where layout.tsx is used as the layout component and page.tsx as the\ncontent component, which is a leaf node of the whole route, for example the\nfollowing directory structure：\n\n.\n└── routes\n    ├── page.tsx\n    └── user\n        └── page.tsx\n\n\nThe following two routes are produced:\n\n * /\n * /user\n\n\nDynamic Route\n\nIf the directory name of the route file is named with [], the generated route\nwill be used as a dynamic route. For example, the following file directories:\n\n└── routes\n    ├── [id]\n    │   └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nThe routes/[id]/page.tsx file will be converted to a /:id route. All /xxx will\nmatch that route, except for the /blog route, which can be matched exactly.\n\nIn the component, you can get the corresponding parameters by useParams.\n\nIn the loader, params will be used as input to loader, and the corresponding\nparameters can be retrieved through the property params.\n\n\nLayout component\n\nAs in the example below, you can add a common layout component for all routing\ncomponents by adding layout.tsx\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\nYou can represent child components in layout components by using <Outlet>:\n\n\n\nexport default () => {\n  return (\n    <>\n      <Outlet></Outlet>\n    </>\n  );\n};\n\n\nNOTE\n\n<Outlet> is a new API in React Router 6, see [Outlet] for\ndetails(https://reactrouter.com/en/main/components/outlet#outlet).","frontmatter":{"title":"routes/","sidebar_position":2}},{"id":27,"title":"*.[server|node].[tj]sx","routePath":"/en/apis/app/hooks/src/server","lang":"en","toc":[],"domain":"","content":"\n\nUsed in application projects to place server side code, it generally has the\nfollowing two functions：\n\n 1. When *.tsx and *. [server|node].tsx coexist, rendering on the server side\n    will give preference to the *. [server|node].tsx file instead of the *.tsx\n    file.\n\n 2. When using data loader, the server-side dependencies need to be re-exported\n    from this file\n\n// routes/user/avatar.tsx\n\n\n\ntype ProfileData = {\n  /* some type declarations */\n};\n\nexport const loader = async (): ProfileData => {\n  const profile = await readFile('profile.json');\n  return profile;\n};\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return <div>{profileData}</div>;\n}\n\n// routes/user/utils.server.ts\nexport * from 'fs-extra';\n","frontmatter":{"title":"*.[server|node].[tj]sx","sidebar_position":8}},{"id":28,"title":"**/*.stories.[tj]sx","routePath":"/en/apis/app/hooks/src/stories","lang":"en","toc":[],"domain":"","content":"\n\nApp Storybook debug file. files in src/ which suffix *.stories.[tj]sx are as\ndebug files for Storybook.\n\nExecute the dev story command to debugging these files in the Storybook.\n\nINFO\n\nUsing a Storybook requires executing new command to enable the 「Visual Testing\n(Storybook)」 mode.","frontmatter":{"title":"**/*.stories.[tj]sx","sidebar_position":7}},{"id":29,"title":"**/*.test.[tj]sx?","routePath":"/en/apis/app/hooks/src/test","lang":"en","toc":[],"domain":"","content":"\n\nApp test file.\n\nThe App supports the file suffixed with .test.[tj]sx under the src/ to write\ntest cases.\n\nINFO\n\nTo use unit test and integration test, you need to execute the new command in\nadvance to enable the unit test/integration test.","frontmatter":{"title":"**/*.test.[tj]sx?","sidebar_position":6}},{"id":30,"title":"defineConfig","routePath":"/en/apis/app/runtime/app/define-config","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nFor dynamically configuring applications runtime features.\n\n\nUsage\n\n\n\nRuntime configurations can usually be configured under the runtime of the\nmodern.config.js, such as the router configuration.\n\nThe configuration in modern.config.js is determined at build time，If some\nconfiguration parameters are obtained at runtime, or if the configuration\nparameters are from a module (such as a component), then need use defineConfig\nAPI configuration on runtime.\n\nINFO\n\n@modern-js/app-tools has the same name API, Used to provide TS type for\nconfiguration, please distinguish them.\n\n\nFunction Signature\n\nfunction defineConfig(Component, config): any;\n\n\n\nInput\n\n * Component: App root Component.\n * config: runtime config.\n\n\nExample\n\nfunction App () {\n  ...\n}\n\ndefineConfig(App, {\n  router: {\n    supportHtml5History: false\n  }\n})\n\n\n 1. defineConfig can configuring runtime.state、runtime.router etc.\n\n 2. defineConfig before configuring a property, such as router, you need to make\n    sure that the modern.config.js has been configured to enable this feature.\n\n 3. defineConfig incoming configuration will be merged with the configuration in\n    modern.config.js. Taking router as an example, the final application\n    configuration is as follows:\n\n{\n  // 来自 `modern.config.js`\n  ...runtime.router\n  // 来自 `defineConfig`\n  ...config.router\n}\n","frontmatter":{"title":"defineConfig"}},{"id":31,"title":"hook","routePath":"/en/apis/app/runtime/bff/hook","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUsed to add framework middleware under BFF function mode, the middleware will\nexecute before BFF function.\n\n\nUsage\n\naccording to the framework extend plugin, export from the corresponding\nnamespace:\n\n\n\n\nFunction Signature\n\ntype HookOptions = {\n  addMiddleware: string | function;\n};\n\nfunction hook(options: HookOptions): void;\n\n\n\nInput\n\n * options: a range of hooks provided by Modern.js.\n   * addMiddleware: add middlewares for BFF.\n\n\nExample\n\nmiddleware for different frameworks should be different(an example is when using\nthe koa framework):\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(async (ctx, next) => {\n    ctx.req.query.id = 'koa';\n    await next();\n  });\n});\n","frontmatter":{"title":"hook"}},{"id":32,"title":"useContext","routePath":"/en/apis/app/runtime/bff/use-context","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUsed to get the request context in the BFF function.\n\n\nUsage\n\naccording to the framework extend plugin, export from the corresponding\nnamespace:\n\n\n\n\nFunction Signature\n\nfunction useContext(): any\n\n\nExample\n\nDevelopers can get more request information through context, such as browser\nUA(an example is when using the koa framework):\n\n\n\nexport async function get() {\n  const ctx = useContext();\n  return ctx.req.headers['user-agent'];\n}\n\n\nCAUTION\n\nonly in BFF function, useContext API can be used.\n\nAlthough the useContext API is supported in any framework extend plugin, the\ntypes of return values are different.","frontmatter":{"title":"useContext"}},{"id":33,"title":"bootstrap","routePath":"/en/apis/app/runtime/core/bootstrap","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUsed to start and mount App, usually without manual calls. This API is only\nrequired when using Custom App.\n\n\nUsage\n\n\n\n\nbootstrap(App, 'root', undefined, ReactDOM);\n\n\n\nFunction Signature\n\ntype BootStrap<T = unknown> = (\n  App: React.ComponentType,\n  id: string | HTMLElement | RuntimeContext,\n  root?: any,\n  ReactDOM?: {\n    render?: Renderer;\n    hydrate?: Renderer;\n    createRoot?: typeof createRoot;\n    hydrateRoot?: typeof hydrateRoot;\n  },\n) => Promise<T>;\n\n\n\nInput\n\n * AppComponent: reactElement instance created by createApp.\n * rootId: DOM root element id to mount，like \"root\".\n * root: ReactDOM.create the return value, which is used in the scenario where\n   the root needs to destroy the component outside the bootstrap function.\n * ReactDOM: ReactDOM object for distinguishing between React 18 and React 17\n   APIs.\n\n\nExample\n\n\n\n\nfunction App() {\n  return <div>Hello Modern.js</div>;\n}\n\nconst WrappedApp = createApp({\n  // customized plugin\n  plugins: [customPlugin()],\n})(App);\n\nbootstrap(WrappedApp, 'root', undefined, ReactDOM);\n\n\nINFO\n\nsince @modern-js/runtime/plugins is a alias，when used in a ts project, its type\nneeds to be declared，Just add the following type declarations to\nsrc/modern-app-env.d.ts:\n\ndeclare module '@modern-js/runtime/plugins';\n\n\nWARNING\n\nbootstrap only supported for use in CSR.","frontmatter":{"title":"bootstrap"}},{"id":34,"title":"createApp","routePath":"/en/apis/app/runtime/core/create-app","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2},{"id":"create-custom-entry","text":"Create Custom Entry","depth":3},{"id":"custom-plugins","text":"Custom Plugins","depth":3}],"domain":"","content":"\n\nUsed to create custom entries, custom runtime plugins. This API is only required\nwhen using Custom App.\n\n\nUsage\n\n\n\n\nFunction Signature\n\n\n\nfunction createApp(options: { plugins: Plugin[] }): React.ComponentType<any>;\n\n\n\nInput\n\n * options: optional configuration.\n   * plugins: custom plugin extensions.\n\n\nExample\n\n\nCreate Custom Entry\n\nFor details, see bootstrap.\n\n\nCustom Plugins\n\n\n\nfunction App() {\n  return <div>app</div>;\n}\n\nexport default createApp({\n  plugins: [customPlugin()],\n})(App);\n","frontmatter":{"title":"createApp"}},{"id":35,"title":"useLoader","routePath":"/en/apis/app/runtime/core/use-loader","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-value","text":"Return Value","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nIsomorphic API，usually used to make asynchronous requests. When SSR, the server\nlevel uses useLoader to prefetch the data, and the browser side also reuses this\npart of the data.\n\n\nUsage\n\n\n\n\nFunction Signature\n\ntype LoaderFn = (context: runtimeContext) => Promise<unknow>;\ntype Options = {\n  onSuccess: (data: Record<string, any>) => void;\n  onError: (error: Error) => void;\n  initialData: Record<string, any>;\n  skip: boolean;\n  params: Record<string, any>;\n  static: boolean;\n};\ntype ReturnData = {\n  data: Record<string, any>;\n  loading: boolean;\n  error: Error;\n  reload: (params?: Record<string, any>) => Promise<any> | undefined;\n  reloading: boolean;\n};\n\nfunction useLoader(loaderFn: LoaderFn, options: Options): ReturnData;\n\n\nINFO\n\nruntimeContext can refer to useRuntimeContext.\n\n\nInput\n\n * loaderFn: function for loading data, returning a Promise.\n * options: optional configuration.\n   * onSuccess: successful callback.\n   * onError: error callback.\n   * initialData: the initial data before the first execution,.\n   * skip: when the value is true, the function does not execute.\n   * params: when the result of the params serialization changes，the function is\n     re-executed. params is also passed in as the second argument of the\n     function.\n   * static: when the value is true, useLoader is used for SSG.\n\n\nReturn Value\n\n * data: return data on successful execution.\n * loading: indicates whether the function is in execution.\n * error: error message when function execution fails.\n * reload: the function can be re-executed after the call.\n   * params: when the value is undefined, the last value will be reused;\n     otherwise, the function will be re-executed with the new value.\n * reloading: during the execution of the call to reload, the value of reloading\n   is true.\n\n\nExample\n\nfunction Container() {\n  const { data, error, loading } = useLoader(\n    async (context, params) => {\n      console.log(params) // nicole\n      return fetch(user);\n    },\n    {\n      onSuccess: data => {\n        console.log('I did success:(',  data);\n      },\n      onError: error => {\n        console.log('I met error:)',  error);\n      },\n      initialData: { name: 'nicole', gender: 'female' },\n      params: 'nicole'\n    }\n  );\n\n  return ...;\n}\n","frontmatter":{"title":"useLoader"}},{"id":36,"title":"useModuleApps","routePath":"/en/apis/app/runtime/core/use-module-apps","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"example","text":"Example","depth":2},{"id":"centralized-routing","text":"Centralized Routing","depth":3},{"id":"load-animation","text":"Load Animation","depth":2}],"domain":"","content":"\n\nReturns the React components of all micro-front-end sub-applications for freely\ncontrolled routing.\n\n\nUsage\n\n\n\n\nFunction Signature\n\nfunction useModuleApps(): Record<string, React.FC<any>>\n\nReturns the React components wrapped around each subapp.\n\n\nExample\n\nYou need to configure the micro-front-end sub-application information first.\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n    masterApp: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\nfunction App() {\n  const { Home, Contact } = useModuleApps();\n\n  return (\n    <div>\n      Master APP\n      <Route exact path=\"/home\">\n        <Home />\n      </Route>\n      <Route exact path=\"/home\">\n        <Contact />\n      </Route>\n    </div>\n  );\n}\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        // name is case-sensitive, what name provides is what useModuleApps returns\n        name: 'Home',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'Contact',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\nGet the Home and Contact sub-application components(the same as name in the\nconfig) through useModuleApps(). After that, you can load the child application\njust like a normal React component.\n\n\nCentralized Routing\n\nCentralized Routing is a way to centrally configure the activation routes of\nsub-applications. Add activeWhen config to enable Centralized Routing.\n\n\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        name: 'DashBoard',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'TableList',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\nThen use the useModuleApp method to get the MApp component in the main\napplication, and render the MApp in the main application.\n\n\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    <div>\n      <MApp />\n    </div>\n  );\n}\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        // name is case sensitive, what name provides is what useModuleApps returns\n        name: 'Dashboard',\n        activeWhen: '/dashboard',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'TableList',\n        activeWhen: '/table',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\nAfter starting the application in this way, accessing the /dashboard route will\nrender the Dashboard, and accessing the /table route will render the TableList.\n\n\nLoad Animation\n\nThe transition animation of the component loading process can be customized in\nthe following ways.\n\nfunction App() {\n  const {\n    Components: { Home },\n  } = useModuleApps();\n\n  return (\n    <div>\n      Master APP\n      <Route exact path=\"/home\">\n        <Home\n          loadable={{\n            loading: ({ pastDelay, error }: any) => {\n              if (error) {\n                console.error(error);\n                return <div>error: {error?.message}</div>;\n              } else if (pastDelay) {\n                return <div>loading</div>;\n              } else {\n                return null;\n              }\n            },\n          }}\n        />\n      </Route>\n    </div>\n  );\n}\n","frontmatter":{"title":"useModuleApps"}},{"id":37,"title":"useRuntimeContext","routePath":"/en/apis/app/runtime/core/use-runtime-context","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"return-value","text":"Return Value","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nThis function is mainly used to get the runtime context and can only be used in\nfunction components.\n\n\nUsage\n\n\n\nexport function App() {\n  const runtimeContext = useRuntimeContext();\n  return <div>Hello World</div>;\n}\n\n\n\nFunction Signature\n\ntype RuntimeContext = {\n  request: {\n    params: Record<string, string>;\n    pathname: string;\n    query: Record<string, string>;\n    headers: IncomingHttpHeaders;\n    cookie: string;\n  };\n  store: ReduckStore;\n};\n\nfunction useRuntimeContext(): RuntimeContext;\n\n\n\nReturn Value\n\n * request: additional information in the request context.\n   * params: dynamic parameters in the request path.\n   * pathname: the pathname of the request.\n   * query: the query of the request.\n   * headers: the header info of the request.\n   * cookie: the cookie of the request.\n * store: when the runtime.state is enabled, this value is the reduck global\n   store.\n\n\nExample\n\n\n\n\nfunction App() {\n  const { store } = useRuntimeContext();\n\n  const [state, actions] = store.use(fooModel);\n\n  return <div>state: {state}</div>;\n}\n","frontmatter":{"title":"useRuntimeContext"}},{"id":38,"title":"Provider","routePath":"/en/apis/app/runtime/model/Provider","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nProvider is a component that injects Reduck's Store into the application's\ncomponent tree, making the Model accessible to components inside the component\ntree. Normally, Provider is defined at the top level of the component tree.\n\n\nFunction Signature\n\ninterface ProviderProps {\n  store?: ReduckStore;\n  config?: AppConfig;\n}\n\n\n\nInput\n\n * store: the Store object created by createStore.\n * config: this config to create Reduck Store, same as config param in\n   createApp.\n\n\nExample\n\nReactDOM.render(\n  <Provider>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n","frontmatter":{"sidebar_position":8,"title":"Provider"}},{"id":39,"title":"Auto actions","routePath":"/en/apis/app/runtime/model/auto-actions","lang":"en","toc":[{"id":"example","text":"Example","depth":2},{"id":"basic-data-type","text":"Basic Data Type","depth":3},{"id":"array","text":"Array","depth":3},{"id":"plainobject","text":"PlainObject","depth":3}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nReduck can automatically generate Actions according to the type of State，for\neasy to modify State.\n\nTIP\n\ncan use runtime.state.autoActions close auto actions feature.\n\n\nExample\n\n\nBasic Data Type\n\nState type in string、number、boolean、null，generate setState Action.\n\nconst fooModel = model('foo').define({\n  state: 1,\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  return (\n    <div>\n      <div>State: {state}</div>\n      <button\n        type=\"button\"\n        onClick={() => {\n          // call auto generate setState Action\n          actions.setState(state + 1);\n        }}\n      >\n        add\n      </button>\n    </div>\n  );\n}\n\n\n\nArray\n\nState type is Array，generate the following Actions:\n\n * push: adds one or more elements to the end of the array.\n * pop: removes the last element from the array.\n * shift: removes the first element from the array.\n * unshift: adds one or more elements to the beginning of the array.\n   * usage: arr.unshift(element1, ..., elementN)\n   * elementN: the element or elements to add to the beginning of the array.\n * filter: filter element. {/* 语义与原生方法不同，待修改 API */}\n * concat: concat array. {/* 语义与原生方法不同，待修改 API */}\n * splice: modify the array by deleting or replacing existing elements or adding\n   new elements in place, and return the modified array(Note that it is\n   different from the native splice return value).\n   * usage: splice(start[, deleteCount[, item1[, item2[, ...]]]])\n   * start: specifies the start position of the modification(counting from 0).\n   * deleteCount: an integer representing the number of array elements to\n     remove.\n   * item, item2, ...: The elements to add to the array, starting at the start\n     position. If not specified, splice will only delete array elements.\n\nconst fooModel = model('foo').define({\n  state: [1, 2, 3],\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  useEffect(() => {\n    actions.push(4);\n    actions.pop();\n    actions.shift(0);\n    actions.unshift();\n    actions.filter(val => val <= 2);\n    actions.splice(0, 1, 1, 2);\n  }, []);\n\n  return (\n    <div>\n      <div>State: {state}</div>\n    </div>\n  );\n}\n\n\n\nPlainObject\n\nState type is PlainObject，base on the names contained in State，generate\nset${key}(Camel-Case) Actions.\n\nconst fooModel = model('foo').define({\n  state: {\n    a: 1,\n    b: { value: 1 },\n    c: 'c',\n  },\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  useEffect(() => {\n    actions.setA(2);\n    actions.setB({ value: 2 });\n    actions.setC('d');\n  }, []);\n\n  return (\n    <div>\n      <div>State: {state}</div>\n    </div>\n  );\n}\n","frontmatter":{"sidebar_position":6,"title":"Auto actions"}},{"id":40,"title":"connect","routePath":"/en/apis/app/runtime/model/connect","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-type","text":"Return Type","depth":3},{"id":"example","text":"Example","depth":2},{"id":"basic","text":"Basic","depth":3},{"id":"select-state--actions","text":"Select State & Actions","depth":3},{"id":"forwarding-ref","text":"Forwarding Ref","depth":3}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nTIP\n\nThe original type of Reduck is complex. The following type definition shows the\nsimplified type information. For the original type, see connect.\n\nConnect is the same as useModel and is the corresponding HOC-style API. It is\nrecommended to use the Hook-style useModel first.\n\n\nFunction Signature\n\ntype SelectStateToProps = (\n  ...modelStates: State[],\n  ownProps?: any,\n) => PlainObject;\ntype SelectActionsToProps = (\n  ...modelActions: Actions[],\n  ownProps?: any,\n) => PlainObject;\n\nfunction connect(models: Model, options?: ConnectOptions);\nfunction connect(\n  models: [...Model[], SelectStateToProps?, SelectActionsToProps?],\n  options?: ConnectOptions,\n);\n\n\n\nInput\n\n * models: passed one or more Models. When models is an array type parameter,\n   the last two params can be a function for filtering State (SelectStateToProps\n   type) and a function for filtering Actions (SelectActionsToProps type).\n   \n   * SelectStateToProps: modelStates is an array of the State of the passed\n     Model object, ownProps is the props received by current component. The data\n     returned by SelectStateToProps is passed to the props of the component.\n     When the SelectStateToProps parameter is not passed in models, the States\n     of all Models are merged and passed to the props of the component.\n   \n   * SelectActionsToProps: modelActions is an array of the Action of the passed\n     Model object, ownProps is the props received by current component. returned\n     by SelectActionsToProps is passed to the props of the component. When the\n     SelectActionsToProps parameter is not passed in models, the Action of all\n     Models are merged and passed to the props of the component.\n\n * options: Optional parameter for auxiliary configuration. Currently supports\n   setting forwardRef, which is used to control whether to forward the ref of\n   the component. The default value is false, which means that the ref is not\n   forwarded. Set to { forwardRef: true }, which means to forward ref.\n\n\nReturn Type\n\nReturns a HOC: receives an component, returns a component with extra State and\nActions injected on props.\n\n\nExample\n\n\nBasic\n\nconst modelA = model('modelA').define({\n  state: {\n    a: 1,\n  },\n  actions: {\n    incA(state) {\n      return {\n        ...state,\n        a: state.a + 1,\n      };\n    },\n  },\n});\n\nconst modelB = model('modelB').define({\n  state: {\n    b: 10,\n  },\n  actions: {\n    incB(state) {\n      return {\n        ...state,\n        b: state.b + 1,\n      };\n    },\n  },\n});\n\nfunction Test(props) {\n  props.incA(); // call modelA's action\n  props.incB(); // call modelB's action\n\n  props.a; // get modelA's state: a\n  props.b; // get modelB's state: b\n}\n\nexport default connect([modelA, modelB])(Test);\n\n\n\nSelect State & Actions\n\nfunction Test(props) {\n  props.incAll();\n  props.c;\n}\n\nconst stateSelector = (stateA, stateB) => ({\n  ...stateA,\n  ...stateB,\n  c: stateA.a + stateA.b,\n});\nconst actionsSelector = (actionsA, actionsB) => ({\n  ...actionsA,\n  ...actionsB,\n  incAll: () => {\n    actionsA.incA();\n    actionsB.incB();\n  },\n});\n\nexport default connect([modelA, modelB, stateSelector, actionsSelector])(Test);\n\n\n\nForwarding Ref\n\n\n\nfunction Test(props, ref) {\n  const { a, b } = props;\n\n  return (\n    <div ref={ref}>\n      <span>{a}</span>\n      <span>{b}</span>\n    </div>\n  );\n}\n\nconst TestWrapper = connect([modelA, modelB], { forwardRef: true })(\n  forwardRef(Test),\n);\n\nfunction App() {\n  const testRef = useRef();\n\n  return <TestWrapper ref={testRef} />;\n}\n","frontmatter":{"sidebar_position":5,"title":"connect"}},{"id":41,"title":"createApp","routePath":"/en/apis/app/runtime/model/create-app","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-value","text":"Return Value","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nReduck will call createApp to create a global application by default. If the\nentire application only needs one Store, then there is no need to call createApp\nmanually.Only need to use createApp when you need to create a Store locally in\nthe app.\n\nCAUTION\n\nNote that the exported createApp in @modern-js/runtime/model is used to manage\nstate, while the exported createApp in @modern-js/runtime is used to create the\nentire application. The two are differently.\n\n\nFunction Signature\n\ninterface AppConfig extends StoreConfig {\n  devTools?: boolean | DevToolsOptions;\n  autoActions?: boolean;\n}\n\nfunction createApp(config: AppConfig): object;\n\n\n\nInput\n\n * config\n   * StoreConfig: the same as createStore params.\n   * devTools: the default value is true. when it is an object type，configuring\n     Options of Redux DevTools.\n   * autoActions: the default value is true.if auto generate Actions.\n\n\nReturn Value\n\nReduck App, consists of the following properties:\n\n * Provider: inject shared Store into locally component tree, same as Provider.\n * useModel: get the Model mounted by the app's local Store, same as useModel.\n * useStaticModel: get the Model mounted by the app's local Store. same as\n   useStaticModel.\n * useLocalModel: get the Model mounted by the app's local Store. same as\n   useLocalModel.\n * useStore: get the Store used locally by the app. same as useStore.\n\n\nExample\n\nuse createApp, local states can be created to isolate the states between\ndifferent Reduck applications.\n\nconst { Provider: LocalFooProvider, useModel: useLocalFooModel } = createApp();\nconst { Provider: LocalBarProvider, useModel: useLocalBarModel } = createApp();\n\nfunction Foo() {\n  const [fooState] = useLocalFooModel(fooModel);\n  const [barState] = useLocalBarModel(fooModel);\n\n  return (\n    <div>\n      <div>Foo: {fooState}</div>\n      <div>Bar: {barState}</div>\n    </div>\n  );\n}\n\nfunction Container() {\n  return (\n    <LocalFooProvider>\n      <LocalBarProvider>\n        <Foo />\n      </LocalBarProvider>\n    </LocalFooProvider>\n  );\n}\n","frontmatter":{"sidebar_position":11,"title":"createApp"}},{"id":42,"title":"createStore","routePath":"/en/apis/app/runtime/model/create-store","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-value","text":"Return Value","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\ncreateStore is used to create a Store. Reduck’s Store based on Redux's Store\nimplementatio. Used to store the state of the application and managing the state\nand Model.\n\nIn general, this API is only used when you need to have full control over the\ncreation of the Store. For example, to customize a Store, pass in the 'Provider'\ncomponent to use.\n\n\nFunction Signature\n\ninterface StoreConfig {\n  initialState?: Record<string, any>;\n  middlewares?: Middleware[];\n  models?: Model[];\n  plugins?: Plugin[];\n  enhancers?: StoreEnhancer[];\n}\n\ninterface ReduckStore extends ReduxStore {\n  use: typeof useModel;\n  unmount: (model: Model) => void;\n}\n\nfunction createStore(config?: StoreConfig): ReduckStore;\n\n\n\nInput\n\n * config: store options.\n   * initialState: set the initial state for store.\n   * models: set the Model to mount to the Store in advance(No need for normal\n     use).\n   * middlewares: set Redux middleware.\n   * enhancers: set Redux Store enhancer.\n   * plugins: set Reduck plugin.experimental API, not recommended.\n\n\nReturn Value\n\nReduck Store:\n\n * use: mount and fetch Model objects dynamically. Usage is the same as\n   'useModel', but can be used outside of React components.\n * unmount: unmount the Model object, and the Model State is cleared from the\n   Store.\n * ReduxStore: Redux Store API.\n\n\nExample\n\nconst store = createStore();\n\nfunction load() {\n  const [, actions] = store.use(fooModel);\n\n  actions.load();\n}\n","frontmatter":{"sidebar_position":10,"title":"createStore"}},{"id":43,"title":"handleEffect","routePath":"/en/apis/app/runtime/model/handle-effect","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-type","text":"Return Type","depth":3}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nAn asynchronous function type Effect usually has three states that need to be\nprocessed: in request, request successful, and request failed. The way to handle\nthese states is to write the Action functions (pending, fulfilled, rejected).\n\nWith the help of the handleEffect API, we can generate default Action functions\nto handle different results at each stage of an asynchronous request. The\nstructure of the State returned by the Action generated by handleEffect is as\nfollows:\n\ninterface State {\n  result: any; // result of fulfilled state\n  pending: boolean; // request is pending\n  error: string; // request error message\n}\n\n\n\nFunction Signature\n\ninterface EffectActions {\n  pending: Action;\n  fulfilled: Action;\n  rejected: Action;\n}\n\ninterface Config {\n  ns?: string;\n  result?: string | false;\n  error?: string | false;\n  pending?: string | false;\n  combineMode?: 'merge' | 'replace';\n  omitResultNamespace?: boolean;\n}\n\nfunction handleEffect(config: Config): EffectActions;\n\n\n\nInput\n\n * ns: the default returned State structure is flat, By setting this parameter,\n   the returned State can be mounted under the field named by the ns. For\n   example, if ns is set to \"data\", the returned structure is:\n\ninterface State {\n  data: {\n    pending: boolean;\n    result: any;\n    error: string;\n  };\n}\n\n\n * result: the default value is \"result\". This parameter corresponds to the\n   field name that stores the fulfilled state results. For example, set result\n   to \"items\", the returned State structure is:\n\ninterface State {\n  items: any; // Default result -> items\n  pending: boolean;\n  error: string;\n}\n\n\nif result is false，then returned State has no result:\n\ninterface State {\n  pending: boolean;\n  error: string;\n}\n\n\n * pending: the default value is \"pending\". Change the name of the pending field\n   in the returned State. Usage is the same as result.\n\n * error: the default value is \"error\". Change the name of the error field in\n   the returned State. Usage is the same as result.\n\n * combineMode: the default value is \"merge\". Get fulfilled state results. There\n   are two ways to deal with it (The data types that can be automatically\n   processed here are also limited to simple object or array types):\n   \n   * \"merge\": the previous data is merged with the current data. the data is an\n     array type, operation is similar to [].concat(lastData, currentData). the\n     data is an object，operation is similar to {...lastData, ...curData}.\n   * \"replace\": the current data directly replaces the previous data.\n\n * omitResultNamespace: the default value is false. When the result is an object\n   type, you want to mount the result directly on the State of the Model, rather\n   than on \"result\", you can set it to true. For example:\n\n// the result: {user: 'xx', email: 'xx'}，\n// config handleEffect({ omitResultNamespace: true })\n// get State like follows:\n{\n  user: 'xx',\n  email: 'xx',\n  pending: false,\n  error: null,\n}\n\n\n\nReturn Type\n\nObjects are processed by actions in pending, fulfilled, and rejected states.\n\nMore\n\nManage Effect.","frontmatter":{"sidebar_position":7,"title":"handleEffect"}},{"id":44,"title":"model","routePath":"/en/apis/app/runtime/model/model_","lang":"en","toc":[{"id":"model","text":"model","depth":2},{"id":"define","text":"define","depth":2},{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"input","text":"Input","depth":3},{"id":"modeldescstate","text":"ModelDesc.state","depth":4},{"id":"modeldescactions","text":"ModelDesc.actions","depth":4},{"id":"modeldesccomputed","text":"ModelDesc.computed","depth":4},{"id":"modeldesceffects","text":"ModelDesc.effects","depth":4}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nTIP\n\nThe original type of Reduck is complex. The following type definition shows the\nsimplified type information. For the original type, see model.\n\n\nmodel\n\nCreate a Model for managing application state.\n\nfunction model(name: string): { define: function }\n\n * name: string, the unique id of the Model created.\n\nmodel('foo');\n\n\n\ndefine\n\nUsed to define the detailed structure of the Model, supporting passing in an\nobject type or function type parameter.\n\n\nObject Type\n\nfunction define(modelDesc: ModelDesc): Model;\n\n * modelDesc: ModelDesc，definition of Model structure，includes\n   state、computed、actions、effects etc. props.\n\nconst fooModel = model('foo').define({\n  state: 'foo',\n  computed: {\n    cFoo: state => `c${state}`,\n  },\n  actions: {\n    setState: (state, value) => {\n      return value;\n    },\n  },\n  effects: {\n    loadState: async () => {\n      // get state from remote\n    },\n  },\n});\n\n\n\nFunction Type\n\nfunction define((context: Context, utils: Utils) => ModelDesc): Model;\n\n * context: Reduck Context, can get underlying store object. store support all\n   Redux Store API, also mounts the use method for consuming the Model, and the\n   unmount method for unmounting the Model.\n * utils: commonly used tool like use、onMount. use is the same as\n   store.use，onMount is the hook function after the Model is mounted.\n\n{/* TODO: @anchao 调整类型 */}\n\ninterface Utils {\n  use: UseModel;\n  onMount: OnMountHook;\n}\n\ninterface Context {\n  store: ReduxStore & {\n    use: UseModel;\n    unmount: (model: Model) => void;\n  };\n}\n\n\nFor example, through use, you can get the state and actions of the Model itself\nand other Models.\n\nconst fooModel = model('foo').define(() => {\n  return {\n    state: 'foo',\n    actions: {\n      setState: (state, value) => {\n        return value;\n      },\n    },\n  };\n});\n\nconst barModel = model('bar').define((_, { use }) => {\n  return {\n    state: 'bar',\n    effects: {\n      syncFoo() {\n        const [state, actions] = use(fooModel);\n        actions.setState(state);\n      },\n    },\n  };\n});\n\n\n\nInput\n\nModelDesc.state\n\nDefine the state of the Model. Technically, any type of State is supported, but\nin practice it is recommended to use a JSON serializable type.\n\ninterface ModelDesc {\n  state: any;\n}\n\n\nModelDesc.actions\n\nDefine the Actions of the Model. The function type of Actions is:\n\ninterface ModelDesc {\n  actions: {\n    [actionKey: string]: (state: State, payload: any) => State | void;\n  };\n}\n\n\nReduck internally integrates immer, which can directly return the original\nstate. When the Action has no explicit return value, Reduck internally returns a\nmodified new State object.\n\nModelDesc.computed\n\nDefines the derived state of the Model. The definition of derived state supports\ntwo types:\n\n 1. Depends only on the state of the Model itself\n\ninterface ModelDesc {\n  computed: {\n    [computedKey: string]: (state: State) => any;\n  };\n}\n\n\n 2. Depends on the state of other Models\n\ninterface ModelDesc {\n  computed: {\n    [computedKey: string]: [\n      ...models: Model[],\n      (state: State, ...args: ModelState[]) => any,\n    ];\n  };\n}\n\n\nconst fooModel = model('foo').define({\n  state: 'foo',\n});\n\nconst barModel = model('bar').define({\n  state: 'bar',\n  computed: {\n    combineFoo: [fooModel, (state, fooState) => state + fooState],\n  },\n});\n\n\nModelDesc.effects\n\nDefines the Effects of the Model. The function types defined in Effects are:\n\ninterface ModelDesc {\n  effects: {\n    [effectKey: string]: (...args: any[]) => any;\n  };\n}\n\n\nconst fooModel = model('foo').define((context, { use }) => ({\n  state: 'foo',\n  effects: {\n    persist() {\n      const [state] = use(fooModel);\n      localStorage.setItem('state', state);\n    },\n  },\n}));\n\n\nMore\n\nDefine Model.","frontmatter":{"sidebar_position":1,"title":"model"}},{"id":45,"title":"useLocalModel","routePath":"/en/apis/app/runtime/model/use-local-model","lang":"en","toc":[{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nTo use the State in the Model as a local state, the effect is similar to React's\nuseState. useLocalModel API same as useModel. For detail, see useModel.\n\n\nExample\n\nfunction Container() {\n  const [state, actions] = useLocalModel(modelA);\n  const [state1, actions1] = useLocalModel(modelA);\n\n  // ...\n}\n\n\nmodelA was loaded twice with useLocalModel above, because useLocalModel consumes\nlocal state, so state and state1 are also completely isolated.\n\nMore\n\nUse Model.","frontmatter":{"sidebar_position":4,"title":"useLocalModel"}},{"id":46,"title":"useModel","routePath":"/en/apis/app/runtime/model/use-model","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-value","text":"Return Value","depth":3},{"id":"example","text":"Example","depth":2},{"id":"basic","text":"Basic","depth":3},{"id":"selector-usage","text":"Selector Usage","depth":3}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nTIP\n\nThe original type of Reduck is complex. The following type definition shows the\nsimplified type information. For the original type, see model.\n\n\nFunction Signature\n\nfunction useModel(\n  models: Models[],\n  stateSelector?: StateSelector,\n  actionSelector?: ActionSelector,\n): [state, actions, subscribe];\nfunction useModel(\n  ...models: Models[],\n  stateSelector?: (...args: State[]) => any,\n  actionSelector?: (...args: Actions[]) => any,\n): [state, actions, subscribe];\n\n\n\nInput\n\n * models: Array of Model objects, which can be passed in as an array type\n   parameter, or all Models can be passed in as parameters one by one.\n * stateSelector: Optional parameters, used to filter State calculations. The\n   first n parameters are the States corresponding to n Models, and the returned\n   data is used as the first element of the useModel return value array.\n * actionSelector: Optional parameters, used to filter Action calculations. The\n   first n parameters are the States corresponding to n Models, and the returned\n   data is used as the second element of the useModel return value array.\n\n\nReturn Value\n\nReturns an array with each value:\n\n * state: return value of stateSelector. if there is no stateSelector，will\n   combine all incoming Model States(including derived states) and return them.\n   If there is an attribute of the same name in the State of different Models,\n   the following State will override the previous State. when state changes，the\n   component call useModel will re-render.\n * actions: return value of actionSelector. if there is no actionSelector，will\n   combine all incoming Model Action(including Effect) and return them. If there\n   is an attribute of the same name in the Action of different Models, the\n   following Action will override the previous Action.\n * subscribe: A function that subscribes to State changes. This function is\n   called when the State of any Model passed in changes.\n\n\nExample\n\n\nBasic\n\n\n\n\nfunction Test(props) {\n  const [state, actions] = useModel([todoModel, filterModel]);\n  actions.add(); // call todoModel add action\n  actions.setVisibleStatus(); // call filterModel filterModel action\n\n  state.items; // get todoModel state items\n  state.visibleStatus; // get filterModel state visibleStatus\n}\n\n\n\nSelector Usage\n\nfunction Test(props) {\n  const [state, actions] = useModel(\n    [todoModel, filterModel],\n    (todoState, filterState) => ({\n      items: todoState.items,\n      visibleStatus: `${props.prefix}-${filterState.visibleStatus}`,\n    }),\n    (todoActions, filterActions) => ({\n      ...todoActions,\n      ...filterActions,\n    }),\n  );\n  actions.add(); // call todoModel add action\n  actions.setVisibleStatus(); // call filterModel filterModel action\n\n  state.items; // get todoModel state items\n  state.visibleStatus; // get filterModel state visibleStatus\n}\n\n\nMore\n\nuse Model.","frontmatter":{"sidebar_position":2,"title":"useModel"}},{"id":47,"title":"useStaticModel","routePath":"/en/apis/app/runtime/model/use-static-model","lang":"en","toc":[{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nIf want to consume a Model in the form of React Hook in the component，and can\nget the current latest state at any time，but you don't want the Model state to\nbe updated, which will cause the component to be re-rendered, we can use\nuseStaticModel.\n\nuseStaticModel API is same as useModel.For detail, see useModel.\n\nTo ensure that the latest state is always available, be careful not to\ndeconstruct the returned state.\n\nfunction App() {\n  // ❌ Do not deconstruct state，but can deconstruct actions.\n  const [{ username }, { logout }] = useStaticModel(userModel);\n\n  // ✅ True Usage.\n  const [state, { logout }] = useStaticModel(userModel);\n\n  useEffect(() => {\n    state.username;\n  }, []);\n}\n\n\n\nExample\n\nThe following App component consumes the userModel state, but does not use it\ndirectly in JSX. It can be found that changes in the userModel state do not\nnecessarily cause the component to re-render. This situation can be optimized\nusing useStaticModel.\n\nfunction App() {\n  const [state] = useStaticModel(userModel);\n\n  useEffect(() => {\n    // 统计 UV 数据\n    send('pageview', { user: state.user });\n  }, [state]);\n\n  return <div>Hello</div>;\n}\n\n\nMore\n\nUse Model.","frontmatter":{"sidebar_position":3,"title":"useStaticModel"}},{"id":48,"title":"useStore","routePath":"/en/apis/app/runtime/model/use-store","lang":"en","toc":[{"id":"function-signature","text":"Function Signature","depth":2},{"id":"return-type","text":"Return Type","depth":3}],"domain":"","content":"\n\ninformation\n\nBy default, the export package name for all APIs in this section is:\n@modern-js/runtime/model.\n\nIf Reduck is integrated separately from Modern.js, the export package name is:\n@modern-js-reduck/react.\n\nuseStore Used to get the store shared by the current component tree.\n\n\nFunction Signature\n\nfunction useStore(): ReduckStore;\n\n\n\nReturn Type\n\n * ReduckStore: Reduck Store，type refer to the return type of createStore.\n\nMore\n\nUse Model.","frontmatter":{"sidebar_position":9,"title":"useStore"}},{"id":49,"title":"router","routePath":"/en/apis/app/runtime/router/router","lang":"en","toc":[{"id":"hooks","text":"hooks","depth":2},{"id":"usenavigate","text":"useNavigate","depth":3},{"id":"uselocation","text":"useLocation","depth":3},{"id":"useparams","text":"useParams","depth":3},{"id":"components","text":"Components","depth":2},{"id":"link","text":"Link","depth":3},{"id":"navlink","text":"NavLink","depth":3},{"id":"outlet","text":"Outlet","depth":3},{"id":"route","text":"Route","depth":3},{"id":"more","text":"More","depth":2}],"domain":"","content":"\n\nINFO\n\nThe router solution based on react-router 6.\n\n\nhooks\n\n\nuseNavigate\n\ndeclare function useNavigate(): NavigateFunction;\n\ninterface NavigateFunction {\n  (\n    to: To,\n    options?: {\n      replace?: boolean;\n      state?: any;\n      relative?: RelativeRoutingType;\n    },\n  ): void;\n  (delta: number): void;\n}\n\n\nThe useNavigate hook returns a function that lets you navigate programmatically.\n\n\n\nexport function HomeButton() {\n  let navigate = useNavigate();\n\n  function handleClick() {\n    navigate('/home');\n  }\n\n  return (\n    <button type=\"button\" onClick={handleClick}>\n      Go home\n    </button>\n  );\n}\n\n\n\nuseLocation\n\ndeclare function useLocation(): Location;\n\ninterface Location extends Path {\n  state: unknown;\n  key: Key;\n}\n\n\nThe useLocation hook returns the current location object. A new location object\nwould be returned whenever the current location changes.\n\n\n\nfunction usePageViews() {\n  let location = useLocation();\n  React.useEffect(() => {\n    ga.send([\"pageview\", location.pathname]);\n  }, [location]);\n}\n\nfunction App() {\n  usePageViews();\n  return (\n    //...\n  );\n}\n\n\n\nuseParams\n\ndeclare function useParams<K extends string = string>(): Readonly<Params<K>>;\n\n\nThe useParams hook returns an object of key/value pairs of the dynamic params\nfrom the current URL that were matched by the <Route path>.\n\n\n\nfunction BlogPost() {\n  const { slug } = useParams();\n  return <div>Now showing post {slug}</div>;\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<div>home</div>} />\n      <Route path=\"/blog/:slug\" element={<BlogPost />} />\n    </Routes>\n  );\n}\n\n\n\nComponents\n\n\nLink\n\ndeclare function Link(props: LinkProps): React.ReactElement;\n\ninterface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href'> {\n  replace?: boolean;\n  state?: any;\n  to: To;\n  reloadDocument?: boolean;\n}\n\ntype To = string | Partial<Path>;\n\n\nA <Link> is an element that lets the user navigate to another page by clicking\nor tapping on it.\n\n<Link to=\"/about\">About</Link>\n\n\n\nNavLink\n\ndeclare function NavLink(props: NavLinkProps): React.ReactElement;\n\ninterface NavLinkProps\n  extends Omit<LinkProps, 'className' | 'style' | 'children'> {\n  caseSensitive?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean }) => React.ReactNode);\n  className?: string | ((props: { isActive: boolean }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: { isActive: boolean }) => React.CSSProperties);\n}\n\n\nA <NavLink> is a special kind of <Link> that knows whether or not it is\n\"active\".\n\n\nOutlet\n\ninterface OutletProps {\n  context?: unknown;\n}\ndeclare function Outlet(props: OutletProps): React.ReactElement | null;\n\n\nAn <Outlet> should be used in parent route elements to render their child route\nelements. This allows nested UI to show up when child routes are rendered.\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n\n      {/* This element will render either <DashboardMessages> when the URL is\n          \"/messages\", <DashboardTasks> at \"/tasks\", or null if it is \"/\"\n      */}\n      <Outlet />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Dashboard />}>\n        <Route path=\"messages\" element={<DashboardMessages />} />\n        <Route path=\"tasks\" element={<DashboardTasks />} />\n      </Route>\n    </Routes>\n  );\n}\n\n\n\nRoute\n\ninterface RouteObject {\n  path?: string;\n  index?: boolean;\n  children?: React.ReactNode;\n  caseSensitive?: boolean;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  handle?: RouteObject['handle'];\n  shouldRevalidate?: ShouldRevalidateFunction;\n}\n\n\nRoute represents the route information. A Route object couples URL segments to\ncomponents, data loading and data mutations.\n\nRoute can be used as a plain object, passing to the router creation functions：\n\nconst router = createBrowserRouter([\n  {\n    // it renders this element\n    element: <Team />,\n\n    // when the URL matches this segment\n    path: 'teams/:teamId',\n\n    // with this data loaded before rendering\n    loader: async ({ request, params }) => {\n      return fetch(`/fake/api/teams/${params.teamId}.json`, {\n        signal: request.signal,\n      });\n    },\n\n    // performing this mutation when data is submitted to it\n    action: async ({ request }) => {\n      return updateFakeTeam(await request.formData());\n    },\n\n    // and renders this element in case something went wrong\n    errorElement: <ErrorBoundary />,\n  },\n]);\n\n\nYou can also declare your routes with JSX and createRoutesFromElements, the\nprops to the element are identical to the properties of the route objects:\n\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route\n      element={<Team />}\n      path=\"teams/:teamId\"\n      loader={async ({ params }) => {\n        return fetch(`/fake/api/teams/${params.teamId}.json`);\n      }}\n      action={async ({ request }) => {\n        return updateFakeTeam(await request.formData());\n      }}\n      errorElement={<ErrorBoundary />}\n    />,\n  ),\n);\n\n\n\nMore\n\nYou can access to React Router to get the full API information.","frontmatter":{"title":"router","sidebar_position":1}},{"id":50,"title":"NoSSR","routePath":"/en/apis/app/runtime/ssr/no-ssr","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"example","text":"Example","depth":2},{"id":"scene","text":"Scene","depth":2}],"domain":"","content":"\n\nThe content wrapped by NoSSR will not be rendered at the server, nor will it be\nrendered during the client side hydrate. it will only be rendered immediately\nafter the entire app is rendered.\n\n\nUsage\n\n\n\nexport default () => <NoSSR>...</NoSSR>;\n\n\n\nExample\n\nIn the following code, the Time component is used to display the current time.\nSince the time obtained by server-side rendering and client side hydrate are\ndiff, React will throw an exception. For this case, you can use NoSSR to\noptimize:\n\n\n\nfunction Time() {\n  return (\n    <NoSSR>\n      <div>Time: {Date.now()}</div>\n    </NoSSR>\n  );\n}\n\n\n\nScene\n\nIn CSR, it is often necessary to render different content according to the\nbrowser UA, or a parameter of the current page URL. If the application switches\ndirectly to SSR at this time, it is very likely that the results will not meet\nthe expectations.\n\nModern.js provides complete browser side information in the SSR context, which\ncan be used to determine the rendering result of the component on the server\nside.\n\nEven so, if there is too much logic in the application, or the developer wants\nto use the context later, or does not want some content to be rendered at the\nserver side. developer can use the NoSSR component to exclude this part from\nserver-side rendering.","frontmatter":{"title":"NoSSR"}},{"id":51,"title":"PreRender","routePath":"/en/apis/app/runtime/ssr/pre-render","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nA Helmet-like HOC without content implements SPA routing-level caching, manner\nwithout additional configuration.\n\n\nUsage\n\n\n\nexport default () => (\n  <>\n    <PreRender interval={5} />\n  </>\n);\n\n\n\nFunction Signature\n\nThe PreRender provides a set of configuration for controlling caching rules,\nexpiration times, caching algorithms, and more.\n\ntype Props {\n  interval: number;\n  staleLimit: number;\n  level: number;\n  include: { header?: string[], query?: string[] };\n  matches: { header?: Record<string, any>, query?: Record<string, any> }\n}\n\nfunction PreRender(props: Props): React.Component\n\n\n\nInput\n\n * interval: set the time the cache keep fresh，seconds. During this time, the\n   cache will be used directly and not invoke asynchronous rendering.\n * staleLimit: sets the time when the cache is completely expired，seconds.During\n   this time, The cache can be returned and asynchronous rendering will be\n   invoke, otherwise must wait for the re-rendered result.\n * level: sets the calculation rule level for the cache identity, usually used\n   with includes and matches. The default value is 0.\n\n0: pathname\n1: pathname + querystring\n2: pathname + headers\n3: pathname + querystring + headers\n\n\n * includes: sets the content that needs to be included in the cache identifier,\n   used when the level is not 0. The default value is null.\n * matches: sets the rewriting rule for the value of query or header in cache\n   identity, usually used in cache category, supports regular expressions. The\n   default value is null.\n\n\nExample\n\n\n\nexport default function App() {\n  return (\n    <>\n      <PreRender interval={10} />\n      <div>Hello Modern</div>\n    </>\n  );\n}\n\n\nThe following example shows how to add the parameters in the query and header\ninto the cache identifier calculation:\n\n/* calculate cache identifier using channel in query and language in header */\n<PreRender\n  interval={10}\n  level={2}\n  includes={{\n    query: ['channel'],\n    header: ['language'],\n  }}\n/>\n\n\nThe following example shows how not to let the test channel affect the online\ncache:\n\n/* rewrite the channel value starting with test_ in the query as \"testChannel\", otherwise rewrite it as \"otherChannel\" */\n<PreRender interval={10} level={2} includes={{\n  query: [\"channel\"],\n  header: [\"language\"]\n}} matches={{\n  query: {\n    channel: {\n      \"testChannel\", \"^test_\",\n      \"otherChannel\", \".*\"\n    }\n  }\n}} />\n","frontmatter":{"title":"PreRender"}},{"id":52,"title":"act","routePath":"/en/apis/app/runtime/testing/act","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUsed to ensure that behaviors such as rendering, events, data fetching, etc.\nhave been applied to the DOM.\n\n\nUsage\n\n\n\n\nFunction Signature\n\nact is the same as react-dom/test-utils act function.\n\n\nExample\n\n\n\n\n\ndescribe('test act', () => {\n  it('it should be foo', () => {\n    const el = document.createElement('div');\n    act(() => {\n      ReactDOM.render(<Foo />, el);\n    });\n\n    expect(el.innerHTML).toBe('<div>Foo</div>');\n  });\n});\n","frontmatter":{"title":"act"}},{"id":53,"title":"cleanup","routePath":"/en/apis/app/runtime/testing/cleanup","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUsed to uninstall all currently rendered components.\n\n\nUsage\n\n\n\n\nFunction Signature\n\nfunction cleanup(): void\n\n\nExample\n\nINFO\n\nNote that if you are using a testing framework that supports afterEach and it is\ninjected into your testing environment (such as mocha, Jest, and Jasmine), will\nexecute cleanup in the afterEach hook by default. Otherwise, you will need to do\nmanual cleanup after each test.\n\nFor example, if you use the ava test framework, then you need to use the\ntest.after Each hook like this.\n\n\n\n\ntest.afterEach(cleanup);\n\ntest('renders into document', () => {\n  render(<div />);\n  // ...\n});\n\n// ... more tests ...\n","frontmatter":{"title":"cleanup","sidebar_position":3}},{"id":54,"title":"render","routePath":"/en/apis/app/runtime/testing/render","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"return-value","text":"Return Value","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUsed to render the component in the test case.\n\n\nUsage\n\n\n\n\nFunction Signature\n\ntype Options = {\n  container: DOMElement;\n  baseElement: DOMElement;\n  hydrate: boolean;\n  warpper: React.ComponentType<{children: ReactNode}>;\n  queries: any;\n};\n\ntype RenderResult = {\n  {...queries}: any;\n  container: DOMElement;\n  baseElement: DOMElement;\n  debug: function;\n  rerender: function;\n  unmount: function;\n  asFragment: function;\n}\n\nfunction render(ui: React.ReactElement<any>, options: Options): RenderResult;\n\n\n\nInput\n\n * ui: the React component that needs to be rendered.\n * options: render options.\n   * container: the dom which component mounted. by default create a div\n     element，and auto append to document.body. the default value is\n     document.body.append(document.createElement('div')).\n   * baseElement: Used to specify the basename used in queries. If container is\n     specified, the default value is the value of container, otherwise it is\n     document.body.\n   * hydrate: If set to true, the ReactDOM.hydrate rendering component is used.\n     The default value is false.\n   * wrapper: a react component that can be used to customize rendering logic.\n   * queries: customize some own queries.\n\n\nReturn Value\n\n * {...queries}: all available queries.\n * container: the DOM element that React component mounted.\n * baseElement\n * debug\n * rerender: if you want to test some scene when a rendered component is\n   updated, you can use rerender for reality.\n * unmount: unmount rendered components. This API is helpful if you want to test\n   what happens after the component is unmounted.\n * asFragment: return the DocumentFragment of rendered component. used to test\n   the response of the DOM structure after the react event is triggered.\n\n\nExample\n\n\n\n\ntest('renders a message', () => {\n  const { container, getByText } = render(<App />);\n  expect(getByText('Hello, world!')).toBeInTheDocument();\n  expect(container.firstChild).toMatchInlineSnapshot(`\n    <h1>Hello, World!</h1>\n  `);\n});\n","frontmatter":{"title":"render"}},{"id":55,"title":"renderApp","routePath":"/en/apis/app/runtime/testing/renderApp","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nThe render function is used to test normal components, and the renderApp\nfunction is used to test App components.\n\n\nUsage\n\n\n\nApp components refer to components that contain some Modern.js contexts, such as\nApp root components, Containers using Models, etc.\n\nFor the testing of such components, you can use the renderApp function, which\nwill automatically wrap the context information according to the current\nmodern.config.js.\n\n\nFunction Signature\n\nrenderApp is the same as render.\n\n\nExample\n\n\n\n\ndescribe('test', () => {\n  it('test App', () => {\n    const { getByText } = renderApp(<App />);\n    expect(getByText('Hello Modern!')).toBeInTheDocument();\n  });\n});\n","frontmatter":{"title":"renderApp"}},{"id":56,"title":"CSS-In-JS API","routePath":"/en/apis/app/runtime/utility/css-in-js","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nUse Style Component to write CSS.\n\n\nUsage\n\n\n\n\nFunction Signature\n\nsee styled-component API.\n\n\nExample\n\n\n\nconst Button = styled.button`\n  background: palevioletred;\n  border-radius: 3px;\n  border: none;\n  color: white;\n`;\n\nconst TomatoButton = styled(Button)`\n  background: tomato;\n`;\n\nfunction ButtonExample() {\n  return (\n    <>\n      <Button>I'm purple.</Button>\n      <br />\n      <TomatoButton>I'm red.</TomatoButton>\n    </>\n  );\n}\n","frontmatter":{"title":"CSS-In-JS API"}},{"id":57,"title":"Head","routePath":"/en/apis/app/runtime/utility/head","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"example","text":"Example","depth":2},{"id":"more","text":"More","depth":2}],"domain":"","content":"\n\nUsed to add html elements (such as title, meta, script, etc.) to the <head>\nelement, supports SSR.\n\n\nUsage\n\n\n\nexport default () => <Helmet>...</Helmet>;\n\n\n\nExample\n\n\n\nfunction IndexPage() {\n  return (\n    <div>\n      <Helmet>\n        <title>My page title</title>\n        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n      </Helmet>\n      <p>Hello Modern.js!</p>\n    </div>\n  );\n}\n\nexport default IndexPage;\n\n\n\nMore\n\nFor detail, see react-helmet.","frontmatter":{"title":"Head"}},{"id":58,"title":"loadable","routePath":"/en/apis/app/runtime/utility/loadable","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"loadfn","text":"loadFn","depth":4},{"id":"optionsresolvecomponent","text":"options.resolveComponent","depth":4},{"id":"optionsfallback","text":"options.fallback","depth":4},{"id":"optionsssr","text":"options.ssr","depth":4},{"id":"return-value","text":"Return Value","depth":3},{"id":"loadablecomponent","text":"LoadableComponent","depth":4}],"domain":"","content":"\n\nUsed to create Loadable component\n\n\nUsage\n\n\n\n\nFunction Signature\n\ntype Options = {\n  resolveComponent?: (\n    module: Module,\n    props: Props,\n  ) => React.ComponentType<Props>,\n  fallback?: JSX.Element;\n  ssr?: boolean;\n}\n\nfunction loadable(loadFn: Function, options?: Options) => LoadableComponent\n\n\n\nInput\n\nloadFn\n\nUsed to load component.\n\n\n\nconst OtherComponent = loadable(() => import('./OtherComponent'));\n\n\noptions.resolveComponent\n\nType: (module: Module, props: Props) => React.ComponentType<Props>\n\nmodule is the component returned by loadFn, and props is the props parameter\naccepted by the component.\n\nBy default, we think that the default export of file is a react component, so we\ncan render the component directly. But when the component is named export, or we\nneed to dynamically determine which component needs to be rendered according to\nthe props, we can use resolveComponent. Here is an example:\n\nexport const Apple = () => 'Apple!';\nexport const Orange = () => 'Orange!';\n\n\nconst LoadableApple = loadable(() => import('./components'), {\n  resolveComponent: components => components.Apple,\n});\nconst LoadableOrange = loadable(() => import('./components'), {\n  resolveComponent: components => components.Orange,\n});\nconst LoadableFruit = loadable(() => import('./components'), {\n  resolveComponent: (components, props) => components[props.fruit],\n});\n\n\noptions.fallback\n\nWhether to display fallback content during loading.\n\noptions.ssr\n\nWhether to support SSR, the default value is true.\n\n\nReturn Value\n\nLoadableComponent\n\ntype LoadableComponent<Props> = React.ComponentType<\n  Props & { fallback?: JSX.Element }\n> & {\n  preload(props?: Props): void;\n  load(props?: Props): Promise<React.ComponentType<Props>>;\n};\n","frontmatter":{"title":"loadable"}},{"id":59,"title":"Hook","routePath":"/en/apis/app/runtime/web-server/hook","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2},{"id":"redirect","text":"Redirect","depth":3},{"id":"rewrite","text":"Rewrite","depth":3},{"id":"html-inject","text":"HTML Inject","depth":3}],"domain":"","content":"\n\nUsed to extend Modern.js built-in Web Server, requests except BFF are handled by\nthese hooks.\n\nNOTE\n\nFor more detail, see Extend Web Server.\n\n\nUsage\n\n\n\nexport const afterMatch: AfterMatchHook = (context, next) => {};\nexport const afterRender: AfterRenderHook = (context, next) => {};\n\n\nINFO\n\nBefore using this API, please execute pnpm run new to create a new \"Custom Web\nServer\" source code directory.\n\npnpm run new\n? Action Create project element\n? New \"Custom Web Server\" source code directory\n\n\n\nFunction Signature\n\ntype HookContext = {\n  response: {\n    set: (key: string, value: string) => void;\n    status: (code: number) => void;\n    cookies: {\n      get: (key: string) => string;\n      set: (key: string, value: string) => void;\n      delete: () => void;\n      clear: () => void;\n    };\n    raw: (\n      body: string,\n      { status, headers }: { status: number; headers: Record<string, any> },\n    ) => void;\n  };\n  request: {\n    host: string;\n    pathname: string;\n    query: Record<string, any>;\n    cookie: string;\n    cookies: {\n      get: (key: string) => string;\n    };\n    headers: IncomingHttpHeaders;\n  };\n};\n\nfunction Hook(context: HookContext, next: NextFunction): Promsie<void> | void;\n\n\ndifferent Hooks additionally provide different contexts. Currently Modern.js\nsupport AtferMatch and AfterRender.\n\ntype AfterMatchContext = HookContext & {\n  router: {\n    redirect: (url: string, status: number) => void;\n    rewrite: (entry: string) => void;\n  };\n};\n\ntype AfterRenderContext = {\n  template: {\n    get: () => string;\n    set: (html: string) => void;\n    prependHead: (fragment: string) => void;\n    appendHead: (fragment: string) => void;\n    prependBody: (fragment: string) => void;\n    appendBody: (fragment: string) => void;\n  };\n};\n\n\n\nInput\n\n * context: Hook context.\n   * response: provides a series of methods to process the response.\n   * request: provides a series of methods to get request info.\n   * router: provides methods on routing.\n   * template: provides methods on content.\n * next: call next listener（not affect the server process, only current hook）.\n\n\nExample\n\n\nRedirect\n\nRedirect to pages outside the site, for example to login page:\n\n\n\nexport const afterMatch: AfterMatch = async (ctx, next) => {\n  ctx.router.redirect('https://website.com/login', 302);\n};\n\n\n\nRewrite\n\nRewrite to pages of the current site, for example, the same route returns pages\nthat are adapted to different UA:\n\n\n\nexport const afterMatch: AfterMatch = async (ctx, next) => {\n  ctx.router.rewrite('mobile');\n};\n\n\n\nHTML Inject\n\nInject some HTML content to the page, such as scripts, page skeletons, etc.:\n\n\n\nexport const afterRender: AfterRenderHook = (context, next) => {\n  ctx.template.prependBody('<div>Footer</div>');\n};\n","frontmatter":{"title":"Hook"}},{"id":60,"title":"Middleware","routePath":"/en/apis/app/runtime/web-server/middleware","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"function-signature","text":"Function Signature","depth":2},{"id":"input","text":"Input","depth":3},{"id":"example","text":"Example","depth":2},{"id":"tracking","text":"Tracking","depth":3},{"id":"inject-tools--data","text":"Inject Tools & Data","depth":3}],"domain":"","content":"\n\nUsed to extend Modern.js built-in Web Server, only SSR requests are handled by\nthese middleware.\n\nUnlike Hook, middleware can be extended using the framework plugin.\n\nNOTE\n\nFor more detail, see Extend Web Server.\n\n\nUsage\n\n\n\nexport const middleware: Middleware = async (context, next) => {};\nexport const middleware: Middleware[] = [\n  async (context, next) => {},\n  async (context, next) => {},\n];\n\n\nINFO\n\nBefore using this API, please execute pnpm run new to create a new \"Custom Web\nServer\" source code directory.\n\npnpm run new\n? Action Create project element\n? New \"Custom Web Server\" source code directory\n\n\n\nFunction Signature\n\ntype MiddlewareContext = {\n  response: {\n    set: (key: string, value: string) => void;\n    status: (code: number) => void;\n    cookies: {\n      get: (key: string) => string;\n      set: (key: string, value: string) => void;\n      delete: () => void;\n      clear: () => void;\n      apply: () => void;\n    };\n    raw: (\n      body: string,\n      { status, headers }: { status: number; headers: Record<string, any> },\n    ) => void;\n    locals: Record<string, any>;\n  };\n  request: {\n    host: string;\n    pathname: string;\n    query: Record<string, any>;\n    cookie: string;\n    cookies: {\n      get: (key: string) => string;\n    };\n    headers: IncomingHttpHeaders;\n  };\n  source: {\n    req: IncomingMessage;\n    res: ServerResponse;\n  };\n};\n\ntype RequestHandler = (\n  context: Context,\n  next: NextFunction,\n) => Promise<void> | void;\n\n\n\nInput\n\n * context: Middleware context.\n   * response: provides a series of methods to process the response.\n   * request: provides a series of methods to get request info.\n   * source: provides Node.js native req and res object.\n * next: call next listener（not affect the server process, only current hook）.\n\n\nExample\n\n\nTracking\n\nexport const Middleware = () => async (ctx, next) => {\n  const start = Date.now();\n  ctx.res.once('finish', () => {\n    console.log(Date.now() - start);\n  });\n};\n\n\n\nInject Tools & Data\n\nModern.js provides res.locals to store local variables for the current request.\n\nexport const Middleware = () => async (ctx, next) => {\n  ctx.res.locals.id = 'Modern.js';\n  ctx.res.locals.rpc = createRpcInstance();\n});\n","frontmatter":{"title":"Middleware"}},{"id":61,"title":"autoLoadPlugins","routePath":"/en/configure/app/auto-load-plugin","lang":"en","toc":[{"id":"manual-registration-plugin","text":"Manual Registration Plugin","depth":3},{"id":"auto-registration-plugin","text":"Auto Registration plugin","depth":3}],"domain":"","content":"\n\n * Type: boolean\n * Default: false\n\nUsed to configure whether Modern.js enables auto-registration of plugins.\n\n\nManual Registration Plugin\n\nBy default, installing the plugin requires you to register the plugin manually\nin the modern.config.ts.\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), i18nPlugin()],\n});\n\n\n\nAuto Registration plugin\n\nIn addition to means registration, Modern.js also provides a way to\nautomatically register plugins: set the autoLoadPlugin configuration item to\ntrue.\n\n\n\nexport default defineConfig({\n  autoLoadPlugins: true,\n});\n\n\nModern.js will help you automatically register the plugin by following these\nsteps\n\n 1. Modern.js maintains an official list of plugins internally.\n\nconst InternalPlugins = ['@modern-js/app-tools', '@modern-js/plugin-i18n', ...];\n\n\n 2. Modern.js will read your package.json and collect the dependency\n    information.\n\n\"dependencies\": {\n  \"@modern-js/plugin-i18n\": \"x.x.x\"\n  ...\n},\n\"devDependencies\": {\n  \"@modern-js/app-tools\": \"x.x.x\"\n  ...\n}\n\n\n 3. Modern.js observes that when you install dependencies such as\n    @modern-js/plugin-i18n and @modern-js/app-tools, automatic plugin\n    registration will be imported.\n\nYou can notice that this approach is relatively black-box and you are not even\naware of the process of loading the plugin. We want to expose more details to\nthe developer and be able to let the developer control the process.\n\nTherefore we recommend you to register the plugin manually.","frontmatter":{"title":"autoLoadPlugins","sidebar_position":11}},{"id":62,"title":"bff.prefix","routePath":"/en/configure/app/bff/prefix","lang":"en","toc":[],"domain":"","content":"\n\n * Type: string\n * Default: /api\n\nCaution\n\nFirst you need to enable the \"BFF\" function using new command.\n\nBy default, the route access BFF prefix's directory is /api, with the following\ndirectory structure:\n\napi\n└── hello.ts\n\n\nThe corresponding route for api/hello.ts access is localhost:8080/api/hello.\n\nThis configuration option can modify the default route prefix:\n\nexport default defineConfig({\n  bff: {\n    prefix: '/api-demo',\n  },\n});\n\n\nThe corresponding api/hello.ts access route is localhost:8080/api-demo/hello.","frontmatter":{"sidebar_label":"prefix"}},{"id":63,"title":"bff.proxy","routePath":"/en/configure/app/bff/proxy","lang":"en","toc":[{"id":"common-usage","text":"Common usage","depth":2},{"id":"solve-interface-cross-domain-problems","text":"Solve interface cross-domain problems","depth":3}],"domain":"","content":"\n\n * Type: Record<string, string>\n * Default: {}\n\nCaution\n\nFirst you need to enable the \"BFF\" function using new command.\n\nWith simple configuration, no code is required, Modern.js automatically forwards\nrequests. Requests sent to Modern.js BFF server are proxied to the specified\nservice.\n\nBFF Proxy uses the powerful http-proxy-middleware, and if you need more advanced\nusage, you can check its documentation.\n\nAdd the following configuration to modern.server-runtime.config.ts, you can turn\non the proxy:\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api': 'https://cnodejs.org',\n    },\n  },\n});\n\n\nAssuming that the starting Modern.js BFF server's service address is\nlocalhost:8080, all requests whose path starts with api will be intercepted,\nsuch as requests sent to localhost:8080/api/v1/topics will be proxied to\nhttps://cnodejs.org/api/v1/topics.\n\nYou can do path rewriting, such as proxying requests sent to\nlocalhost:8080/api/topics to https://cnodejs.org/api/v1/topics.\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api': {\n        target: 'https://cnodejs.org',\n        pathRewrite: { '/api/topics': '/api/v1/topics' },\n        changeOrigin: true,\n      },\n    },\n  },\n});\n\n\nUnlike dev.proxy, the proxy described in this section only works on requests\nentering the BFF/API service; at the same time, this configuration can be used\nnot only in the development environment, but also in the production environment.\nThe corresponding request will also be proxied in the production environment.\n\n\nCommon usage\n\n\nSolve interface cross-domain problems\n\nIn the process of project development, because web pages and interface services\nare not deployed under the same domain name, cross-domain problems are often\nencountered.\n\nThere are many ways to solve cross-domain problems, and here we use bff.proxy to\neasily solve cross-domain problems.\n\nINFO\n\nIn BFF proxy mode, if you do not need to write the BFF interface, the API\ndirectory can be deleted; at this time, BFF proxy will still be enabled.\n\nAs shown below, in the modern.server-runtime.config.js, write the following\nconfiguration; we send all web pages to the same domain that request proxies\nstarting with /api to another domain's service.\n\nexport default defineServerConfig({\n  bff: {\n    proxy: {\n      '/api': 'https://cnodejs.org',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"proxy"}},{"id":64,"title":"builderPlugins","routePath":"/en/configure/app/builder-plugins","lang":"en","toc":[{"id":"precautions","text":"Precautions","depth":2},{"id":"when-to-use","text":"When to use","depth":2},{"id":"example","text":"Example","depth":2},{"id":"using-plugins-on-npm","text":"Using plugins on npm","depth":3},{"id":"using-local-plugins","text":"Using local plugins","depth":3},{"id":"plugin-configuration-items","text":"Plugin configuration items","depth":3}],"domain":"","content":"\n\n * Type: BuilderPlugin[]\n * Default: []\n\nUsed to configure the Modern.js Builder plugin.\n\nModern.js Builder is the build engine of Modern.js, please read Builder for\nbackground. If you want to know how to write Builder plugins, you can refer to\nModern.js Builder - Introduce to Plugin.\n\n\nPrecautions\n\nThis option is used to configure the Modern.js Builder plugins. If you need to\nconfigure other types of plugins, please select the corresponding configs:\n\n * Use plugins to configure Modern.js framework plugins.\n * Use tools.webpack or tools.webpackChain to configure webpack plugins.\n * Use tools.babel to configure babel plugins.\n\n\nWhen to use\n\nIn most scenarios, we recommend you to use the Modern.js framework plugin, which\ncan be registered through the plugins config. Because the API provided by the\nframework plugin is richer and more capable, while the API provided by the\nBuilder plugin can only be used to build scenes.\n\nWhen you need to reference some existing Builder plugins (and there is no\nrelated capability in Modern.js), or reuse Builder plugins between different\nframeworks, you can use the builderPlugins field to register them.\n\n\nExample\n\nBelow is an example of using the Builder plugin.\n\n\nUsing plugins on npm\n\nTo use a plugin on npm, you need to install the plugin through the package\nmanager and import it.\n\n\n\nexport default defineConfig({\n  builderPlugins: [myBuilderPlugin()],\n});\n\n\n\nUsing local plugins\n\nUse the plugin in the local code repository, you can import it directly through\nthe relative path import.\n\n\n\nexport default defineConfig({\n  builderPlugins: [myBuilderPlugin()],\n});\n\n\n\nPlugin configuration items\n\nIf the plugin provides some custom configuration options, you can pass in the\nconfiguration through the parameters of the plugin function.\n\n\n\nexport default defineConfig({\n  builderPlugins: [\n    myBuilderPlugin({\n      foo: 1,\n      bar: 2,\n    }),\n  ],\n});\n","frontmatter":{"title":"builderPlugins","sidebar_position":10}},{"id":65,"title":"deploy.microFrontend","routePath":"/en/configure/app/deploy/microFrontend","lang":"en","toc":[{"id":"example","text":"Example","depth":2},{"id":"configuration","text":"Configuration","depth":2},{"id":"enablehtmlentry","text":"enableHtmlEntry","depth":3},{"id":"externalbasiclibrary","text":"externalBasicLibrary","depth":3}],"domain":"","content":"\n\n * Type: object\n * Default: { enableHtmlEntry: true, externalBasicLibrary: false }\n\ninterface MicroFrontend {\n  enableHtmlEntry?: boolean;\n  externalBasicLibrary?: boolean;\n  moduleApp?: string;\n}\n\n\nDevelopers can use the deploy.microFrontend to configure micro-frontend\nsub-application information.\n\nCAUTION\n\nEnable the \"Micro Frontend\" features through pnpm run new first.\n\n\nExample\n\nexport default defineConfig({\n  deploy: {\n    microFrontend: {\n      enableHtmlEntry: true,\n    },\n  },\n});\n\n\n\nConfiguration\n\n\nenableHtmlEntry\n\n * Type: boolean\n * Default: true\n\nWhether to enable the html entry, the default is true, the sub-application is\nbuilt into the HTML mode, Garfish supports the html entry, you can turn on the\nopen option, experience the corresponding features, and directly point the\nsub-application entry to the HTML entry when it is the HTML entry. Just point to\nthe html of the sub-application\n\nSet it to false to indicate that the sub-application is built as js. After the\nsub-application is built as js, it cannot run independently. When it is a JS\nentry, point the entry file of the sub-application to the JS of the\nsub-application.\n\n\nexternalBasicLibrary\n\n * Type: boolean\n * Default: false\n\nWhether the external base library, when set to true, the current child\napplication will be external: react, react-dom, Modern.js main application will\nautomatically setExternal these two base libraries, if other types of frameworks\nPlease add react, react-dom dependencies through Garfish.setExternal.","frontmatter":{"sidebar_label":"microFrontend"}},{"id":66,"title":"dev.assetPrefix","routePath":"/en/configure/app/dev/asset-prefix","lang":"en","toc":[{"id":"boolean-type","text":"Boolean Type","depth":4},{"id":"string-type","text":"String type","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ndev.assetPrefix.\n\n * Type: boolean | string\n * Default: '/'\n\nSet the URL prefix of static assets in the development environment, similar to\nthe output.publicPath config of webpack.\n\nassetPrefix will affect the URLs of most of the static assets, including\nJavaScript files, CSS files, images, videos, etc. If an incorrect value is\nspecified, you'll receive 404 errors while loading these resources.\n\nThis config is only used in the development environment. In the production\nenvironment, please use the output.assetPrefix to set the URL prefix.\n\nBoolean Type\n\nIf assetPrefix is set to true, the URL prefix will be //ip:port/:\n\nexport default {\n  dev: {\n    assetPrefix: true,\n  },\n};\n\n\nThe script URL will be:\n\n<script defer src=\"//${ip}:8080/static/js/main.js\"></script>\n\n\nIf assetPrefix is set to false or not set, / is used as the default value.\n\nString type\n\nWhen the value of assetPrefix is string type, the string will be used as the URL\nprefix:\n\nexport default {\n  dev: {\n    assetPrefix: 'http://example.com/assets/',\n  },\n};\n\n\nThe script URL will be:\n\n<script defer src=\"http://example.com/assets/static/js/main.js\"></script>\n","frontmatter":{"sidebar_label":"assetPrefix"}},{"id":67,"title":"dev.hmr","routePath":"/en/configure/app/dev/hmr","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see dev.hmr.\n\n * Type: boolean\n * Default: true\n\nWhether to enable Hot Module Replacement.\n\nIf hmr is set to false, the HMR and react-refresh will no longer work.\n\nexport default {\n  dev: {\n    hmr: false,\n  },\n};\n","frontmatter":{"sidebar_label":"hmr"}},{"id":68,"title":"dev.https","routePath":"/en/configure/app/dev/https","lang":"en","toc":[{"id":"automatically-generate-certificates","text":"Automatically generate certificates","depth":4},{"id":"manually-set-the-certificate","text":"Manually set the certificate","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see dev.https.\n\n * Type: boolean | { key: string; cert: string }\n * Default: false\n\nAfter configuring this option, you can enable HTTPS Dev Server, and disabling\nthe HTTP Dev Server.\n\nHTTP:\n\n  > Local: http://localhost:8080/\n  > Network: http://192.168.0.1:8080/\n\n\nHTTPS:\n\n  > Local: https://localhost:8080/\n  > Network: https://192.168.0.1:8080/\n\n\nAutomatically generate certificates\n\nYou can directly set https to true, Builder will automatically generate the\nHTTPS certificate based on devcert.\n\nWhen using this method, you need to manually install the devcert dependency in\nyour project:\n\n# npm\nnpm install devcert@1.2.2 -D\n\n#yarn\nyarn add devcert@1.2.2 -D\n\n#pnpm\npnpm add devcert@1.2.2 -D\n\n\nThen configure dev.https to true:\n\nexport default {\n  dev: {\n    https: true,\n  },\n};\n\n\nThe devcert has some limitations, it does not currently support IP addresses\nyet.\n\nTIP\n\nThe https proxy automatically installs the certificate and needs root authority,\nplease enter the password according to the prompt. The password is only used to\ntrust the certificate, and will not be leaked or be used elsewhere.\n\nManually set the certificate\n\nYou can also manually pass in the certificate and the private key required in\nthe dev.https option. This parameter will be directly passed to the createServer\nmethod of the https module in Node.js.\n\nFor details, please refer to https.createServer.\n\n\n\nexport default {\n  dev: {\n    https: {\n      key: fs.readFileSync('certificates/private.pem'),\n      cert: fs.readFileSync('certificates/public.pem'),\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"https"}},{"id":69,"title":"dev.port","routePath":"/en/configure/app/dev/port","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see dev.port.\n\n * Type: number\n * Default: 8080\n\nSpecify a port number for Dev Server to listen.\n\nBy default, Dev Server listens on port 8080 and automatically increments the\nport number when the port is occupied.\n\n\nExample\n\nSet the port to 3000:\n\nexport default {\n  dev: {\n    port: 3000,\n  },\n};\n","frontmatter":{"sidebar_label":"port"}},{"id":70,"title":"dev.progressBar","routePath":"/en/configure/app/dev/progress-bar","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ndev.progressBar.\n\n * Type:\n\ntype ProgressBar =\n  | boolean\n  | {\n      id?: string;\n    };\n\n\n * Default: true\n\nWhether to display progress bar during compilation.\n\nexport default {\n  dev: {\n    progressBar: false,\n  },\n};\n\n\nIf you need to modify the text displayed on the left side of the progress bar,\nyou can set the id option:\n\nexport default {\n  dev: {\n    progressBar: {\n      id: 'Some Text',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"progressBar"}},{"id":71,"title":"dev.proxy","routePath":"/en/configure/app/dev/proxy","lang":"en","toc":[{"id":"object","text":"Object","depth":3},{"id":"string","text":"String","depth":3}],"domain":"","content":"\n\n * Type: string | Object\n * Default: null\n\nWhen this option is configured, the development environment will start a global\nproxy, similar to Fiddler, Charles and other web proxy debugging tools, which\ncan be used to view, modify HTTP/HTTPS requests, responses, and can also be used\nas a proxy server.\n\nTIP\n\nUsing this option requires advance installation @modern-js/plugin-proxy.\n\n\nObject\n\nUsing this option requires that the value of Object be installed in advance, the\nkey of the object corresponds to the matching pattern, and the value of the\nobject corresponds to the matching target.\n\nExample:\n\nexport default defineConfig({\n  dev: {\n    proxy: {\n      'https://www.baidu.com': 'https://google.com.hk',\n      // Static files can be returned directly via the file protocol\n      'https://example.com/api': 'file://./data.json',\n    },\n  },\n});\n\n\n\nString\n\nWhen the value is string, it can be used to specify a separate proxy file, for\nexample:\n\nexport default defineConfig({\n  dev: {\n    proxy: './proxy.js',\n  },\n});\n\n\nmodule.exports = {\n  name: 'my-app',\n  rules: `\n    ^example.com:8080/api/***   http://localhost:3001/api/$\n  `,\n};\n\n\nINFO\n\nModern.js global proxy implementation is based on whistle, for more matching\npatterns, please refer to: Matching Patterns\n\nExecute dev, when the prompt is as follows, the proxy server starts\nsuccessfully:\n\n  App running at:\n\n  Local:    http://localhost:8080/\n  Network:  http://192.168.0.1:8080/\n\nℹ  info      Starting the proxy server.....\n✔  success   Proxy Server start on localhost:8899\n\n\nAccess the localhost:8899 to view the Network and configure proxy rules on the\nUI interface:\n\n\n\nCaution\n\nThe https agent automatically installs the certificate to obtain root\nprivileges. Please enter the password as prompted. ** The password is only used\nwhen the certificate is trusted and will not be leaked or used for other links\n**.","frontmatter":{"sidebar_label":"proxy"}},{"id":72,"title":"dev.startUrl","routePath":"/en/configure/app/dev/start-url","lang":"en","toc":[{"id":"port-placeholder","text":"Port placeholder","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see dev.startUrl.\n\n * Type: boolean | string | string[] | undefined\n * Default: undefined\n\ndev.startUrl is used to set the URL of the page that automatically opens in the\nbrowser when Dev Server starts.\n\nBy default, no page will be opened.\n\nYou can set it to the following values:\n\nexport default {\n  dev: {\n    // Open the project's default preview page, equivalent to `http://localhost:<port>`\n    startUrl: true,\n    // Open the specified page\n    startUrl: 'http://localhost:8080',\n    // Open multiple pages\n    startUrl: ['http://localhost:8080', 'http://localhost:8080/about'],\n  },\n};\n\n\n\nPort placeholder\n\nSince the port number may change, you can use the <port> placeholder to refer to\nthe current port number, and Builder will automatically replace the placeholder\nwith the actual listening port number.\n\nexport default {\n  dev: {\n    startUrl: 'http://localhost:<port>/home',\n  },\n};\n","frontmatter":{"sidebar_label":"startUrl"}},{"id":73,"title":"experiments.lazyCompilation","routePath":"/en/configure/app/experiments/lazy-compilation","lang":"en","toc":[{"id":"lazy-compilation-for-dynamic-imports","text":"Lazy Compilation for Dynamic Imports","depth":3},{"id":"lazy-compilation-for-entires","text":"Lazy Compilation for Entires","depth":3},{"id":"limitations","text":"Limitations","depth":3},{"id":"disable-split-chunks","text":"Disable split chunks","depth":4},{"id":"use-proxy","text":"Use proxy","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nexperiments.lazyCompilation.\n\n * Type:\n\ntype LazyCompilationOptions =\n  | boolean\n  | {\n      // Whether to enable lazy compilation for entries\n      entries?: boolean;\n      // Whether to enable lazy compilation for dynamic imports\n      imports?: boolean;\n    };\n\n\n * Default: false\n * Bundler: only support webpack\n\nUsed to enable the lazy compilation (i.e. compile on demand). When this config\nis enabled, Builder will compile entrypoints and dynamic imports only when they\nare used. It will improve the compilation startup time of the project.\n\nLazy compilation only takes effect in the development.\n\n\nLazy Compilation for Dynamic Imports\n\nLazy compile async modules introduced by Dynamic Import:\n\nexport default {\n  experiments: {\n    lazyCompilation: {\n      imports: true,\n      entries: false,\n    },\n  },\n};\n\n\nWhen imports option is enabled, all async modules will only be compiled when\nrequested. If your project is a single-page application, and routing is split\nthrough Dynamic Import, there will be a significant effect of speeding up\ncompilation.\n\n\nLazy Compilation for Entires\n\nIn addition to lazy compilation for async modules, you can also choose to lazily\ncompile both entries and async modules at the same time.\n\nexport default {\n  experiments: {\n    lazyCompilation: {\n      imports: true,\n      entries: true,\n    },\n  },\n};\n\n\nThe above config can also be simplified to:\n\nexport default {\n  experiments: {\n    lazyCompilation: true,\n  },\n};\n\n\nWhen entries option is enabled, all pages will not be compiled when the\ncompilation is started, and the page will be compiled only when you visit it.\n\nWhen using lazy compilation for entries, there are some considerations:\n\n * Only work for multi-page applications, no work for single-page applications.\n * when you visit a page, there will be a white screen for a period of time due\n   to waiting for the page to be compiled.\n\n\nLimitations\n\nDisable split chunks\n\nWhen you enable lazy compilation, in order to ensure the compilation results,\nBuilder will disable split chunks in the development. This will not affect the\nbuild results in the production, but will cause a difference between the build\nresults of the development and production.\n\nUse proxy\n\nLazy Compilation relies on the local development server of webpack. When you\nproxy a domain name to localhost, Lazy Compilation will not work properly.\nTherefore, if you need to develop with proxy, please disable Lazy Compilation.","frontmatter":{"sidebar_label":"lazyCompilation"}},{"id":74,"title":"html.appIcon","routePath":"/en/configure/app/html/app-icon","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.appIcon.\n\n * Type: string\n * Default: undefined\n\nSet the file path of the app icon, can be set as a relative path relative to the\nproject root directory, or as an absolute path to the file. Setting it as a CDN\nURL is not currently supported.\n\nAfter config this option, the icon will be automatically copied to the dist\ndirectory during the compilation, and the corresponding link tag will be added\nto the HTML.\n\n\nExample\n\nSet as a relative path:\n\nexport default {\n  html: {\n    appIcon: './src/assets/icon.png',\n  },\n};\n\n\nSet to an absolute path:\n\n\n\nexport default {\n  html: {\n    appIcon: path.resolve(__dirname, './src/assets/icon.png'),\n  },\n};\n\n\nAfter recompiling, the following tags are automatically generated in the HTML:\n\n<link rel=\"apple-touch-icon\" sizes=\"180*180\" href=\"/static/image/icon.png\" />\n","frontmatter":{"sidebar_label":"appIcon"}},{"id":75,"title":"html.crossorigin","routePath":"/en/configure/app/html/crossorigin","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.crossorigin.\n\n * Type: boolean | 'anonymous' | 'use-credentials'\n * Default: false\n\nSet the crossorigin attribute of the <script> tag.\n\nWhen true is passed, it is automatically set to crossorigin=\"anonymous\".\n\n\nExample\n\nexport default {\n  html: {\n    crossorigin: 'anonymous',\n  },\n};\n\n\nAfter compilation, the <script> tag in HTML becomes:\n\n<script defer src=\"/static/js/main.js\" crossorigin=\"anonymous\"></script>\n","frontmatter":{"sidebar_label":"crossorigin"}},{"id":76,"title":"html.disableHtmlFolder","routePath":"/en/configure/app/html/disable-html-folder","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.disableHtmlFolder.\n\n * Type: boolean\n * Default: false\n\nRemove the folder of the HTML files. When this option is enabled, the generated\nHTML file path will change from [name]/index.html to [name].html.\n\n\nExample\n\nBy default, the structure of HTML files in the dist directory is:\n\n/dist\n└── html\n    └── main\n        └── index.html\n\n\nEnable the html.disableHtmlFolder config:\n\nexport default {\n  html: {\n    disableHtmlFolder: true,\n  },\n};\n\n\nAfter recompiling, the directory structure of the HTML files in dist is:\n\n/dist\n└── html\n    └── main.html\n\n\n> If you want to set the path of the HTML files, use the output.distPath.html\n> config.","frontmatter":{"sidebar_label":"disableHtmlFolder"}},{"id":77,"title":"html.faviconByEntries","routePath":"/en/configure/app/html/favicon-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.faviconByEntries.\n\n * Type: Record<string, string>\n * Default: undefined\n\nSet different favicon for different pages.\n\nThe usage is same as favicon, and you can use the \"entry name\" as the key to set\neach page individually.\n\nfaviconByEntries will overrides the value set in favicon.\n\n\nExample\n\nexport default {\n  html: {\n    favicon: './src/assets/default.png',\n    faviconByEntries: {\n      foo: './src/assets/foo.png',\n    },\n  },\n};\n\n\nAfter recompiling, you will see:\n\n * The favicon for page foo is ./src/assets/foo.png.\n * The favicon for other pages is ./src/assets/default.png.","frontmatter":{"sidebar_label":"faviconByEntries"}},{"id":78,"title":"html.favicon","routePath":"/en/configure/app/html/favicon","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.favicon.\n\n * Type: string\n * Default: undefined\n\nSet the favicon icon path for all pages, can be set as a relative path relative\nto the project root directory, or as an absolute path to the file. Setting it as\na CDN URL is not currently supported.\n\nAfter config this option, the favicon will be automatically copied to the dist\ndirectory during the compilation, and the corresponding link tag will be added\nto the HTML.\n\n\nExample\n\nSet as a relative path:\n\nexport default {\n  html: {\n    favicon: './src/assets/icon.png',\n  },\n};\n\n\nSet to an absolute path:\n\n\n\nexport default {\n  html: {\n    favicon: path.resolve(__dirname, './src/assets/icon.png'),\n  },\n};\n\n\nAfter recompiling, the following tags are automatically generated in the HTML:\n\n<link rel=\"icon\" href=\"/favicon.ico\" />\n","frontmatter":{"sidebar_label":"favicon"}},{"id":79,"title":"html.injectByEntries","routePath":"/en/configure/app/html/inject-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.injectByEntries.\n\n * Type: Record<string, boolean | string>\n * Default: undefined\n\nSet different script tag inject positions for different pages.\n\nThe usage is same as inject, and you can use the \"entry name\" as the key to set\neach page individually.\n\ninjectByEntries will overrides the value set in inject.\n\n\nExample\n\nexport default {\n  html: {\n    inject: 'head',\n    injectByEntries: {\n      foo: 'body',\n    },\n  },\n};\n\n\nAfter recompiling, you will see:\n\n * The script tag of the page foo will be injected inside the body tag.\n * The script tag of other pages will be injected inside the head tag.","frontmatter":{"sidebar_label":"injectByEntries"}},{"id":80,"title":"html.inject","routePath":"/en/configure/app/html/inject","lang":"en","toc":[{"id":"default-inject-position","text":"Default inject position","depth":4},{"id":"inject-into-body","text":"Inject into body","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.inject.\n\n * Type: 'head' | 'body' | 'true' | false\n * Default: 'head'\n\nSet the inject position of the <script> tag.\n\nCan be set to the following values:\n\n * 'head': The script tag will be inject inside the head tag.\n * 'body': The script tag is inject at the end of the body tag.\n * true: The result depends on the scriptLoading config of html-webpack-plugin.\n * false: script tags will not be injected.\n\nDefault inject position\n\nThe script tag is inside the head tag by default:\n\n<html>\n  <head>\n    <title></title>\n    <script defer src=\"/static/js/runtime-main.js\"></script>\n    <script defer src=\"/static/js/main.js\"></script>\n    <link href=\"/static/css/main.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n\nInject into body\n\nAdd the following config to inject script into the body tag:\n\nexport default {\n  html: {\n    inject: 'body',\n  },\n};\n\n\nYou will see that the script tag is generated at the end of the body tag:\n\n<html>\n  <head>\n    <title></title>\n    <link href=\"/static/css/main.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script defer src=\"/static/js/runtime-main.js\"></script>\n    <script defer src=\"/static/js/main.js\"></script>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"inject"}},{"id":81,"title":"html.metaByEntries","routePath":"/en/configure/app/html/meta-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.metaByEntries.\n\n * Type: Record<string, Meta>\n * Default: undefined\n\nSet different meta tags for different pages.\n\nThe usage is same as meta, and you can use the \"entry name\" as the key to set\neach page individually.\n\nmetaByEntries will overrides the value set in meta.\n\n\nExample\n\nexport default {\n  html: {\n    meta: {\n      description: 'ByteDance',\n    },\n    metaByEntries: {\n      foo: {\n        description: 'TikTok',\n      },\n    },\n  },\n};\n\n\nAfter compiling, you can see that the meta of the page foo is:\n\n<meta name=\"description\" content=\"TikTok\" />\n\n\nThe meta of other pages is:\n\n<meta name=\"description\" content=\"ByteDance\" />\n","frontmatter":{"sidebar_label":"metaByEntries"}},{"id":82,"title":"html.meta","routePath":"/en/configure/app/html/meta","lang":"en","toc":[{"id":"string-type","text":"String Type","depth":4},{"id":"object-type","text":"Object Type","depth":4},{"id":"remove-default-value","text":"Remove Default Value","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.meta.\n\n * Type: Record<string, false | string | Record<string, string | boolean>>\n * Default: undefined\n\nConfigure the <meta> tag of the HTML.\n\nString Type\n\nWhen the value of a meta object is a string, the key of the object is\nautomatically mapped to name, and the value is mapped to content.\n\nFor example to set description:\n\nexport default {\n  html: {\n    meta: {\n      description: 'a description of the page',\n    },\n  },\n};\n\n\nThe generated meta tag in HTML is:\n\n<meta name=\"description\" content=\"a description of the page\" />\n\n\nObject Type\n\nWhen the value of a meta object is an object, the key: value of the object is\nmapped to the attribute of the meta tag.\n\nIn this case, the name and content properties will not be set by default.\n\nFor example to set http-equiv:\n\nexport default {\n  html: {\n    meta: {\n      'http-equiv': {\n        'http-equiv': 'x-ua-compatible',\n        content: 'ie=edge',\n      },\n    },\n  },\n};\n\n\nThe meta tag in HTML is:\n\n<meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n\n\n\nRemove Default Value\n\nSetting the value of the meta object to false and the meta tag will not be\ngenerated.\n\nFor example to remove the imagemode:\n\nexport default {\n  html: {\n    meta: {\n      imagemode: false,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"meta"}},{"id":83,"title":"html.mountId","routePath":"/en/configure/app/html/mount-id","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.mountId.\n\n * Type: string\n * Default: 'root'\n\nBy default, the root element is included in the HTML template for component\nmounting, and the element id can be modified through mountId.\n\n<body>\n  <div id=\"root\"></div>\n</body>\n\n\n\nExample\n\nSet the id to app:\n\nexport default {\n  html: {\n    mountId: 'app',\n  },\n};\n\n\nAfter compilation:\n\n<body>\n  <div id=\"app\"></div>\n</body>\n\n\nTIP\n\nIf you customized the HTML template, please make sure that the template contains\n<div id=\"<%= mountId %>\"></div>, otherwise this config will not take effect.","frontmatter":{"sidebar_label":"mountId"}},{"id":84,"title":"html.tagsByEntries","routePath":"/en/configure/app/html/tags-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.tagsByEntries.\n\n * Type: Record<string, ArrayOrNot<HtmlInjectTag | HtmlInjectTagHandler>>\n * Default: undefined\n\nUsed for multiple entry applications, injecting different tags for each entry.\n\nThe usage is the same as tags, and you can use the \"entry name\" as the key to\nset each page individually.\n\ntagsByEntries will override the value set in tags.\n\n\nExample\n\nexport default {\n  html: {\n    tags: [\n      { tag: 'script', attrs: { src: 'a.js' } }\n    ],\n    tagsByEntries: {\n      foo: [\n        { tag: 'script', attrs: { src: 'b.js' } }\n      ],\n    },\n  },\n};\n\n\nCompile the application and you can see a tag injected on the foo page:\n\n<script src=\"b.js\"></script>\n\n\nAnd for any other pages:\n\n<script src=\"a.js\"></script>\n","frontmatter":{"sidebar_label":"tagsByEntries"}},{"id":85,"title":"html.tags","routePath":"/en/configure/app/html/tags","lang":"en","toc":[{"id":"tag-object","text":"Tag Object","depth":4},{"id":"tags-handler","text":"Tags Handler","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.tags.\n\n * Type: ArrayOrNot<HtmlInjectTag | HtmlInjectTagHandler>\n * Default: undefined\n\nModifies the tags that are injected into the HTML page.\n\nTag Object\n\nexport interface HtmlInjectTag {\n  tag: string;\n  attrs?: Record<string, string | boolean | null | undefined>;\n  children?: string;\n  /** @default false */\n  hash?: boolean | string | ((url: string, hash: string) => string);\n  /** @default true */\n  publicPath?: boolean | string | ((url: string, publicPath: string) => string);\n  /** @default false */\n  append?: boolean;\n  /**\n   * Enable by default only for elements that are allowed to be included in the `head` tag.\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head#see_also}\n   */\n  head?: boolean;\n}\n\n\nA tag object can be used to describe the tag to be injected and the location of\nthe injection can be controlled by the parameters.\n\nexport default {\n  output: {\n    assetPrefix: '//example.com/'\n  },\n  html: {\n    tags: [\n      {\n        tag: 'script',\n        attrs: { src: 'a.js' },\n        head: true,\n        append: true,\n        publicPath: true,\n        hash: true,\n      },\n    ],\n  },\n};\n\n\nIt will add a script tag to the end of the head of the HTML:\n\n<html>\n  <head>\n    <!-- some other headTags... -->\n    <script src=\"//example.com/a.js?8327ec63\"></script>\n  </head>\n  <body>\n    <!-- some other bodyTags... -->\n  </body>\n</html>\n\n\nThe final insertion position of the tag is determined by the head and append\noptions, and two elements with the same configuration will be inserted into the\nsame area and hold their relative positions to each other.\n\nFields in the tag that indicate the path to the external resource file are\naffected by the publicPath and hash options. These fields include src for the\nscript tag and href for the link tag.\n\nEnabling publicPath will splice the output.assetPrefix field before the\nattribute representing the path in the tag. And the hash field causes the\nfilename to be followed by an additional hash query to control browser caching,\nwith the same hash string as the HTML file product.\n\nYou can also pass functions to those fields to control the path joining.\n\nTags Handler\n\nexport type HtmlInjectTagUtils = {\n  outputName: string;\n  publicPath: string;\n  hash: string;\n};\n\nexport type HtmlInjectTagHandler = (\n  tags: HtmlInjectTag[],\n  utils: HtmlInjectTagUtils,\n) => HtmlInjectTag[] | void;\n\n\nhtml.tags can also accept functions that can arbitrarily modify tags by writing\nlogic to the callback, often used to ensure the relative position of tags while\ninserting them.\n\nThe callback function accepts a tag list as an argument and needs to modify or\nreturn a new tag array directly.\n\nexport default {\n  html: {\n    tags: [\n      tags => { tags.splice(0, 1); },\n      /* ^?\n       *   { tag: 'script', attrs: { src: 'b.js' } },\n       *   ... some other headTags\n       *   { tag: 'script', attrs: { src: 'c.js' } },\n       *   ... some other bodyTags\n       *   { tag: 'script', attrs: { src: 'a.js' }, head: false },\n       */\n      { tag: 'script', attrs: { src: 'a.js' }, head: false },\n      { tag: 'script', attrs: { src: 'b.js' }, append: false },\n      { tag: 'script', attrs: { src: 'c.js' } },\n      tags => [...tags, { tag: 'script', attrs: { src: 'd.js' } }],\n      /* ^?\n       *   ... some other headTags\n       *   { tag: 'script', attrs: { src: 'c.js' } },\n       *   ... some other bodyTags\n       *   { tag: 'script', attrs: { src: 'a.js' }, head: false },\n       */\n    ],\n  },\n};\n\n\nThe function will be executed at the end of the HTML processing flow. In the\nexample below, the 'tags' parameter will contain all tag objects that form\nconfig, regardless of the function's location in config.\n\nModifying the attributes append, publicPath, hash in the callback will not take\neffect, because they have been applied to the tag's location and path\nattributes, respectively.\n\nSo the end product will look like:\n\n<html>\n  <head>\n    <!-- some other headTags... -->\n    <script src=\"//example.com/c.js\"></script>\n    <script src=\"//example.com/d.js\"></script>\n  </head>\n  <body>\n    <!-- some other bodyTags... -->\n    <script src=\"//example.com/a.js\"></script>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"tags"}},{"id":86,"title":"html.templateByEntries","routePath":"/en/configure/app/html/template-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.templateByEntries.\n\n * Type: Object\n * Default: undefined\n\nSet different template file for different pages.\n\nThe usage is same as template, and you can use the \"entry name\" as the key to\nset each page individually.\n\ntemplateByEntries will overrides the value set in template.\n\n\nExample\n\nexport default {\n  output: {\n    template: './static/index.html',\n    templateByEntries: {\n      foo: './src/pages/foo/index.html',\n      bar: './src/pages/bar/index.html',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"templateByEntries"}},{"id":87,"title":"html.templateParametersByEntries","routePath":"/en/configure/app/html/template-parameters-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.templateParametersByEntries.\n\n * Type: Object\n * Default: undefined\n\nSet different template parameters for different pages.\n\nThe usage is same as templateParameters, and you can use the \"entry name\" as the\nkey to set each page individually.\n\ntemplateParametersByEntries will overrides the value set in templateParameters.\n\n\nExample\n\nexport default {\n  html: {\n    templateParametersByEntries: {\n      foo: {\n        type: 'a',\n      },\n      bar: {\n        type: 'b',\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"templateParametersByEntries"}},{"id":88,"title":"html.templateParameters","routePath":"/en/configure/app/html/template-parameters","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.templateParameters.\n\n * Type: Object | Function\n * Default:\n\ntype DefaultParameters = {\n  meta: string; // corresponding to html.meta config\n  title: string; // corresponding to html.title config\n  mountId: string; // corresponding to html.mountId config\n  entryName: string; // entry name\n  assetPrefix: string; // corresponding to output.assetPrefix config\n  compilation: webpack.Compilation; // Compilation object corresponding to webpack\n  webpackConfig: config; // webpack config\n  // htmlWebpackPlugin built-in parameters\n  // See https://github.com/jantimon/html-webpack-plugin for details\n  htmlWebpackPlugin: {\n    tags: object;\n    files: object;\n    options: object;\n  };\n};\n\n\nDefine the parameters in the HTML template, corresponding to the\ntemplateParameters config of html-webpack-plugin. You can use the config as an\nobject or a function.\n\nIf it is an object, it will be merged with the default parameters. For example:\n\nexport default {\n  html: {\n    templateParameters: {\n      title: 'My App',\n    },\n  },\n};\n\n\nIf it is a function, the default parameters will be passed in, and you can\nreturn an object to override the default parameters. For example:\n\nexport default {\n  html: {\n    templateParameters: defaultParameters => {\n      console.log(defaultParameters.compilation);\n      console.log(defaultParameters.title);\n      return {\n        title: 'My App',\n      };\n    },\n  },\n};\n\n\n\nExample\n\nTo use the foo parameter in the HTML template, you can add the following config:\n\nexport default {\n  html: {\n    templateParameters: {\n      foo: 'bar',\n    },\n  },\n};\n\n\nOr you can use a function to dynamically generate the parameters:\n\nexport default {\n  html: {\n    templateParameters: defaultParameters => {\n      return {\n        foo: 'bar',\n      };\n    },\n  },\n};\n\n\nThen you can use the foo parameter in the HTML template by <%= foo %>:\n\n<script>\n  window.foo = '<%= foo %>';\n</script>\n\n\nThe compiled HTML is:\n\n<script>window.foo = 'bar'</script>\n","frontmatter":{"sidebar_label":"templateParameters"}},{"id":89,"title":"html.template","routePath":"/en/configure/app/html/template","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.template.\n\n * Type: string\n * Default:\n\nDefine the path to the HTML template, corresponding to the template config of\nhtml-webpack-plugin.\n\n\nExample\n\nReplace the default template with a custom HTML template file，you can add the\nfollowing config:\n\nexport default {\n  html: {\n    template: './static/index.html',\n  },\n};\n","frontmatter":{"sidebar_label":"template"}},{"id":90,"title":"html.titleByEntries","routePath":"/en/configure/app/html/title-by-entries","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nhtml.titleByEntries.\n\n * Type: Record<string, string>\n * Default: undefined\n\nSet different title for different pages.\n\nThe usage is same as title, and you can use the \"entry name\" as the key to set\neach page individually.\n\ntitleByEntries will overrides the value set in title.\n\n\nExample\n\nexport default {\n  html: {\n    title: 'ByteDance',\n    titleByEntries: {\n      foo: 'TikTok',\n    },\n  },\n};\n\n\nAfter recompiling, you can see:\n\n * The title of the page foo is TikTok.\n * The title of other pages is ByteDance.","frontmatter":{"sidebar_label":"titleByEntries"}},{"id":91,"title":"html.title","routePath":"/en/configure/app/html/title","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see html.title.\n\n * Type: string\n * Default: undefined\n\nSet the title tag of the HTML page, for example:\n\nexport default {\n  html: {\n    title: 'example',\n  },\n};\n","frontmatter":{"sidebar_label":"title"}},{"id":92,"title":"output.assetPrefix","routePath":"/en/configure/app/output/asset-prefix","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.assetPrefix.\n\n * Type: boolean | string\n * Default: '/'\n\nWhen using CDN in the production environment, you can use this option to set the\nURL prefix of static assets, similar to the output.publicPath config of webpack.\n\nassetPrefix will affect the URLs of most of the static assets, including\nJavaScript files, CSS files, images, videos, etc. If an incorrect value is\nspecified, you'll receive 404 errors while loading these resources.\n\nThis config is only used in the production environment. In the development\nenvironment, please use the dev.assetPrefix to set the URL prefix.\n\nAfter setting, the URLs of JavaScript, CSS and other static files will be\nprefixed with output.assetPrefix:\n\n\nExample\n\nexport default {\n  output: {\n    assetPrefix: 'https://cdn.example.com/assets/',\n  },\n};\n\n\nAfter building, you can see that the JS files are loaded from:\n\n<script\n  defer\n  src=\"https://cdn.example.com/assets/static/js/main.ebc4ff4f.js\"\n></script>\n","frontmatter":{"sidebar_label":"assetPrefix"}},{"id":93,"title":"output.assetsRetry","routePath":"/en/configure/app/output/assets-retry","lang":"en","toc":[{"id":"assetsretrymax","text":"assetsRetry.max","depth":3},{"id":"assetsretrydomain","text":"assetsRetry.domain","depth":3},{"id":"assetsretrytype","text":"assetsRetry.type","depth":3},{"id":"assetsretrytest","text":"assetsRetry.test","depth":3},{"id":"assetsretrycrossorigin","text":"assetsRetry.crossOrigin","depth":3},{"id":"assetsretryonretry","text":"assetsRetry.onRetry","depth":3},{"id":"assetsretryonsuccess","text":"assetsRetry.onSuccess","depth":3},{"id":"assetsretryonfail","text":"assetsRetry.onFail","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.assetsRetry.\n\n * Type: Object\n\noutput.assetsRetry is used to configure the retry of assets.The type of\nAssetsRetryOptions is as follows:\n\nexport type AssetsRetryHookContext = {\n  times: number;\n  domain: string;\n  url: string;\n  tagName: string;\n};\n\nexport type AssetsRetryOptions = {\n  type?: string[];\n  domain?: string[];\n  max?: number;\n  test?: string | ((url: string) => boolean);\n  crossOrigin?: boolean;\n  onRetry?: (options: AssetsRetryHookContext) => void;\n  onSuccess?: (options: AssetsRetryHookContext) => void;\n  onFail?: (options: AssetsRetryHookContext) => void;\n};\n\n\nThe default value is as follows:\n\nexport const defaultAssetsRetryOptions: AssetsRetryOptions = {\n  type: ['script', 'link', 'img'],\n  domain: [],\n  max: 3,\n  test: '',\n  crossOrigin: false,\n  onRetry: () => {},\n  onSuccess: () => {},\n  onFail: () => {},\n};\n\n\n * Bundler: only support webpack\n\n\nassetsRetry.max\n\n * Type: number\n * Default: 3\n\nThe maximum number of retries for a single asset. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      max: 3,\n    },\n  },\n};\n\n\n\nassetsRetry.domain\n\n * Type: string[]\n * Default: []\n\nThe domain of the asset to be retried. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      domain: ['https://cdn1.example.com', 'https://cdn2.example.com'],\n    },\n  },\n};\n\n\n\nassetsRetry.type\n\n * Type: string[]\n * Default: ['script', 'link', 'img']\n\nThe type of the asset to be retried. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      type: ['script', 'link'],\n    },\n  },\n};\n\n\n\nassetsRetry.test\n\n * Type: string | ((url: string) => boolean) | undefined\n * Default: undefined\n\nThe test function of the asset to be retried. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      test: /cdn\\.example\\.com/,\n    },\n  },\n};\n\n\n\nassetsRetry.crossOrigin\n\n * Type: undefined | boolean\n * Default: false\n\nWhether to add the crossOrigin attribute to the asset to be retried. For\nexample:\n\nexport default {\n  output: {\n    assetsRetry: {\n      crossOrigin: true,\n    },\n  },\n};\n\n\n\nassetsRetry.onRetry\n\n * Type: undefined | (options: AssetsRetryHookContext) => void\n\nThe callback function when the asset is being retried. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      onRetry: ({ times, domain, url, tagName }) => {\n        console.log(\n          `Retry ${times} times, domain: ${domain}, url: ${url}, tagName: ${tagName}`,\n        );\n      },\n    },\n  },\n};\n\n\n\nassetsRetry.onSuccess\n\n * Type: undefined | (options: AssetsRetryHookContext) => void\n\nThe callback function when the asset is successfully retried. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      onSuccess: ({ times, domain, url, tagName }) => {\n        console.log(\n          `Retry ${times} times, domain: ${domain}, url: ${url}, tagName: ${tagName}`,\n        );\n      },\n    },\n  },\n};\n\n\n\nassetsRetry.onFail\n\n * Type: undefined | (options: AssetsRetryHookContext) => void\n\nThe callback function when the asset is failed to be retried. For example:\n\nexport default {\n  output: {\n    assetsRetry: {\n      onFail: ({ times, domain, url, tagName }) => {\n        console.log(\n          `Retry ${times} times, domain: ${domain}, url: ${url}, tagName: ${tagName}`,\n        );\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"assetsRetry"}},{"id":94,"title":"output.charset","routePath":"/en/configure/app/output/charset","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.charset.\n\n * Type: 'ascii' | 'utf8'\n * Default: 'ascii'\n\nBy default, Builder's output is ASCII-only and will escape all non-ASCII\ncharacters.\n\nIf you want to output the original characters without using escape sequences,\nyou can set output.charset to utf8.\n\nexport default {\n  output: {\n    charset: 'utf8',\n  },\n};\n\n\nBuilder will automatically add <meta charset=\"utf-8\"> to the generated HTML\nfiles if output.charset is utf8.","frontmatter":{"sidebar_label":"charset"}},{"id":95,"title":"output.cleanDistPath","routePath":"/en/configure/app/output/clean-dist-path","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.cleanDistPath.\n\n * Type: boolean\n * Default: true\n\nWhether to clean all files in the dist path before starting compilation.\n\nBy default, Builder clean up the dist file, you can disable this behavior by\nsetting cleanDistPath to false.\n\nexport default {\n  output: {\n    cleanDistPath: false,\n  },\n};\n","frontmatter":{"sidebar_label":"cleanDistPath"}},{"id":96,"title":"output.convertToRem","routePath":"/en/configure/app/output/convert-to-rem","lang":"en","toc":[{"id":"boolean-type","text":"Boolean Type","depth":4},{"id":"object-type","text":"Object Type","depth":4},{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.convertToRem.\n\n * Type: boolean | object\n * Default: false\n\nBy setting output.convertToRem, the Builder can do the following things:\n\n * Convert px to rem in CSS.\n * Insert runtime code into the HTML template to set the fontSize of the root\n   element.\n\nBoolean Type\n\nIf output.convertToRem is set to true, Rem processing capability will be turned\non.\n\nexport default {\n  output: {\n    convertToRem: true,\n  },\n};\n\n\nAt this point, the rem configuration defaults as follows:\n\n{\n  enableRuntime: true,\n  rootFontSize: 50,\n  screenWidth: 375,\n  rootFontSize: 50,\n  maxRootFontSize: 64,\n  widthQueryKey: '',\n  excludeEntries: [],\n  supportLandscape: false,\n  useRootFontSizeBeyondMax: false,\n  pxtorem: {\n    rootValue: 50,\n    unitPrecision: 5,\n    propList: ['*'],\n  }\n}\n\n\nObject Type\n\nWhen the value of output.convertToRem is object type, The Builder will perform\nRem processing based on the current configuration.\n\noptions:\n\n| Name | Type | Default | Description | | ------------------------ | ----------\n|\n--------------------------------------------------------------------------------\n------------------------------------ |\n--------------------------------------------------------------------------------\n------------------------------------------- | | enableRuntime | boolean | true |\nWhether to inject runtime code into html templates, to support dynamic\ncalculation of the font size of the root element | | rootFontSize | number | 50\n| The root element font size | | maxRootFontSize | number | 64 | The root\nelement max font size | | widthQueryKey | string | '' | Get clientWidth from the\nurl query based on widthQueryKey | | screenWidth | number | 375 | The screen\nwidth for UI design drawings（Usually, fontSize = (clientWidth * rootFontSize) /\nscreenWidth） | | excludeEntries | string[] | [] | The entries to ignore | |\nsupportLandscape | boolean | false | Use height to calculate rem in landscape |\n| useRootFontSizeBeyondMax | boolean | false | Whether to use rootFontSize when\nlarge than maxRootFontSize | | pxtorem | object | rootValue (Default is the same\nas rootFontSize) unitPrecision: 5 propList: ['*'] | postcss-pxtorem options |\n\n\nExample\n\nexport default {\n  output: {\n    convertToRem: {\n      rootFontSize: 30,\n      excludeEntries: ['404', 'page2'],\n      pxtorem: {\n        propList: ['font-size'],\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"convertToRem"}},{"id":97,"title":"output.copy","routePath":"/en/configure/app/output/copy","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see output.copy.\n\n * Type: CopyPluginOptions | CopyPluginOptions['patterns']\n * Default: undefined\n\nCopies the specified file or directory to the dist directory.\n\nFor example, copy the files under src/assets to the dist directory:\n\nexport default {\n  output: {\n    copy: [{ from: './src/assets', to: '' }],\n  },\n};\n\n\nFor more detailed configuration, please refer to: copy-webpack-plugin.","frontmatter":{"sidebar_label":"copy"}},{"id":98,"title":"output.cssModuleLocalIdentName","routePath":"/en/configure/app/output/css-module-local-ident-name","lang":"en","toc":[{"id":"default-value","text":"Default Value","depth":3},{"id":"template-string","text":"Template String","depth":3},{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.cssModuleLocalIdentName.\n\n * Type: string\n * Default:\n\n// isProd indicates that the production build\nconst localIdentName = isProd\n  ? '[hash:base64:5]'\n  : '[path][name]__[local]--[hash:base64:5]';\n\n\nSets the format of the className generated by CSS Modules after compilation.\n\n\nDefault Value\n\ncssModuleLocalIdentName has different default values in development and\nproduction.\n\nIn a production, Builder will generate shorter class names to reduce the bundle\nsize.\n\n\n\n// In development, the value is `.src-index-module__header--xxxxx`\n// In production, the value is `.xxxxx`\nconsole.log(styles.header);\n\n\n\nTemplate String\n\nYou can use the following template strings in cssModuleLocalIdentName:\n\n * [name] - the basename of the asset.\n * [local] - original class.\n * [hash] - the hash of the string.\n * [folder] - the folder relative path.\n * [path] - the relative path.\n * [file] - filename and path.\n * [ext] - extension with leading dot.\n * [hash:<hashDigest>:<hashDigestLength>]: hash with hash settings.\n\n\nExample\n\nSet cssModuleLocalIdentName to other value:\n\nexport default {\n  output: {\n    cssModuleLocalIdentName: '[hash:base64:4]',\n  },\n};\n","frontmatter":{"sidebar_label":"cssModuleLocalIdentName"}},{"id":99,"title":"output.dataUriLimit","routePath":"/en/configure/app/output/data-uri-limit","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.dataUriLimit.\n\n * Type\n\ntype DataUriLimitConfig = {\n  svg?: number;\n  font?: number;\n  image?: number;\n  media?: number;\n};\n\n\n * Default\n\nconst defaultDatUriLimit = {\n  svg: 10000,\n  font: 10000,\n  image: 10000,\n  media: 10000,\n};\n\n\nSet the size threshold to inline static assets such as images and fonts.\n\nBy default, static assets will be Base64 encoded and inline into the page if the\nsize is less than 10KB.\n\nYou can adjust the threshold by setting the dataUriLimit config.\n\nDetail:\n\n * svg: The threshold of the SVG image.\n * font: The threshold of the font file.\n * image: The threshold of non-SVG images.\n * media: The threshold of media assets such as videos.\n\n\nExample\n\nSet the threshold of images to 5000 Bytes, and set media assets not to be\ninlined:\n\nexport default {\n  output: {\n    dataUriLimit: {\n      image: 5000,\n      media: 0,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"dataUriLimit"}},{"id":100,"title":"output.disableCssExtract","routePath":"/en/configure/app/output/disable-css-extract","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableCssExtract.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to disable CSS extract and inline CSS files into JS files.\n\nBy default, Builder will extract CSS into a separate .css file and output it to\nthe dist directory. When this option is set to true, CSS files will be inlined\ninto JS files and inserted on the page at runtime via <style> tags.\n\n\nExample\n\nexport default {\n  output: {\n    disableCssExtract: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableCssExtract"}},{"id":101,"title":"output.disableCssModuleExtension","routePath":"/en/configure/app/output/disable-css-module-extension","lang":"en","toc":[{"id":"example","text":"Example","depth":3},{"id":"detailed","text":"Detailed","depth":3},{"id":"disablecssmoduleextension-is-false-default","text":"disableCssModuleExtension is false (default)","depth":4},{"id":"disablecssmoduleextension-is-true","text":"disableCssModuleExtension is true","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableCssModuleExtension.\n\n * Type: boolean\n * Default: false\n\nWhether to treat all .css files in the source directory as CSS Modules.\n\nBy default, only the *.module.css files are treated as CSS Modules. After\nenabling this config, all *.css style files in the source directory will be\nregarded as CSS Modules.\n\n.sass, .scss and .less files are also affected by disableCssModuleExtension.\n\nTIP\n\nWe do not recommend enabling this config, because after enabling\ndisableCssModuleExtension, CSS Modules files and ordinary CSS files cannot be\nclearly distinguished, which is not conducive to long-term maintenance.\n\n\nExample\n\nexport default {\n  output: {\n    disableCssModuleExtension: true,\n  },\n};\n\n\n\nDetailed\n\nThe following is a detailed explanation of the CSS Modules rules:\n\ndisableCssModuleExtension is false (default)\n\nThe following files are treated as CSS Modules:\n\n * all *.module.css files\n\nThe following files are treated as normal CSS:\n\n * all *.css files (excluding .module)\n * all *.global.css files\n\ndisableCssModuleExtension is true\n\nThe following files are treated as CSS Modules:\n\n * *.css and *.module.css files in the source directory\n * *.module.css files under node_modules\n\nThe following files are treated as normal CSS:\n\n * all *.global.css files\n * *.css files under node_modules (without .module)\n\nTIP\n\nFor CSS Modules files inside node_modules, please always use the\n*.module.csssuffix.","frontmatter":{"sidebar_label":"disableCssModuleExtension"}},{"id":102,"title":"output.disableFilenameHash","routePath":"/en/configure/app/output/disable-filename-hash","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableFilenameHash.\n\n * Type: boolean\n * Default: false\n\nRemove the hash from the name of static files after production build.\n\nAfter the production build, there will be a hash in the middle of the filename\nby default. You can disable this behavior through the output.disableFilenameHash\nconfig.\n\n\nExample\n\nBy default, the filename is:\n\nFile                                     Size         Gzipped\ndist/static/css/187.7879e19d.css         126.99 KB    9.17 KB\ndist/static/js/main.18a568e5.js          2.24 KB      922 B\n\n\nAdd output.disableFilenameHash config:\n\nexport default {\n  output: {\n    disableFilenameHash: true,\n  },\n};\n\n\nAfter rebuild, the filenames become:\n\nFile                            Size         Gzipped\ndist/static/css/187.css         126.99 KB    9.17 KB\ndist/static/js/main.js          2.24 KB      922 B\n","frontmatter":{"sidebar_label":"disableFilenameHash"}},{"id":103,"title":"output.disableInlineRuntimeChunk","routePath":"/en/configure/app/output/disable-inline-runtime-chunk","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableInlineRuntimeChunk.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nControls whether to the inline the runtime chunk to HTML.\n\nIn production mode, the runtime chunk file will be inlined into HTML by default\nrather than written into dist directory, this can reduce the HTTP request\nnumber.\n\nThis option is used to disable that default behavior.\n\nexport default {\n  output: {\n    disableInlineRuntimeChunk: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableInlineRuntimeChunk"}},{"id":104,"title":"output.disableMinimize","routePath":"/en/configure/app/output/disable-minimize","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableMinimize.\n\n * Type: boolean\n * Default: false\n\nWhether to disable code minification in production build.\n\nBy default, JS code and CSS code are minified during production build. If you do\nnot want to minify the code, you can set disableMinimize to true.\n\nexport default {\n  output: {\n    disableMinimize: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableMinimize"}},{"id":105,"title":"output.disableNodePolyfill","routePath":"/en/configure/app/output/disable-node-polyfill","lang":"en","toc":[],"domain":"","content":"\n\n * Type: boolean\n * Default: true\n\nThis config is used to control whether to inject the Polyfill of the Node module\ninto the code.\n\nBy default, we will not inject Node Polyfill into the code to avoid bundle size\nincrease. If you need to inject Node Polyfill, you can set\noutput.disableNodePolyfill to false:\n\nexport default defineConfig({\n  output: {\n    disableNodePolyfill: false,\n  },\n});\n\n\nThis config is implemented based on the Node Polyfill plugin of Modern.js\nBuilder, you can read Modern.js Builder - Node Polyfill Plugin documentation for\ndetails.","frontmatter":{"sidebar_label":"disableNodePolyfill"}},{"id":106,"title":"output.disableSourceMap","routePath":"/en/configure/app/output/disable-source-map","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableSourceMap.\n\n * Type:\n\ntype DisableSourceMap =\n  | boolean\n  | {\n      js?: boolean;\n      css?: boolean;\n    };\n\n\n * Default:\n\nconst defaultDisableSourceMap = {\n  js: false,\n  css: process.env.NODE_ENV === 'production',\n};\n\n\nWhether to disable Source Map generation.\n\nWhat is a Source Map\n\nSource Map is an information file that saves the source code mapping\nrelationship. It records each location of the compiled code and the\ncorresponding pre-compilation location. With Source Map, you can directly view\nthe source code when debugging the compiled code.\n\nBy default, Builder's Source Map generation rules are:\n\n * In development build, SourceMap of JS files and CSS files will be generated,\n   which is convenient for debugging.\n * In production build, the Source Map of JS files will be generated for\n   debugging and troubleshooting online problems; the Source Map of CSS files\n   will not be generated.\n\nIf the project does not need Source Map, you can turned off it to speed up the\ncompile speed.\n\nexport default {\n  output: {\n    disableSourceMap: true,\n  },\n};\n\n\nIf you want to enable Source Map in development and disable it in the\nproduction, you can set to:\n\nexport default {\n  output: {\n    disableSourceMap: process.env.NODE_ENV === 'production',\n  },\n};\n\n\nIf you need to individually control the Source Map of JS files or CSS files, you\ncan refer to the following settings:\n\nexport default {\n  output: {\n    disableSourceMap: {\n      js: false,\n      css: true,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"disableSourceMap"}},{"id":107,"title":"output.disableTsChecker","routePath":"/en/configure/app/output/disable-ts-checker","lang":"en","toc":[{"id":"blocking-compilation","text":"Blocking Compilation","depth":3},{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.disableTsChecker.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to disable TypeScript type checker during compilation.\n\nBy default, Builder will run the TypeScript type checker in a separate process\nduring the build process. Its checking logic is consistent with TypeScript's\nnative tsc command. You can use tsconfig.json or Builder's tools.tsChecker\nconfig to customize the checking behavior.\n\n\nBlocking Compilation\n\n * In development build, type errors will not block the compilation process.\n * In production build, type errors will cause the build to fail to ensure the\n   stability of the production code.\n\n\nExample\n\nDisable TypeScript type checker:\n\nexport default {\n  output: {\n    disableTsChecker: true,\n  },\n};\n\n\nDisable type checker in development:\n\nexport default {\n  output: {\n    disableTsChecker: process.env.NODE_ENV === 'development',\n  },\n};\n\n\nDisable type checker in production:\n\nexport default {\n  output: {\n    disableTsChecker: process.env.NODE_ENV === 'production',\n  },\n};\n\n\nTIP\n\nIt is not recommended to disable type checker in production, which will reduce\nthe stability of the production code, please use it with caution.","frontmatter":{"sidebar_label":"disableTsChecker"}},{"id":108,"title":"output.distPath","routePath":"/en/configure/app/output/dist-path","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.distPath.\n\n * Type\n\ntype DistPathConfig = {\n  root?: string;\n  js?: string;\n  css?: string;\n  svg?: string;\n  font?: string;\n  html?: string;\n  image?: string;\n  media?: string;\n  server?: string;\n};\n\n\n * Default\n\nconst defaultDistPath = {\n  root: 'dist',\n  html: 'html',\n  js: 'static/js',\n  css: 'static/css',\n  svg: 'static/svg',\n  font: 'static/font',\n  image: 'static/image',\n  media: 'static/media',\n  server: 'bundles',\n};\n\n\nSet the directory of the dist files. Builder will output files to the\ncorresponding subdirectory according to the file type.\n\nDetail:\n\n * root: The root directory of all files.\n * html: The output directory of HTML files.\n * js: The output directory of JavaScript files.\n * css: The output directory of CSS style files.\n * svg: The output directory of SVG images.\n * font: The output directory of font files.\n * image: The output directory of non-SVG images.\n * media: The output directory of media assets, such as videos.\n * server: The output directory of server bundles when target is node.\n\n\nExample\n\nThe JavaScript files will be output to the distPath.root + distPath.js\ndirectory, which is dist/static/js.\n\nIf you need to output JavaScript files to the build/resource/js directory, you\ncan add following config:\n\nexport default {\n  output: {\n    distPath: {\n      root: 'build',\n      js: 'resource/js',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"distPath"}},{"id":109,"title":"output.enableAssetFallback","routePath":"/en/configure/app/output/enable-asset-fallback","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.enableAssetFallback.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nIf this option is enabled, all unrecognized files will be emitted to the dist\ndirectory; otherwise, an exception will be thrown.\n\n\nExample\n\nEnable the config:\n\nexport default {\n  output: {\n    enableAssetFallback: true,\n  },\n};\n\n\nImport a module of unknown type in code:\n\nimport './foo.xxx';\n\n\nAfter compilation, foo.xxx will be output to the dist/static/media directory.\n\nYou can control the output path and filename after fallback through the\noutput.distPath.media and output.filename.media configs.\n\nTIP\n\nEnabling this config will change the rules structure in the webpack config. In\nmost cases, we do not recommend using this config.","frontmatter":{"sidebar_label":"enableAssetFallback"}},{"id":110,"title":"output.enableAssetManifest","routePath":"/en/configure/app/output/enable-asset-manifest","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.enableAssetManifest.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to generate a manifest file that contains information of all assets.\n\n\nExample\n\nEnable asset manifest:\n\nexport default {\n  output: {\n    enableAssetManifest: true,\n  },\n};\n\n\nAfter compiler, there will be a dist/manifest.json file:\n\n{\n  \"files\": {\n    \"main.css\": \"/static/css/main.45b01211.css\",\n    \"main.js\": \"/static/js/main.52fd298f.js\",\n    \"html/main/index.html\": \"/html/main/index.html\"\n  },\n  \"entrypoints\": [\"static/css/main.45b01211.css\", \"static/js/main.52fd298f.js\"]\n}\n","frontmatter":{"sidebar_label":"enableAssetManifest"}},{"id":111,"title":"output.enableCssModuleTSDeclaration","routePath":"/en/configure/app/output/enable-css-module-tsdeclaration","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.enableCssModuleTSDeclaration.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to generate a TypeScript declaration file for CSS modules.\n\n\nExample\n\nEnable CSS module TypeScript declaration:\n\nexport default {\n  output: {\n    enableCssModuleTSDeclaration: true,\n  },\n};\n\n\nAfter building, there will be a .d.ts file for each CSS module file. For example\n\ninterface CssExports {\n  title: string;\n}\nexport const cssExports: CssExports;\nexport default cssExports;\n","frontmatter":{"sidebar_label":"enableCssModuleTSDeclaration"}},{"id":112,"title":"output.enableInlineScripts","routePath":"/en/configure/app/output/enable-inline-scripts","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.enableInlineScripts.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to inline output scripts files (.js files) into HTML with <script> tags\nin production mode.\n\nNote that, with this option on, the scripts files will no longer be written in\ndist directory, they will only exist inside the HTML file instead.\n\n\nExample\n\nBy default, we have following output files:\n\ndist/html/main/index.html\ndist/static/css/style.css\ndist/static/js/main.js\n\n\nAfter turn on the output.enableInlineScripts option:\n\nexport default {\n  output: {\n    enableInlineScripts: true,\n  },\n};\n\n\nThe output files will become:\n\ndist/html/main/index.html\ndist/static/css/style.css\n\n\nAnd dist/static/js/main.js will be inlined in index.html:\n\n<html>\n  <body>\n    <script>\n      // content of dist/static/js/main.js\n    </script>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"enableInlineScripts"}},{"id":113,"title":"output.enableInlineStyles","routePath":"/en/configure/app/output/enable-inline-styles","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.enableInlineStyles.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to inline output style files (.css files) into HTML with <style> tags in\nproduction mode.\n\nNote that, with this option on, the style files will no longer be written in\ndist directory, they will only exist inside the HTML file instead.\n\n\nExample\n\nBy default, we have following output files:\n\ndist/html/main/index.html\ndist/static/css/style.css\ndist/static/js/main.js\n\n\nAfter turn on the output.enableInlineStyles option:\n\nexport default {\n  output: {\n    enableInlineStyles: true,\n  },\n};\n\n\nThe output files will become:\n\ndist/html/main/index.html\ndist/static/js/main.js\n\n\nAnd dist/static/css/style.css will be inlined in index.html:\n\n<html>\n  <head>\n    <style>\n      /* content of dist/static/css/style.css */\n    </style>\n  </head>\n  <body>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"enableInlineStyles"}},{"id":114,"title":"output.enableLatestDecorators","routePath":"/en/configure/app/output/enable-latest-decorators","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.enableLatestDecorators.\n\n * Type: boolean\n * Default: false\n\nWhether to use the new decorator proposal.\n\nBy default, Builder uses the legacy decorator proposal when compiling\ndecorators.\n\nWhen output.enableLatestDecorators is set to true, the Builder will compile with\nthe new decorator proposal (version 2018-09).\n\nexport default {\n  output: {\n    enableLatestDecorators: true,\n  },\n};\n","frontmatter":{"sidebar_label":"enableLatestDecorators"}},{"id":115,"title":"output.externals","routePath":"/en/configure/app/output/externals","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.externals.\n\n * Type: string | object | function | RegExp\n\n * Default: undefined\n\nAt build time, prevent some import dependencies from being packed into bundles\nin your code, and instead fetch them externally at runtime.\n\nFor more information, please see: webpack Externals\n\n\nExample\n\nExclude the react-dom dependency from the build product. To get this module at\nruntime, the value of react-dom will globally retrieve the ReactDOM variable.\n\nexport default {\n  output: {\n    externals: {\n      'react-dom': 'ReactDOM',\n    },\n  },\n};\n\n\nTIP\n\nWhen the build target is Web Worker, externals will not take effect. This is\nbecause the Worker environment can not access global variables.","frontmatter":{"sidebar_label":"externals"}},{"id":116,"title":"output.filename","routePath":"/en/configure/app/output/filename","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.filename.\n\n * Type\n\ntype FilenameConfig = {\n  js?: string;\n  css?: string;\n  svg?: string;\n  font?: string;\n  image?: string;\n  media?: string;\n};\n\n\n * Default\n\n// Development\nconst devDefaultFilename = {\n  js: '[name].js',\n  css: '[name].css',\n  svg: '[name].[contenthash:8].svg',\n  font: '[name].[contenthash:8][ext]',\n  image: '[name].[contenthash:8][ext]',\n  media: '[name].[contenthash:8][ext]',\n};\n\n// Production\nconst prodDefaultFilename = {\n  js: '[name].[contenthash:8].js',\n  css: '[name].[contenthash:8].css',\n  svg: '[name].[contenthash:8].svg',\n  font: '[name].[contenthash:8][ext]',\n  image: '[name].[contenthash:8][ext]',\n  media: '[name].[contenthash:8][ext]',\n};\n\n\nSets the filename of dist files.\n\nAfter the production build, there will be a hash in the middle of the filename\nby default. You can disable this behavior through the output.disableFilenameHash\nconfig.\n\nDetail:\n\n * js: The name of the JavaScript file.\n * css: The name of the CSS style file.\n * svg: The name of the SVG image.\n * font: The name of the font file.\n * image: The name of a non-SVG image.\n * media: The name of a media asset, such as a video.\n\n\nExample\n\nSet the name of the JavaScript file to [name]_script.js:\n\nexport default {\n  output: {\n    filename: {\n      js:\n        process.env.NODE_ENV === 'production'\n          ? '[name]_script.[contenthash:8].js'\n          : '[name]_script.js',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"filename"}},{"id":117,"title":"output.legalComments","routePath":"/en/configure/app/output/legal-comments","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.legalComments.\n\n * Type: 'linked' | 'inline' | 'none'\n * Default: 'linked'\n * Bundler: only support webpack\n\nConfigure how to handle the legal comment.\n\nA \"legal comment\" is considered to be any statement-level comment in JS or\nrule-level comment in CSS that contains @license or @preserve or that starts\nwith //! or /*!. These comments are preserved in output files by default since\nthat follows the intent of the original authors of the code.\n\nThis behavior can be configured by using one of the following options:\n\n * linked: Extract all legal comments to a .LEGAL.txt file and link to them with\n   a comment.\n * inline: Preserve all legal comments in original position.\n * none: Remove all legal comments.\n\n\nExample\n\nRemove all legal comments:\n\nexport default {\n  output: {\n    legalComments: 'none',\n  },\n};\n","frontmatter":{"sidebar_label":"legalComments"}},{"id":118,"title":"output.overrideBrowserslist","routePath":"/en/configure/app/output/override-browserslist","lang":"en","toc":[{"id":"priority","text":"Priority","depth":4},{"id":"default-value","text":"Default Value","depth":4},{"id":"example","text":"Example","depth":3},{"id":"set-according-to-targets","text":"Set according to Targets","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.overrideBrowserslist.\n\n * Type: string[] | Record<BuilderTarget, string[]\n * Default: undefined\n\nSpecifies the range of target browsers that the project is compatible with. This\nvalue will be used by @babel/preset-env and autoprefixer to identify the\nJavaScript syntax that need to be transformed and the CSS browser prefixes that\nneed to be added.\n\nPriority\n\nThe overrideBrowserslist config will override the .browserslistrc config file in\nthe project and the browserslist field in package.json.\n\nIn most cases, it is recommended to use the .browserslistrc file rather than the\noverrideBrowserslist config. Because the .browserslistrc file is the official\nconfig file, it is more general and can be recognized by other libraries in the\ncommunity.\n\nDefault Value\n\nIf there is no browserslist configs defined in the project, nor\noverrideBrowserslist defined, then Builder will set the default browserslist to:\n\n['> 0.01%', 'not dead', 'not op_mini all'];\n\n\n\nExample\n\nAn example compatible with mobile scenarios:\n\nexport default {\n  output: {\n    overrideBrowserslist: [\n      'iOS 9',\n      'Android 4.4',\n      'last 2 versions',\n      '> 0.2%',\n      'not dead',\n    ],\n  },\n};\n\n\nCheck out the browserslist documentation to learn more about browserslist.\n\nSet according to Targets\n\nWhen you build multiple targets at the same time, you can set different browser\nranges for different targets. At this point, you need to set\noverrideBrowserslist to an object whose key is the corresponding build target.\n\nFor example to set different ranges for web and node:\n\nexport default {\n  output: {\n    overrideBrowserslist: {\n      web: ['iOS 9', 'Android 4.4', 'last 2 versions', '> 0.2%', 'not dead'],\n      node: ['node >= 14'],\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"overrideBrowserslist"}},{"id":119,"title":"output.polyfill","routePath":"/en/configure/app/output/polyfill","lang":"en","toc":[{"id":"config","text":"Config","depth":3},{"id":"entry","text":"entry","depth":4},{"id":"usage","text":"usage","depth":4},{"id":"ua","text":"ua","depth":4},{"id":"off","text":"off","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.polyfill.\n\n * Type: 'entry' | 'usage' | 'ua' | 'off'\n * Default: 'entry'\n\nVia output.polyfill you can configure how the polyfill is injected.\n\n\nConfig\n\nentry\n\nPolyfill is injected in every entry file when output.polyfill is configured as\n'entry'.\n\nEquivalent to useBuiltIns: 'entry' configuration in @babel/preset-env.\n\nusage\n\nPolyfill is injected in each file based on the API used in the code.\n\nEquivalent to useBuiltIns: 'usage' configuration in @babel/preset-env.\n\nua\n\nThe Polyfill code is dynamically delivered according to the currently requested\nUA information.\n\noff\n\nPolyfill is not injected. When using this option, you need to ensure code\ncompatibility yourself.","frontmatter":{"sidebar_label":"polyfill"}},{"id":120,"title":"output.ssg","routePath":"/en/configure/app/output/ssg","lang":"en","toc":[{"id":"example","text":"Example","depth":2},{"id":"single-entry","text":"Single Entry","depth":3},{"id":"multi-entries","text":"Multi Entries","depth":3},{"id":"configure-route","text":"Configure Route","depth":3},{"id":"prevent-default","text":"Prevent Default","depth":3},{"id":"dynamic-params","text":"Dynamic Params","depth":3}],"domain":"","content":"\n\n * Type: boolean | object | function\n * Default: undefined\n\nEnable the SSG for Self-controlled Routing or Conventional Routing.\n\nINFO\n\nFor more routes detail, see routes.\n\n\nExample\n\n\nSingle Entry\n\nWhen the configuration is set to true, the SSG of all entries will be enabled by\ndefault.\n\nFor self-controlled routing, the root route of the entry will be rendered. For\nconvention routing, every route in the entry will be rendered.\n\nFor example, the src/ directory has the following file structure that satisfies\nconventional routing:\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\nMake the following config in modern.config.[tj]s:\n\nexport default defineConfig({\n  output: {\n    ssg: true,\n  },\n});\n\n\nAfter executing pnpm build to build the application. The dist/ directory will\ngenerate three HTML for each of the three routes (only one HTML if SSG not\nenabled), and all HTML has been rendered.\n\nFor example the following self-controlled routing:\n\n\n\n\n\n\nconst Router = typeof window === 'undefined' ? StaticRouter : BrowserRouter;\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const pathname = context?.request?.pathname;\n  return (\n    <Router location={pathname}>\n      <Routes>\n        <Route index element={<div>index</div>} />\n        <Route path=\"about\" element={<div>about</div>} />\n      </Routes>\n    </Router>\n  );\n};\n\n\nAlso using the above configuration, after executing pnpm run build, only the\nentry route / will generate the rendered HTML.\n\n\nMulti Entries\n\noutput.ssg can also be configured according to the entries, and the rules that\nthe configuration takes effect are also determined by the entries routing\nmethod.\n\n例如以下目录结构：\n\n.\n├── src\n│   ├── entryA\n│   │   └── routes\n│   │       ├── layout.tsx\n│   │       ├── page.tsx\n│   │       └── user\n│   │           ├── layout.tsx\n│   │           ├── page.tsx\n│   │           └── profile\n│   │               └── page.tsx\n│   └── entryB\n│       └── App.tsx\n\n\nBy default, all entryA entrances are rendered at build time after setting\noutput.ssg to true. You can configure false to cancel the default behavior of\nthe specified entries. For example, to cancel the rendering of the entryA at\nbuild time:\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      entryA: true,\n      entryB: false,\n    },\n  },\n});\n\n\n\nConfigure Route\n\nAs mentioned above, Self-Controlled Routing only enables SSG configuration for\nentries route by default.\n\nSet specific routes in output.ssg can tell Modern.js to enable the SSG of these\nclient side routes. For example, the content of the above src/App.tsx file is:\n\nWhen set like this in modern.config.[jt]s, the /about route will also enable\nSSG:\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: ['/', '/about'],\n    },\n  },\n});\n\n\nModern.js will automatically concat the complete URL according to the entry and\nhand it over to the SSG plugin to complete the rendering.\n\nRequest headers can also be configured for specific entries or routes, for\nexample:\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      headers: {},\n      routes: [\n        '/',\n        {\n          url: '/about',\n          headers: {},\n        },\n      ],\n    },\n  },\n});\n\n\nINFO\n\nThe headers set in the route override the headers set in the entry.\n\n\nPrevent Default\n\nBy default, Conventional Routing all turn on SSG. Modern.js provides another\nfield to prevent the default SSG behavior.\n\nFor example, the following directory structure ，/、/user and /user/profle all\nhave SSG enabled:\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\nYou can set this to disable the default behavior of a client-side route:\n\nexport default defineConfig({\n  output: {\n    preventDefault: ['/user'],\n  },\n});\n\n\n\nDynamic Params\n\nSome routes may be dynamic, such as the /user/:id in a self-controlled route or\nthe route generated by the user/[id]/page.tsx file in a conventional route.\n\nconfigure specific parameters in output.ssg to render the route of the specified\nparameters, for example:\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: [\n        {\n          url: '/user/:id',\n          params: [\n            {\n              id: 'modernjs',\n            },\n          ],\n        },\n      ],\n    },\n  },\n});\n\n\nThe features of dynamic routing and SSG is useful when generating static pages\nin real time based on CMS system.","frontmatter":{"sidebar_label":"ssg"}},{"id":121,"title":"output.svgDefaultExport","routePath":"/en/configure/app/output/svg-default-export","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\noutput.svgDefaultExport.\n\n * Type: url | component\n * Default: url\n\noutput.svgDefaultExport is used to configure the default export type of SVG\nfiles.\n\nWhen output.svgDefaultExport is set to url , the default export of SVG files is\nthe URL of the file. For example:\n\n\n\nconsole.log(logo); // => asset url\n\n\nWhen output.svgDefaultExport is set to component , the default export of SVG\nfiles is the React component of the file. For example:\n\n\n\nconsole.log(Logo); // => React Component\n\n\nAt this time, you can also specify the ?url query to import the URL, for\nexample:\n\n\n\nconsole.log(logo); // => asset url\n","frontmatter":{"sidebar_label":"svgDefaultExport"}},{"id":122,"title":"performance.buildCache","routePath":"/en/configure/app/performance/build-cache","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.buildCache.\n\n * Type:\n\ntype BuildCacheConfig =\n  | {\n      /**\n       * Base directory for the filesystem cache.\n       */\n      cacheDirectory?: string;\n    }\n  | boolean;\n\n\n * Default:\n\nconst defaultBuildCacheConfig = {\n  cacheDirectory: './node_modules/.cache/webpack',\n};\n\n\n * Bundler: only support webpack\n\nControls the Builder's caching behavior during the build process.\n\nBuilder will enable build cache by default to improve the compile speed, the\ngenerated cache files are write to the ./node_modules/.cache/webpack directory\nby default.\n\nYou can configure the cache path with buildCache, e.g.\n\nexport default {\n  performance: {\n    buildCache: {\n      cacheDirectory: './node_modules/.custom_cache/webpack',\n    },\n  },\n};\n\n\nYou can also disable the build cache by setting it to false:\n\nexport default {\n  performance: {\n    buildCache: false,\n  },\n};\n","frontmatter":{"sidebar_label":"buildCache"}},{"id":123,"title":"performance.bundleAnalyze","routePath":"/en/configure/app/performance/bundle-analyze","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.bundleAnalyze.\n\n * Type: Object | undefined\n\nYou have two ways to enable webpack-bundle-analyzer to analyze the size of\noutput files:\n\n * Add environment variable BUNDLE_ANALYZE=true.\n * Add performance.bundleAnalyze config.\n\nBy default, webpack-bundle-analyzer is not enabled. When enabled, its\nconfiguration is as follows:\n\n{\n  analyzerMode: 'static',\n  openAnalyzer: false,\n  // `target` is the compilation target, such as `web`, `node`, etc.\n  reportFilename: `report-${target}.html`,\n}\n\n\nYou can override the default config through performance.bundleAnalyze, for\nexample:\n\nexport default {\n  performance: {\n    bundleAnalyze: {\n      analyzerMode: 'server',\n      openAnalyzer: true,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"bundleAnalyze"}},{"id":124,"title":"performance.chunkSplit","routePath":"/en/configure/app/performance/chunk-split","lang":"en","toc":[{"id":"chunksplitstrategy","text":"chunkSplit.strategy","depth":3},{"id":"chunksplitminsize","text":"chunkSplit.minSize","depth":3},{"id":"chunksplitmaxsize","text":"chunkSplit.maxSize","depth":3},{"id":"chunksplitforcesplitting","text":"chunkSplit.forceSplitting","depth":3},{"id":"chunksplitsplitchunks","text":"chunkSplit.splitChunks","depth":3},{"id":"chunksplitoverride","text":"chunkSplit.override","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.chunkSplit.\n\n * Type: Object\n * Default: { strategy: 'split-by-experience' }\n\nperformance.chunkSplit is used to configure the chunk splitting strategy. The\ntype of ChunkSplit is as follows:\n\ninterface BaseChunkSplit {\n  strategy?:\n    | 'split-by-module'\n    | 'split-by-experience'\n    | 'all-in-one'\n    | 'single-vendor';\n  override?: SplitChunks;\n  forceSplitting?: Array<RegExp>;\n}\n\ninterface SplitBySize {\n  strategy?: 'split-by-size';\n  minSize?: number;\n  maxSize?: number;\n  override?: SplitChunks;\n  forceSplitting?: Array<RegExp>;\n}\n\ninterface SplitCustom {\n  strategy?: 'custom';\n  splitChunks?: SplitChunks;\n  forceSplitting?: Array<RegExp>;\n}\n\nexport type ChunkSplit = BaseChunkSplit | SplitBySize | SplitCustom;\n\n\n\nchunkSplit.strategy\n\nBuilder provides the following chunk splitting strategies:\n\n * split-by-experience: split by experience, the default strategy\n * split-by-module: split a chunk per npm package\n * split-by-size: split by chunk size\n * all-in-one: all code is bundled into a single chunk\n * single-vendor: The code in node_modules is bundled into a single chunk\n * custom: custom chunk splitting strategy\n\nBuilder use split-by-experience strategy by default, in which the following npm\npackage group will be split into a single chunk:\n\n * react and react-dom\n * react-router、history and react-router-dom\n * antd component library\n * semi component library\n * arco component library\n * @babel/runtime (including @babel/runtime-corejs2、 @babel/runtime-corejs3)\n * lodash、lodash-es\n * core-js\n\nIf you want to use other splitting strategies, you can specify it via\nperformance.chunkSplit.strategy.\n\n\nchunkSplit.minSize\n\n * Type: number\n * Default: 10000\n\nWhen performance.chunkSplit.strategy is split-by-size, you can specify the\nminimum size of a chunk via performance.chunkSplit.minSize, the unit is bytes.\nThe default value is 10000. For example:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-size',\n      minSize: 20000,\n    },\n  },\n};\n\n\n\nchunkSplit.maxSize\n\n * Type: number\n * Default: Infinity\n\nWhen performance.chunkSplit.strategy is split-by-size, you can specify the\nmaximum size of a chunk via performance.chunkSplit.maxSize, the unit is bytes.\nThe default value is Infinity. For example:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-size',\n      maxSize: 50000,\n    },\n  },\n};\n\n\n\nchunkSplit.forceSplitting\n\n * Type: Array<RegExp>\n * Default: []\n\nVia performance.chunkSplit.forceSplitting, you can specify the NPM packages that\nneed to be forced to split. For example:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      forceSplitting: [/^@arco-design\\/web-react/],\n    },\n  },\n};\n\n\nThis is an easier way than configuring webpack's splitChunks directly.\n\n\nchunkSplit.splitChunks\n\nWhen performance.chunkSplit.strategy is custom, you can specify the custom\nwebpack chunk splitting config via performance.chunkSplit.splitChunks. This\nconfig will be merged with the webpack splitChunks config (the cacheGroups\nconfig will also be merged). For example:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'custom',\n      splitChunks: {\n        cacheGroups: {\n          react: {\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n            name: 'react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n  },\n};\n\n\n\nchunkSplit.override\n\nWhen performance.chunkSplit.strategy is split-by-experience, split-by-module,\nsplit-by-size or single-vendor, you can specify the custom webpack chunk\nsplitting config via performance.chunkSplit.override. This config will be merged\nwith the webpack splitChunks config (the cacheGroups config will also be\nmerged). For example:\n\nexport default {\n  performance: {\n    strategy: 'split-by-experience',\n    chunkSplit: {\n      override: {\n        cacheGroups: {\n          react: {\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n            name: 'react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n  },\n};\n\n\n> When the Builder target is \"node\", since Node Bundles do not need to be\n> splitted to optimize loading performance, the chunkSplit rule will not take\n> effect.","frontmatter":{"sidebar_label":"chunkSplit"}},{"id":125,"title":"performance.printFileSize","routePath":"/en/configure/app/performance/print-file-size","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.printFileSize.\n\n * Type: boolean\n * Default: true\n\nWhether to print the file sizes after production build.\n\ninfo    File sizes after production build:\n\n  File                                     Size         Gzipped\n  dist/static/js/lib-corejs.1c836fe7.js    212.89 kB    66.57 kB\n  dist/static/js/lib-react.fcafbc5c.js     134.65 kB    43.45 kB\n  dist/static/js/main.6ff06f70.js          8.93 kB      3.73 kB\n  dist/static/css/main.9f48031b.css        2.64 kB      927 B\n  dist/html/main/index.html                1.64 kB      874 B\n\n\n\nExample\n\nDisable the logs:\n\nexport default {\n  performance: {\n    printFileSize: false,\n  },\n};\n","frontmatter":{"sidebar_label":"printFileSize"}},{"id":126,"title":"performance.profile","routePath":"/en/configure/app/performance/profile","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.profile.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether capture timing information for each module, same as the profile config\nof webpack.\n\n\nExample\n\nexport default {\n  performance: {\n    profile: true,\n  },\n};\n\n\nWhen turned on, webpack generates a JSON file with some statistics about the\nmodule that includes information about timing information for each module.","frontmatter":{"sidebar_label":"profile"}},{"id":127,"title":"performance.removeConsole","routePath":"/en/configure/app/performance/remove-console","lang":"en","toc":[{"id":"remove-all-consoles","text":"Remove all consoles","depth":4},{"id":"remove-specific-console","text":"Remove specific console","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.removeConsole.\n\n * Type: boolean | ConsoleType[]\n * Default: false\n\nWhether to remove console.xx in production build.\n\nRemove all consoles\n\nWhen removeConsole is set to true, all types of console.xx are removed:\n\nexport default {\n  performance: {\n    removeConsole: true,\n  },\n};\n\n\nRemove specific console\n\nYou can also specify to remove only certain types of console.xx, such as\nconsole.log and console.warn:\n\nexport default {\n  performance: {\n    removeConsole: ['log', 'warn'],\n  },\n};\n\n\nThe following types of console are currently supported:\n\ntype ConsoleType = 'log' | 'info' | 'warn' | 'error' | 'table' | 'group';\n","frontmatter":{"sidebar_label":"removeConsole"}},{"id":128,"title":"performance.removeMomentLocale","routePath":"/en/configure/app/performance/remove-moment-locale","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nperformance.removeMomentLocale.\n\n * Type: boolean\n * Default: false\n * Bundler: only support webpack\n\nWhether to remove the locales of moment.js.\n\nmoment.js contains a lot of locales by default, which will increase the bundle\nsize.\n\nWhen moment.js is used in the project, it is recommended to enable this option\nto automatically exclude all locales:\n\nexport default {\n  performance: {\n    removeMomentLocale: true,\n  },\n};\n\n\nOnce enabled, you can load a specific locale via:\n\n\nimport 'moment/locale/zh-cn';\n\nmoment.locale('zh-cn');\n","frontmatter":{"sidebar_label":"removeMomentLocale"}},{"id":129,"title":"plugins","routePath":"/en/configure/app/plugins","lang":"en","toc":[{"id":"precautions","text":"Precautions","depth":2},{"id":"plugin-type","text":"Plugin type","depth":2},{"id":"plugin-execution-order","text":"Plugin execution order","depth":2},{"id":"example","text":"Example","depth":2},{"id":"using-plugins-on-npm","text":"Using plugins on npm","depth":3},{"id":"use-local-plugins","text":"Use local plugins","depth":3},{"id":"plugin-configuration","text":"Plugin configuration","depth":3}],"domain":"","content":"\n\n * Type: CliPlugin[]\n * Default: []\n\nUsed to configure custom Modern.js framework plugins.\n\nFor the way to write custom plugins, please refer to How to Write Plugins.\n\n\nPrecautions\n\nThis config is used to configure the Modern.js framework plugin. If you need to\nconfigure other types of plugins, please select the corresponding configs:\n\n * Use builderPlugins to configure Modern.js Builder plugins.\n * Use tools.webpack or tools.webpackChain to configure webpack plugins.\n * Use tools.babel to configure babel plugins.\n\n\nPlugin type\n\nThere are three different type of framework plugins built into the Modern.js:\n\n * CLI Plugin，for local development, compilation and build phases, can extend\n   various capabilities on the command line and compilation phases.\n * Server Plugin，for server-level.\n * Runtime Plugin，for runtime.\n\nThe ability to customize CLI plugins is currently open Modern.js, and the Server\nplugin and Runtime plugin will be available in the future.\n\n\nPlugin execution order\n\nBy default, custom plugins are executed sequentially in the order of an array of\nplugins, Modern.js built-in plugins are executed earlier than custom plugins.\n\nWhen the plugin uses related fields that control the order, such as pre and\npost, the execution order will be adjusted based on the declared fields, see\nRelationship between plugins.\n\n\nExample\n\nBelow is an example of using the CLI plugin.\n\n\nUsing plugins on npm\n\nTo use the plugin on npm, you need to install the plugin through the package\nmanager and import it.\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\nUse local plugins\n\nUsing the plugin in the local code repository, you can import it directly\nthrough the relative path import.\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\nPlugin configuration\n\nIf the plugin provides some custom configuration options, you can pass in the\nconfiguration through the parameters of the plugin function.\n\n\n\nexport default defineConfig({\n  plugins: [\n    myPlugin({\n      foo: 1,\n      bar: 2,\n    }),\n  ],\n});\n","frontmatter":{"title":"plugins","sidebar_position":9}},{"id":130,"title":"Overview","routePath":"/en/configure/app/runtime/intro","lang":"en","toc":[{"id":"configuration","text":"Configuration","depth":2},{"id":"runtime","text":"runtime","depth":3},{"id":"base","text":"Base","depth":4},{"id":"defineconfig","text":"DefineConfig","depth":4},{"id":"runtimebyentries","text":"runtimeByEntries","depth":3},{"id":"introduction","text":"Introduction","depth":4}],"domain":"","content":"\n\nThis section describes the configuration of the Runtime plugin.\n\n\nConfiguration\n\n\nruntime\n\n * Type: Object\n\nThe runtime is configured as follows:\n\nBase\n\nConfigure in modern.config.ts:\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: true,\n    router: true,\n  },\n});\n\n\nDefineConfig\n\nConfigure use defineConfig API:\n\nINFO\n\nWhen there is a function in the runtime configuration, it can only be configured\nin this way.\n\n\n\nconst App = () => {\n  /** */\n};\n\ndefineConfig(App, {\n  router: {\n    supportHtml5History: false,\n  },\n});\n\nexport default App;\n\n\nINFO\n\nUsing runtime configuration, you can solve the problem that runtime plugin\nconfiguration needs to be at runtime to get specific content.\n\nRuntime plugin runtime configuration and configuration directly in\nmodern.config.ts are merged by default, and runtime configuration takes\nprecedence.\n\nWARNING\n\ndefineConfig can only define the specific configuration content of the Runtime\nplugin. To confirm whether to enable the plugin, it needs to be determined\nthrough the configuration in modernConfig in package.json or modern.config.ts.\n\n\nruntimeByEntries\n\n * Type: Object\n\nIntroduction\n\nAdd the runtime configuration according to the entry. The option attribute is\nconsistent with the runtime. The specified value will be replaced and merged\nwith the content of the runtime attribute.\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: false,\n  },\n  runtimeByEntries: {\n    entry1: {\n      state: true, // { state: true }\n    },\n    entry2: {\n      // { state: false, router: true }\n      router: true,\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"Overview","sidebar_position":1}},{"id":131,"title":"runtime.masterApp","routePath":"/en/configure/app/runtime/master-app","lang":"en","toc":[{"id":"example","text":"Example","depth":2},{"id":"manifest","text":"manifest","depth":2},{"id":"getapplist","text":"getAppList?","depth":3},{"id":"apps","text":"apps","depth":3},{"id":"other-config","text":"Other Config","depth":3}],"domain":"","content":"\n\n * Type: Object\n\nINFO\n\nFirst you need to enable the \"micro frontend\" function using new command.\n\n\nExample\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n    masterApp: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\nmanifest\n\ninterface Manifest {\n  getAppList?: () => Array<AppInfo>;\n}\n\n\n\ngetAppList?\n\nThrough the getAppList configuration, you can customize how to get remote list\ndata\n\ntype GetAppList = () => Promise<Array<AppInfo>>;\n\n\n\napps\n\nWhen apps is an object, it represents the information of the child application\nmodule Array<AppInfo>.\n\ninterface AppInfo {\n  name: string;\n  entry: string;\n  activeWhen?: string | ()=> boolean;\n}\n\n\n * name: The name of the module.\n * entry: The entry of the module.\n\n\nOther Config\n\nUnder the masterApp configuration, developers can pass through the configuration\nitems of Garfish.\n\nAll supported configuration items see here.","frontmatter":{"sidebar_label":"masterApp"}},{"id":132,"title":"runtime.router","routePath":"/en/configure/app/runtime/router","lang":"en","toc":[{"id":"basename","text":"basename","depth":2},{"id":"supporthtml5history","text":"supportHtml5History","depth":2}],"domain":"","content":"\n\n * Type: boolean | Object\n * Default: false\n\nWhen router is enabled, routing management of conventional routes provided by\nModern.js is supported. Based on React Router 6.\n\n\nbasename\n\n * Type: string\n * Default: ``\n\nThe basename of the app for situations where you can't deploy to the root of the\ndomain, but a sub directory.\n\n\nsupportHtml5History\n\n * Type: boolean\n * Default: true\n\nIf the value of supportHtml5History is true, BrowserRouter would be used,\notherwise HashRouter would be used. BrowserRouter is recommended.\n\nWARNING\n\nWhen SSR is enabled, supportHtml5History is not supported.","frontmatter":{"sidebar_label":"router"}},{"id":133,"title":"runtime.state","routePath":"/en/configure/app/runtime/state","lang":"en","toc":[{"id":"models","text":"models","depth":2},{"id":"initialstate","text":"initialState","depth":2},{"id":"immer","text":"immer","depth":2},{"id":"effects","text":"effects","depth":2},{"id":"autoactions","text":"autoActions","depth":2},{"id":"devtools","text":"devtools","depth":2}],"domain":"","content":"\n\n * Type: boolean | object\n * Default: false\n\nOnce state is enabled, you can use Model for state management.\n\nThe specific configuration items are as follows:\n\n\nmodels\n\n * Type: Array<Model>\n * Default: []\n\nRegister model objects that are mounted in advance, and these models will be\nmounted immediately after the Reduck store is created. Generally, there is no\nneed to mount in advance.\n\n\ninitialState\n\n * Type: Object\n * Default: {}\n\nUsed to set the initial state of the global store. Generally used for SSR to\ninitialize data during the hydration phase.\n\n\nimmer\n\n * Type: boolean\n * Default: true\n\nWhether to enable to update the state with mutable, it is enabled by default,\nand set to false if you want to disable it.\n\n\neffects\n\n * Type: boolean\n * Default: true\n\nWhether to enable the side effect management feature, it is enabled by default,\nand set to false if you want to disable it.\n\n\nautoActions\n\n * Type: boolean\n * Default: true\n\nWhether to enable the auto-generated actions feature, it is enabled by default,\nand set to false if you want to disable it.\n\n\ndevtools\n\n * Type: boolean | EnhancerOptions\n * Default: true\n\nWhether to enable devtools, it is enabled by default, and all parameters of\nredux-devtools-extension are supported at the same time. If you want to disable\nit, set it to false.","frontmatter":{"sidebar_label":"state"}},{"id":134,"title":"security.checkSyntax","routePath":"/en/configure/app/security/check-syntax","lang":"en","toc":[{"id":"example","text":"Example","depth":2},{"id":"error-log","text":"Error Log","depth":3},{"id":"solution","text":"Solution","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsecurity.checkSyntax.\n\n * Type:\n\ntype CheckSyntax =\n  | boolean\n  | {\n      targets: string[];\n    };\n\n\n * Default: false\n * Bundler: only support webpack\n\nAnalyzes the build output files for the presence of high-level syntax that is\nincompatible with the current browserslist. If present, the details will be\nprinted in the terminal.\n\n\nExample\n\nexport default {\n  security: {\n    checkSyntax: true,\n  },\n};\n\n\nIf security.checkSyntax is specified as true, targets will be recognized as the\nbrowserslist set by the project. For details, please refer to Browserslist\n\nWhen enabled, it will be detected in the production environment, and when an\nincompatible advanced syntax is detected, it will not only print the error logs\non the terminal but also exit the build process.\n\n\nError Log\n\nThe format of the error log is as follows, including the source file, output\nlocation, error reason and source code:\n\nerror [Syntax Checker] Find some syntax errors after production build:\n\n   ERROR#1:\n   source - /node_modules/foo/index.js:1:0\n   output - /Project/dist/static/js/main.3f7a4d7e.js:2:39400\n   reason - The keyword 'const' is reserved (2:39400)\n   code - const foo = 'bar';\n\n\n\nSolution\n\nIf a syntax error is detected, you can handle it in the following ways:\n\n * If you want to downgrade this syntax to ensure good code compatibility, you\n   can compile the corresponding module through the source.include config.\n * If you don't want to downgrade the syntax, you can adjust the project's\n   browserslist to match the syntax.","frontmatter":{"sidebar_label":"checkSyntax"}},{"id":135,"title":"security.sri","routePath":"/en/configure/app/security/sri","lang":"en","toc":[{"id":"introduce-sri","text":"Introduce SRI","depth":4},{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see security.sri.\n\n * Type:\n\ntype SRIOptions =\n  | {\n      hashFuncNames?: string[];\n      enabled?: 'auto' | boolean;\n      hashLoading?: 'eager' | 'lazy';\n    }\n  | boolean;\n\n\n * Default: undefined\n * Bundler: only support webpack\n\nAdding an integrity attribute (integrity) to sub-resources introduced by HTML\nallows the browser to verify the integrity of the introduced resource, thus\npreventing tampering with the downloaded resource.\n\nEnabling this option will set the webpack output.crossOriginLoading\nconfiguration item to anonymous.\n\nIntroduce SRI\n\nSubresource Integrity (SRI) is a security feature that enables browsers to\nverify that resources they fetch (for example, from a CDN) are delivered without\nunexpected manipulation. It works by allowing you to provide a cryptographic\nhash that a fetched resource must match.\n\nFor script tags, the result is to refuse to execute the code; for CSS links, the\nresult is not to load the styles.\n\nFor more on subresource integrity, see Subresource Integrity - MDN.\n\n\nExample\n\nBy default, SRI is not turned on, and when it is, its default configuration is\nas follows:\n\n{\n  hashFuncNames: ['sha384'];\n  enabled: \"auto\",\n  hashLoading: \"eager\",\n}\n\n\nYou can customize the configuration items according to your own needs:\n\nexport default {\n  security: {\n    sri: {\n      hashFuncNames: ['sha-256'],\n      enabled: true,\n      hashLoading: 'lazy',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"sri"}},{"id":136,"title":"server.baseUrl","routePath":"/en/configure/app/server/base-url","lang":"en","toc":[],"domain":"","content":"\n\n * Type: string | string[]\n * Default: undefined\n\nUniformly set the server-level routing prefix (often used in the case of shared\ndomain names to distinguish traffic).\n\nexport default defineConfig({\n  server: {\n    // All generated routes are automatically prefixed with `/base`\n    // Path to the generated server-side route file: dist/route.json\n    baseUrl: '/base'\n\n    // Multiple baseUrl\n    baseUrl: ['/base-new', '/base-old']\n  }\n})\n\n\nAfter dev, you can see that the routed access will be prefixed accordingly:\n\nApp running at:\n\n  > Local:    http://localhost:8080/base/\n  > Network:  http://192.168.0.1:8080/base/\n","frontmatter":{"sidebar_label":"baseUrl"}},{"id":137,"title":"server.enableFrameworkExt","routePath":"/en/configure/app/server/enable-framework-ext","lang":"en","toc":[{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\n * Type: boolean\n * Default: false\n\nBy default, with 【Custom Web Server](/docs/guides/advanced-features/web-server)\nenable, Middleware uses the syntax of the Modern.js itself.\n\nEnable server.enableFrameworkExt to use the syntax of framework extensions.\n\nexport default defineConfig({\n  server: {\n    enableFrameworkExt: true,\n  },\n});\n\n\n\nExample\n\nDefault usage:\n\n\n\nexport const middleware: Middleware = (ctx, next) => {\n  console.log(ctx.request.url);\n  next();\n};\n\n\nWhen enabled, Middleware types will be exported from other namespaces and can\nthe syntax of framework extensions:\n\n\n\nexport const middleware: SomeType = (...args) => {\n  console.log(args[0].url);\n  next();\n};\n\n\nNOTE\n\nThe above code is pseudo-code, and the specific usage needs to refer to the\ncorresponding framework extension.","frontmatter":{"sidebar_label":"enableFrameworkExt"}},{"id":138,"title":"server.port","routePath":"/en/configure/app/server/port","lang":"en","toc":[{"id":"difference-with-devport","text":"Difference with dev.port","depth":3}],"domain":"","content":"\n\n * Type: number\n * Default: 8080\n\nWhen Modern.js executes dev, start and serve commands, it will start with 8080\nas the default port, and will automatically increment the port number when the\nport is occupied. You can change the port number of Server through this config:\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n  },\n});\n\n\n\nDifference with dev.port\n\nIn most cases, we recommend using server.port instead of dev.port to set the\nport number, the differences between them are as follows:\n\n * dev.port only takes effect in the development, and server.port takes effect\n   in both development and production.\n * In the development, dev.port takes precedence over server.port.\n\nWhen you set dev.port and server.port at the same time, dev.port will take\neffect in the development, and server.port will take effect in the production.\nFor example, in the following example, the port in the development is 3001, and\nthe port in the production is 3002.\n\nexport default defineConfig({\n  dev: {\n    port: 3001,\n  },\n  server: {\n    port: 3002,\n  },\n});\n","frontmatter":{"sidebar_label":"port"}},{"id":139,"title":"server.publicRoutes","routePath":"/en/configure/app/server/public-routes","lang":"en","toc":[],"domain":"","content":"\n\n * Type: Object\n * Default: Automatic generation of server-level routing rules based on file\n   conventions: One routing rule is generated per file of the application.\n\nThis configuration option only applies to server-level routing, and you can\ncustomize the access route of resources in config/public/.\n\nThe key of the object is the relative file path of the current application (not\nused ./）, value can be string.\n\nexport default defineConfig({\n  server: {\n    publicRoutes: {\n      // Set up a long route\n      'index.json': '/user-config/card-info/extra/help.json',\n\n      // Set up a route without a suffix\n      'robot.txt': '/app/authentication',\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"publicRoutes"}},{"id":140,"title":"server.routes","routePath":"/en/configure/app/server/routes","lang":"en","toc":[{"id":"custom-access-routing","text":"Custom access routing","depth":2},{"id":"custom-response-header","text":"Custom response header","depth":2}],"domain":"","content":"\n\n * Type: Object\n * Default: Automatic generation of server-level routing rules based on file\n   conventions: One routing rule is generated per file of the application,and\n   the default route is the same as the entry name.\n\nThis configuration option only applies to server-level routing, and can\ncustomize the service access configuration of the application entry.\n\n\nCustom access routing\n\nThe key of the object is the entry name of the current application, and the\nvalue can be string | Array<string>.\n\nWhen the value type is string, the current value represents the name of the\nroute to access the entry.\n\nexport default defineConfig({\n  server: {\n    routes: {\n      // The default route is /entryName1, /p/test1 after customization\n      entryName1: '/p/test1'\n      // Support dynamic server-level routing configuration\n      entryName2: '/detail/:id'\n    }\n  }\n});\n\n\nMultiple access routes can also be set for entries using the Array<string>:\n\nexport default defineConfig({\n  server: {\n    routes: {\n      'page-a': [`/a`, '/b'],\n    },\n  },\n});\n\n\nAt this point, the 'page-a entry can be accessed through both /a and /b routes.\n\nAfter executing the dev command, you can see in dist/route.json that there are\ntwo routing records in the entry page-a:\n\n{\n  \"routes\": [\n    {\n      \"urlPath\": \"/a\",\n      \"entryName\": \"page-a\",\n      \"entryPath\": \"html/page-a/index.html\",\n      \"isSPA\": true,\n      \"isSSR\": false\n    },\n    {\n      \"urlPath\": \"/b\",\n      \"entryName\": \"page-a\",\n      \"entryPath\": \"html/page-a/index.html\",\n      \"isSPA\": true,\n      \"isSSR\": false\n    }\n  ]\n}\n\n\n\nCustom response header\n\nThe response header can be set by configuring the resHeaders of the entry:\n\nexport default defineConfig({\n  server: {\n    routes: {\n      'page-a': {\n        route: ['/a', '/b'],\n        resHeaders: {\n          'x-modern-test': '1',\n        },\n      },\n    },\n  },\n});\n\n\nNOTE\n\nThis configuration takes effect in both the production environment and the\ndevelopment environment, and can set different response headers according to the\nNODE_ENV. But if you only need to set response headers in the development\nenvironment, tools.devServer.headers is recommended.","frontmatter":{"sidebar_label":"routes"}},{"id":141,"title":"server.ssrByEntries","routePath":"/en/configure/app/server/ssr-by-entries","lang":"en","toc":[],"domain":"","content":"\n\n * Type: Object\n * Default: undefined\n\nSet the ssr option according to the entry. The attributes in the option are the\nsame as ssr. The specified value will be replaced and merged with the content of\nthe ssr attribute. For example:\n\nINFO\n\nThe \"entry name\" defaults to the directory name. In a few cases, when the entry\nis customized by source.entries, the entry name source.entries the key of the\nobject.\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n    ssrByEntries: {\n      // page-a does not enable ssr\n      'page-a': false,\n    },\n  },\n});\n\n\nAs configured above, the project has ssr enabled as a whole, but the ssr\nrendering capability is turned off for the entry page-a.","frontmatter":{"sidebar_label":"ssrByEntries"}},{"id":142,"title":"server.ssr","routePath":"/en/configure/app/server/ssr","lang":"en","toc":[],"domain":"","content":"\n\n * Type: boolean\n * Default: false\n\nEnalbe SSR configuration.\n\nWhen the value type is boolean, it indicates whether to enable SSR deployment\nmode, and false is not enabled by default.\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n  },\n});\n","frontmatter":{"sidebar_label":"ssr"}},{"id":143,"title":"source.alias","routePath":"/en/configure/app/source/alias","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":4},{"id":"function-type","text":"Function Type","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see source.alias.\n\n * Type: Record<string, string | string[]> | Function\n * Default: undefined\n\nCreate aliases to import or require certain modules, same as the resolve.alias\nconfig of webpack.\n\nTIP\n\nFor TypeScript projects, you only need to configure compilerOptions.paths in\ntsconfig.json, Builder will automatically recognize the aliases in\ntsconfig.json, so the aliasconfig is unnecessary.\n\nObject Type\n\nThe alias can be an Object, and the relative path will be automatically\nconverted to absolute path.\n\nexport default {\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n};\n\n\nWith above configuration, if @common/Foo.tsx is import in the code, it will be\nmapped to the <root>/src/common/Foo.tsx path.\n\nFunction Type\n\nThe alias can be a function, it will accept the previous alias object, and you\ncan modify it.\n\nexport default {\n  source: {\n    alias: alias => {\n      alias['@common'] = './src/common';\n    },\n  },\n};\n\n\nYou can also return a new object as the final result in the function, which will\nreplace the previous alias object.\n\nexport default {\n  source: {\n    alias: alias => {\n      return {\n        '@common': './src/common',\n      };\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"alias"}},{"id":144,"title":"source.compileJsDataURI","routePath":"/en/configure/app/source/compile-js-data-uri","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.compileJsDataURI.\n\n * Type: boolean\n * Default: true\n\nWhether to compile JavaScript code imported via Data URI.\n\nSuch as:\n\n\n\nimport 'data:text/javascript;charset=utf-8;base64,Y29uc29sZS5sb2coJ2lubGluZSAxJyk7';\n\n\n\nExample\n\nAdd the following config to disable:\n\nexport default {\n  source: {\n    compileJsDataURI: false,\n  },\n};\n","frontmatter":{"sidebar_label":"compileJsDataURI"}},{"id":145,"title":"source.configDir","routePath":"/en/configure/app/source/config-dir","lang":"en","toc":[],"domain":"","content":"\n\n * Type: string\n * Default: ./config\n\nModern.js supports placing some files in the ./config folder to customize HTML\ntemplates, icons, static resources, etc. For details, please refer to File\nConvention.\n\nThis option allows you to customize the directory of configuration files.\n\nFor example, adjust the resource file directory to the resources directory:\n\n\n\nexport default defineConfig({\n  source: {\n    configDir: './resources',\n  },\n});\n","frontmatter":{"title":"source.configDir","sidebar_label":"configDir"}},{"id":146,"title":"source.define","routePath":"/en/configure/app/source/define","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see source.define.\n\n * Type: Record<string, unknown>\n * Default: {}\n\nReplaces variables in your code with other values or expressions at compile\ntime. This can be useful for allowing different behavior between development\nbuilds and production builds.\n\nEach key passed into options is an identifier or multiple identifiers joined\nwith ..\n\n * If the value is a string it will be used as a code fragment.\n * If the value isn't a string, it will be stringified (including functions).\n * If the value is an object all keys are defined the same way.\n * If you prefix typeof to the key, it's only defined for typeof calls.\n\nFor more information please visit https://webpack.js.org/plugins/define-plugin/.\n\n\nExample\n\nexport default {\n  source: {\n    define: {\n      PRODUCTION: JSON.stringify(true),\n      VERSION: JSON.stringify('5fa3b9'),\n      BROWSER_SUPPORTS_HTML5: true,\n      TWO: '1 + 1',\n      'typeof window': JSON.stringify('object'),\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n      'import.meta': { test: undefined },\n    },\n  },\n};\n\n\nExpressions will be replaced with the corresponding code fragments:\n\nconst foo = TWO;\n\n// ⬇️ Turn into being...\nconst foo = 1 + 1;\n","frontmatter":{"sidebar_label":"define"}},{"id":147,"title":"source.designSystem","routePath":"/en/configure/app/source/design-system","lang":"en","toc":[{"id":"structure","text":"Structure","depth":3},{"id":"screens","text":"Screens","depth":4},{"id":"colors","text":"Colors","depth":4},{"id":"spacing","text":"Spacing","depth":4},{"id":"core-plugins","text":"Core plugins","depth":4},{"id":"custom-default-configuration","text":"Custom default configuration","depth":3},{"id":"override-default-configuration","text":"Override default configuration","depth":4},{"id":"extension-default-configuration","text":"Extension default configuration","depth":4},{"id":"reference-other-values","text":"Reference other values","depth":4},{"id":"disable-the-entire-core-plugin","text":"Disable the entire core plugin","depth":4},{"id":"add-your-own-key","text":"Add your own key","depth":4},{"id":"configure-reference","text":"Configure reference","depth":3},{"id":"additional-configuration","text":"Additional configuration","depth":3},{"id":"sourcedesignsystemsupportstyledcomponents","text":"source.designSystem.supportStyledComponents","depth":4}],"domain":"","content":"\n\n * Type: Object\n * Default: See configuration details below.\n\nCaution\n\nYou need to enable the Tailwind CSS feature through pnpm run new first.\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n  colors: {\n    transparent: 'transparent',\n    current: 'currentColor',\n\n    black: '#000',\n    white: '#fff',\n\n    gray: {\n      100: '#f7fafc',\n      200: '#edf2f7',\n      300: '#e2e8f0',\n      400: '#cbd5e0',\n      500: '#a0aec0',\n      600: '#718096',\n      700: '#4a5568',\n      800: '#2d3748',\n      900: '#1a202c',\n    },\n    red: {\n      100: '#fff5f5',\n      200: '#fed7d7',\n      300: '#feb2b2',\n      400: '#fc8181',\n      500: '#f56565',\n      600: '#e53e3e',\n      700: '#c53030',\n      800: '#9b2c2c',\n      900: '#742a2a',\n    },\n    orange: {\n      100: '#fffaf0',\n      200: '#feebc8',\n      300: '#fbd38d',\n      400: '#f6ad55',\n      500: '#ed8936',\n      600: '#dd6b20',\n      700: '#c05621',\n      800: '#9c4221',\n      900: '#7b341e',\n    },\n    yellow: {\n      100: '#fffff0',\n      200: '#fefcbf',\n      300: '#faf089',\n      400: '#f6e05e',\n      500: '#ecc94b',\n      600: '#d69e2e',\n      700: '#b7791f',\n      800: '#975a16',\n      900: '#744210',\n    },\n    green: {\n      100: '#f0fff4',\n      200: '#c6f6d5',\n      300: '#9ae6b4',\n      400: '#68d391',\n      500: '#48bb78',\n      600: '#38a169',\n      700: '#2f855a',\n      800: '#276749',\n      900: '#22543d',\n    },\n    teal: {\n      100: '#e6fffa',\n      200: '#b2f5ea',\n      300: '#81e6d9',\n      400: '#4fd1c5',\n      500: '#38b2ac',\n      600: '#319795',\n      700: '#2c7a7b',\n      800: '#285e61',\n      900: '#234e52',\n    },\n    blue: {\n      100: '#ebf8ff',\n      200: '#bee3f8',\n      300: '#90cdf4',\n      400: '#63b3ed',\n      500: '#4299e1',\n      600: '#3182ce',\n      700: '#2b6cb0',\n      800: '#2c5282',\n      900: '#2a4365',\n    },\n    indigo: {\n      100: '#ebf4ff',\n      200: '#c3dafe',\n      300: '#a3bffa',\n      400: '#7f9cf5',\n      500: '#667eea',\n      600: '#5a67d8',\n      700: '#4c51bf',\n      800: '#434190',\n      900: '#3c366b',\n    },\n    purple: {\n      100: '#faf5ff',\n      200: '#e9d8fd',\n      300: '#d6bcfa',\n      400: '#b794f4',\n      500: '#9f7aea',\n      600: '#805ad5',\n      700: '#6b46c1',\n      800: '#553c9a',\n      900: '#44337a',\n    },\n    pink: {\n      100: '#fff5f7',\n      200: '#fed7e2',\n      300: '#fbb6ce',\n      400: '#f687b3',\n      500: '#ed64a6',\n      600: '#d53f8c',\n      700: '#b83280',\n      800: '#97266d',\n      900: '#702459',\n    },\n  },\n  spacing: {\n    px: '1px',\n    0: '0',\n    1: '0.25rem',\n    2: '0.5rem',\n    3: '0.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    8: '2rem',\n    10: '2.5rem',\n    12: '3rem',\n    16: '4rem',\n    20: '5rem',\n    24: '6rem',\n    32: '8rem',\n    40: '10rem',\n    48: '12rem',\n    56: '14rem',\n    64: '16rem',\n  },\n  backgroundColor: theme => theme('colors'),\n  backgroundOpacity: theme => theme('opacity'),\n  backgroundPosition: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  backgroundSize: {\n    auto: 'auto',\n    cover: 'cover',\n    contain: 'contain',\n  },\n  borderColor: theme => ({\n    ...theme('colors'),\n    default: theme('colors.gray.300', 'currentColor'),\n  }),\n  borderOpacity: theme => theme('opacity'),\n  borderRadius: {\n    none: '0',\n    sm: '0.125rem',\n    default: '0.25rem',\n    md: '0.375rem',\n    lg: '0.5rem',\n    full: '9999px',\n  },\n  borderWidth: {\n    default: '1px',\n    0: '0',\n    2: '2px',\n    4: '4px',\n    8: '8px',\n  },\n  boxShadow: {\n    xs: '0 0 0 1px rgba(0, 0, 0, 0.05)',\n    sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',\n    default: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',\n    md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',\n    lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',\n    xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',\n    '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',\n    inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',\n    outline: '0 0 0 3px rgba(66, 153, 225, 0.5)',\n    none: 'none',\n  },\n  container: {},\n  cursor: {\n    auto: 'auto',\n    default: 'default',\n    pointer: 'pointer',\n    wait: 'wait',\n    text: 'text',\n    move: 'move',\n    'not-allowed': 'not-allowed',\n  },\n  divideColor: theme => theme('borderColor'),\n  divideOpacity: theme => theme('borderOpacity'),\n  divideWidth: theme => theme('borderWidth'),\n  fill: {\n    current: 'currentColor',\n  },\n  flex: {\n    1: '1 1 0%',\n    auto: '1 1 auto',\n    initial: '0 1 auto',\n    none: 'none',\n  },\n  flexGrow: {\n    0: '0',\n    default: '1',\n  },\n  flexShrink: {\n    0: '0',\n    default: '1',\n  },\n  fontFamily: {\n    sans: [\n      'system-ui',\n      '-apple-system',\n      'BlinkMacSystemFont',\n      '\"Segoe UI\"',\n      'Roboto',\n      '\"Helvetica Neue\"',\n      'Arial',\n      '\"Noto Sans\"',\n      'sans-serif',\n      '\"Apple Color Emoji\"',\n      '\"Segoe UI Emoji\"',\n      '\"Segoe UI Symbol\"',\n      '\"Noto Color Emoji\"',\n    ],\n    serif: ['Georgia', 'Cambria', '\"Times New Roman\"', 'Times', 'serif'],\n    mono: [\n      'Menlo',\n      'Monaco',\n      'Consolas',\n      '\"Liberation Mono\"',\n      '\"Courier New\"',\n      'monospace',\n    ],\n  },\n  fontSize: {\n    xs: '0.75rem',\n    sm: '0.875rem',\n    base: '1rem',\n    lg: '1.125rem',\n    xl: '1.25rem',\n    '2xl': '1.5rem',\n    '3xl': '1.875rem',\n    '4xl': '2.25rem',\n    '5xl': '3rem',\n    '6xl': '4rem',\n  },\n  fontWeight: {\n    hairline: '100',\n    thin: '200',\n    light: '300',\n    normal: '400',\n    medium: '500',\n    semibold: '600',\n    bold: '700',\n    extrabold: '800',\n    black: '900',\n  },\n  height: theme => ({\n    auto: 'auto',\n    ...theme('spacing'),\n    full: '100%',\n    screen: '100vh',\n  }),\n  inset: {\n    0: '0',\n    auto: 'auto',\n  },\n  letterSpacing: {\n    tighter: '-0.05em',\n    tight: '-0.025em',\n    normal: '0',\n    wide: '0.025em',\n    wider: '0.05em',\n    widest: '0.1em',\n  },\n  lineHeight: {\n    none: '1',\n    tight: '1.25',\n    snug: '1.375',\n    normal: '1.5',\n    relaxed: '1.625',\n    loose: '2',\n    3: '.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    7: '1.75rem',\n    8: '2rem',\n    9: '2.25rem',\n    10: '2.5rem',\n  },\n  listStyleType: {\n    none: 'none',\n    disc: 'disc',\n    decimal: 'decimal',\n  },\n  margin: (theme, { negative }) => ({\n    auto: 'auto',\n    ...theme('spacing'),\n    ...negative(theme('spacing')),\n  }),\n  maxHeight: {\n    full: '100%',\n    screen: '100vh',\n  },\n  maxWidth: (theme, { breakpoints }) => ({\n    none: 'none',\n    xs: '20rem',\n    sm: '24rem',\n    md: '28rem',\n    lg: '32rem',\n    xl: '36rem',\n    '2xl': '42rem',\n    '3xl': '48rem',\n    '4xl': '56rem',\n    '5xl': '64rem',\n    '6xl': '72rem',\n    full: '100%',\n    ...breakpoints(theme('screens')),\n  }),\n  minHeight: {\n    0: '0',\n    full: '100%',\n    screen: '100vh',\n  },\n  minWidth: {\n    0: '0',\n    full: '100%',\n  },\n  objectPosition: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  opacity: {\n    0: '0',\n    25: '0.25',\n    50: '0.5',\n    75: '0.75',\n    100: '1',\n  },\n  order: {\n    first: '-9999',\n    last: '9999',\n    none: '0',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n    8: '8',\n    9: '9',\n    10: '10',\n    11: '11',\n    12: '12',\n  },\n  padding: theme => theme('spacing'),\n  placeholderColor: theme => theme('colors'),\n  placeholderOpacity: theme => theme('opacity'),\n  space: (theme, { negative }) => ({\n    ...theme('spacing'),\n    ...negative(theme('spacing')),\n  }),\n  stroke: {\n    current: 'currentColor',\n  },\n  strokeWidth: {\n    0: '0',\n    1: '1',\n    2: '2',\n  },\n  textColor: theme => theme('colors'),\n  textOpacity: theme => theme('opacity'),\n  width: theme => ({\n    auto: 'auto',\n    ...theme('spacing'),\n    '1/2': '50%',\n    '1/3': '33.333333%',\n    '2/3': '66.666667%',\n    '1/4': '25%',\n    '2/4': '50%',\n    '3/4': '75%',\n    '1/5': '20%',\n    '2/5': '40%',\n    '3/5': '60%',\n    '4/5': '80%',\n    '1/6': '16.666667%',\n    '2/6': '33.333333%',\n    '3/6': '50%',\n    '4/6': '66.666667%',\n    '5/6': '83.333333%',\n    '1/12': '8.333333%',\n    '2/12': '16.666667%',\n    '3/12': '25%',\n    '4/12': '33.333333%',\n    '5/12': '41.666667%',\n    '6/12': '50%',\n    '7/12': '58.333333%',\n    '8/12': '66.666667%',\n    '9/12': '75%',\n    '10/12': '83.333333%',\n    '11/12': '91.666667%',\n    full: '100%',\n    screen: '100vw',\n  }),\n  zIndex: {\n    auto: 'auto',\n    0: '0',\n    10: '10',\n    20: '20',\n    30: '30',\n    40: '40',\n    50: '50',\n  },\n  gap: theme => theme('spacing'),\n  gridTemplateColumns: {\n    none: 'none',\n    1: 'repeat(1, minmax(0, 1fr))',\n    2: 'repeat(2, minmax(0, 1fr))',\n    3: 'repeat(3, minmax(0, 1fr))',\n    4: 'repeat(4, minmax(0, 1fr))',\n    5: 'repeat(5, minmax(0, 1fr))',\n    6: 'repeat(6, minmax(0, 1fr))',\n    7: 'repeat(7, minmax(0, 1fr))',\n    8: 'repeat(8, minmax(0, 1fr))',\n    9: 'repeat(9, minmax(0, 1fr))',\n    10: 'repeat(10, minmax(0, 1fr))',\n    11: 'repeat(11, minmax(0, 1fr))',\n    12: 'repeat(12, minmax(0, 1fr))',\n  },\n  gridColumn: {\n    auto: 'auto',\n    'span-1': 'span 1 / span 1',\n    'span-2': 'span 2 / span 2',\n    'span-3': 'span 3 / span 3',\n    'span-4': 'span 4 / span 4',\n    'span-5': 'span 5 / span 5',\n    'span-6': 'span 6 / span 6',\n    'span-7': 'span 7 / span 7',\n    'span-8': 'span 8 / span 8',\n    'span-9': 'span 9 / span 9',\n    'span-10': 'span 10 / span 10',\n    'span-11': 'span 11 / span 11',\n    'span-12': 'span 12 / span 12',\n  },\n  gridColumnStart: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n    8: '8',\n    9: '9',\n    10: '10',\n    11: '11',\n    12: '12',\n    13: '13',\n  },\n  gridColumnEnd: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n    8: '8',\n    9: '9',\n    10: '10',\n    11: '11',\n    12: '12',\n    13: '13',\n  },\n  gridTemplateRows: {\n    none: 'none',\n    1: 'repeat(1, minmax(0, 1fr))',\n    2: 'repeat(2, minmax(0, 1fr))',\n    3: 'repeat(3, minmax(0, 1fr))',\n    4: 'repeat(4, minmax(0, 1fr))',\n    5: 'repeat(5, minmax(0, 1fr))',\n    6: 'repeat(6, minmax(0, 1fr))',\n  },\n  gridRow: {\n    auto: 'auto',\n    'span-1': 'span 1 / span 1',\n    'span-2': 'span 2 / span 2',\n    'span-3': 'span 3 / span 3',\n    'span-4': 'span 4 / span 4',\n    'span-5': 'span 5 / span 5',\n    'span-6': 'span 6 / span 6',\n  },\n  gridRowStart: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n  },\n  gridRowEnd: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n  },\n  transformOrigin: {\n    center: 'center',\n    top: 'top',\n    'top-right': 'top right',\n    right: 'right',\n    'bottom-right': 'bottom right',\n    bottom: 'bottom',\n    'bottom-left': 'bottom left',\n    left: 'left',\n    'top-left': 'top left',\n  },\n  scale: {\n    0: '0',\n    50: '.5',\n    75: '.75',\n    90: '.9',\n    95: '.95',\n    100: '1',\n    105: '1.05',\n    110: '1.1',\n    125: '1.25',\n    150: '1.5',\n  },\n  rotate: {\n    '-180': '-180deg',\n    '-90': '-90deg',\n    '-45': '-45deg',\n    0: '0',\n    45: '45deg',\n    90: '90deg',\n    180: '180deg',\n  },\n  translate: (theme, { negative }) => ({\n    ...theme('spacing'),\n    ...negative(theme('spacing')),\n    '-full': '-100%',\n    '-1/2': '-50%',\n    '1/2': '50%',\n    full: '100%',\n  }),\n  skew: {\n    '-12': '-12deg',\n    '-6': '-6deg',\n    '-3': '-3deg',\n    0: '0',\n    3: '3deg',\n    6: '6deg',\n    12: '12deg',\n  },\n  transitionProperty: {\n    none: 'none',\n    all: 'all',\n    default:\n      'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform',\n    colors: 'background-color, border-color, color, fill, stroke',\n    opacity: 'opacity',\n    shadow: 'box-shadow',\n    transform: 'transform',\n  },\n  transitionTimingFunction: {\n    linear: 'linear',\n    in: 'cubic-bezier(0.4, 0, 1, 1)',\n    out: 'cubic-bezier(0, 0, 0.2, 1)',\n    'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',\n  },\n  transitionDuration: {\n    75: '75ms',\n    100: '100ms',\n    150: '150ms',\n    200: '200ms',\n    300: '300ms',\n    500: '500ms',\n    700: '700ms',\n    1000: '1000ms',\n  },\n  transitionDelay: {\n    75: '75ms',\n    100: '100ms',\n    150: '150ms',\n    200: '200ms',\n    300: '300ms',\n    500: '500ms',\n    700: '700ms',\n    1000: '1000ms',\n  },\n};\n\n\nTIP\n\nMore about：TailwindCSS configuration.\n\ndesignSystem is used to define the project's color palette, typographic scale\n(Typographic Scales or Type Scale), font list, breakpoints, border rounded\nvalues, and more. Because Modern.js borrowed the design method of Tailwind\nTheme, and also integrates Tailwind CSS internally, the designSystem is used in\nthe same way as Tailwind CSS Theme.\n\n\nStructure\n\nThe designSystem object contains properties for screens, colors, and spacing, as\nwell as each customizable core plugin.\n\nScreens\n\nUse screens to customize response breakpoints in your project:\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n};\n\n\nWhere the property name in the screens object is the screen name (used as a\nprefix for adaptive utility variants generated by Tailwind CSS, such as\nmd:text-center), and the value is the min-width at which the breakpoint should\nbegin.\n\nDefault breakpoints are inspired by common device resolutions:\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    // => @media (min-width: 640px) { ... }\n\n    md: '768px',\n    // => @media (min-width: 768px) { ... }\n\n    lg: '1024px',\n    // => @media (min-width: 1024px) { ... }\n\n    xl: '1280px',\n    // => @media (min-width: 1280px) { ... }\n  },\n};\n\n\nYou can use any name you like as a breakpoint property in your project:\n\nconst designSystem = {\n  screens: {\n    tablet: '640px',\n    // => @media (min-width: 640px) { ... }\n\n    laptop: '1024px',\n    // => @media (min-width: 1024px) { ... }\n\n    desktop: '1280px',\n    // => @media (min-width: 1280px) { ... }\n  },\n};\n\n\nThese screen names are reflected in utilities, so text-center now looks like\nthis:\n\n.text-center {\n  text-align: center;\n}\n\n@media (min-width: 640px) {\n  .tablet\\:text-center {\n    text-align: center;\n  }\n}\n\n@media (min-width: 1024px) {\n  .laptop\\:text-center {\n    text-align: center;\n  }\n}\n\n@media (min-width: 1280px) {\n  .desktop\\:text-center {\n    text-align: center;\n  }\n}\n\n\nMax-width breakpoint\n\nIf you want to use a max-width breakpoint instead of a min-width, you can\nspecify the screen as an object with a max property:\n\nconst designSystem = {\n  screens: {\n    xl: { max: '1279px' },\n    // => @media (max-width: 1279px) { ... }\n\n    lg: { max: '1023px' },\n    // => @media (max-width: 1023px) { ... }\n\n    md: { max: '767px' },\n    // => @media (max-width: 767px) { ... }\n\n    sm: { max: '639px' },\n    // => @media (max-width: 639px) { ... }\n  },\n};\n\n\nIf necessary, to create breakpoints with min-width and max-width definitions,\nfor example:\n\nconst designSystem = {\n  screens: {\n    sm: { min: '640px', max: '767px' },\n    md: { min: '768px', max: '1023px' },\n    lg: { min: '1024px', max: '1279px' },\n    xl: { min: '1280px' },\n  },\n};\n\n\nMultiple ranges of breakpoints\n\nSometimes it is useful to apply a single breakpoint definition to multiple\nscopes.\n\nFor example, let's say you have a sidebar and want the breakpoint to be based on\nthe width of the content area rather than the entire viewport. You can simulate\nthis situation, using a smaller breakpoint style when the sidebar is visible and\nshrinks the content area:\n\nconst designSystem = {\n  screens: {\n    sm: '500px',\n    md: [\n      // Sidebar appears at 768px, so revert to `sm:` styles between 768px\n      // and 868px, after which the main content area is wide enough again to\n      // apply the `md:` styles.\n      { min: '668px', max: '767px' },\n      { min: '868px' },\n    ],\n    lg: '1100px',\n    xl: '1400px',\n  },\n};\n\n\nCustom media queries\n\nIf you need to provide a fully customized media query for the breakpoint, you\ncan use an object with a raw attribute:\n\nconst designSystem = {\n  extend: {\n    screens: {\n      portrait: { raw: '(orientation: portrait)' },\n      // => @media (orientation: portrait) { ... }\n    },\n  },\n};\n\n\nPrint Style\n\nThe raw option can be especially useful if you need to apply a different style\nto the print.\n\nAll you need to do is add a print in designSystem.extend.screens:\n\nconst designSystem = {\n  extend: {\n    screens: {\n      print: { raw: 'print' },\n      // => @media print { ... }\n    },\n  },\n};\n\n\nYou can then use a class like print:text-black to specify styles that are only\napplied when someone tries to print a page:\n\n<div class=\"text-gray-700 print:text-black\">\n  {/* ...  */}\n</div>\n\n\nDark Mode\n\nThe raw option can be used to implement the \"dark mode\" screen:\n\nconst designSystem = {\n  extend: {\n    screens: {\n      dark: { raw: '(prefers-color-scheme: dark)' },\n      // => @media (prefers-color-scheme: dark) { ... }\n    },\n  },\n};\n\n\nYou can then style the element differently in dark mode using the dark: prefix:\n\n<div class=\"text-gray-700 dark:text-gray-200\">\n  {/* ...  */}\n</div>\n\n\nNote that since these screen variants are implemented in Tailwind CSS, ** you\ncannot use this method to combine breakpoints with dark modes **, for example\nmd:dark:text-gray-300 will not work.\n\nColors\n\nThe colors property allows you to customize the global palette of your project.\n\nconst designSystem = {\n  colors: {\n    transparent: 'transparent',\n    black: '#000',\n    white: '#fff',\n    gray: {\n      100: '#f7fafc',\n      // ...\n      900: '#1a202c',\n    },\n\n    // ...\n  },\n};\n\n\nBy default, these colors are inherited by the backgroundColor, textColor, and\nborderColor core plugins.\n\no learn more, see: Customizing Colors.\n\nSpacing\n\nUsing the space property, you can customize the global spacing and scaling of\nitems:\n\nconst designSystem = {\n  spacing: {\n    px: '1px',\n    0: '0',\n    1: '0.25rem',\n    2: '0.5rem',\n    3: '0.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    8: '2rem',\n    10: '2.5rem',\n    12: '3rem',\n    16: '4rem',\n    20: '5rem',\n    24: '6rem',\n    32: '8rem',\n    40: '10rem',\n    48: '12rem',\n    56: '14rem',\n    64: '16rem',\n  },\n};\n\n\nBy default, these values are inherited by the padding, margin, negativeMargin,\nwidth, and height core plugins.\n\nTo learn more, see: Customizing Spacing.\n\nCore plugins\n\nThe rest of the topic section is used to configure the values available for each\ncore plugin.\n\nFor example, the borderRadius property allows you to customize the utilities of\nthe rounded corners that will be generated:\n\nconst designSystem = {\n  borderRadius: {\n    none: '0',\n    sm: '.125rem',\n    default: '.25rem',\n    lg: '.5rem',\n    full: '9999px',\n  },\n};\n\n\n** The property name determines the suffix of the generated class, and the value\ndetermines the value of the actual CSS declaration. ** The example borderRadius\nconfiguration above will generate the following CSS class:\n\n.rounded-none {\n  border-radius: 0;\n}\n.rounded-sm {\n  border-radius: 0.125rem;\n}\n.rounded {\n  border-radius: 0.25rem;\n}\n.rounded-lg {\n  border-radius: 0.5rem;\n}\n.rounded-full {\n  border-radius: 9999px;\n}\n\n\nYou will notice that the rounded class is created without the suffix using the\ndefault property in the theme configuration. This is a common convention in\nTailwind CSS supported by many, though not all, core plugins.\n\nTo learn more about customizing a specific core plugin, visit the plugin's\ndocumentation.\n\n\nCustom default configuration\n\nOut of the box, your project will automatically inherit values from the default\ntheme configuration. If you want to customize the default theme, you have\nseveral different options depending on the target.\n\nOverride default configuration\n\nTo override the options in the default configuration, add the properties to\noverride in designSystem:\n\nconst designSystem = {\n  // Replaces all of the default `opacity` values\n  opacity: {\n    0: '0',\n    20: '0.2',\n    40: '0.4',\n    60: '0.6',\n    80: '0.8',\n    100: '1',\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\nThis completely replaces the default property configuration, so in the example\nabove, the default opacity utilities is not generated.\n\nAny properties you don't provide will be inherited from the default theme, so in\nthe example above, the default theme configuration for color, spacing, border\nrounded corners, background position, and more will be preserved.\n\nExtension default configuration\n\nIf you want to keep the default value for the theme option, but want to add a\nnew value, add the extended content in the designSystem.extend property.\n\nFor example, if you want to add an additional breakpoint but keep the existing\none, you can extend the screens property:\n\nconst designSystem = {\n  extend: {\n    // Adds a new breakpoint in addition to the default breakpoints\n    screens: {\n      '2xl': '1440px',\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\nYou can of course override some parts of the default theme and extend other\nparts of the default theme in the same configuration:\n\nconst designSystem = {\n  opacity: {\n    0: '0',\n    20: '0.2',\n    40: '0.4',\n    60: '0.6',\n    80: '0.8',\n    100: '1',\n  },\n  extend: {\n    screens: {\n      '2xl': '1440px',\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\nReference other values\n\nIf you need to reference another value in the configuration, you can do so by\nproviding a closure function instead of a static value. The function will\nreceive a theme() function as an argument, which you can use to look up other\nvalues in the configuration using dot notation.\n\nFor example, you can generate a fill utility for each color in the palette by\nreferencing theme('colors') on a fill configuration.\n\nconst designSystem = {\n  colors: {\n    // ...\n  },\n  fill: theme => theme('colors'),\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\nThe theme() function tries to find the value you're looking for from a fully\nmerged configuration object, so it can reference your own custom settings as\nwell as default theme values. It also works recursively, so as long as there's a\nstatic value at the end of the chain, it can parse the value you're looking for.\n\nReference default configuration\n\nIf you want to reference a value in the default configuration for any reason,\nyou can import it from tailwindcss/defaultTheme. A useful example is if you want\nto add one of the fonts provided by the default configuration:\n\nconst defaultTheme = require('tailwindcss/defaultTheme');\n\nconst designSystem = {\n  extend: {\n    fontFamily: {\n      sans: ['Lato', ...defaultTheme.fontFamily.sans],\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\nDisable the entire core plugin\n\nIf you don't want to generate any classes for a core plugin, it's better to set\nthe plugin to false in the corePlugins configuration instead of providing an\nempty object for this property in the configuration:\n\n// Don't assign an empty object in your theme configuration\n\nconst designSystem = {\n  opacity: {},\n};\n\n// Do disable the plugin in your corePlugins configuration\nconst designSyttem = {\n  corePlugins: {\n    opacity: false,\n  },\n};\n\n\nThe end result is the same, but since many core plugins don't expose any\nconfiguration, they can only be disabled using corePlugins anyway, and it's best\nto keep them consistent.\n\nAdd your own key\n\nIn many cases, it can be useful to add your own properties to the configuration\nobject.\n\nAn example of this is adding new properties for reuse between multiple core\nplugins. For example, you can extract a positions object that both the\nbackgroundPosition and objectPosition plugins can reference:\n\nconst designSystem = {\n  positions: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  backgroundPosition: theme => theme('positions'),\n  objectPosition: theme => theme('positions'),\n};\n\n\nAnother example is adding new attributes to a custom plugin for reference. For\nexample, if you wrote a gradual change plugin for a project, you can add a\ngradual change attribute to the subject object referenced by the plugin:\n\nconst designSystem = {\n  gradients: theme => ({\n    'blue-green': [theme('colors.blue.500'), theme('colors.green.500')],\n    'purple-blue': [theme('colors.purple.500'), theme('colors.blue.500')],\n    // ...\n  }),\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n  tools: {\n    tailwind: {\n      plugins: [require('./plugins/gradients')],\n    },\n  },\n});\n\n\n\nConfigure reference\n\nWith the exception of screens, colors, and spacing, all properties in the\nconfiguration object map to the core plugin of Tailwind CSS. Since many plugins\nare responsible for accepting only CSS properties for static value sets (eg\nfloat), note that not every plugin has corresponding properties in the theme\nobject.\n\nAll of these properties can also be used in the designSystem.extend property to\nextend the default theme.\n\nSee this link for what all properties do.\n\n\nAdditional configuration\n\nIn addition to the same configuration as the Tailwind CSS Theme, there are\nadditional configurations available Modern.js.\n\nsource.designSystem.supportStyledComponents\n\nThe configuration type is boolean and defaults to false.\n\nWhen the configuration value is true, the runtime provides the styled-components\nThemeProvider component outside the application and will inject it through the\nTheme Token object generated by designSystem.","frontmatter":{"title":"source.designSystem","sidebar_label":"designSystem"}},{"id":148,"title":"source.disableDefaultEntries","routePath":"/en/configure/app/source/disable-default-entries","lang":"en","toc":[],"domain":"","content":"\n\n * Type: boolean\n * Default: false\n\nTurn off the function of automatically identifying the application build entry\naccording to the project directory structure. By default, the Modern.js will get\nthe corresponding build entry according to the project directory structure.\n\nINFO\n\nBy default, Modern.js will get the corresponding entry information according to\nthe project directory structure. For details, please refer to Entry. After\nconfiguring the shutdown mechanism, you need to configure the custom entry with\nsource.entries.\n\nWarning\n\nOrganizing your code according to the catalog specification provided by the\nModern.js is recommended to make better use of the framework's capabilities and\navoid some redundant configuration.\n\nSet the following to turn off the default behavior:\n\nexport default defineConfig({\n  source: {\n    disableDefaultEntries: true,\n  },\n});\n","frontmatter":{"title":"source.disableDefaultEntries","sidebar_label":"disableDefaultEntries"}},{"id":149,"title":"source.disableEntryDirs","routePath":"/en/configure/app/source/disable-entry-dirs","lang":"en","toc":[],"domain":"","content":"\n\n * Type: string[]\n * Default: []\n\nBy default, application entries are identified based on the'src 'directory, you\ncan disable some directories from being identified as application entries with\nthis option.\n\nFor example, when the configuration and directory structure is as follows：\n\nexport default defineConfig({\n  source: {\n    disableEntryDirs: './src/one',\n  },\n});\n\n\n└── src/\n    ├── one/\n    |    └── App.tsx\n    ├── two/\n    |    └── routes/\n    └── env.d.ts\n\n\nWhen this option is not set, Modern.js will generate two entries based on the\nproject directory:\n\n * one\n * two\n\nWhen this option is set, src/one will not be recognized as an entry directory.\n\nA common usage is to configure the src/common, src/components directories to\nthis option to avoid these directories being recognized as application entries.","frontmatter":{"title":"source.disableEntryDirs","sidebar_label":"disableEntryDirs"}},{"id":150,"title":"source.enableAsyncEntry","routePath":"/en/configure/app/source/enable-async-entry","lang":"en","toc":[{"id":"background-knowledge","text":"Background knowledge","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\n * Type: boolean\n * Default: false\n\nThis option is used in the webpack Module Federation scenario.\n\nWhen this option is turned on, the Modern.js wraps the automatically generated\nasynchronous boundary via Dynamic Import, allowing the page code to consume\nremote modules generated by the module federation.\n\n\nBackground knowledge\n\nIf you don't know webpack module federation, please read the official Module\nFederation documentation first.\n\n\nExample\n\nFirst, turn this option on in the configuration file:\n\nexport default defineConfig({\n  source: {\n    enableAsyncEntry: true,\n  },\n});\n\n\nThen execute the dev or build command, and you can see Modern.js automatically\ngenerated file becomes the following structure:\n\nnode_modules\n  └─ .modern-js\n     └─ main\n        ├─ bootstrap.js  #  real entry code\n        ├─ index.js      # asynchronous entry file\n        └─ index.html\n\n\nThe index.js reads as follows:\n\nimport('./bootstrap.js');\n\n\nAt this point, you can consume any remote modules in the current page.\n\nINFO\n\nModern.js the ModuleFederationPlugin of webpack is not encapsulated, please\nconfigure the ModuleFederationPlugin yourself through tools.webpack Chain.","frontmatter":{"title":"source.enableAsyncEntry","sidebar_label":"enableAsyncEntry"}},{"id":151,"title":"source.entriesDir","routePath":"/en/configure/app/source/entries-dir","lang":"en","toc":[],"domain":"","content":"\n\n * Type: string\n * Default: ./src\n\nBy default, the application entry will be identified according to the src\ndirectory. You can customize the identification directory of the application\nentry through this option.\n\nFor example, when the configuration and directory structure are as follows:\n\nexport default defineConfig({\n  source: {\n    entriesDir: './src/pages',\n  },\n});\n\n\n.\n└── src\n    └── pages\n        ├── a\n        │   └── App.jsx\n        └── b\n            └── App.jsx\n\n\nModern.js will generate the build entry a and entry b according to the\n./src/pages directory structure, the result is as follows:\n\n {\n   a: './src/pages/a/App.jsx',\n   b: './src/pages/b/App.jsx'\n }\n","frontmatter":{"title":"source.entriesDir","sidebar_label":"entriesDir"}},{"id":152,"title":"source.entries","routePath":"/en/configure/app/source/entries","lang":"en","toc":[{"id":"string","text":"String","depth":2},{"id":"object","text":"Object","depth":2},{"id":"combine-entry","text":"Combine Entry","depth":2}],"domain":"","content":"\n\n * Type: Object = { [ entryName: string ]: string | Object }\n * Default: Default entry object dynamically settled according to the current\n   project directory structure.\n\nFor most scenarios, Modern.js automatically generated entries according to the\ndirectory structure can meet most business requirements. For details, please\nrefer to Entries.\n\nIf you need to customize the build entry, you can specify it with this option.\n\n\nString\n\nWhen the value is of type string, the file path of the entry:\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      // Specify a new entry named entry_customize\n      entry_customize: './src/home/test/index.js',\n    },\n  },\n});\n\n\nBy default, the configured entry is equivalent to App.[jt]sx, that is, the\nspecified entry file only needs to export the root component of the application.\n\nFor example the following directory structure:\n\n.\n├── src\n│   └── entry\n│       ├── chat.tsx\n│       └── home.tsx\n└── package.json\n\n\nWith the content of the above default entry mechanism, Modern.js when analyzing\nthe above directory, will not get any default entry.\n\nIn cases where you do not want to change the directory structure (such as\nproject migration), you can customize the entry through source.entries:\n\nexport default defineConfig({\n  source: {\n    entries: {\n      home: './src/entry/home.tsx',\n      chat: './src/entry/chat.tsx',\n    },\n  },\n});\n\n\n\nObject\n\nWhen the value is Object, the following properties can be configured:\n\n * entry：string，entry file path.\n * disableMount：boolean = false，turn off Modern.js generate entry code.\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      entry_customize: {\n        // entry file path\n        entry: './src/home/test/App.jsx',\n      },\n      // Use Conventional Routing\n      entry_spa: {\n        // The entry path of a conventional route must be set to a directory\n        entry: './src/about',\n      },\n    },\n  },\n});\n\n\nBy default, the configured entry is equivalent to App.[jt]sx. If you want the\nentry to be equivalent to the entry in build mode, you can set the value\nto'Object' and the property disableMount to true.\n\n\nCombine Entry\n\nWhen source.entries is specified, the Modern.js merges the user-defined entry\nwith the default entry obtained by analyzing the directory structure. The\nmerging rule is:\n\nCompare the entry path set by the custom entry with the default entry path. When\nthe entry paths are the same, the custom entry will override the default entry.\n\nFor example the following directory structure:\n\n.\n├── src\n│   ├── chat\n│   │   └── App.jsx\n│   └── home\n│       └── index.js\n└── package.json\n\n\nModern.js analyze the src/ directory to get the default entries chat and home.\nWhen the user configures the following in the modern.config.js file:\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      index: './src/home/index.js',\n    },\n  },\n};\n\n\nYou can see that the path of the custom entry index is the same as the path of\nthe default entry home. During the merging process, index will override home,\nand the final entry is as follows:\n\n * chat -> ./src/chat/App.jsx\n * index -> ./src/home/index.js","frontmatter":{"title":"source.entries","sidebar_label":"entries"}},{"id":153,"title":"source.exclude","routePath":"/en/configure/app/source/exclude","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.exclude.\n\n * Type: Array<string | RegExp>\n * Default: []\n\nSpecifies JavaScript/TypeScript files that do not need to be compiled. The usage\nis consistent with Rule.exclude in webpack, which supports passing in strings or\nregular expressions to match the module path.\n\nFor example:\n\n\n\nexport default {\n  source: {\n    exclude: [path.resolve(__dirname, 'src/module-a'), /src\\/module-b/],\n  },\n};\n","frontmatter":{"sidebar_label":"exclude"}},{"id":154,"title":"source.globalVars","routePath":"/en/configure/app/source/global-vars","lang":"en","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.globalVars.\n\n * Type: Record<string, JSONValue>\n * Default:\n\nconst defaultGlobalVars = {\n  // The environment variable `process.env.NODE_ENV` will be added by default,\n  // so you don't need to set it in manually.\n  'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n};\n\n\nDefine global variables. It can replace expressions like process.env.FOO in your\ncode after compile. Such as:\n\nconsole.log(process.env.NODE_ENV);\n\n// ⬇️ Turn into being...\nconsole.log('development');\n\n\nDoesn't works with destructuring assignment, because builder does not know if\nNODE_ENV and process.env.NODE_ENV are associated:\n\nconst { NODE_ENV } = process.env;\nconsole.log(NODE_ENV);\n// ❌ Won't get a string.\n\n\nYou can take source.globalVars as the syntax sugar of source.define, the only\ndifference is that source.globalVars will automatically stringify the value,\nwhich makes it easier to set the value of global variables. The values of\nglobalVars should be JSON-safe to ensure it can be serialized.\n\nexport default {\n  source: {\n    globalVars: {\n      'process.env.BUILD_VERSION': '0.0.1',\n      'import.meta.foo': { bar: 42 },\n      'import.meta.baz': false,\n    },\n    define: {\n      'process.env.BUILD_VERSION': JSON.stringify('0.0.1'),\n      'import.meta': {\n        foo: JSON.stringify({ bar: 42 }),\n        baz: JSON.stringify(false),\n      },\n    },\n  },\n};\n\n\n\nExample\n\nAdd the following config to use:\n\nexport default {\n  source: {\n    globalVars: {\n      ENABLE_VCONSOLE: true,\n      APP_CONTEXT: { answer: 42 },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"globalVars"}},{"id":155,"title":"source.include","routePath":"/en/configure/app/source/include","lang":"en","toc":[{"id":"compile-npm-packages","text":"Compile Npm Packages","depth":3},{"id":"compile-sub-dependencies","text":"Compile Sub Dependencies","depth":3},{"id":"compile-libraries-in-monorepo","text":"Compile Libraries in Monorepo","depth":3},{"id":"compile-commonjs-module","text":"Compile CommonJS Module","depth":3},{"id":"matching-symlink","text":"Matching Symlink","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.include.\n\n * Type: Array<string | RegExp>\n * Default: []\n\nIn order to maintain faster compilation speed, Builder will not compile\nJavaScript/TypeScript files under node_modules through babel-loader or ts-loader\nby default, as will as the JavaScript/TypeScript files outside the current\nproject directory.\n\nThrough the source.include config, you can specify directories or modules that\nneed to be compiled by Builder. The usage of source.include is consistent with\nRule.include in webpack, which supports passing in strings or regular\nexpressions to match the module path.\n\nFor example:\n\n\n\nexport default {\n  source: {\n    include: [path.resolve(__dirname, '../other-dir')],\n  },\n};\n\n\n\nCompile Npm Packages\n\nA typical usage scenario is to compile npm packages under node_modules, because\nsome third-party dependencies have ES6+ syntax, which may cause them to fail to\nrun on low-version browsers. You can solve the problem by using this config to\nspecify the dependencies that need to be compiled.\n\nTake query-string as an example, you can add the following config:\n\n\n\nexport default {\n  source: {\n    include: [\n      // Method 1:\n      // First get the path of the module by require.resolve\n      // Then pass path.dirname to point to the corresponding directory\n      path.dirname(require.resolve('query-string')),\n      // Method 2:\n      // Match by regular expression\n      // All paths containing `/query-string/` will be matched\n      /\\/query-string\\//,\n    ],\n  },\n};\n\n\n> Note that this config will only compile the code of query-string itself, not\n> the sub-dependencies of query-string. If you need to compile a sub-dependency\n> of query-string, you need to add the corresponding npm package to\n> source.include.\n\n\nCompile Sub Dependencies\n\nWhen you compile an npm package via source.include, Builder will only compile\nthe matching module by default, not the Sub Dependencies of the module.\n\nTake query-string for example, it depends on the decode-uri-component package,\nwhich also has ES6+ code, so you need to add the decode-uri-component package to\nsource.include as well.\n\n\n\nexport default {\n  source: {\n    include: [/\\/query-string\\//, /\\/decode-uri-component\\//],\n  },\n};\n\n\n\nCompile Libraries in Monorepo\n\nWhen developing in Monorepo, if you need to refer to the source code of other\nlibraries in Monorepo, you can add the corresponding library to source.include:\n\n\n\nexport default {\n  source: {\n    include: [\n      // Method 1:\n      // Compile all files in Monorepo's package directory\n      path.resolve(__dirname, '../../packages'),\n\n      // Method 2:\n      // Compile the source code of a package in Monorepo's package directory\n      // This way of writing matches the range more accurately and has less impact on the overall build performance.\n      path.resolve(__dirname, '../../packages/xxx/src'),\n    ],\n  },\n};\n\n\n\nCompile CommonJS Module\n\nBabel cannot compile CommonJS modules by default, and if you compile a CommonJS\nmodule, you may get a runtime error message exports is not defined.\n\nWhen you need to compile a CommonJS module using source.include, you can set\nBabel's sourceType configuration to unambiguous.\n\nexport default {\n  tools: {\n    babel(config) {\n      config.sourceType = 'unambiguous';\n    },\n  },\n};\n\n\nSetting sourceType to unambiguous may have some other effects, please refer to\nBabel official documentation.\n\n\nMatching Symlink\n\nIf you match a module that is symlinked to the current project, then you need to\nmatch the real path of the module, not the symlinked path.\n\nFor example, if you symlink the packages/foo path in Monorepo to the\nnode_modules/foo path of the current project, you need to match the packages/foo\npath, not the node_modules/foo path.\n\nThis behavior can be controlled via webpack's resolve.symlinks config.","frontmatter":{"sidebar_label":"include"}},{"id":156,"title":"source.moduleScopes","routePath":"/en/configure/app/source/module-scopes","lang":"en","toc":[{"id":"example","text":"Example","depth":3},{"id":"array-type","text":"Array Type","depth":4},{"id":"function-type","text":"Function Type","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.moduleScopes.\n\n * Type: Array<string | Regexp> | Function\n * Default: undefined\n * Bundler: only support webpack\n\nRestrict importing paths. After configuring this option, all source files can\nonly import code from the specific paths, and import code from other paths is\nnot allowed.\n\n\nExample\n\nFirst, we configure moduleScopes to only include the src directory:\n\nexport default {\n  source: {\n    moduleScopes: ['./src'],\n  },\n};\n\n\nThen we import the utils/a module outside the src directory in src/App.tsx:\n\n\n\nAfter compiling, there will be a reference path error:\n\n\n\nIf we configure the utils directory in moduleScopes, the error will disappear.\n\nexport default {\n  source: {\n    moduleScopes: ['./src', './utils'],\n  },\n};\n\n\nArray Type\n\nYou can directly set several paths like this:\n\nexport default {\n  source: {\n    moduleScopes: ['./src', './shared', './utils'],\n  },\n};\n\n\nFunction Type\n\nmoduleScopes also supports setting as a function, which can be modified instead\nof overriding the default value:\n\nexport default {\n  source: {\n    moduleScopes: scopes => {\n      scopes.push('./shared');\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"moduleScopes"}},{"id":157,"title":"source.preEntry","routePath":"/en/configure/app/source/pre-entry","lang":"en","toc":[{"id":"add-a-single-script","text":"Add a single script","depth":4},{"id":"add-global-style","text":"Add global style","depth":4},{"id":"add-multiple-scripts","text":"Add multiple scripts","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.preEntry.\n\n * Type: string | string[]\n * Default: undefined\n\nAdd a script before the entry file of each page. This script will be executed\nbefore the page code. It can be used to execute global logics, such as injecting\npolyfills, setting global styles, etc.\n\nAdd a single script\n\nFirst create a src/polyfill.ts file:\n\nconsole.log('I am a polyfill');\n\n\nThen configure src/polyfill.ts to source.preEntry:\n\nexport default {\n  source: {\n    preEntry: './src/polyfill.ts',\n  },\n};\n\n\nRe-run the compilation and visit any page, you can see that the code in\nsrc/polyfill.ts has been executed, and the I am a polyfill is logged in the\nconsole.\n\nAdd global style\n\nYou can also configure the global style through source.preEntry, this CSS code\nwill be loaded earlier than the page code, such as introducing a normalize.css\nfile:\n\nexport default {\n  source: {\n    preEntry: './src/normalize.css',\n  },\n};\n\n\nAdd multiple scripts\n\nYou can add multiple scripts by setting preEntry to an array, and they will be\nexecuted in array order:\n\nexport default {\n  source: {\n    preEntry: ['./src/polyfill-a.ts', './src/polyfill-b.ts'],\n  },\n};\n","frontmatter":{"sidebar_label":"preEntry"}},{"id":158,"title":"source.resolveExtensionPrefix","routePath":"/en/configure/app/source/resolve-extension-prefix","lang":"en","toc":[{"id":"example","text":"Example","depth":3},{"id":"set-according-to-targets","text":"Set according to Targets","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.resolveExtensionPrefix.\n\n * Type: string | Record<BuilderTarget, string>\n * Default: undefined\n\nAdd a prefix to resolve.extensions.\n\nIf multiple files share the same name but have different extensions, Builder\nwill resolve the one with the extension listed first in the array and skip the\nrest.\n\n\nExample\n\nexport default {\n  source: {\n    resolveExtensionPrefix: '.web',\n  },\n};\n\n\nWith the configuration above, the extensions array will become:\n\n// before\nconst extensions = ['.js', '.ts', ...];\n\n// after\nconst extensions = ['.web.js', '.js', '.web.ts' , '.ts', ...];\n\n\nWhen import './foo' in the code, the foo.web.js file will be resolved first,\nthen the foo.js file.\n\nSet according to Targets\n\nWhen you build multiple targets at the same time, you can set different\nextension prefix for different targets. At this point, you need to set\nresolveExtensionPrefix to an object whose key is the corresponding build target.\n\nFor example to set different extension prefix for web and node:\n\nexport default {\n  output: {\n    source: {\n      resolveExtensionPrefix: {\n        web: '.web',\n        node: '.node',\n      },\n    },\n  },\n};\n\n\nWhen import './foo' in the code, the foo.node.js file will be resolved for node\ntarget, and the foo.web.js file will be resolved for web target.","frontmatter":{"sidebar_label":"resolveExtensionPrefix"}},{"id":159,"title":"source.resolveMainFields","routePath":"/en/configure/app/source/resolve-main-fields","lang":"en","toc":[{"id":"example","text":"Example","depth":3},{"id":"set-according-to-targets","text":"Set according to Targets","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\nsource.resolveMainFields.\n\n * Type:\n\ntype Fields = (string | string[])[];\n\ntype ResolveMainFields = Fields | Record<BuilderTarget, Fields>;\n\n\n * Default: undefined\n\nThis config will determine which field of package.json you use to import the npm\nmodule. Same as the resolve.mainFields config of webpack.\n\n\nExample\n\nexport default {\n  source: {\n    resolveMainFields: ['main', 'browser', 'exports'],\n  },\n};\n\n\nSet according to Targets\n\nWhen you build multiple targets at the same time, you can set different\nmainFields for different targets. At this point, you need to set\nresolveMainFields to an object whose key is the corresponding build target.\n\nFor example to set different mainFields for web and node:\n\nexport default {\n  output: {\n    source: {\n      resolveMainFields: {\n        web: ['main', 'browser', 'exports'],\n        node: ['main', 'node', 'exports'],\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"resolveMainFields"}},{"id":160,"title":"testing.transformer","routePath":"/en/configure/app/testing/transformer","lang":"en","toc":[],"domain":"","content":"\n\n * Type: 'babel-jest' | 'ts-jest'\n * Default: babel-jest\n\nCaution\n\nFirst you need to enable the \"Unit Test\" function using new command.\n\nConfigure the compiler for source code when executing tests: babel-jest or\nts-jest. babel-jest is used by default.\n\nAdditional information\n\nBabel-jest can also compile TS files, but there is no type error. If you need to\ncheck the TS type when running tests, then use ts-jest.","frontmatter":{"title":"testing.transformer","sidebar_label":"transformer","sidebar_position":1}},{"id":161,"title":"tools.autoprefixer","routePath":"/en/configure/app/tools/autoprefixer","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.autoprefixer.\n\n * Type: Object | Function\n * Default:\n\n{\n  flexbox: 'no-2009',\n  // Depends on the browserslist config in the project\n  // and the `output.overrideBrowserslist` (higher priority) config\n  overrideBrowserslist: browserslist,\n}\n\n\nYou can modify the config of autoprefixer by tools.autoprefixer.\n\n\nObject Type\n\nWhen tools.autoprefixer is configured as Object type, it is merged with the\ndefault config through Object.assign. For example:\n\nexport default {\n  tools: {\n    autoprefixer: {\n      flexbox: 'no-2009',\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.autoprefixer is a Function, the default config is passed as the first\nparameter and can be directly modified or returned as the final result. For\nexample:\n\nexport default {\n  tools: {\n    autoprefixer(config) {\n      // modify flexbox config\n      config.flexbox = 'no-2009';\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"autoprefixer"}},{"id":162,"title":"tools.babel","routePath":"/en/configure/app/tools/babel","lang":"en","toc":[{"id":"function-type","text":"Function Type","depth":3},{"id":"object-type","text":"Object Type","depth":3},{"id":"util-functions","text":"Util Functions","depth":3},{"id":"addplugins","text":"addPlugins","depth":4},{"id":"addpresets","text":"addPresets","depth":4},{"id":"removeplugins","text":"removePlugins","depth":4},{"id":"removepresets","text":"removePresets","depth":4},{"id":"addincludes","text":"addIncludes","depth":4},{"id":"addexcludes","text":"addExcludes","depth":4},{"id":"modifypresetenvoptions","text":"modifyPresetEnvOptions","depth":4},{"id":"modifypresetreactoptions","text":"modifyPresetReactOptions","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.babel.\n\n * Type: Object | Function\n * Default: undefined\n * Bundler: only support webpack\n\nBy tools.babel you can modify the options of babel-loader.\n\n\nFunction Type\n\nWhen tools.babel's type is Function，the default babel config will be passed in\nas the first parameter, the config object can be modified directly, or a value\ncan be returned as the final result. The second parameter provides some util\nfunctions that can be called directly:\n\nexport default {\n  tools: {\n    babel(config) {\n      // Add a babel plugin\n      // note: the plugin have been added to the default config to support antd load on demand\n      config.plugins.push([\n        'babel-plugin-import',\n        {\n          libraryName: 'xxx-components',\n          libraryDirectory: 'es',\n          style: true,\n        },\n      ]);\n    },\n  },\n};\n\n\n\nObject Type\n\nWhen tools.babel's type is Object, the config will be merged with default config\nby Object.assign. Note that Object.assign is a shallow copy and will completely\noverwrite the built-in presets or plugins array, please use it with caution.\n\nexport default {\n  tools: {\n    babel: {\n      plugins: [\n        [\n          'babel-plugin-import',\n          {\n            libraryName: 'xxx-components',\n            libraryDirectory: 'es',\n            style: true,\n          },\n        ],\n      ],\n    },\n  },\n};\n\n\n\nUtil Functions\n\nWhen tools.babel is a Function, the tool functions available for the second\nparameter are as follows:\n\naddPlugins\n\n * Type: (plugins: BabelPlugin[]) => void\n\nAdd some Babel plugins. For example:\n\nexport default {\n  tools: {\n    babel(config, { addPlugins }) {\n      addPlugins([\n        [\n          'babel-plugin-import',\n          {\n            libraryName: 'xxx-components',\n            libraryDirectory: 'es',\n            style: true,\n          },\n        ],\n      ]);\n    },\n  },\n};\n\n\naddPresets\n\n * Type: (presets: BabelPlugin[]) => void\n\nAdd Babel preset configuration. (No need to add presets in most cases)\n\nexport default {\n  tools: {\n    babel(config, { addPresets }) {\n      addPresets(['@babel/preset-env']);\n    },\n  },\n};\n\n\nremovePlugins\n\n * Type: (plugins: string | string[]) => void\n\nTo remove the Babel plugin, just pass in the name of the plugin to be removed,\nyou can pass in a single string or an array of strings.\n\nexport default {\n  tools: {\n    babel(config, { removePlugins }) {\n      removePlugins('babel-plugin-import');\n    },\n  },\n};\n\n\nremovePresets\n\n * Type: (presets: string | string[]) => void\n\nTo remove the Babel preset configuration, pass in the name of the preset to be\nremoved, you can pass in a single string or an array of strings.\n\nexport default {\n  tools: {\n    babel(config, { removePresets }) {\n      removePresets('@babel/preset-env');\n    },\n  },\n};\n\n\naddIncludes\n\n * Type: (includes: string | RegExp | (string | RegExp)[]) => void\n\nBy default, Babel will only compile the application code in the src directory.\nWith addIncludes you can specify that Babel compile some files in node_modules.\nFor example:\n\nexport default {\n  tools: {\n    babel(config, { addIncludes }) {\n      addIncludes(/\\/query-string\\//);\n    },\n  },\n};\n\n\nTIP\n\nThe usage of the addIncludes function is basically the same as the\nsource.include config, please see the source.include documentation for a more\ndetailed usage. You can also use source.include directly instead of the\naddIncludesfunction.\n\naddExcludes\n\n * Type: (excludes: string | RegExp | (string | RegExp)[]) => void\n\nContrary to addIncludes, specifies that certain files are excluded from Babel's\ncompilation.\n\nFor example, without compiling files in the src/example directory:\n\nexport default {\n  tools: {\n    babel(config, { addExcludes }) {\n      addExcludes('src/example');\n    },\n  },\n};\n\n\nTIP\n\nThe usage of the addExcludes function is basically the same as the\nsource.exclude config, please see the source.exclude documentation for a more\ndetailed usage. You can also use source.exclude directly instead of the\naddExcludesfunction.\n\nmodifyPresetEnvOptions\n\n * Type: (options: PresetEnvOptions) => void\n\nModify the configuration of @babel/preset-env, the configuration you pass in\nwill be shallowly merged with default config. For example:\n\nexport default {\n  tools: {\n    babel(config, { modifyPresetEnvOptions }) {\n      modifyPresetEnvOptions({\n        targets: {\n          browsers: ['last 2 versions'],\n        },\n      });\n    },\n  },\n};\n\n\nmodifyPresetReactOptions\n\n * Type: (options: PresetReactOptions) => void\n\nModify the configuration of @babel/preset-react, the configuration you pass in\nwill be shallowly merged with default config. For example:\n\nexport default {\n  tools: {\n    babel(config, { modifyPresetReactOptions }) {\n      modifyPresetReactOptions({\n        pragma: 'React.createElement',\n      });\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"babel"}},{"id":163,"title":"tools.cssExtract","routePath":"/en/configure/app/tools/css-extract","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.cssExtract.\n\n * Type: Object | Function\n * Default:\n\nconst defaultOptions = {\n  // The loader options\n  loaderOptions: {},\n  // The plugin options\n  pluginOptions: {\n    // The default value of cssPath is `static/css`\n    // while the default value of cssFilename is `[name].[contenthash:8].css`\n    filename: `${cssPath}/${cssFilename}`,\n    chunkFilename: `${cssPath}/async/${cssFilename}`,\n    ignoreOrder: true,\n  },\n};\n\n\n * Bundler: only support webpack\n\nThe config of mini-css-extract-plugin can be modified through tools.cssExtract.\n\n\nObject Type\n\nWhen this value is an Object, it is merged with the default config via\nObject.assign. For example:\n\nexport default {\n  tools: {\n    cssExtract: {\n      pluginOptions: {\n        filename: 'static/css/[name].[contenthash:8].css',\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen the value a Function, the default config is passed in as the first\nparameter. You can modify the config object directly, or return an object as the\nfinal config. For example:\n\nexport default {\n  tools: {\n    cssExtract: config => {\n      config.pluginOptions.filename = 'static/css/[name].[contenthash:8].css';\n      return config;\n    },\n  },\n};\n\n\nFor more config details, please refer to mini-css-extract-plugin.","frontmatter":{"sidebar_label":"cssExtract"}},{"id":164,"title":"tools.cssLoader","routePath":"/en/configure/app/tools/css-loader","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.cssLoader.\n\n * Type: Object | Function\n * Default: undefined\n * Bundler: only support webpack\n\nThe config of css-loader can be modified through tools.cssLoader. The default\nconfig is as follows:\n\n{\n  importLoaders: 1,\n  modules: {\n    auto: true,\n    exportLocalsConvention: 'camelCase',\n    localIdentName: config.output.cssModuleLocalIdentName,\n    // isServer indicates node (SSR) build\n    // isWebWorker indicates web worker build\n    exportOnlyLocals: isServer || isWebWorker,\n  },\n  // CSS Source Map enabled by default in development environment\n  sourceMap: isDev,\n}\n\n\n\nObject Type\n\nWhen this value is an Object, it is merged with the default config via deep\nmerge. For example:\n\nexport default {\n  tools: {\n    cssLoader: {\n      modules: {\n        exportOnlyLocals: true,\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen the value is a Function, the default config is passed in as the first\nparameter. You can modify the config object directly, or return an object as the\nfinal config. For example:\n\nexport default {\n  tools: {\n    cssLoader: config => {\n      config.modules.exportOnlyLocals = true;\n      return config;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"cssLoader"}},{"id":165,"title":"tools.devServer","routePath":"/en/configure/app/tools/dev-server","lang":"en","toc":[{"id":"options","text":"Options","depth":3},{"id":"after","text":"after","depth":4},{"id":"before","text":"before","depth":4},{"id":"client","text":"client","depth":4},{"id":"devmiddleware","text":"devMiddleware","depth":4},{"id":"headers","text":"headers","depth":4},{"id":"historyapifallback","text":"historyApiFallback","depth":4},{"id":"hot","text":"hot","depth":4},{"id":"https","text":"https","depth":4},{"id":"livereload","text":"liveReload","depth":4},{"id":"setupmiddlewares","text":"setupMiddlewares","depth":4},{"id":"proxy","text":"proxy","depth":4},{"id":"watch","text":"watch","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.devServer.\n\n * Type: Object\n * Default: {}\n\nThe config of DevServer can be modified through tools.devServer.\n\n\nOptions\n\nafter\n\n * Type: Array\n * Default: []\n\nProvides the ability to execute custom middleware after all other middleware\ninternally within the server.\n\nexport default {\n  tools: {\n    devServer: {\n      after: [\n        async (req, res, next) => {\n          console.log('after dev middleware');\n          next();\n        },\n      ],\n    },\n  },\n};\n\n\nbefore\n\n * Type: Array\n * Default: []\n\nProvides the ability to execute custom middleware prior to all other middleware\ninternally within the server.\n\nexport default {\n  tools: {\n    devServer: {\n      before: [\n        async (req, res, next) => {\n          console.log('before dev middleware');\n          next();\n        },\n      ],\n    },\n  },\n};\n\n\nclient\n\n * Type:\n\n{\n    /** Specify a protocol to use */\n    protocol?: string;\n    /** The path which the middleware is serving the event stream on */\n    path?: string;\n    /** Specify a port number to listen for requests on */\n    port?: string;\n    /** Specify a host to use */\n    host?: string;\n}\n\n\n * Default:\n\n{\n    path: '/webpack-hmr',\n    port: '8080',\n    host: networkAddress || 'localhost',\n}\n\n\nThe config of hmr client.\n\ndevMiddleware\n\n * Type:\n\n{\n  writeToDisk: boolean | ((filename: string) => boolean);\n}\n\n\n * Default:\n\n{\n  writeToDisk: (file: string) => !file.includes('.hot-update.'),\n}\n\n\nThe config of devMiddleware. Current options is the subset of\nwebpack-dev-middleware.\n\nheaders\n\n * Type: Record<string, string>\n * Default: undefined\n\nAdds headers to all responses.\n\nexport default {\n  tools: {\n    devServer: {\n      headers: {\n        'X-Custom-Foo': 'bar',\n      },\n    },\n  },\n};\n\n\nhistoryApiFallback\n\n * Type: boolean | ConnectHistoryApiFallbackOptions\n * Default: false\n\nThe index.html page will likely have to be served in place of any 404 responses.\nEnable devServer.historyApiFallback by setting it to true:\n\nexport default {\n  tools: {\n    devServer: {\n      historyApiFallback: true,\n    },\n  },\n};\n\n\nFor more options and information, see the connect-history-api-fallback\ndocumentation.\n\nhot\n\n * Type: boolean\n * Default: true\n\nEnable Hot Module Replacement feature.\n\nhttps\n\n * Type: boolean | { key: string; cert: string }\n * Default: false\n\nBy default, DevServer will be served over HTTP. It can optionally be served over\nHTTPS by setting devServer.https to true, and will disable the HTTP server.\n\nYou can also manually pass in the certificate and corresponding private key\nrequired by the HTTPS server:\n\nexport default {\n  tools: {\n    devServer: {\n      https: {\n        key: fs.readFileSync('certificates/private.pem'),\n        cert: fs.readFileSync('certificates/public.pem'),\n      },\n    },\n  },\n};\n\n\nliveReload\n\n * Type: boolean\n * Default: true\n\nBy default, the DevServer will reload/refresh the page when file changes are\ndetected（devServer.hot option must be disabled in order for liveReload to take\neffect）. Disable devServer.liveReload by setting it to false.\n\nsetupMiddlewares\n\n * Type:\n\nArray<\n  (\n    middlewares: {\n      unshift: (...handlers: RequestHandler[]) => void;\n      push: (...handlers: RequestHandler[]) => void;\n    },\n    server: {\n      sockWrite: (\n        type: string,\n        data?: string | boolean | Record<string, any>,\n      ) => void;\n    },\n  ) => void\n>;\n\n\n * Default: undefined\n\nProvides the ability to execute a custom function and apply custom middlewares.\n\nThe order among several different types of middleware is: devServer.before =>\nunshift => internal middlewares => push => devServer.after.\n\nexport default {\n  tools: {\n    devServer: {\n      setupMiddlewares: [\n        (middlewares, server) => {\n          middlewares.unshift((req, res, next) => {\n            next();\n          });\n\n          middlewares.push((req, res, next) => {\n            next();\n          });\n        },\n      ],\n    },\n  },\n};\n\n\nIt is possible to use some server api to meet special scenario requirements:\n\n * sockWrite. Allow send some message to hmr client, and then the hmr client\n   will take different actions depending on the message type. If you send a\n   \"content changed\" message, the page will reload.\n\nexport default {\n  tools: {\n    devServer: {\n      setupMiddlewares: [\n        (middlewares, server) => {\n          // add custom watch & trigger page reload when change\n          watcher.on('change', changed => {\n            server.sockWrite('content-changed');\n          });\n        },\n      ],\n    },\n  },\n};\n\n\nproxy\n\n * Type: Record<string, string> | Record<string, ProxyDetail>\n * Default: undefined\n\nProxying some URLs.\n\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': 'http://localhost:3000',\n      },\n    },\n  },\n};\n\n\nA request to /api/users will now proxy the request to\nhttp://localhost:3000/api/users.\n\nIf you don't want /api to be passed along, we need to rewrite the path:\n\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': {\n          target: 'http://localhost:3000',\n          pathRewrite: { '^/api': '' },\n        },\n      },\n    },\n  },\n};\n\n\nThe DevServer Proxy makes use of the http-proxy-middleware package. Check out\nits documentation for more advanced usages.\n\nThe full type definition of DevServer Proxy is:\n\n\n\ntype ProxyDetail = HttpProxyOptions & {\n  bypass?: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    proxyOptions: ProxyOptions,\n  ) => string | undefined | null | false;\n  context?: string | string[];\n};\n\ntype ProxyOptions =\n  | Record<string, string>\n  | Record<string, ProxyDetail>\n  | ProxyDetail[]\n  | ProxyDetail;\n\n\nIn addition to the http-proxy-middleware option, we also support the bypass and\ncontext configuration:\n\n * bypass：bypass the proxy based on the return value of a function.\n   * Return null or undefined to continue processing the request with proxy.\n   * Return false to produce a 404 error for the request.\n   * Return a path to serve from, instead of continuing to proxy the request.\n * context：If you want to proxy multiple, specific paths to the same target, you\n   can use an array of one or more objects with a context property.\n\n// custom bypass\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': {\n          target: 'http://localhost:3000',\n          bypass: function (req, res, proxyOptions) {\n            if (req.headers.accept.indexOf('html') !== -1) {\n              console.log('Skipping proxy for browser request.');\n              return '/index.html';\n            }\n          },\n        },\n      },\n    },\n  },\n};\n\n\n// proxy multiple\nexport default {\n  tools: {\n    devServer: {\n      proxy: [\n        {\n          context: ['/auth', '/api'],\n          target: 'http://localhost:3000',\n        },\n      ],\n    },\n  },\n};\n\n\nwatch\n\n * Type: boolean\n * Default: true\n\nWhether to watch files change in directories such as mock/, server/, api/.","frontmatter":{"sidebar_label":"devServer"}},{"id":166,"title":"tools.esbuild","routePath":"/en/configure/app/tools/esbuild","lang":"en","toc":[{"id":"introduction","text":"Introduction","depth":2},{"id":"configuration","text":"Configuration","depth":2}],"domain":"","content":"\n\n * Type: Object\n * Default: undefined\n\n\nIntroduction\n\nAbout esbuild\n\nesbuild is a front-end build tool based on Golang. It has the functions of\nbundling, compiling and minimizing JavaScript code. Compared with traditional\ntools, the performance is significantly improved. When minimizing code, compared\nto webpack's built-in terser minimizer, esbuild has dozens of times better\nperformance.\n\nModern.js provides esbuild plugin that allow you to use esbuild instead of\nbabel-loader, ts-loader and terser for transformation and minification process.\n\n\nConfiguration\n\nYou can set the esbuild compilation behavior through the tools.esbuild config.\n\n\n\nexport default defineConfig({\n  tools: {\n    esbuild: {\n      loader: {\n        target: 'chrome61',\n      },\n      minimize: {\n        target: 'chrome61',\n      },\n    },\n  },\n});\n\n\nFor config details, please refer to Modern.js Builder - Esbuild Plugin\nConfiguration.","frontmatter":{"title":"tools.esbuild","sidebar_label":"esbuild"}},{"id":167,"title":"tools.htmlPlugin","routePath":"/en/configure/app/tools/html-plugin","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"boolean-type","text":"Boolean Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.htmlPlugin.\n\n * Type: false | Object | Function\n * Default:\n\nconst defaultHtmlPluginOptions = {\n  inject, // corresponding to the html.inject config\n  favicon, // corresponding to html.favicon config\n  filename, // generated based on output.distPath and entryName\n  template, // defaults to the built-in HTML template path\n  templateParameters, // corresponding to the html.templateParameters config\n  chunks: [entryName],\n  minify: {\n    removeComments: false,\n    useShortDoctype: true,\n    keepClosingSlash: true,\n    collapseWhitespace: true,\n    removeRedundantAttributes: true,\n    removeScriptTypeAttributes: true,\n    removeStyleLinkTypeAttributes: true,\n  },\n};\n\n\nThe configs of html-webpack-plugin can be modified through tools.htmlPlugin.\n\n\nObject Type\n\nWhen tools.htmlPlugin is Object type, the value will be merged with the default\nconfig via Object.assign.\n\nexport default {\n  tools: {\n    htmlPlugin: {\n      scriptLoading: 'blocking',\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.htmlPlugin is a Function:\n\n * The first parameter is the default config, which can be modified directly.\n * The second parameter is also an object, containing the entry name and the\n   entry value.\n * The Function can return a new object as the final config.\n\nexport default {\n  tools: {\n    htmlPlugin(config, { entryName, entryValue }) {\n      if (entryName === 'main') {\n        config.scriptLoading = 'blocking';\n      }\n    },\n  },\n};\n\n\n\nBoolean Type\n\nThe built-in html-webpack-plugin plugins can be disabled by set tools.htmlPlugin\nto false.\n\nexport default {\n  tools: {\n    htmlPlugin: false,\n  },\n};\n","frontmatter":{"sidebar_label":"htmlPlugin"}},{"id":168,"title":"tools.inspector","routePath":"/en/configure/app/tools/inspector","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.inspector.\n\n * Type: Object | Function | undefined\n * Default: undefined\n * Bundler: only support webpack\n\nYou can enable or configure the webpack inspector through tools.inspector.\n\nWhen the configuration is not undefined, it means that webpack-inspector is\nenabled, and the type of tools.inspector can be Object or Function.\n\n\nObject Type\n\nWhen tools.inspector is configured with type Object, it is merged with the\ndefault configuration via Object.assign. For example:\n\nexport default {\n  tools: {\n    inspector: {\n      // The default port is 3333\n      port: 3334,\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.inspector is a Function, the default configuration is passed as the\nfirst parameter and can be directly modified or returned as the final result.\nFor example:\n\nexport default {\n  tools: {\n    inspector(config) {\n      config.port = 3334;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"inspector"}},{"id":169,"title":"tools.jest","routePath":"/en/configure/app/tools/jest","lang":"en","toc":[],"domain":"","content":"\n\n * Type: Object | Function\n * Default: {}\n\nCaution\n\nFirst you need to enable the \"Unit Test\" function using new command.\n\nCorresponding to the configuration of Jest, when of type Object, all underlying\nconfigurations supported by Jest can be configured.\n\nexport default defineConfig({\n  tools: {\n    jest: {\n      testTimeout: 10000,\n    },\n  },\n});\n\n\nWhen the value is of type Function, the default configuration is passed in as\nthe first parameter and a new Jest configuration object needs to be returned.\n\nexport default defineConfig({\n  tools: {\n    jest: options => {\n      return {\n        ...options,\n        testTimeout: 10000,\n      };\n    },\n  },\n});\n","frontmatter":{"title":"tools.jest","sidebar_label":"jest"}},{"id":170,"title":"tools.less","routePath":"/en/configure/app/tools/less","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"util-function","text":"Util Function","depth":3},{"id":"addexcludes","text":"addExcludes","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.less.\n\n * Type: Object | Function\n * Default:\n\nconst defaultOptions = {\n  lessOptions: {\n    javascriptEnabled: true,\n  },\n  // CSS Source Map enabled by default in development environment\n  sourceMap: isDev,\n};\n\n\nYou can modify the config of less-loader via tools.less.\n\n\nObject Type\n\nWhen tools.less is configured as Object type, it is merged with the default\nconfig through Object.assign in a shallow way. It should be noted that\nlessOptions is merged through deepMerge in a deep way. For example:\n\nexport default {\n  tools: {\n    less: {\n      lessOptions: {\n        javascriptEnabled: false,\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.less is a Function, the default config is passed as the first\nparameter, which can be directly modified or returned as the final result. The\nsecond parameter provides some utility functions that can be called directly.\nFor example:\n\nexport default {\n  tools: {\n    less(config) {\n      // Modify the config of lessOptions\n      config.lessOptions = {\n        javascriptEnabled: false,\n      };\n    },\n  },\n};\n\n\n\nUtil Function\n\naddExcludes\n\n * Type: (excludes: RegExp | RegExp[]) => void\n\nUsed to specify which files less-loader does not compile, You can pass in one or\nmore regular expressions to match the path of less files, for example:\n\nexport default {\n  tools: {\n    less(config, { addExcludes }) {\n      addExcludes(/node_modules/);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"less"}},{"id":171,"title":"tools.minifyCss","routePath":"/en/configure/app/tools/minify-css","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.minifyCss.\n\n * Type: Object | Function | undefined\n * Default:\n\nconst defaultOptions = {\n  minimizerOptions: {\n    preset: [\n      'default',\n      {\n        mergeLonghand: false,\n      },\n    ],\n  },\n};\n\n\n * Bundler: only support webpack\n\nWhen building for production, Builder will minimize the CSS code through\ncss-minimizer-webpack-plugin. The config of css-minimizer-webpack-plugin can be\nmodified via tools.minifyCss.\n\n\nObject Type\n\nWhen tools.minifyCss is Object type, it will be merged with the default config\nvia Object.assign.\n\nFor example, modify the preset config of cssnano:\n\nexport default {\n  tools: {\n    minifyCss: {\n      minimizerOptions: {\n        preset: require.resolve('cssnano-preset-simple'),\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.minifyCss is Function type, the default config is passed in as the\nfirst parameter, the config object can be modified directly, or a value can be\nreturned as the final result.\n\nexport default {\n   tools: {\n    minifyCss: options => {\n      options.minimizerOptions = {\n        preset: require.resolve('cssnano-preset-simple'),\n      },\n    }\n  }\n};\n","frontmatter":{"sidebar_label":"minifyCss"}},{"id":172,"title":"tools.postcss","routePath":"/en/configure/app/tools/postcss","lang":"en","toc":[{"id":"function-type","text":"Function Type","depth":3},{"id":"object-type","text":"Object Type","depth":3},{"id":"util-functions","text":"Util Functions","depth":3},{"id":"addplugins","text":"addPlugins","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.postcss.\n\n * Type: Object | Function\n * Default:\n\nconst defaultOptions = {\n  postcssOptions: {\n    plugins: [\n      require('postcss-flexbugs-fixes'),\n      require('postcss-custom-properties'),\n      require('postcss-initial'),\n      require('postcss-page-break'),\n      require('postcss-font-variant'),\n      require('postcss-media-minmax'),\n      require('postcss-nesting'),\n      require('autoprefixer')({\n        flexbox: 'no-2009',\n      }),\n    ],\n    // CSS Source Map enabled by default in development environment\n    sourceMap: isDev,\n  },\n};\n\n\nBuilder integrates PostCSS by default, you can configure postcss-loader through\ntools.postcss.\n\n\nFunction Type\n\nWhen the value is a Function, the internal default config is passed as the first\nparameter, and the config object can be modified directly without returning, or\nan object can be returned as the final result; the second parameter is a set of\ntool functions for modifying the postcss-loader config.\n\nFor example, you need to add a PostCSS plugin on the basis of the original\nplugin, and push a new plugin to the postcssOptions.plugins array:\n\nexport default {\n  tools: {\n    postcss: opts => {\n      opts.postcssOptions.plugins.push(require('postcss-px-to-viewport'));\n    },\n  },\n};\n\n\nWhen you need to pass parameters to the PostCSS plugin, you can pass them in by\nfunction parameters:\n\nexport default {\n  tools: {\n    postcss: opts => {\n      const viewportPlugin = require('postcss-px-to-viewport')({\n        viewportWidth: 375,\n      });\n      opts.postcssOptions.plugins.push(viewportPlugin);\n    },\n  },\n};\n\n\ntools.postcss can return a config object and completely replace the default\nconfig:\n\nexport default {\n  tools: {\n    postcss: () => {\n      return {\n        postcssOptions: {\n          plugins: [require('postcss-px-to-viewport')],\n        },\n      };\n    },\n  },\n};\n\n\n\nObject Type\n\nWhen this value is an Object, it is merged with the default config via\nObject.assign. Note that Object.assign is a shallow copy and will completely\noverwrite the built-in presets or plugins array, please use it with caution.\n\nexport default {\n  tools: {\n    postcss: {\n      // Because `Object.assign` is used, the default postcssOptions will be overwritten.\n      postcssOptions: {\n        plugins: [require('postcss-px-to-viewport')],\n      },\n    },\n  },\n};\n\n\n\nUtil Functions\n\naddPlugins\n\n * Type: (plugins: PostCSSPlugin | PostCSSPlugin[]) => void\n\nFor adding additional PostCSS plugins, You can pass in a single PostCSS plugin,\nor an array of PostCSS plugins.\n\nexport default {\n  tools: {\n    postcss: (config, { addPlugins }) => {\n      // Add a PostCSS Plugin\n      addPlugins(require('postcss-preset-env'));\n      // Add multiple PostCSS Plugins\n      addPlugins([require('postcss-preset-env'), require('postcss-import')]);\n    },\n  },\n};\n\n\nTIP\n\nBuilder uses the PostCSS v8 version. When you use third-party PostCSS plugins,\nplease pay attention to whether the PostCSS version is compatible. Some legacy\nplugins may not work in PostCSS v8.","frontmatter":{"sidebar_label":"postcss"}},{"id":173,"title":"tools.pug","routePath":"/en/configure/app/tools/pug","lang":"en","toc":[{"id":"boolean-type","text":"Boolean Type","depth":3},{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.pug.\n\n * Type: true | Object | Function | undefined\n * Default: false\n * Bundler: only support webpack\n\nConfigure the Pug template engine.\n\n\nBoolean Type\n\nPug template engine is not enabled by default, you can enable it by setting\ntools.pug to true.\n\nexport default {\n  tools: {\n    pug: true,\n  },\n};\n\n\nWhen enabled, you can use index.pug as the template file in html.template\nconfig.\n\n\nObject Type\n\nWhen tools.terser is Object type, you can passing the Pug options:\n\nexport default {\n  tools: {\n    pug: {\n      doctype: 'xml',\n    },\n  },\n};\n\n\nFor detailed options, please refer to Pug API Reference.\n\n\nFunction Type\n\nWhen tools.pug is Function type, the default configuration is passed in as the\nfirst parameter, the configuration object can be modified directly, or a value\ncan be returned as the final result.\n\nexport default {\n  tools: {\n    pug(config) {\n      config.doctype = 'xml';\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"pug"}},{"id":174,"title":"tools.rspack","routePath":"/en/configure/app/tools/rspack","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"utils","text":"Utils","depth":3},{"id":"env","text":"env","depth":4},{"id":"isprod","text":"isProd","depth":4},{"id":"target","text":"target","depth":4},{"id":"isserver","text":"isServer","depth":4},{"id":"iswebworker","text":"isWebWorker","depth":4},{"id":"addrules","text":"addRules","depth":3},{"id":"prependplugins","text":"prependPlugins","depth":3},{"id":"appendplugins","text":"appendPlugins","depth":3},{"id":"removeplugin","text":"removePlugin","depth":3},{"id":"mergeconfig","text":"mergeConfig","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.rspack.\n\n * Type: Object | Function | undefined\n * Default: undefined\n * Bundler: only support Rspack\n\ntools.rspack is used to configure Rspack.\n\n\nObject Type\n\nYou can configure it as an object, which will be merged with the original Rspack\nconfiguration through webpack-merge. For example:\n\nexport default {\n  tools: {\n    rspack: {\n      resolve: {\n        alias: {\n          '@util': 'src/util',\n        },\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nYou can also configure it as a function, which accepts one parameter, the\noriginal Rspack configuration, you can modify this configuration, and then\nreturn a new configuration. For example:\n\nexport default {\n  tools: {\n    rspack: config => {\n      config.resolve.alias['@util'] = 'src/util';\n      return config;\n    },\n  },\n};\n\n\nThe second parameter of this function is an object that contains some\ninformation about the tool collection. Details are as follows:\n\n\nUtils\n\nenv\n\n * Type: 'development' | 'production' | 'test'\n\nThe env parameter can be used to determine whether the current environment is\ndevelopment, production or test. For example:\n\nexport default {\n  tools: {\n    rspack: (config, { env }) => {\n      if (env === 'development') {\n        config.devtool = 'cheap-module-eval-source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\nisProd\n\n * Type: boolean\n\nThe isProd parameter can be used to determine whether the current environment is\nproduction. For example:\n\nexport default {\n  tools: {\n    rspack: (config, { isProd }) => {\n      if (isProd) {\n        config.devtool = 'source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\ntarget\n\n * Type: 'web' | 'node' | 'modern-web' | 'web-worker'\n\nThe target parameter can be used to determine the current target. For example:\n\nexport default {\n  tools: {\n    rspack: (config, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisServer\n\n * Type: boolean\n\nDetermines whether the target environment is node, equivalent to target ===\n'node'.\n\nexport default {\n  tools: {\n    rspack: (config, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisWebWorker\n\n * Type: boolean\n\nDetermines whether the target environment is web-worker, equivalent to target\n=== 'web-worker'.\n\nexport default {\n  tools: {\n    rspack: (config, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\n\naddRules\n\n * Type: (rules: RuleSetRule | RuleSetRule[]) => void\n\nAdd additional Rspack rules.\n\nFor example:\n\nexport default {\n  tools: {\n    rspack: (config, { addRules }) => {\n      // add a single rule\n      addRules({\n        test: /\\.foo/,\n        loader: require.resolve('foo-loader'),\n      });\n\n      // Add multiple rules as an array\n      addRules([\n        {\n          test: /\\.foo/,\n          loader: require.resolve('foo-loader'),\n        },\n        {\n          test: /\\.bar/,\n          loader: require.resolve('bar-loader'),\n        },\n      ]);\n    },\n  },\n};\n\n\n\nprependPlugins\n\n * Type: (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\nAdd additional plugins to the head of the internal Rspack plugins array, and the\nplugin will be executed first.\n\nexport default {\n  tools: {\n    rspack: (config, { prependPlugins }) => {\n      // add a single plugin\n      prependPlugins(\n        new PluginA(),\n      );\n\n      // Add multiple plugins\n      prependPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nappendPlugins\n\n * Type: (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\nAdd additional plugins at the end of the internal Rspack plugins array, the\nplugin will be executed last.\n\nexport default {\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      // add a single plugin\n      appendPlugins([\n        new PluginA(),\n      ]);\n\n      // Add multiple plugins\n      appendPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nremovePlugin\n\n * Type: (name: string) => void\n\nRemove the internal Rspack plugin, the parameter is the constructor.name of the\nplugin.\n\nFor example, remove the internal webpack-bundle-analyzer:\n\nexport default {\n  tools: {\n    rspack: (config, { removePlugin }) => {\n      removePlugin('BundleAnalyzerPlugin');\n    },\n  },\n};\n\n\n\nmergeConfig\n\n * Type: (...configs: RspackConfig[]) => RspackConfig\n\nUsed to merge multiple Rspack configs, same as webpack-merge。\n\nexport default {\n  tools: {\n    rspack: (config, { mergeConfig }) => {\n      return mergeConfig(config, {\n        devtool: 'eval',\n      });\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"rspack"}},{"id":175,"title":"tools.sass","routePath":"/en/configure/app/tools/sass","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"utility-function","text":"Utility Function","depth":3},{"id":"addexcludes","text":"addExcludes","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.sass.\n\n * Type: Object | Function\n * Default:\n\nconst defaultOptions = {\n  // CSS Source Map enabled by default in development environment\n  sourceMap: isDev,\n};\n\n\nYou can modify the config of sass-loader via tools.sass.\n\n\nObject Type\n\nWhen tools.sass is Object type, it is merged with the default config through\nObject.assign. It should be noted that sassOptions is merged through deepMerge\nin a deep way.\n\nFor example:\n\nexport default {\n  tools: {\n    sass: {\n      sourceMap: true,\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.sass is a Function, the default config is passed as the first\nparameter, which can be directly modified or returned as the final result. The\nsecond parameter provides some utility functions that can be called directly.\nFor Example:\n\nexport default {\n  tools: {\n    sass(config) {\n      // Modify sourceMap config\n      config.additionalData = async (content, loaderContext) => {\n        // ...\n      };\n    },\n  },\n};\n\n\n\nUtility Function\n\naddExcludes\n\n * Type: (excludes: RegExp | RegExp[]) => void\n\nUsed to specify which files sass-loader does not compile, You can pass in one or\nmore regular expressions to match the path of sass files, for example:\n\nexport default {\n  tools: {\n    sass(config, { addExcludes }) {\n      addExcludes(/node_modules/);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"sass"}},{"id":176,"title":"tools.styleLoader","routePath":"/en/configure/app/tools/style-loader","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.styleLoader.\n\n * Type: Object | Function\n * Default: {}\n * Bundler: only support webpack\n\nThe config of style-loader can be set through tools.styleLoader.\n\nIt is worth noting that Builder does not enable style-loader by default. You can\nuse output.disableCssExtract config to enable it。\n\n\nObject Type\n\nWhen this value is an Object, it is merged with the default config via\nObject.assign. For example:\n\nexport default {\n  tools: {\n    styleLoader: {\n      loaderOptions: {\n        insert: 'head',\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen the value is a Function, the default config is passed in as the first\nparameter. You can modify the config object directly, or return an object as the\nfinal config. For example:\n\nexport default {\n  tools: {\n    styleLoader: config => {\n      config.loaderOptions.insert = 'head';\n      return config;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"styleLoader"}},{"id":177,"title":"tools.styledComponents","routePath":"/en/configure/app/tools/styled-components","lang":"en","toc":[],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.styledComponents.\n\n * Type: Object | Function\n * Default\n\n{\n  displayName: true,\n  // `isSSR` is true in SSR build\n  ssr: isSSR,\n  // `pure` is enabled in production to reduce bundle size\n  pure: isProd,\n  transpileTemplateLiterals: true,\n}\n\n\n * Bundler: only support webpack\n\ntools.styledComponents config is corresponding to\nbabel-plugin-styled-components.\n\nWhen the value is an Object, use the Object.assign function to merge with the\ndefault config. For example:\n\nexport default {\n  tools: {\n    styledComponents: {\n      pure: false,\n    },\n  },\n};\n\n\nWhen the config is a Function, the first parameter is the default configuration,\nand the second parameter provides some utility functions that can be called\ndirectly:\n\nexport default {\n  tools: {\n    styledComponents(config) {\n      config.pure = false;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"styledComponents"}},{"id":178,"title":"tools.swc","routePath":"/en/configure/app/tools/swc","lang":"en","toc":[{"id":"introduction","text":"Introduction","depth":2},{"id":"install","text":"Install","depth":2},{"id":"config","text":"Config","depth":2}],"domain":"","content":"\n\n * Type: Object\n * Default: undefined\n\n\nIntroduction\n\nSWC (Speedy Web Compiler) is a transformer and minimizer for JavaScript and\nTypeScript based on Rust. SWC can provide the same abilities with Babel, and\nit's more than 10x faster than Babel.\n\nModern.js Builder has a out-of-box plugin for SWC, power your Web application\nwith Polyfill and minification, we also port some common used Babel plugins to\nSWC.\n\n\nInstall\n\nThe @modern-js/plugin-swc plugin needs to be installed before use.\n\npnpm add @modern-js/plugin-swc -D\n\n\nAfter the installation，please register the SWC plugin in the modern.config.ts\nfile, then the SWC compilation and compression will be enabled.\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), swcPlugin()],\n});\n\n\n\nConfig\n\nYou can set the SWC compilation behavior through the tools.swc config.\n\n\n\nexport default defineConfig({\n  tools: {\n    swc: {\n      jsMinify: {\n        compress: {},\n        mangle: true,\n      },\n    },\n  },\n});\n\n\nFor config details, please refer to Modern.js Builder - SWC Plugin\nConfiguration.","frontmatter":{"title":"tools.swc","sidebar_label":"swc"}},{"id":179,"title":"tools.tailwindcss","routePath":"/en/configure/app/tools/tailwindcss","lang":"en","toc":[{"id":"limitations","text":"Limitations","depth":3}],"domain":"","content":"\n\n * Type: Object | Function\n * Default:\n\nconst tailwind = {\n  content: [\n    './config/html/**/*.html',\n    './config/html/**/*.ejs',\n    './config/html/**/*.hbs',\n    './src/**/*.js',\n    './src/**/*.jsx',\n    './src/**/*.ts',\n    './src/**/*.tsx',\n    './storybook/**/*',\n  ],\n  // Use source.design System config as Tailwind CSS theme config\n  theme: source.designSystem,\n};\n\n\nWhen the value is of type Object, rhe configuration corresponding to TailwindCSS\nis merged with the default configuration through Object.assign.\n\nWhen the value is of type Function, the object returned by the function is\nmerged with the default configuration by Object.assign.\n\n\nLimitations\n\nThe theme attribute is not allowed, otherwise the build will fail. Modern.js use\nsource.designSystem as the Tailwind CSS Theme configuration.\n\nOther uses are consistent with Tailwind CSS.","frontmatter":{"sidebar_label":"tailwindcss"}},{"id":180,"title":"tools.terser","routePath":"/en/configure/app/tools/terser","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.terser.\n\n * Type: Object | Function | undefined\n * Default:\n\nconst defaultTerserOptions = {\n  terserOptions: {\n    mangle: {\n      safari10: true,\n    },\n  },\n};\n\n\n * Bundler: only support webpack\n\nWhen building for production, Builder will minimize the JavaScript code through\nterser-webpack-plugin. The config of terser-webpack-plugin can be modified via\ntools.terser.\n\n\nObject Type\n\nWhen tools.terser is Object type, it will be merged with the default config via\nObject.assign.\n\nFor example, to exclude some files from minification:\n\nexport default {\n  tools: {\n    terser: {\n      exclude: /\\/excludes/,\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen tools.terser is Function type, the default config is passed in as the first\nparameter, the config object can be modified directly, or a value can be\nreturned as the final result.\n\nexport default {\n  tools: {\n    terser: opts => {\n      opts.exclude = /\\/excludes/;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"terser"}},{"id":181,"title":"tools.tsChecker","routePath":"/en/configure/app/tools/ts-checker","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.tsChecker.\n\n * Type: Object | Function\n * Default:\n\nconst defaultOptions = {\n  typescript: {\n    // avoid OOM issue\n    memoryLimit: 8192,\n    // use tsconfig of user project\n    configFile: tsconfigPath,\n    // use typescript of user project\n    typescriptPath: require.resolve('typescript'),\n  },\n  issue: {\n    exclude: [\n      { file: '**/*.(spec|test).ts' },\n      { file: '**/node_modules/**/*' },\n    ],\n  },\n  logger: {\n    log() {\n      // do nothing\n      // we only want to display error messages\n    },\n    error(message: string) {\n      console.error(message.replace(/ERROR/g, 'Type Error'));\n    },\n  },\n},\n\n\n * Bundler: only support webpack\n\nBy default, the fork-ts-checker-webpack-plugin is enabled for type checking. You\ncan use output.disableTsChecker config to disable it.\n\n\nObject Type\n\nWhen this value is an Object, it is merged with the default config via\nObject.assign.\n\n\nFunction Type\n\nWhen the value is a Function, the default config is passed in as the first\nparameter. You can modify the config object directly, or return an object as the\nfinal config.","frontmatter":{"sidebar_label":"tsChecker"}},{"id":182,"title":"tools.tsLoader","routePath":"/en/configure/app/tools/ts-loader","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"util-functions","text":"Util Functions","depth":3},{"id":"addincludes","text":"addIncludes","depth":4},{"id":"addexcludes","text":"addExcludes","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.tsLoader.\n\n * Type: Object | Function | undefined\n * Default: undefined\n * Bundler: only support webpack\n\nts-loader is not enabled by default in the project. When tools.tsLoader is not\nundefined, builder will use ts-loader instead of babel-loader to compile\nTypeScript code.\n\n\nObject Type\n\nWhen this value is an Object, it is merged with the default configuration via\nObject.assign.\n\nThe default configuration is as follows:\n\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"ESNext\"\n  },\n  \"transpileOnly\": true,\n  \"allowTsInNodeModules\": true\n}\n\n\nYou can override the default configuration via the tools.tsLoader configuration\nitem:\n\nexport default {\n  tools: {\n    tsLoader: {\n      allowTsInNodeModules: false,\n    },\n  },\n};\n\n\n\nFunction Type\n\nWhen this value is a Function, the default configuration is passed in as the\nfirst parameter, the configuration object can be modified directly, or an object\ncan be returned as the final configuration.The second parameter is the util\nfunctions to modify the ts-loader configuration. For example:\n\nexport default {\n  tools: {\n    tsLoader: opts => {\n      opts.allowTsInNodeModules = false;\n    },\n  },\n};\n\n\n\nUtil Functions\n\nWhen the value of tools.tsLoader is a Function, the utils functions available\nfor the second parameter are as follows:\n\naddIncludes\n\nType: (includes: string | RegExp | Array<string | RegExp>) => void\n\nBy default, only the application code in the src directory will be compiled. Use\naddIncludes to specify ts-loader to compile some files under node_modules. For\nexample:\n\nexport default {\n  tools: {\n    tsLoader: (config, { addIncludes }) => {\n      addIncludes([/node_modules\\/react/]);\n    },\n  },\n};\n\n\naddExcludes\n\nType: (excludes: string | RegExp | Array<string | RegExp>) => void\n\nContrary to addIncludes, specify ts-loader to exclude certain files when\ncompiling.\n\nFor example, without compiling files in the src/example directory:\n\nexport default {\n  tools: {\n    tsLoader: (config, { addExcludes }) => {\n      addExcludes([/src\\/example\\//]);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"tsLoader"}},{"id":183,"title":"tools.webpackChain","routePath":"/en/configure/app/tools/webpack-chain","lang":"en","toc":[{"id":"utils","text":"Utils","depth":3},{"id":"env","text":"env","depth":4},{"id":"isprod","text":"isProd","depth":4},{"id":"target","text":"target","depth":4},{"id":"isserver","text":"isServer","depth":4},{"id":"iswebworker","text":"isWebWorker","depth":4},{"id":"webpack","text":"webpack","depth":4},{"id":"htmlwebpackplugin","text":"HtmlWebpackPlugin","depth":3},{"id":"chain_id","text":"CHAIN_ID","depth":4},{"id":"chain_idone_of","text":"CHAIN_ID.ONE_OF","depth":3},{"id":"chain_iduse","text":"CHAIN_ID.USE","depth":3},{"id":"chain_idplugin","text":"CHAIN_ID.PLUGIN","depth":3},{"id":"chain_idminimizer","text":"CHAIN_ID.MINIMIZER","depth":3},{"id":"examples","text":"Examples","depth":3},{"id":"addmodifydelete-loader","text":"Add/Modify/Delete loader","depth":4},{"id":"addmodifydelete-plugin","text":"Add/Modify/Delete plugin","depth":4}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see\ntools.webpackChain.\n\n * Type: Function | undefined\n * Default: undefined\n * Bundler: only support webpack\n\nYou can modify the webpack configuration by configuring tools.webpackChain which\nis type of Function. The function receives two parameters, the first is the\noriginal webpack chain object, and the second is an object containing some\nutils.\n\nCompared with tools.webpack, webpack-chain not only supports chained calls, but\nalso can locate built-in Rule or Plugin based on aliases, so as to achieve\nprecise config modification. We recommend using tools.webpackChain instead of\ntools.webpack.\n\n> tools.webpackChain is executed earlier than tools.webpack and thus will be\n> overridden by changes in tools.webpack.\n\n\nUtils\n\nenv\n\n * Type: 'development' | 'production' | 'test'\n\nThe env parameter can be used to determine whether the current environment is\ndevelopment, production or test. For example:\n\nexport default {\n  tools: {\n    webpackChain: (chain, { env }) => {\n      if (env === 'development') {\n        chain.devtool('cheap-module-eval-source-map');\n      }\n    },\n  },\n};\n\n\nisProd\n\n * Type: boolean\n\nThe isProd parameter can be used to determine whether the current environment is\nproduction. For example:\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isProd }) => {\n      if (isProd) {\n        chain.devtool('source-map');\n      }\n    },\n  },\n};\n\n\ntarget\n\n * Type: 'web' | 'node' | 'modern-web' | 'web-worker'\n\nThe target parameter can be used to determine the current environment. For\nexample:\n\nexport default {\n  tools: {\n    webpackChain: (chain, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n    },\n  },\n};\n\n\nisServer\n\n * Type: boolean\n\nDetermines whether the target environment is node, equivalent to target ===\n'node'.\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n    },\n  },\n};\n\n\nisWebWorker\n\n * Type: boolean\n\nDetermines whether the target environment is web-worker, equivalent to target\n=== 'web-worker'.\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n    },\n  },\n};\n\n\nwebpack\n\n * Type: typeof import('webpack')\n\nThe webpack instance. For example:\n\nexport default {\n  tools: {\n    webpackChain: (chain, { webpack }) => {\n      chain.plugin('my-progress').use(webpack.ProgressPlugin);\n    },\n  },\n};\n\n\n\nHtmlWebpackPlugin\n\n * Type: typeof import('html-webpack-plugin')\n\nThe HtmlWebpackPlugin instance:\n\nexport default {\n  tools: {\n    webpackChain: (chain, { HtmlWebpackPlugin }) => {\n      console.log(HtmlWebpackPlugin);\n    },\n  },\n};\n\n\nCHAIN_ID\n\nSome common Chain IDs are predefined in the Builder, and you can use these IDs\nto locate the built-in Rule or Plugin.\n\nCHAIN_ID.RULE\n\n| ID | Description | | ------------ | ---------------- | | RULE.MJS | Rule for\nmjs | | RULE.JS | Rule for js | | RULE.TS | Rule for ts | | RULE.CSS | Rule for\ncss | | RULE.LESS | Rule for less | | RULE.SASS | Rule for sass | | RULE.PUG |\nRule for pug | | RULE.TOML | Rule for toml | | RULE.YAML | Rule for yaml | |\nRULE.FONT | Rule for font | | RULE.IMAGE | Rule for image | | RULE.MEDIA | Rule\nfor media |\n\n\nCHAIN_ID.ONE_OF\n\nONE_OF.XXX can match a certain type of rule in the rule array.\n\n| ID | Description | | ------------------- |\n------------------------------------------------------------------ | |\nONE_OF.SVG | Rules for SVG, automatic choice between data URI and separate file\n| | ONE_OF.SVG_URL | Rules for SVG, output as a separate file | |\nONE_OF.SVG_INLINE | Rules for SVG, inlined into bundles as data URIs | |\nONE_OF.SVG_ASSETS | Rules for SVG, automatic choice between data URI and\nseparate file |\n\n\nCHAIN_ID.USE\n\nUSE.XXX can match a certain loader.\n\n| ID | Description | | ---------------------- |\n---------------------------------------------- | | USE.TS | correspond to\nts-loader | | USE.CSS | correspond to css-loader | | USE.LESS | correspond to\nless-loader | | USE.SASS | correspond to sass-loader | | USE.PUG | correspond to\npug-loader | | USE.TOML | correspond to toml-loader | | USE.YAML | correspond to\nyaml-loader | | USE.FILE | correspond to file-loader | | USE.URL | correspond to\nurl-loader | | USE.SVGR | correspond to @svgr/webpack | | USE.BABEL | correspond\nto babel-loader | | USE.STYLE | correspond to style-loader | | USE.POSTCSS |\ncorrespond to postcss-loader | | USE.MARKDOWN | correspond to markdown-loader |\n| USE.CSS_MODULES_TS | correspond to css-modules-typescript-loader | |\nUSE.MINI_CSS_EXTRACT | correspond to mini-css-extract-plugin.loader |\n\n\nCHAIN_ID.PLUGIN\n\nPLUGIN.XXX can match a certain webpack plugin.\n\n| ID | Description | | ------------------------------ |\n--------------------------------------------------------------------------------\n------------------------------ | | PLUGIN.HMR | correspond to\nHotModuleReplacementPlugin | | PLUGIN.COPY | correspond to CopyWebpackPlugin | |\nPLUGIN.HTML | correspond to HtmlWebpackPlugin, you need to splice the entry name\nwhen using: ${PLUGIN.HTML}-${entryName} | | PLUGIN.DEFINE | correspond to\nDefinePlugin | | PLUGIN.IGNORE | correspond to IgnorePlugin | | PLUGIN.BANNER |\ncorrespond to BannerPlugin | | PLUGIN.PROGRESS | correspond to Webpackbar | |\nPLUGIN.APP_ICON | correspond to AppIconPlugin | | PLUGIN.LOADABLE | correspond\nto LoadableWebpackPlugin | | PLUGIN.MANIFEST | correspond to\nWebpackManifestPlugin | | PLUGIN.TS_CHECKER | correspond to\nForkTsCheckerWebpackPlugin | | PLUGIN.INLINE_HTML | correspond to\nInlineChunkHtmlPlugin | | PLUGIN.BUNDLE_ANALYZER | correspond to\nWebpackBundleAnalyzer | | PLUGIN.BOTTOM_TEMPLATE | correspond to\nBottomTemplatePlugin | | PLUGIN.MINI_CSS_EXTRACT | correspond to\nMiniCssExtractPlugin | | PLUGIN.REACT_FAST_REFRESH | correspond to\nReactFastRefreshPlugin | | PLUGIN.NODE_POLYFILL_PROVIDE | correspond to\nProvidePlugin for node polyfills | | PLUGIN.INSPECTOR | correspond to\n@modern-js/inspector-webpack-plugin | | PLUGIN.SUBRESOURCE_INTEGRITY |\ncorrespond to webpack-subresource-integrity | | PLUGIN.ASSETS_RETRY | correspond\nto webpack static asset retry plugin in Builder | | PLUGIN.AUTO_SET_ROOT_SIZE |\ncorrespond to automatically set root font size plugin in Builder |\n\n\nCHAIN_ID.MINIMIZER\n\nMINIMIZER.XXX can match a certain minimizer.\n\n| ID | Description | | ------------------- |\n----------------------------------------- | | MINIMIZER.JS | correspond to\nTerserWebpackPlugin | | MINIMIZER.CSS | correspond to CssMinimizerWebpackPlugin\n| | MINIMIZER.ESBUILD | correspond to ESBuildPlugin | | MINIMIZER.SWC |\ncorrespond to SwcWebpackPlugin |\n\n\nExamples\n\nThe following are some common configuration examples, see the full webpack-chain\nAPI webpack-chain documentation.\n\nAdd/Modify/Delete loader\n\nexport default {\n  tools: {\n    webpackChain: (chain, { CHAIN_ID }) => {\n      // Add loader\n      chain.module\n        .rule('md')\n        .test(/\\.md$/)\n        .use('md-loader')\n        .loader('md-loader');\n\n      // Modify loader\n      chain.module\n        .rule(CHAIN_ID.RULE.JS)\n        .use(CHAIN_ID.USE.BABEL)\n        .tap(options => {\n          options.plugins.push('babel-plugin-xxx');\n          return options;\n        });\n\n      // Delete loader\n      chain.module.rule(CHAIN_ID.RULE.JS).uses.delete(CHAIN_ID.USE.BABEL);\n    },\n  },\n};\n\n\nAdd/Modify/Delete plugin\n\nexport default {\n  tools: {\n    webpackChain: (chain, { webpack, CHAIN_ID }) => {\n      // Add plugin\n      chain.plugin('custom-define').use(webpack.DefinePlugin, [\n        {\n          'process.env': {\n            NODE_ENV: JSON.stringify(process.env.NODE_ENV),\n          },\n        },\n      ]);\n\n      // Modify plugin\n      chain.plugin(CHAIN_ID.PLUGIN.HMR).tap(options => {\n        options[0].fullBuildTimeout = 200;\n        return options;\n      });\n\n      // Delete plugin\n      chain.plugins.delete(CHAIN_ID.PLUGIN.HMR);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"webpackChain"}},{"id":184,"title":"tools.webpack","routePath":"/en/configure/app/tools/webpack","lang":"en","toc":[{"id":"object-type","text":"Object Type","depth":3},{"id":"function-type","text":"Function Type","depth":3},{"id":"utils","text":"Utils","depth":3},{"id":"env","text":"env","depth":4},{"id":"isprod","text":"isProd","depth":4},{"id":"target","text":"target","depth":4},{"id":"isserver","text":"isServer","depth":4},{"id":"iswebworker","text":"isWebWorker","depth":4},{"id":"webpack","text":"webpack","depth":4},{"id":"htmlwebpackplugin","text":"HtmlWebpackPlugin","depth":3},{"id":"addrules","text":"addRules","depth":3},{"id":"prependplugins","text":"prependPlugins","depth":3},{"id":"appendplugins","text":"appendPlugins","depth":3},{"id":"removeplugin","text":"removePlugin","depth":3},{"id":"mergeconfig","text":"mergeConfig","depth":3}],"domain":"","content":"\n\nTIP\n\nThis config is provided by Modern.js Builder, more detail can see tools.webpack.\n\n * Type: Object | Function | undefined\n * Default: undefined\n * Bundler: only support webpack\n\ntools.webpack is used to configure webpack。\n\n> tools.webpackChain is also used to modify the webpack configuration, and the\n> function is more powerful. It is recommended to use tools.webpackChain first.\n\n\nObject Type\n\nYou can configure it as an object, which will be merged with the original\nwebpack configuration through webpack-merge. For example:\n\nexport default {\n  tools: {\n    webpack: {\n      resolve: {\n        alias: {\n          '@util': 'src/util',\n        },\n      },\n    },\n  },\n};\n\n\n\nFunction Type\n\nYou can also configure it as a function, which accepts one parameter, the\noriginal webpack configuration, you can modify this configuration, and then\nreturn a new configuration. For example:\n\nexport default {\n  tools: {\n    webpack: config => {\n      config.resolve.alias['@util'] = 'src/util';\n      return config;\n    },\n  },\n};\n\n\nThe second parameter of this function is an object that contains some\ninformation about the tool collection. Details are as follows:\n\n\nUtils\n\nenv\n\n * Type: 'development' | 'production' | 'test'\n\nThe env parameter can be used to determine whether the current environment is\ndevelopment, production or test. For example:\n\nexport default {\n  tools: {\n    webpack: (config, { env }) => {\n      if (env === 'development') {\n        config.devtool = 'cheap-module-eval-source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\nisProd\n\n * Type: boolean\n\nThe isProd parameter can be used to determine whether the current environment is\nproduction. For example:\n\nexport default {\n  tools: {\n    webpack: (config, { isProd }) => {\n      if (isProd) {\n        config.devtool = 'source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\ntarget\n\n * Type: 'web' | 'node' | 'modern-web' | 'web-worker'\n\nThe target parameter can be used to determine the current target. For example:\n\nexport default {\n  tools: {\n    webpack: (config, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisServer\n\n * Type: boolean\n\nDetermines whether the target environment is node, equivalent to target ===\n'node'.\n\nexport default {\n  tools: {\n    webpack: (config, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisWebWorker\n\n * Type: boolean\n\nDetermines whether the target environment is web-worker, equivalent to target\n=== 'web-worker'.\n\nexport default {\n  tools: {\n    webpack: (config, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nwebpack\n\n * Type: typeof import('webpack')\n\nThe webpack instance. For example:\n\nexport default {\n  tools: {\n    webpack: (config, { webpack }) => {\n      config.plugins.push(new webpack.ProgressPlugin());\n      return config;\n    },\n  },\n};\n\n\n\nHtmlWebpackPlugin\n\n * Type: typeof import('html-webpack-plugin')\n\nThe HtmlWebpackPlugin instance:\n\nexport default {\n  tools: {\n    webpackChain: (chain, { HtmlWebpackPlugin }) => {\n      console.log(HtmlWebpackPlugin);\n    },\n  },\n};\n\n\n\naddRules\n\n * Type: (rules: RuleSetRule | RuleSetRule[]) => void\n\nAdd additional webpack rules.\n\nFor example:\n\nexport default {\n  tools: {\n    webpack: (config, { addRules }) => {\n      // add a single rule\n      addRules({\n        test: /\\.foo/,\n        loader: require.resolve('foo-loader'),\n      });\n\n      // Add multiple rules as an array\n      addRules([\n        {\n          test: /\\.foo/,\n          loader: require.resolve('foo-loader'),\n        },\n        {\n          test: /\\.bar/,\n          loader: require.resolve('bar-loader'),\n        },\n      ]);\n    },\n  },\n};\n\n\n\nprependPlugins\n\n * Type: (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\nAdd additional plugins to the head of the internal webpack plugins array, and\nthe plugin will be executed first.\n\nexport default {\n  tools: {\n    webpack: (config, { prependPlugins, webpack }) => {\n      // add a single plugin\n      prependPlugins(\n        new webpack.BannerPlugin({\n          banner: 'hello world!',\n        }),\n      );\n\n      // Add multiple plugins\n      prependPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nappendPlugins\n\n * Type: (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\nAdd additional plugins at the end of the internal webpack plugins array, the\nplugin will be executed last.\n\nexport default {\n  tools: {\n    webpack: (config, { appendPlugins, webpack }) => {\n      // add a single plugin\n      appendPlugins([\n        new webpack.BannerPlugin({\n          banner: 'hello world!',\n        }),\n      ]);\n\n      // Add multiple plugins\n      appendPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nremovePlugin\n\n * Type: (name: string) => void\n\nRemove the internal webpack plugin, the parameter is the constructor.name of the\nplugin.\n\nFor example, remove the internal fork-ts-checker-webpack-plugin:\n\nexport default {\n  tools: {\n    webpack: (config, { removePlugin }) => {\n      removePlugin('ForkTsCheckerWebpackPlugin');\n    },\n  },\n};\n\n\n\nmergeConfig\n\n * Type: (...configs: WebpackConfig[]) => WebpackConfig\n\nUsed to merge multiple webpack configs, same as webpack-merge。\n\nexport default {\n  tools: {\n    webpack: (config, { mergeConfig }) => {\n      return mergeConfig(config, {\n        devtool: 'eval',\n      });\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"webpack"}},{"id":185,"title":"Configuring Modern.js","routePath":"/en/configure/app/usage","lang":"en","toc":[{"id":"configure-in-the-configuration-file","text":"Configure in the configuration file","depth":2},{"id":"modernconfigjs","text":"modern.config.js","depth":3},{"id":"modernconfigts-recommended","text":"modern.config.ts (recommended)","depth":3},{"id":"export-configuration-function","text":"Export Configuration Function","depth":3},{"id":"export-async-function","text":"Export Async Function","depth":3},{"id":"specify-the-configuration-file","text":"Specify the Configuration File","depth":3},{"id":"configure-in-packagejson-not-recommended","text":"Configure in package.json (not recommended)","depth":2},{"id":"note","text":"Note","depth":3},{"id":"debug-configuration-locally","text":"Debug configuration locally","depth":2},{"id":"example","text":"Example","depth":3},{"id":"note-1","text":"Note","depth":3}],"domain":"","content":"\n\nThere are two configurations in the Modern.js, a compile configuration and a\nserver runtime configuration.\n\nThe compile configuration can be configured in two places:\n\n * modern.config.(ts|js|mjs) file in the root path\n * package.json file\n\nINFO\n\nConfigurations in both package.json and modern.config.ts file are not supported\nfor the same configuration. Configuration in modern.config.ts is recommended.\n\nServer runtime configuration can be configured in the\nmodern.server-runtime.config.(ts|js|mjs) file in the root path.\n\n\nConfigure in the configuration file\n\nModern.js configuration files are defined in the root path of the project, and\nsupports .js, .ts and .mjs formats:\n\n * modern.config.js\n * modern.config.ts\n * modern.config.mjs\n\n\nmodern.config.js\n\nYou can use JavaScript syntax in the modern.config.js file and it is more\nflexible than in the package.json file.\n\nFor example, you can define configuration options for function types in\nmodern.config.js:\n\nexport default {\n  source: {\n    alias: opts => {\n      opts['@common'] = './src/common';\n    },\n  },\n};\n\n\nYou can also dynamically set it with process.env.NODE _ENV:\n\nexport default {\n  server: {\n    ssr: process.env.NODE_ENV === 'development',\n  },\n};\n\n\n\nmodern.config.ts (recommended)\n\nWe recommend using configuration files in .ts format, which provides friendly\nTypeScript type hints to help you avoid configuration errors.\n\nImport the defineConfig tool function from @modern-js/app-tools, which will help\nyou with configuration type derivation and type completion:\n\n\n\nexport default defineConfig({\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n});\n\n\n\nExport Configuration Function\n\nModern.js supports exporting a function in the configuration file, and you can\ndynamically compute the configuration in the function and return it to\nModern.js.\n\n\n\nexport default defineConfig(({ env, command }) => ({\n  source: {\n    alias: {\n      '@foo': env === 'development' ? './src/foo.dev.ts' : './src/foo.prod.ts',\n    },\n  },\n}));\n\n\nThis function takes the following parameters:\n\n * env: same as the value of process.env.NODE_ENV.\n   * When running modern dev or modern start, the value of env is development.\n   * When running modern build or modern serve, the value of env is production.\n   * When running modern test, the value of env is test.\n * command: corresponds to the currently running command, such as dev, start,\n   build, serve.\n\n\nExport Async Function\n\nModern.js also supports exporting an asynchronous function in the configuration\nfile, you can perform some asynchronous operations in the function:\n\n\n\nexport default defineConfig(async ({ env, command }) => {\n  const result = await someAsyncFunction();\n\n  return {\n    html: {\n      title: result,\n    },\n  };\n});\n\n\n\nSpecify the Configuration File\n\nYou can specify the name of the configuration file using the --config option.\n\nFor example, if you need to use the modern.prod.config.js file when running\nbuild, you can add the following scripts to package.json:\n\n{\n  \"scripts\": {\n    \"dev\": \"modern dev\",\n    \"build\": \"modern build --config modern.prod.config.js\"\n  }\n}\n\n\nYou can also abbreviate the --config option to -c:\n\n$ modern build -c modern.prod.config.js\n\n\n\nConfigure in package.json (not recommended)\n\nIn addition to configuration files, configuration options can also be set the\nmodernConfig field in the package.json, such as:\n\n{\n  \"modernConfig\": {\n    \"source\": {\n      \"alias\": {\n        \"@common\": \"./src/common\"\n      }\n    }\n  }\n}\n\n\nDue to the limitation of the JSON file format, only simple types such as\nnumbers, strings, boolean values, arrays, etc. can be defined in package.json.\nWhen we need to set the value of the function type, it is recommended to set it\nin the Modern.js configuration file.\n\n\nNote\n\n * It is not recommended to use both package.json and modern.config.t[j]s for\n   configuration. If both are used and a configuration conflict occurs,\n   Modern.js will prompt error on the command line.\n * @modern-js/runtime exports the defineConfig API of the same name, please pay\n   attention to the distinction.\n\n\nDebug configuration locally\n\nTo facilitate local debugging configuration locally, Modern.js supports creating\nmodern.config.local.(ts|js|mjs) files in the root directory of the project to\noverride modern.config.(ts|js|mjs) configurations.\n\n\nExample\n\nFor example, the port number is configured as 3000 in modern.config.ts:\n\n\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n  },\n});\n\n\nIf you need to change the port number to 3001 to debugging locally, but you\ndon't want to change the modern.config.ts file of the current project, you can\ncreate a modern.config.local.ts file and add the following configuration:\n\n\n\nexport default defineConfig({\n  server: {\n    port: 3001,\n  },\n});\n\n\nThe configuration in the modern.config.local.ts file will be deep merged with\nthe configuration in modern.config.ts and override the configurations in\nmodern.config.ts, so server.port will be is overridden by 3001.\n\n\nNote\n\nWhen using modern.config.local.ts, please note the following:\n\n * The modern.config.local.ts file is only loaded when running modern dev or\n   modern start commands, and will not be loaded when running modern build.\n * The modern.config.local.ts file overrides not only over modern.config.ts, but\n   also the modernConfig field in package.json.\n * As modern.config.local.ts is only used for local debugging, it is not\n   recommended to commit it to the repository, please ensure that the project's\n   .gitignore file contains modern.config.local.ts.\n\nmodern.config.local.ts\nmodern.config.local.js\nmodern.config.local.mjs\n","frontmatter":{"sidebar_position":0}},{"id":186,"title":"Use Proxy","routePath":"/en/guides/advanced-features/bff/bff-proxy","lang":"en","toc":[],"domain":"","content":"\n\nBy configuring the BFF proxy, API requests can be forwarded without manual\ncoding\n\nCAUTION\n\nUsing a BFF proxy ensures that requests can enter the BFF handler. (eg the\nrequest path must contain a bff prefix)\n\nWriting the following BFF proxy configuration in the\nmodern.server-runtime.config.js file will proxy requests sent to\nhttp://localhost:8080/api/v1/topics to https://cnodejs.org/api/v1/topics.\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api/v1/topics': 'https://cnodejs.org',\n    },\n  },\n};\n\n\nNOTE\n\nFor more detail, see bff.proxy. For more proxy info, see Proxy.","frontmatter":{"sidebar_position":5,"title":"Use Proxy"}},{"id":187,"title":"Frameworks","routePath":"/en/guides/advanced-features/bff/frameworks","lang":"en","toc":[{"id":"function-writing","text":"Function Writing","depth":2},{"id":"framework-writing","text":"Framework Writing","depth":2},{"id":"express","text":"Express","depth":3},{"id":"koa","text":"Koa","depth":3}],"domain":"","content":"\n\nModern.js's BFF supports different runtime frameworks, currently Modern.js's BFF\nsupports two runtime frameworksExpress.js 和 Koa.js.\n\n\nFunction Writing\n\nUnder the function writing, only the middleware writing method of various\nruntime frameworks is different, and other implementations are basically the\nsame. Take Express as an example to introduce how to write a middleware by hand\nin the api/_ app.ts and add permission verification:\n\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(async (req: Request, res: Response, next: NextFunction) => {\n    if (req.url !== '/api/login') {\n      const sid = req?.cookies?.sid;\n      if (!sid) {\n        res.status(400);\n        res.json({ code: -1, message: 'need login' });\n      } else {\n        next();\n      }\n    } else {\n      next();\n    }\n  });\n});\n\n\nThen add a normal BFF function /api/hello.ts:\n\nexport default async () => {\n  return 'Hello Modern.js';\n};\n\n\nFinally, add the access code of the interface in the front-end src/App.tsx, and\ncall it directly in an integrated way:\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    async function fetchMyApi() {\n      const { message } = await hello();\n      setText(message);\n    }\n\n    fetchMyApi();\n  }, []);\n\n  return <p>{text}</p>;\n};\n\n\nThen exec pnpm run dev starts the project, and accessing http://localhost:8080/\nwill find that the request for'/api/hello 'is blocked:\n\n\n\nFinally, modify the front-end code src/App.tsx to call the login interface\nbefore accessing /api/hello:\n\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    async function fetchAfterLogin() {\n      const { code } = await login();\n      if (code === 0) {\n        const { message } = await hello();\n        setText(message);\n      }\n    }\n    fetchAfterLogin();\n  }, []);\n\n  return <p>{text}</p>;\n};\n\n\nRefresh the page and you can see that /api/hello was accessed successfully:\n\n\n\nThe above code simulates the way to add middleware to the /api/_app.ts to\nachieve an easy login function. Also, other functions can be implemented in this\nhook file to extend BFF Server.\n\n\nFramework Writing\n\nUnder the framework writing, Modern.js does not collect middleware in the\napi/_app.ts, and the running process is controlled by the plugin itself.\n\n\nExpress\n\nThe framework writing of Express supports defining the startup logic of API\nServer in api/app.[tj]s. performing the initialization work of the application,\nadding global middleware, declaring routes, and even extending the original\nframework.\n\nThe route defined by the BFF function will be registered after the route defined\nby the app.ts file, so here you can also intercept the route defined by the BFF\nfunction, preprocess or respond in advance.\n\n\n\nconst app = express();\n\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n\napp.use(async (req, res, next) => {\n  console.info(`access url: ${req.url}`);\n  next();\n});\n\nexport default app;\n\n\n\nKoa\n\nThe Koa framework is written in a similar way to Express. It supports defining\nthe startup logic of API Server in app.[tj]s, performing the initialization work\nof the application, adding global middleware, declaring routes, extending the\noriginal framework, etc.\n\nThe route defined by the BFF function will be registered after the route defined\nby the app.ts file, so here you can also intercept the route defined by the BFF\nfunction, preprocess or respond in advance.\n\nCAUTION\n\nUse the framework writing, when there is no app.ts, Modern.js will add koa-body\nby default. When there is app.ts, if the developer wants to use the BFF function\nwith Body, he needs to ensure that the koa-body middleware has been added.\n\n\n\nconst app = new Koa();\n\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n\napp.use(async (ctx, next) => {\n  console.info(`access url: ${ctx.url}`);\n  await next();\n});\n\nexport default app;\n","frontmatter":{"sidebar_position":3,"title":"Frameworks"}},{"id":188,"title":"Basic Usage","routePath":"/en/guides/advanced-features/bff/function","lang":"en","toc":[{"id":"enable-bff","text":"Enable BFF","depth":2},{"id":"bff-function","text":"BFF Function","depth":2},{"id":"api-routes","text":"API Routes","depth":2},{"id":"default-route","text":"Default Route","depth":3},{"id":"multi-layer-route","text":"Multi-layer Route","depth":3},{"id":"dynamic-route","text":"Dynamic Route","depth":3},{"id":"allow-list","text":"Allow List","depth":3},{"id":"restful-api","text":"RESTful API","depth":2},{"id":"function-named-export","text":"Function Named Export","depth":3},{"id":"function-parameter-rule","text":"Function Parameter Rule","depth":3},{"id":"dynamic-path","text":"Dynamic Path","depth":4},{"id":"requestoption","text":"RequestOption","depth":4}],"domain":"","content":"\n\nApplications developed with Modern.js can define API functions in the api/\ndirectory, which can be called by the front-end to send requests without writing\nfront and back-end glue layer code, At the same time, it ensures the type safety\nof the front and back end\n\n\nEnable BFF\n\n 1. Execute pnpm new and select \"Enable BFF\"\n 2. Add the following code to modern.config.[tj]s according to the chosen\n    runtime framework：\n\n\n\n\nexport default defineConfig({\n  plugins: [expressPlugin(), bffPlugin()],\n});\n\n\n\n\n\nexport default defineConfig({\n  plugins: [koaPlugin(), bffPlugin()],\n});\n\n\n\nBFF Function\n\nThe functions that are allowed to be called through integration are called BFF\nfunctions. Here is the simplest BFF function to write, creating an api/hello.ts\nfile:\n\nexport const get = async () => 'Hello Modern.js';\n\n\nThen directly import the function in src/App.tsx and call:\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    hello().then(setText);\n  }, []);\n  return <div>{text}</div>;\n};\n\n\nINFO\n\nModern.js generator has already configured the @api alias in tsconfig.json, so\nyou can import functions directly by aliases.\n\nThe functions import in src/App.tsx will be automatically converted into\ninterface calls, so there is no need to call the interface through fetch.\n\nExecute pnpm run dev, then open http://localhost:8080/ to see that the page has\ndisplayed the content returned by the BFF function. In Network, you can see that\nthe page sent a request to http://localhost:8080/api/hello.\n\n\n\n\nAPI Routes\n\nIn Modern.js, the BFF function routing system is implemented based on the file\nsystem, and it is also a conventional routing system.\n\nIn Function Writing, All files under api/ will map to an interface. In Framework\nWriting, All files under api/lambda will map to an interface\n\nNOTE\n\nFunction Writing & Framework Writing will introduce soon.\n\nAll routes generated by BFF functions have a prefix, and the default value is\n/api. The prefix can be set through [bff.prefix]\n(/docs/configure/app/bff/prefix).\n\nSeveral routing conventions are described as follow.\n\n\nDefault Route\n\nFiles named index.[jt]s are mapped to the previous directory.\n\n * api/index.ts -> {prefix}/\n * api/user/index.ts -> {prefix}/user\n\n\nMulti-layer Route\n\nSupports parsing nested files, if you create a nested folder structure, the\nfiles will still automatically parse routes in the same way.\n\n * api/hello.ts -> {prefix}/hello\n * api/user/list.ts -> {prefix}/user/list\n\n\nDynamic Route\n\nCreate folders or files named with [xxx] to support dynamic named routing\nparameters.\n\n * api/user/[username]/info.ts -> {prefix}/user/:username/info\n * api/user/username/[action].ts -> {prefix}/user/username/:action\n\n\nAllow List\n\nBy default, all files in the'api/'directory will be parsed as BFF function\nfiles, but the following files will not be parsed:\n\n * file name start with _, for example _utils.ts.\n * files in directory which name start with _, for example\n   _utils/index.ts、_utils/cp.ts.\n * test files, for example foo.test.ts.\n * type files, for example hello.d.ts.\n * files in node_module.\n\n\nRESTful API\n\nModern.js BFF functions need to be defined according to the RESTful API\nstandard, follow the HTTP Method specification, and do not allow free parameter\ndefinition.\n\nINFO\n\nAssuming that the function allows free definition of parameters, the resulting\nroute must be called by the private protocol (the reason is that the request\nparameters cannot be distinguished from the request body), and cannot implement\nany RESTful API.\n\nIf the service is only used for the application itself, there is no problem. but\nits non-standard interface definition cannot be integrated into the larger\nsystem. In the case of multiple systems working together (such as BFF low-code\nconstruction), other systems also need to follow the private protocol.\n\n\nFunction Named Export\n\nModern.js the export name of the BFF function determines the Method of the\ncorresponding interface of the function, such as get, post and so on.\n\nFor example, following the example, a GET interface can be exported.\n\nexport const get = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\nFollowing the example below, a POST interface can be exported.\n\nexport const post = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n * Modern.js supports 9 definitions for HTTP Method:\n   GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTION、HEAD, can be exported using\n   these methods as functions.\n\n * The name is size insensitive，if GET，can write get、Get、GEt、GET，can be\n   accurately identified. But default export as export default xxx will be map\n   to Get.\n\n * Multiple functions of different Methods can be defined in one file, but if\n   multiple functions of the same Method are defined, only the first will take\n   effect.\n\nINFO\n\nIt should be noted that the defined functions should all be asynchronous, which\nis related to the type when the function is called, which will be mentioned\nlater.\n\n\nFunction Parameter Rule\n\nAs mentioned above, in order to meet the design criteria of RESTful APIs, the\nBFF function in Modern.js needs to follow certain imported parameter rules.\n\nThe function parameters are divided into two parts, the dynamic part in the\nrequest path and the request option RequestOption.\n\nDynamic Path\n\nDynamic routing will be used as imported parameters in the first part of the\nfunction, and each imported parameter corresponds to a dynamic route. For\nexample, in the following example, uid will be passed into the function as the\nfirst two parameters:\n\nexport default async (level: number, id: number) => {\n  const userData = await queryUser(level, uid);\n  return userData;\n};\n\n\nPass dynamic parameters directly when calling:\n\n\n\n\nexport default () => {\n  const [name, setName] = useState('');\n\n  useEffect(() => {\n    getUser(6, 001).then(userData => setName(userData.name));\n  }, []);\n\n  return <div>{name}</div>;\n};\n\n\nRequestOption\n\nThe parameter after Dynamic Path is the object RequestOption containing\nquerystring and request body, which is used to define the types of data and\nquery.\n\nIn normal functions without dynamic routing, the incoming data and query can be\nobtained from the first imported parameter, for example:\n\n\n\nexport async function post({\n  query,\n  data,\n}: RequestOption<Record<string, string>, Record<string, string>>) {\n  // do somethings\n}\n\n\nWhen a function file uses dynamic routing rules, dynamic routing before the\nRequestOption parameter.\n\nexport async function post(\n  sku: string,\n  id: string,\n  {\n    data,\n    query,\n  }: RequestOption<Record<string, string>, Record<string, string>>,\n) {\n  // do somethings\n}\n\n\nAlso pass in the parameters according to the function definition:\n\n\n\nexport default () => {\n  const addSku = () => {\n    post('0001' /* sku */, '1234' /* id */, {\n      query: {\n        /* ... */\n      },\n      data: {\n        /* ... */\n      },\n    });\n  };\n\n  return <div onClick={addSku}>添加 SKU</div>;\n};\n\n\nAs mentioned earlier, the defined functions should be asynchronous because they\nare automatically converted to HTTP interface calls when called by the front\nend.\n\nso in order to keep the type definition consistent with the actual calling, it\nis necessary to set the BFF function to asynchronous when defining it.","frontmatter":{"sidebar_position":1,"title":"Basic Usage"}},{"id":189,"title":"BFF","routePath":"/en/guides/advanced-features/bff/","lang":"en","toc":[],"domain":"","content":"\n\nIn the development of the concept of front back separation, the front-end part\ncan do more and more things, and the front-end needs some UI-oriented data\ninterfaces, so the industry introduced the concept of BFF (Backends for\nFrontends).\n\nThe main problems it to solve include:\n\n * Aggregation, mapping, clipping, and proxying of lower-level APIs according to\n   their own business needs.\n * Cache data for some specific scenarios to improve performance and thus\n   improve user experience.\n * Quickly development of new products based on existing interfaces.\n * Interface with third-party systems, such as login authentication.\n\nModern.js officially supported the BFF and provided the Integrated BFF to\nfurther strengthen the BFF's capabilities, mainly including the following\ncapabilities:\n\n * Quick development and debugging go live, running, building, and deploying BFF\n   code in the same project.\n * Minimal pure function call, directly import BFF function on the front end,\n   and can be automatically converted into HTTP request when called.\n * No private protocol, follow RESTful API specification, all BFF interfaces are\n   standardized.\n * Full TypeScript support.\n * Meet user preferences and support multi-frame extension writing.","frontmatter":{"title":"BFF"}},{"id":190,"title":"Writing Type","routePath":"/en/guides/advanced-features/bff/type","lang":"en","toc":[{"id":"function-writing","text":"Function Writing","depth":2},{"id":"framework-writing","text":"Framework Writing","depth":2}],"domain":"","content":"\n\nRuntime framework support is also an important part of BFF. Modern.js supports\nextending BFF's runtime framework through plugins, and provides a series of\nbuilt-in plugins, developers can directly use the conventions and ecology of the\nframework.\n\nThe plugin is compatible with most of the specifications of these frameworks,\nand each framework needs to provide two types of ways to extend the writing of\nBFF functions, namely Function Writing and Framework Writing.\n\nNOTE\n\nWhether the current api/ directory structure is written as a framework is\ndetermined by the corresponding plugin, Modern.js don't care.\n\n\nFunction Writing\n\nWhen the plugin considers that it is currently written as a function, it must\nsupport writing middleware in the api/_ app.ts to extend the BFF function.\n\nModern.js collects the middleware in the api/_app.ts and passes it to the\nplugin, which injects the middleware into the runtime, for example:\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(myMiddleware);\n});\n\n\nNOTE\n\nThe writing of middleware for different plugins is not the same, see Runtime\nFramework for details.\n\n\nFramework Writing\n\nFramework writing is a way of using frame structure to extend BFF functions.\nCompared with function writing, although frame writing can use more frame\nstructure and make the entire BFF Server clearer in complex scenarios, it is\nalso more complex and requires more attention to the content at the framework\nlevel.\n\nIn the framework writing method, all BFF functions need to be written in the\napi/lambda/ directory, and the hook file _app.[tj]s cannot be used.\n\nIn most cases, the function writing method can cover the customization\nrequirements of most BFF functions. Only when your project server level logic is\nmore complex, the code needs to be layered, or you need to use more elements of\nthe framework, you need to use the framework writing method.\n\nNOTE\n\nThe directory structure of different plugin frameworks is not the same, see\nRuntime Frameworks for details.","frontmatter":{"sidebar_position":2,"title":"Writing Type"}},{"id":191,"title":"Code Split","routePath":"/en/guides/advanced-features/code-split","lang":"en","toc":[{"id":"import","text":"import","depth":2},{"id":"reactlazy","text":"React.lazy","depth":2},{"id":"loadable","text":"loadable","depth":2}],"domain":"","content":"\n\nCode Split is a common way to optimizing front-end resource loading. This doc\nwill introduce three methods supported by Modern.js:\n\nINFO\n\nWhen you use Modern.js Conventional routing, by default it will do code\nsplitting based on routing components, wrapping Suspense components, no need to\ndo code splitting by yourself.\n\n * import\n * React.lazy\n * loadable\n\n\nimport\n\nuse dynamic import()，import The JS modules pass to this API will be packaged\ninto a separate JS file as a new packaging entry, for example:\n\nimport('./math').then(math => {\n  console.log(math.add(16, 26));\n});\n\n\nThe JS modules corresponding to the './math' path will be packaged in a separate\nJS file.\n\n\nReact.lazy\n\nThe officially way provides by React to split component code.\n\nCAUTION\n\nSSR is not supported in React 17 and below, and it is recommended that SSR\napplications for React 17 use loadable.\n\n\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <section>\n          <OtherComponent />\n          <AnotherComponent />\n        </section>\n      </Suspense>\n    </div>\n  );\n}\n\n\nFor detail, see React lazy.\n\n\nloadable\n\nuse loadable API，for example：\n\n\n\nconst OtherComponent = loadable(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return <OtherComponent />;\n}\n\n\nFor detail, see loadable API.\n\nINFO\n\nSSR is supported out of the box by loadable.","frontmatter":{"title":"Code Split","sidebar_position":6}},{"id":192,"title":"Compatibility","routePath":"/en/guides/advanced-features/compatibility","lang":"en","toc":[{"id":"browserslist","text":"Browserslist","depth":2},{"id":"polyfill","text":"Polyfill","depth":2},{"id":"polyfill-at-compile","text":"Polyfill At Compile","depth":3},{"id":"polyfill-at-runtime","text":"Polyfill At Runtime","depth":3}],"domain":"","content":"\n\n\nBrowserslist\n\nModern.js supports the browserslist field in the package.json file, or a\n.browserslistrc file to specify the target browser range covered by the project.\n\nThis value is used by ['@babel/preset-env']\n(https://babeljs.io/docs/en/babel-preset-env) and ['autoprefixer']\n(https://github.com/postcss/autoprefixer) to determine the JavaScript syntax\nfeatures to be converted and the CSS browser prefix to be added.\n\nThe default value in Modern.js as follow:\n\n['> 0.01%', 'not dead', 'not op_mini all'];\n\n\nYou can learn how to customize the browserslist here.\n\nSee Modern.js Builder docs to learn more Browserslist info.\n\nNOTE\n\nModern.js also supports configuring output.override Browserslist to override the\ndefault browserslist value.\n\n\nPolyfill\n\n\nPolyfill At Compile\n\nModern.js inject the Polyfill code via [core-js]\n(https://github.com/zloirock/core-js) at compile time by default.\n\nBy default, the required Polyfill code will be introduced according to the\nsettings of the Browserslist, so there is no need to worry about the Polyfill\nproblem of the project source code and third-party dependencies, but because it\ncontains some Polyfill code that is not used, the final bundle size may be\nincreased.\n\nINFO\n\nFor case where Polyfill is not required for third-party dependencies, you can\nset 'output.polyfill' to usage, so that Babel compiles only Polyfill code based\non the syntax used in the code.\n\n\nPolyfill At Runtime\n\nModern.js also provides a runtime Polyfill solution based on browser UA\ninformation, which has the following advantages over Babel:\n\n * It will not be inserted into the code, reducing the code .\n * The same browser will share a Polyfill code. Therefore, with more and more\n   projects, the UA-based Polyfill code will be delivered faster and faster.\n\nexec pnpm run new to enable this features：\n\n? Action Enable features\n? Enable features Enable UA-based Polyfill Feature\n\n\nAfter executing the command, register the Polyfill plugin in modern.config.ts:\n\n\n\nexport default defineConfig({\n  plugins: [..., polyfillPlugin()],\n});\n\n\nAfter configuring output.polyfill as ua and executing pnpm run build & & pnpm\nrun serve to start the server, visiting the page can see that the HTML product\ncontains the following script:\n\n<script src=\"/__polyfill__\" crossorigin></script>\n\n\nVisit the page http://localhost:8080/__polyfill__ on Chrome 51 to see:\n\n\n\nCAUTION\n\nThis feature only works when using Modern.js built-in Web Server.","frontmatter":{"title":"Compatibility","sidebar_position":5}},{"id":193,"title":"ESLint","routePath":"/en/guides/advanced-features/eslint","lang":"en","toc":[{"id":"q-how-to-deal-with-lint","text":"Q: How To Deal With Lint","depth":2},{"id":"automatic-fix","text":"Automatic Fix","depth":3},{"id":"batch-automatic-fix","text":"Batch Automatic Fix","depth":3},{"id":"manual-fix","text":"Manual Fix","depth":3},{"id":"声明例外情况","text":"声明例外情况","depth":3},{"id":"q-如何自定义-eslint-规则","text":"Q: 如何自定义 ESLint 规则","depth":2},{"id":"仓库根目录下-packagejson-里的-eslintconfig-字段","text":"仓库根目录下 package.json 里的 \"eslintConfig\" 字段","depth":3},{"id":"srceslintrcjs-文件","text":"src/.eslintrc.js 文件","depth":3},{"id":"packagejson-里的-eslintignore-字段","text":"package.json 里的 eslintIgnore 字段","depth":3},{"id":"q-如何升级-eslint-插件的版本","text":"Q: 如何升级 ESLint 插件的版本","depth":2},{"id":"q-webstorm-有时候会报-eslint-错误","text":"Q: WebStorm 有时候会报 ESLint 错误","depth":2}],"domain":"","content":"\n\nModern.js ESLint Rules Is the full set of ESLint rules，includes @modern-js （Lint\nrules for Node.js projects）and @modern-js-app（Lint rules for web projects）。\n\nMore ESLint usage is described below with specific questions.\n\n\nQ: How To Deal With Lint\n\n\nAutomatic Fix\n\nMost problems will be solved by the automatic fix of ESLint rules or the code\nformatting of Prettier (which has been integrated into ESLint), and the\ndeveloper does not need to care about the details of the problem and how to\nsolve it.\n\nINFO\n\nThis kind of automatic fix is mainly performed when the IDE saves the file, and\na few will be automatically fix on submit.\n\n\nBatch Automatic Fix\n\n在少数情况下，比如旧项目迁移的时候，可以执行以下命令，批量修复和检查所有文件：\n\npnpm run lint:error\n\n\n\nManual Fix\n\n对于无法自动修复的问题，可以在 IDE 里点击问题提示框里的规则链接，打开这条规则的文档，查看问题的解释和解决方案。\n\n\n声明例外情况\n\n目前阶段，有些规则并不能做到足够智能，多数情况下会有很大收益，在少数情况下也许不适用。但如果为了这些少数情况就把整个规则关掉或改掉，得不偿失。\n\n这种情况下可以用 eslint-disable 注释，对符合少数情况的代码块做标注，声明这里是一个例外，应该忽略。比如：\n\n/* eslint-disable filenames/match-exported */\n...\n/* eslint-enable filenames/match-exported */\n\n\nINFO\n\n在 VS Code 编辑器里输入 eslint，会自动出现关于 \"eslint-disable\" 的提示框，选择提示选项生成对应注释对。\n\n【Modern.js ESLint 规则集】要求 eslint-disable\n必须成对使用，必须明确表达要影响的范围，以及在这个范围内明确表达要禁用什么规则，目的是让例外有明确的、最小化的范围，避免 eslint-disable\n被滥用，导致不属于例外的代码也被禁用了规则。\n\n\nQ: 如何自定义 ESLint 规则\n\n\n仓库根目录下 package.json 里的 \"eslintConfig\" 字段\n\n这个地方是整个仓库的默认 ESLint 配置，是针对纯 Node.js 代码（只能在 Node.js 里运行）设计的。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置。该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n \"eslintConfig\": {\n    \"extends\": [\n      \"@modern-js\"\n    ],\n    \"rules\": {\n      \"filenames/match-exported\": \"off\"\n    }\n  },\n\n\n\n\nsrc/.eslintrc.js 文件\n\nModern.js 的应用工程、模块工程，源代码目录里都会默认有这个配置文件，是针对 Universal JS 代码设计的。\n\nINFO\n\nUniversal JS 代码是既能浏览器端也能在服务器端运行的代码。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置，该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n// eslint-disable-next-line import/no-commonjs\nmodule.exports = {\n  root: true,\n  extends: ['@modern-js-app'],\n  parserOptions: {\n    tsconfigRootDir: __dirname,\n    project: ['../tsconfig.json'],\n  },\n  rules: {\n    'filenames/match-exported': 'off',\n  },\n};\n\n\n如果有需要，还可以继续在不同的子目录里增加 .eslintrc.js 文件，针对这个子目录里的代码做特殊配置：\n\nmodule.exports = {\n  rules: {\n    'filenames/match-exported': 'off',\n  },\n};\n\n\nTIP\n\n注意：没有必要使用 extends 字段，会自动继承父目录的配置。\n\n\npackage.json 里的 eslintIgnore 字段\n\n把包含 .js、.jsx、.ts、.tsx 文件、但不需要做代码检查和自动修复的目录，添加到 eslintIgnore 里，可以优化 ESLint\n检查的速度，比如：\n\n \"eslintIgnore\": [\n    \"node_modules\",\n    \"dist\",\n    \"output\"\n  ],\n\n\n\nQ: 如何升级 ESLint 插件的版本\n\n只要不是 Major 版本的变化（不符合 Semver 规则的 ^ 符号），就可以直接在业务项目的 package.json 里指定这个依赖，删除 Lock\n文件（或尝试手动删除 Lock 文件中这个包名的内容），执行 pnpm install 重新安装依赖并且生成新的 Lock 文件。\n\n做完这些操作之后，在业务项目的 ./node_modules 目录里，这个插件应该只存在一份，并且升级到了你指定的版本。\n\nTIP\n\n * Major 版本就是主版本号。更多信息，请阅读【Semantic Versioning】。\n * 所有被 Modern.js 封装的上游项目（比如 ESLint、ESLint 插件、React Router 等），也都可以这样升级。\n * Modern.js 也会在每次发版中尽量及时的升级这些上游依赖。\n * Major 版本的升级需要由 Modern.js 来发版。\n\n\nQ: WebStorm 有时候会报 ESLint 错误\n\n由于 WebStorm 认为 ESLint 执行目录是根据 .eslintrc 文件来决定的。因此 src/.eslintrc 文件位置的放置会导致\ntsconfig.json 文件指定的位置（项目根目录下）在 src/ 目录下找不到。\n\n此时需要手动配置一下：\n\n--parser-options=project:../tsconfig.json\n\n\n","frontmatter":{"title":"ESLint","sidebar_position":8}},{"id":194,"title":"Low-Level Tools","routePath":"/en/guides/advanced-features/low-level","lang":"en","toc":[{"id":"usage","text":"Usage","depth":2},{"id":"low-level-configuration-details","text":"Low-level Configuration Details","depth":2}],"domain":"","content":"\n\n\nUsage\n\nModern.js internally integrates tools such as Babel, TypeScript, Webpack,\nPostCSS, [Tailwind CSS] (https://tailwindcss.com/) by default.\n\nUsually, the default configuration can meet most development needs. When there\nare special needs, it can be achieved through the underlying configuration.\n\nTake configuring Webpack as an example, just add ['tools.webpack']\n(/docs/configure/app/tools/webpack) to the modern.config.ts:\n\nexport default defineConfig({\n  tools: {\n    webpack: config => {},\n  },\n});\n\n\nConfigurations in the tools can be set to Object or Function.\n\nWhen the value is Object, it will be merged with the default configuration. For\nthe specific merging strategy, refer to the configuration options document (see\ntable below).\n\nWhen the value is Function, the first parameter is the default configuration\nvalue. You can directly modify this object without returning it, or you can\nreturn a new object or a merged object as the final result.\n\n\nLow-level Configuration Details\n\nCurrently provided is as follows:\n\n| Tools | Config | | ----------------- |\n--------------------------------------------------------------------- | |\nDevServer | tools.devServer | | Babel | tools.babel | | styled-components |\ntools.styledComponents | | PostCSS | tools.postcss | | Less | tools.less | |\nSass | tools.sass | | webpack | tools.webpack | | Minify CSS | tools.minifyCss |\n| terser | tools.terser | | Tailwind CSS | tools.tailwind | | Autoprefixer |\ntools.autoprefixer |","frontmatter":{"title":"Low-Level Tools","sidebar_position":11}},{"id":195,"title":"Static Site Generation","routePath":"/en/guides/advanced-features/ssg","lang":"en","toc":[{"id":"conventional-routing","text":"Conventional Routing","depth":3},{"id":"self-controlled-routing","text":"Self-controlled Routing","depth":3}],"domain":"","content":"\n\nStatic Site Generation is a solution for rendering complete static web pages at\nbuild time based on data and templates.\n\nFirst need to execute pnpm run new to enable the SSG features:\n\n? Action Enable features\n? Enable features Enable SSG\n\n\nAfter execute script，register SSG plugin in modern.config.ts:\n\n\n\nexport default defineConfig({\n  output: {\n    ssg: true,\n  },\n  plugins: [..., ssgPlugin()],\n});\n\n\nSSG in Conventional Routing and Self-controlled Routing has different usage.\n\n\nConventional Routing\n\nModern.js generate routes based on the file structure under the entry, so the\nframework can collect complete routing information.\n\nFor example, the following is a project directory structure using conventional\nrouting:\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\nThe above file directory will generate the following three routes:\n\n * /\n * /user\n * /user/profile\n\nNOTE\n\nIf you don't know the rules for routing, you can first check routes.\n\nadd component to src/routes/page.tsx：\n\nexport default () => {\n  return <div>Index Page</div>;\n};\n\n\nSSG is also render in Node.js. So we can enable SSR in developmenet env, expose\ncode problems in advance and verify SSG rendering effect：\n\nexport default defineConfig({\n  server: {\n    ssr: process.env.NODE_ENV === 'development',\n  }\n}\n\n\nExecute the pnpm run dev command in the project to view the dist/ directory, and\nonly generate an HTML file main/index.html.\n\nExecute the pnpm run build command in the root path of the project. After the\nconstruction is completed, view the dist/ directory, and generate\nmain/index.html, main/user/index.html and main/user/profile/index.html three\nHTML files, the content corresponds to the above three routes.\n\nUsing Conventional Routing, each route will generate a HTML file. Looking at the\nmain/index.html, we can find the text content containing the Index Page, which\nis exactly the effect of SSG.\n\nAfter executing pnpm run serve to start the project, visit the page in the\nNetwork, view the document returned by the request. The document contains the\ncomplete page content rendered by the component.\n\n\nSelf-controlled Routing\n\nSelf-controlled routing is a custom routing through component code, which\nrequires the application to run to obtain accurate routing information.\nTherefore, the SSG function cannot be used out of the box. At this time, the\nuser needs to inform the Modern.js framework in advance which routes need to\nenable the SSG.\n\nFor example, there is the following code, which contains multiple routes. When\nsetting output.ssg to true, only the entry route '/' will be rendered by\ndefault:\n\n\n\n\n\n\nconst Router = typeof window === 'undefined' ? StaticRouter : BrowserRouter;\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const pathname = context?.request?.pathname;\n  return (\n    <Router location={pathname}>\n      <Routes>\n        <Route index element={<div>index</div>} />\n        <Route path=\"about\" element={<div>about</div>} />\n      </Routes>\n    </Router>\n  );\n};\n\n\nIf we want to enable the SSG of /about at the same time, we can configure the\noutput.ssg to tell Modern.js to enable the SSG of the specified route.\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: ['/', '/about'],\n    },\n  },\n});\n\n\nrun pnpm run build and pnpm run serve，access http://localhost:8080/about. In the\nPreview view, you can see that the page has been rendered.\n\nLooking at the bundle file, a new main/about/index.html file has been added in\nthe dist/ directory.\n\nINFO\n\nThe above only introduces the single entry, more related content can be viewed\nSSG API.","frontmatter":{"title":"Static Site Generation","sidebar_position":4}},{"id":196,"title":"Server-side rendering","routePath":"/en/guides/advanced-features/ssr","lang":"en","toc":[{"id":"ssr-data-fetch","text":"SSR Data Fetch","depth":2},{"id":"keep-rendering-consistent","text":"Keep Rendering Consistent","depth":2},{"id":"concerned-memory-leaks","text":"Concerned Memory Leaks","depth":2},{"id":"crop-ssr-data","text":"Crop SSR Data","depth":2},{"id":"serverless-pre-render","text":"Serverless Pre-render","depth":2},{"id":"treeshaking","text":"Treeshaking","depth":2},{"id":"use-environment-variables","text":"Use Environment Variables","depth":3},{"id":"use-file-suffix","text":"Use File Suffix","depth":3},{"id":"independent-file","text":"Independent File","depth":3},{"id":"remote-request","text":"Remote Request","depth":2},{"id":"stream-ssr","text":"Stream SSR","depth":2}],"domain":"","content":"\n\nIn Modern.js, SSR also works out of the box. Developers do not need to write\ncomplex server level logic for SSR, nor do they need to care about the operation\nand maintenance of SSR, or create services. Modern.js have a comprehensive SSR\ndegradation strategy to ensure that pages can run safely.\n\nEnabling SSR is very easy, just set 'server.ssr' to true:\n\n{\n  \"server\": {\n    \"ssr\": true\n  }\n}\n\n\n\nSSR Data Fetch\n\nModern.js provides Data Loader, which is convenient for developers to fetch data\nunder SSR and CSR. Each routing module, such as layout.tsx and page.tsx, can\ndefine its own Data Loader:\n\nexport const loader = () => {\n  return {\n    message: 'Hello World',\n  };\n};\n\n\nin the component, the data returned by the loader function can be get data\nthrough the Hooks API:\n\nexport default () => {\n  const data = useLoaderData();\n  return <div>{data.message}</div>;\n};\n\n\nModern.js break the traditional SSR development model and provide users with a\nuser-friendly SSR development experience.\n\nAnd it provides elegant degradation processing. Once the SSR request fails, it\nwill automatically downgrade and restart the request on the browser side.\n\nHowever, developers still need to pay attention to the fallback of data, such as\nnull values or data returns that do not as expect. Avoid React rendering errors\nor messy rendering results when SSR.\n\nINFO\n\nWhen using Data Loader, data fetching happens before rendering, Modern.js still\nsupports fetching data when the component is rendered. See Data Fetch.\n\n\nKeep Rendering Consistent\n\nIn some businesses, it is usually necessary to display different UI displays\naccording to the current operating container environment characteristics, such\nas UA information.\n\nIf the processing is not careful enough, the rendering results may do not meet\nthe expectations at this time.\n\nHere is an example to show the problem when SSR and CSR rendering are\ninconsistent, add the following code to the component:\n\n{\n  typeof window !== 'undefined' ? <div>browser content</div> : null;\n}\n\n\nAfter starting the app, visit the page and will find that the browser console\nthrows a warning message:\n\nWarning: Expected server HTML to contain a matching <div> in <div>.\n\n\nThis is caused by the inconsistency between the rendering result and the SSR\nrendering result when React executes the hydrate logic on the client side.\nAlthough the page performs normally, in complex applications, it is likely to\ncause problems such as DOM hierarchy confusion and style confusion.\n\nINFO\n\nFor hydrate logic, please refer to here.\n\nApplications need to maintain the consistency of SSR and CSR rendering results.\nIf there are inconsistencies, it means that this part of the content does not\nneed to be rendered in SSR.\n\nModern.js provide <NoSSR> for such content that does not need to be rendered in\nSSR:\n\n\n\nOutside of elements that do not require SSR, wrap with a NoSSR component:\n\n<NoSSR>\n  <div>client content</div>\n</NoSSR>\n\n\nAfter modifying the code, refresh page found that the previous Waring\ndisappeared. Open the Network window of the browser developer tool to see that\nthe returned HTML document does not contain the content of the NoSSR component\npackage.\n\nINFO\n\n'useRuntimeContext' can get complete request information, which can be used to\nensure that the rendering results of SSR and CSR are consistent.\n\n\nConcerned Memory Leaks\n\nWARNING\n\nIn the SSR, developers need to pay special attention to the problem of memory\nleaks. Even small memory leaks can affect services..\n\nIn SSR, every request triggers the component rendering. So, you need to avoid\ndefining any potentially growing global data, or subscribing to events globally,\nor creating streams that will not be destroyed.\n\nFor example, the following code, when using redux-observable, developers used to\ncode like this:\n\n\n\nconst epicMiddleware = createEpicMiddleware();\nconst rootEpic = combineEpics();\n\nexport default function Test() {\n  epicMiddleware.run(rootEpic);\n  return <div>Hello Modern.js</div>;\n}\n\n\nCreate a Middleware instance epicMiddleware outside the component and call\nepicMiddleware.run inside the component.\n\nOn the browser side, this code does not cause any problems. But in SSR, the\nMiddleware instance will never be destroyed. Every time the component is\nrendered and rootEpic is called, new event bindings are added internally,\ncausing the entire object to continue to grow larger, which ultimately affects\napplication performance.\n\nSuch problems in CSR are not easy to detect, so when switching from CSR to SSR,\nif you are not sure whether the application has such hidden dangers, you can\npress the application.\n\n\nCrop SSR Data\n\nIn order to keep the data requested in the SSR phase, it can be used directly on\nthe browser side, Modern.js inject the data and state that collected during the\nrendering process into the HTML.\n\nAs a result, CSR applications often have a large amount of interface data and\nthe state of the components is not crop. If SSR is used directly, the rendered\nHTML size may be too large.\n\nAt this time, SSR not only cannot bring an improvement in the user experience,\nbut may have the opposite effect.\n\nTherefore, when using SSR, developers need to do reasonable weight loss for the\napplication:\n\n 1. Pay attention to the first screen, you can only request the data needed for\n    the first screen in SSR, and render the rest on the browser side.\n 2. Removes the data independent with render from the data returned by the\n    interface.\n\n\nServerless Pre-render\n\nModern.js provide Serverless Pre-rendering(SPR) to improve SSR performance.\n\nSPR uses pre-rendering and caching to provide the responsive performance of\nstatic Web for SSR pages. It allows SSR applications to have the responsiveness\nand stability of static Web pages, while keeping data dynamically updated.\n\nUsing SPR in the Modern.js is very simple, just add the <PreRender> component,\nand the page where the component is located will automatically open SPR.\n\nThis mock a component that uses the useLoaderData API, and the request in the\nData Loader takes 2s.\n\n\n\nexport const loader = async () => {\n  await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(null);\n    }, 2000);\n  });\n\n  return {\n    message: 'Hello Modern.js',\n  };\n};\n\nexport default () => {\n  const data = useLoaderData();\n  return <div>{data?.message}</div>;\n};\n\n\nAfter executing the dev command and opening the page, it is obvious that the\npage needs to wait 2s before returning.\n\nThe next is to use the <PreRender> component, which can be exported directly\nfrom @modern-js/runtime/ssr :\n\n\n\nUse the PreRender component in the routing component and set the parameter\ninterval to indicate that the expiration time of the rendering result is 5s:\n\n<PreRender interval={5} />\n\n\nAfter modification, execute pnpm run build && pnpm run serve to start the\napplication and open the page.\n\nWhen open page for the first time, it is no different from the previous\nrendering, and there is also a 2s delay.\n\nRefresh page, and the page opens instantly, but at this time, the page data has\nnot changed due to the refresh, because the cache has not expired.\n\nWait 5s, refresh the page again, the data of the page is still unchanged.\nRefresh the page again The data changes, but the page still responds almost\ninstantaneously.\n\nThis is because in the previous request, the SPR has asynchronously obtained the\nnew rendering result in the background, and the page requested this time is the\nversion that has been cached in the server.\n\nIt is conceivable that when interval is set to 1, users can have the responsive\nexperience of a static page.\n\nINFO\n\nFor more detail, see <PreRender>.\n\n\nTreeshaking\n\nWhen SSR is enabled, Modern.js will use the same entry to build both the SSR\nBundle and the CSR Bundle. Therefore, the Web API in the SSR Bundle, or the Node\nAPI in the CSR Bundle, can lead to runtime errors.\n\nWeb API into a component is usually to do some global listening, or to get\nbrowser-related data, such as:\n\ndocument.addEventListener('load', () => {\n  console.log('document load');\n});\nconst App = () => {\n  return <div>Hello World</div>;\n};\nexport default App;\n\n\nThe Node API is introduced in the component file, usually because of the use of\nData Loader, for example:\n\n\nexport const loader = () => {\n  const file = fse.readFileSync('./myfile');\n  return {\n    ...\n  };\n};\n\n\n\nUse Environment Variables\n\nFor the first case, we can directly use Modern.js built-in environment variables\nMODERN_TARGET to remove useless code at build time:\n\nif (process.env.MODERN_TARGET === 'browser') {\n  document.addEventListener('load', () => {\n    console.log('document load');\n  });\n}\n\n\nNOTE\n\nFor more information, see environment variables.\n\n\nUse File Suffix\n\nIn the second case, the Treeshaking method does not guarantee that the code is\ncompletely separated. Modern.js also supports the packaging file of SSR Bundle\nand CSR Bundle products through the file suffixed with .node..\n\nFor example, the import of fs-extra in the code, when it is directly referenced\nto the component, will cause the CSR to load an error. You can create .ts and\n.node.ts files of the same name as a layer of proxy:\n\nexport const readFileSync: any = () => {};\n\n\nexport { readFileSync } from 'fs-extra';\n\n\nuse ./compat directly into the file. At this time, files with the .node.ts\nsuffix will be used first in the SSR environment, and files with the .ts suffix\nwill be used in the CSR environment.\n\n\n\nexport const loader = () => {\n  const file = readFileSync('./myfile');\n  return {\n    ...\n  };\n};\n\n\n\nIndependent File\n\nBoth of the above methods will bring some burden to the developer. Modern.js\nbased on Nested Routing developed and designed Data Fetch to separate CSR and\nSSR code.\n\n\nRemote Request\n\nWhen initiating remote requests in SSR, developers sometimes use request tools.\nSome interfaces need to pass user cookies, which developers can get through the\n'useRuntimeContext' API to achieve.\n\nIt should be noted, the request header of the HTML request is obtained, which\nmay not be applicable to remote requests, so must not pass through all request\nheaders.\n\nIn addition, some backend interfaces, or general gateways, will verify according\nto the information in the request header, and full pass-through is prone to\nvarious problems that are difficult to debug. It is recommended that\npass-through on demand.\n\nBe sure to filter the host field if you really need to pass through all request\nheaders.\n\n\nStream SSR\n\nModern.js supports streaming rendering in React 18, the default rendering mode\ncan be modified with the following configuration:\n\n{\n  \"server\": {\n    \"ssr\": {\n      \"mode\": \"stream\"\n    }\n  }\n}\n\n\nNOTE\n\nAt present Modern.js built-in data fetch does not support streaming rendering.\nIf app need it, developers can build it according to the demo of React Stream\nSSR.","frontmatter":{"title":"Server-side rendering","sidebar_position":3}},{"id":197,"title":"Testing","routePath":"/en/guides/advanced-features/testing","lang":"en","toc":[{"id":"test-file","text":"Test file","depth":2},{"id":"usage","text":"Usage","depth":2},{"id":"transform","text":"transform","depth":2}],"domain":"","content":"\n\nModern.js inherits the testing capabilities of Jest by default.\n\nFirst need to execute pnpm run new enable [unit test/integration test] features：\n\n? Action： Enable features\n? Enable features： Enable Unit Test / Integration Test\n\n\nAfter executing the above command, the \"test\": \"modern test\" command will be\nautomatically generated in package.json.\n\nregister plugin in modern.config.ts:\n\n\n\nexport default defineConfig({\n  plugins: [..., testPlugin()],\n});\n\n\n\nTest file\n\nModern.js default recognized test file paths are:\n<rootDir>/src/**/*.test.[jt]s?(x) and <rootDir>/tests/**/*.test.[jt]s?(x).\n\nIf you need to customize the test directory, you can configure it with\ntools.jest.\n\n\nUsage\n\nModern.js test support testing-library. API can be imported from\n@modern-js/runtime/testing.\n\n\n\nOther Modern.js supported testing APIs can be found here.\n\n\ntransform\n\nModern.js tests use babel-jest for source code compilation by default. If you\nneed to use ts-jest, you can configure it through testing.transform.","frontmatter":{"sidebar_position":10,"title":"Testing"}},{"id":198,"title":"Custom Web Server","routePath":"/en/guides/advanced-features/web-server","lang":"en","toc":[{"id":"创建自定义-web-server","text":"创建自定义 Web Server","depth":2},{"id":"使用-api-扩展-web-server","text":"使用 API 扩展 Web Server","depth":2},{"id":"hook","text":"Hook","depth":3},{"id":"middleware","text":"Middleware","depth":3},{"id":"完全自定义的-web-server","text":"完全自定义的 Web Server","depth":2}],"domain":"","content":"\n\nModern.js\n作为以客户端为中心的开发框架，对服务端的定制能力较弱。而在有些开发场景下，需要定制特殊的服务端逻辑，例如用户鉴权、请求预处理、添加页面渲染骨架等。\n\n因此 Modern.js 提供了一种功能，让项目可以在给定的范围内扩展 Modern.js 内置的 Web Server，来实现相应的需求。\n\n\n创建自定义 Web Server\n\n在项目根目录执行 pnpm run new 命令，按照如下选择，开启「自定义 Web Serve」功能：\n\n? 请选择你想要的操作 创建工程元素\n? 创建工程元素 新建「自定义 Web Server」源码目录\n\n\n执行命令后，在 modern.config.ts 中注册 Server 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., serverPlugin()],\n});\n\n\n项目目录下会新建 server/index.ts 文件，自定义逻辑在这个文件中编写。\n\n\n使用 API 扩展 Web Server\n\nModern.js 提供了 Hook 与 Middleware 两类 API 来扩展 Web Server。\n\n\nHook\n\nHook 可以控制 Web Server 对请求处理的内置逻辑，非 BFF 请求会经过 Hook 的处理。\n\nHook 不可以使用运行时框架拓展。\n\n详细 API 可以查看 Hook。\n\n\nMiddleware\n\nMiddleware 可以为 Web Server 添加前置中间件，只有 SSR 请求会经过 Middleware 的处理。\n\nMiddleware 可以使用运行时框架拓展。\n\n详细 API 可以查看 Hook。\n\n\n完全自定义的 Web Server\n\nNOTE\n\n敬请期待","frontmatter":{"title":"Custom Web Server","sidebar_position":2}},{"id":199,"title":"Alias","routePath":"/en/guides/basic-features/alias","lang":"en","toc":[],"domain":"","content":"\n\nModern.js allow aliases in JS and CSS，and the following aliases are built in:\n\n{\n  '@': '<appDirectory>/src',\n  '@shared': '<appDirectory>/shared',\n}\n\n\nINFO\n\nWhen the optional features is enable, the generator will also add built-in\naliases dynamically. For example, when BFF is enabled, the @api alias will be\nadded by default.\n\nFor example, import the modules from the src/common/ directory in the\nsrc/App.tsx file:\n\n.\n├── common\n│   ├── styles\n│   │   └── base.css\n│   └── utils\n│       └── index.ts\n├── App.tsx\n\n\nthe code in src/App.tsx:\n\n\nimport '@/src/common/styles/base.css';\n\n\nModern.js also provides a way to config aliases. Adding the @common alias as an\nexample. For TypeScript projects, you only need to configure\ncompilerOptions.paths under the project root directory tsconfig.json as follows:\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"@/common/*\": [\"./src/common/*\"]\n    }\n  }\n}\n\n\nJavaScript project can config by source.alias in modern.config.js:\n\nexport default defineConfig({\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n});\n\n\nFor detailed usage, please refer to source.alias documentation.","frontmatter":{"title":"Alias","sidebar_position":8}},{"id":200,"title":"Fetch Data","routePath":"/en/guides/basic-features/data-fetch","lang":"en","toc":[{"id":"data-loaderrecommend","text":"Data loader(recommend)","depth":2},{"id":"basic-example","text":"Basic example","depth":3},{"id":"loader-function","text":"loader function","depth":3},{"id":"request","text":"request","depth":4},{"id":"return-value","text":"Return value","depth":4},{"id":"request-api","text":"Request API","depth":3},{"id":"error-handling","text":"Error handling","depth":3},{"id":"get-data-from-upper-level-components","text":"Get data from upper level components","depth":3},{"id":"wiploading-ui","text":"(WIP)Loading UI","depth":3},{"id":"wrong-usage","text":"Wrong usage","depth":3},{"id":"useloaderold","text":"useLoader(Old)","depth":2},{"id":"route-loader","text":"Route Loader","depth":2}],"domain":"","content":"\n\nModern.js provides out of the box fetching data capabilities, developers can use\nthese APIs to develop in CSR and SSR environments isomorphic.\n\nIt should be noted that these APIs do not help applications to initiate\nrequests, but help developers better manage the relationship between data and\nrouting.\n\n\nData loader(recommend)\n\nModern.js recommends the use of conventional routing for route management. With\nModern.js' conventional (nested) routing, each routing component (layout.ts or\npage.ts) can have a loader file with the same name that can be executed before\nthe component renders, providing data to the routing component.\n\nINFO\n\nModern.js v1 supports getting data by useLoader, which is no longer the\nrecommended usage and it is not recommended to mix both except for migration\nprocess.\n\n\nBasic example\n\nA routing component such as layout.ts or page.ts can define a loader file with\nthe same name. The loader file exports a function that provides the data\nrequired by the component, which is then get data by the useLoaderData function\nin the routing component, as in the following example:\n\n.\n└── routes\n    ├── layout.tsx\n    └── user\n        ├── layout.tsx\n        ├── layout.loader.ts\n        ├── page.tsx\n        └── page.loader.ts\n\n\nDefine the following code in the file:\n\n\n\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return <div>{profileData}</div>;\n}\n\n\nexport type ProfileData = {\n  /*  some types */\n};\n\nexport default async (): Promise<ProfileData> => {\n  const res = await fetch('https://api/user/profile');\n  return await res.json();\n};\n\n\nCAUTION\n\nHere the routing component and the loader file share a type, should use the\nimport type syntax.\n\nIn a CSR environment, the loader function is executed on the client side, and\nthe browser API can be used within the loader function (but it is usually not\nneeded and not recommended).\n\nIn an SSR environment, the loader function will only be executed on the server\nside, regardless of the first screen or the navigation on the client side, where\nany Node.js API can be called, and any dependencies and code used here will not\nbe included in the client bundle.\n\nINFO\n\nIn later versions, Modern.js may support loader functions running on the server\nside as well in CSR environments to improve performance and security, so here it\nis recommended to keep the loader as pure as possible and only do data fetching\nscenarios.\n\nWhen navigating on the client side, all loader functions under /user and\n/user/profile are executed (requested) in parallel based on Modern.js's\nconventional routing, i.e. when accessing /user/profile, the loader functions\nunder /user and /user/profile are executed (requested) in parallel to improve\nclient-side performance.\n\n\nloader function\n\nThe loader function has two input parameters：\n\nParams\n\nWhen a routing file is passed through [], it is passed as a dynamic route and\nthe dynamic route fragment is passed as an argument to the loader function：\n\n// routes/user/[id]/page.loader.tsx\n\n\nexport default async ({ params }: LoaderArgs) => {\n  const { id } = params;\n  const res = await fetch(`https://api/user/${id}`);\n  return res.json();\n};\n\n\nWhen accessing /user/123, the parameters of the loader function are { params: {\nid: '123' } }.\n\nrequest\n\nrequest is a Fetch Request instance.\n\nA common usage scenario is to obtain query parameters via request:\n\n// routes/user/[id]/page.loader.ts\n\n\nexport default async ({ request }: LoaderArgs) => {\n  const url = new URL(request.url);\n  const userId = url.searchParams.get('id');\n  return queryUser(userId);\n};\n\n\nReturn value\n\nThe return value of the loader function can be anything serializable, or it can\nbe a Fetch Response instance：\n\nconst loader = async (): Promise<ProfileData> => {\n  return {\n    message: 'hello world',\n  };\n};\nexport default loader;\n\n\nBy default, the response Content-type returned by loader is application/json and\nstatus is 200, which you can set by customizing Response:\n\nconst loader = async (): Promise<ProfileData> => {\n  const data = { message: 'hello world' };\n  return new Response(JSON.stringify(data), {\n    status: 200,\n    headers: {\n      'Content-Type': 'application/json; utf-8',\n    },\n  });\n};\n\n\n\nRequest API\n\nModern.js does a polyfill of the fetch API to initiate requests, which is\nconsistent with the browser's fetch API, but can also be used on the server side\nto initiate requests, meaning that both CSRs and SSRs can use the unified fetch\nAPI for data fetching：\n\nfunction loader() {\n  const res = await fetch('https://api/user/profile');\n}\n\n\n\nError handling\n\nIn the loader function, errors can be handled by throw error or throw response.\nWhen an error is thrown in the loader function, Modern.js will stop executing\nthe code in the current loader and switch the front-end UI to the defined\nErrorBoundary component.\n\n// routes/user/profile/page.loader.tsx\nexport default async function loader() {\n  const res = await fetch('https://api/user/profile');\n  if (!res.ok) {\n    throw res;\n  }\n  return res.json();\n}\n\n// routes/user/profile/error.tsx\n\nconst ErrorBoundary = () => {\n  const error = useRouteError() as Response;\n  return (\n    <div>\n      <h1>{error.status}</h1>\n      <h2>{error.statusText}</h2>\n    </div>\n  );\n};\n\nexport default ErrorBoundary;\n\n\n\nGet data from upper level components\n\nIn many cases, the child component needs to access the data in the ancestor's\nloader, and you can easily access the ancestor's data with useRouteLoaderData:\nuseRouteLoaderData:\n\n// routes/user/profile/page.tsx\n\n\nexport default function UserLayout() {\n  // Get the data returned by the loader in routes/user/layout.loader.ts\n  const data = useRouteLoaderData('user/layout');\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <h2>{data.age}</h2>\n    </div>\n  );\n}\n\n\nuserRouteLoaderData takes one parameter routeId,When using conventional routing,\nModern.js will automatically generate routeId for you. The value of routeId is\nthe path of the corresponding component relative to src/routes, as in the\nexample above, the child component wants to get the data returned by the loader\nin routes/user/layout.tsx, the value of routeId is user/layout.\n\nIn a multi-entry (MPA) scenario, the value of routeId needs to be added to the\nname of the corresponding entry, and the entry name is usually the entry\ndirectory name if not specified, such as the following directory structure:\n\n.\n└── src\n    ├── entry1\n    │     └── routes\n    │           └── layout.tsx\n    └── entry2\n          └── routes\n                └── layout.tsx\n\n\nIf you want to get the data returned by the loader in entry1/routes/layout.tsx,\nthe value of routeId is entry1_layout.\n\n\n(WIP)Loading UI\n\nINFO\n\nThis feature is currently experimental and the API may be adjusted in the\nfuture. Currently, only CSR is supported, so stay tuned for Streaming SSR.\n\nAdd the following code to user/layout.tsx:\n\nimport {\n  Await,\n  defer,\n  useLoaderData,\n  Outlet\n} from '@modern-js/runtime/router';\n\nexport const loader = () => {\n  return defer({\n    // fetchUserInfo 是一个异步函数，返回用户信息\n    userInfo: fetchUserInfo(),\n  })\n}\n\nexport default function UserLayout() {\n  const { userInfo } = useLoaderData() as {userInfo: Promise<UserInfo>};\n  return (\n    <div>\n      <React.Suspense\n        fallback={<p>Loading...</p>}\n      >\n        <Await resolve={userInfo} children={userInfo => (\n          <div>\n            <span>{userInfo.name}</span>\n            <span>{userInfo.age}</span>\n            <Outlet>\n          </div>\n        )}>\n        </Await>\n      </React.Suspense>\n    </div>\n  );\n}\n\n\nINFO\n\nFor specific usage of the Await component, see Await\n\nFor specific usage of the defer function, seedefer\n\n\nWrong usage\n\n 1. Only serializable data can be returned in loader. In SSR environments, the\n    return value of the loader function is serialized to a JSON string, which is\n    then deserialized to an object on the client side. Therefore, no\n    non-serializable data (such as functions) can be returned in the loader\n    function.\n\nWARNING\n\nThis restriction is not currently in place under CSR, but we strongly recommend\nthat you follow it, and we may add it under CSR in the future.\n\n// This won't work!\nexport default () => {\n  return {\n    user: {},\n    method: () => {},\n  };\n};\n\n\n 2. Modern.js will call the loader function for you, you shouldn't call it\n    yourself in the component.\n\n// This won't work!\nexport default async () => {\n  const res = fetch('https://api/user/profile');\n  return res.json();\n};\n\n\nexport default function RouteComp() {\n  const data = loader();\n}\n\n\n 3. You cannot import a loader file from a routing component, nor can you import\n    variables in a routing component from a loader file:\n\n// Not allowed\n// routes/layout.tsx\n\n // should use \"import type\" instead\n\nexport const fetch = wrapFetch(fetch);\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return <div>{profileData}</div>;\n}\n\n// routes/layout.loader.ts\n // should not be imported from the routing component\nexport type ProfileData = {\n  /*  some types */\n};\n\nexport default async (): Promise<ProfileData> => {\n  const res = await fetch('https://api/user/profile');\n  return await res.json();\n};\n\n\n 4. When run on the server side, the loader functions are packaged into a single\n    bundle, so we do not recommend using __filename and __dirname for\n    server-side code.\n\n\nuseLoader(Old)\n\nuseLoader is an API in Modern.js old version. The API is a React Hook specially\nprovided for SSR applications, allowing developers to fetch data in components.\n\nTIP\n\nCSR don't need to use useLoader to fetch data.\n\nHere is the simplest example:\n\n\n\nexport default () => {\n  const { data } = useLoader(async () => {\n    console.log('fetch in useLoader');\n\n    // No real request is sent here, just a hard coding data is returned.\n    // In a real project, the data obtained from the remote end should be returned.\n    return {\n      name: 'Modern.js',\n    };\n  });\n\n  return <div>Hello, {data?.name}</div>;\n};\n\n\nAfter the above code starts, visit the page. You can see that the log is printed\nat terminal, but not at console in browser.\n\nThis is because Modern.js server-side rendering, the data returned by the\nuseLoader is collected and injected into the HTML of the response. If SSR\nrendering succeeds, the following code snippet can be seen in the HTML:\n\n<script>\n  window._SSR_DATA = {};\n</script>\n\n\nIn this global variable, every piece of data is recorded, and this data will be\nused first in the process of rendering on the browser side. If the data does not\nexist, the useLoader function will be re-executed.\n\nNOTE\n\nDuring the build phase, Modern.js will automatically generate a Loader ID for\neach useLoader and inject it into the JS bundle of SSR and CSR, which is used to\nassociate Loader and data.\n\nCompared with getServerSideProps in the Next.js, get data in advance before\nrendering. Using useLoader, you can get the data required by the local UI in the\ncomponent without passing the data layer by layer. Similarly, it will not add\nredundant logic to the outermost data acquisition function because different\nroutes require different data requests. Of course, useLoader also has some\nproblems, such as the difficulty of Treeshaking server-level code, and the need\nfor one more pre-render at the server level.\n\nModern.js in the new version, a new Loader solution is designed. The new\nsolution solves these problems and can cooperate with nested routing to optimize\npage performance.\n\nNOTE\n\nDetailed APIs can be found at useLoader.\n\n\nRoute Loader\n\nNOTE\n\nStay tuned.","frontmatter":{"title":"Fetch Data","sidebar_position":3}},{"id":201,"title":"Environment Variable","routePath":"/en/guides/basic-features/env-vars","lang":"en","toc":[{"id":"built-in-environment","text":"Built-in Environment","depth":2},{"id":"node_env","text":"NODE_ENV","depth":3},{"id":"modern_env","text":"MODERN_ENV","depth":3},{"id":"modern_target","text":"MODERN_TARGET","depth":3},{"id":"custom-environment-variables","text":"Custom Environment Variables","depth":2},{"id":"specify-via-shell","text":"Specify via shell","depth":3},{"id":"specify-via-env-file","text":"Specify via .env file","depth":3},{"id":"using-environment-variables","text":"Using Environment Variables","depth":2},{"id":"convention-names","text":"Convention Names","depth":3},{"id":"any-other-names","text":"Any Other Names","depth":3},{"id":"use-global-replacement","text":"Use Global Replacement","depth":2}],"domain":"","content":"\n\nModern.js provides support for environment variables, including built-in\nenvironment variables and custom environment variables.\n\n\nBuilt-in Environment\n\n\nNODE_ENV\n\nThe current execution environment and is a read-only environment variable whose\nhave different values under different execution commands:\n\n * production：the default value when exec modern build or modern serve.\n * test：the default value when exec modern test.\n * development：the default value when exec modern dev, alse the default value of\n   other case.\n\n\nMODERN_ENV\n\nSet the current execution environment manually. In addition to the values in the\nNODE_ENV, custom environment names are supported here, such as staging, boe,\netc.\n\nTIP\n\nMODERN_ENV priority is higher than NODE_ENV.\n\n\nMODERN_TARGET\n\nAuto inject when use @modern-js/runtime，Used to distinguish between SSR and CSR\nenvironments. Developers can judge by themselves in the code, and dead code will\nbe removed by default when building.\n\nfunction App() {\n  if (process.env.MODERN_TARGET === 'browser') {\n    console.log(window.innerHeight);\n  }\n}\n\n\nIn the development environment, you can see that the SSR and CSR bundles as\nfollows:\n\nfunction App() {\n  if (false) {\n  }\n}\n\n\nfunction App() {\n  if (true) {\n    console.log(window.innerHeight);\n  }\n}\n\n\nNOTE\n\nIn a production environment, dead code is removed, such as the if statement\nabove.\n\nThis can provide different products for different client sides to ensure that\nthe bundle size is minimized. It can also be convenient to deal with some side\neffects in the code in different environments.\n\n\nCustom Environment Variables\n\nCustom environment variables can be specified in both shell and .env files.\n\n\nSpecify via shell\n\nAdd custom environment variables before the command:\n\nREACT_APP_FOO=123 BAR=456 pnpm run dev\n\n\n\nSpecify via .env file\n\nCreate a .env file in the project root and add custom environment variables,\nwhich are added to the Node.js process by default, for example:\n\nREACT_APP_FOO=123\nBAR=456\n\n\nThe .env file follows the following loading rules:\n\n * .env：default.\n * .env.{ MODERN_ENV | NODE_ENV }：Setting environment variables for a specific\n   environment overrides the same in .env.\n\nWhen you need to use different config according to the environment, you can\ndefine environment variables in the .env file corresponding to the environment\nname, and manually set the execution environment when starting the project.\n\nFor example, when starting a project with the following command，the .env and\n.env.staging will load:\n\nMODERN_ENV=staging pnpm run dev\n\n\n\nUsing Environment Variables\n\n\nConvention Names\n\nNODE_ENV can be used directly in front-end code. In addition, custom environment\nvariables starting with MODERN_ can also be used directly in code.\n\nFor Example:\n\nif (process.env.NODE_ENV === 'development') {\n  // do something\n}\n\n\nAfter executing the pnpm run dev, you can see the following bundle:\n\nif (true) {\n  // do something\n}\n\n\nIn custom HTML templates, you can also use such environment variables directly.\nFor example, in config/html/head.html:\n\n<meta name=\"test\" content=\"<process.env.NODE_ENV>\" />\n\n\n\nAny Other Names\n\nIf you need to use environment variables with any other names in your code，you\ncan config source.globalVars, for example:\n\nexport default defineConfig({\n  source: {\n    globalVars: {\n      'process.env.VERSION': process.env.VERSION,\n    }.\n  },\n});\n\n\nAt this point, the process.env.VERSION in the code will be replaced with the\nvalue of VERSION in the environment variables.\n\nNOTE\n\nsource.globalVars also supports replacing other expressions or strings with\nspecified values, not limited to environment variables.\n\n\nUse Global Replacement\n\nIn addition to environment variables, Modern.js also supports replacing\nvariables in code with other values or expressions, which can be used like\ndistinguish development environment and production environment in code.\n\nFor example, converts the expression TWO to 1 + 1:\n\nexport default {\n  source: {\n    define: {\n      TWO: '1 + 1',\n    },\n  },\n};\n\n\nconst foo = TWO;\n\n// ⬇️ Turn into being...\nconst foo = 1 + 1;\n\n\nIn most cases, source.globalVars is already sufficient to replace variables. But\nthe values passed in by source.globalVars will be serialized by JSON by default.\nSo it cannot be replaced like 1 + 1 in the example above，at this time, we need\nuse source.define.","frontmatter":{"title":"Environment Variable","sidebar_position":7}},{"id":202,"title":"HTML Template","routePath":"/en/guides/basic-features/html","lang":"en","toc":[{"id":"jsx-syntax","text":"JSX syntax","depth":2},{"id":"html-component","text":"HTML Component","depth":3},{"id":"template-params","text":"Template Params","depth":3},{"id":"examples","text":"Examples","depth":3},{"id":"html-synxtax","text":"Html Synxtax","depth":2},{"id":"custom-html-fragments","text":"Custom HTML Fragments","depth":3},{"id":"fully-custom-html-templates","text":"Fully Custom HTML Templates","depth":3},{"id":"template-params-1","text":"Template Params","depth":3},{"id":"config-by-entry","text":"Config By Entry","depth":3}],"domain":"","content":"\n\nModern.js provides JSX syntax and HTML(EJS) syntax for customizing HTML\ntemplate.\n\n\nJSX syntax\n\nModern.js convention, in the src/, or in the entry directory, you can create\nDocument.[jt]sx and export a component by default. The rendering result of this\ncomponent can be used as an HTML template for the entry.\n\nFor example the following directory structure:\n\n.\n└── src\n    ├── Document.tsx\n    ├── entry-a\n    │   ├── Document.tsx\n    │   └── routes\n    ├── entry-b\n    │    └── routes\n    └── modern-app-env.d.ts\n\n\nentry-a will take precedence over the Docoument.[jt]sx file under the current\nentry. If the current entry does not have a Document.[jt]sx file, such as\nentry-b, it will look for the Document.[jt]sx file in the root directory.\n\nIf not, it will go to the the logic of traditional templates.\n\n\nHTML Component\n\nModern.js provides a list of components for rendering pages to help developers\ngenerate templates, which can be exported from @modern-js/runtime/document:\n\n\n\nThese components are rendered:\n\n * Html：Provide the ability of native HTML Elements, and render necessary\n   components that the developer did not add by default. <Head> and <Body> must\n   exist, and other components can be assembled by selecting appropriate\n   components on demand.\n\n * Body：Provide the ability of native Body Element, which needs to contain the\n   <Root> component internally, and also supports other elements as child\n   elements at the same time, such as adding footers.\n\n * Root：React root element <div id='root'></div>. the default element id is id =\n   'root', can set props.rootId to change the id.Child components can be added,\n   and will also be rendered into HTML templates, which will be overwritten when\n   React rendering is complete, generally used to implement global Loading.\n\n * Head：Provides native Head Element capabilities and automatically populates\n   <meta>, as well as the <Scripts> component.\n\n * Scripts：The script content generated by the webpack, which can be used to\n   adjust the position of the bundle result, is placed in the <Head> component\n   by default.\n\n\nTemplate Params\n\nBecause it is in the form of JSX, in Document.[jt]sx, you can use various\nvariables in the component to assign values to various custom components more\nfreely.\n\nAt the same time, Modern.js provides DocumentContext to provide some\nconfiguration and environment parameters, The main parameters as follow:\n\n * processEnv：Provide build-time env vars.\n * config：The configuration of the project, only output are exposed.\n * entryName：current entry name.\n * templateParams：HTML template params(in order to be compatible with\n   traditional templates, it is not recommended to use).\n\n\nExamples\n\n\nimport {\n  Html,\n  Root,\n  Head,\n  Body,\n  Scripts,\n  DocumentContext,\n} from '@modern-js/runtime/document';\n\nexport default function Document(): React.ReactElement {\n  // the params provide by DocumentContext\n  const {\n    config: { output: htmlConfig },\n    entryName,\n    templateParams,\n  } = useContext(DocumentContext);\n\n  return (\n    <Html>\n      <Head>\n        <link href=\"https://modernjs.dev\">Modern.js</link>\n      </Head>\n      <Body>\n        <Root rootId=\"root\">\n          <h1 style={{ color: 'red' }}>Some Params：</h1>\n          <h2> entryName：{entryName}</h2>\n          <h2> title：{htmlConfig.title}</h2>\n          <h2> rootId: {templateParams.mountId}</h2>\n        </Root>\n        <h1>bottom</h1>\n      </Body>\n    </Html>\n  );\n}\n\n\nThe above JSX component will generate the following HTML template:\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, shrink-to-fit=no, viewport-fit=cover, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"\n    />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <meta name=\"renderer\" content=\"webkit\" />\n    <meta name=\"layoutmode\" content=\"standard\" />\n    <meta name=\"imagemode\" content=\"force\" />\n    <meta name=\"wap-font-scale\" content=\"no\" />\n    <meta name=\"format-detection\" content=\"telephone=no\" />\n    <script>\n      ...\n    </script>\n    <script defer src=\"/static/js/lib-react.js\"></script>\n    <script defer src=\"/static/js/lib-polyfill.js\"></script>\n    <script defer src=\"/static/js/lib-router.js\"></script>\n    <script\n      defer\n      src=\"/static/js/vendors-node_modules_pnpm_loadable_component_5_15_2_react_18_2_0_node_modules_loadable_compon-3fb0cf.js\"\n    ></script>\n    <script\n      defer\n      src=\"/static/js/packages_runtime_plugin-router-legacy_dist_js_treeshaking_runtime_index_js-packages_runtime_p-28f4c9.js\"\n    ></script>\n    <script defer src=\"/static/js/sub.js\"></script>\n    <link href=\"https://www.baidu.com\" />\n  </head>\n\n  <body>\n    <div id=\"root\">\n      {/* <?- html ?> */}\n      <h1 style=\"color:red\">Some Params：</h1>\n      <h2>entryName：sub</h2>\n      <h2>title：</h2>\n      <h2>rootId: root</h2>\n    </div>\n    <h1>bottom</h1>\n    {/* <?- chunksMap.js ?> */}\n    {/* <?- SSRDataScript ?> */}\n  </body>\n</html>\n\n\n\nHtml Synxtax\n\nModern.js also supports HTML syntax. By default, an HTML template is built into\nthe Modern.js application project to generate HTML code.\n\nBased on HTML syntax templates, Modern.js provides Custom HTML Fragments and\nFully Custom HTML Templates two ways to customize templates.\n\n\nCustom HTML Fragments\n\nIn the application root directory, create the config/html/ directory, which\nsupports the creation of four kinds of HTML fragments.\n\n * top.html\n * head.html\n * body.html\n * bottom.html\n\nThese fragments will be injected into the default HTML template.\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <%= meta %>\n    <title><%= title %></title>\n    <%= topTemplate %>\n\n    <script>\n      window.__assetPrefix__ = '<%= assetPrefix %>';\n    </script>\n    <%= headTemplate %>\n    {/* webpack inject css  */}\n  </head>\n  <body>\n    <noscript>\n      We're sorry but react app doesn't work properly without JavaScript\n      enabled. Please enable it to continue.\n    </noscript>\n    <div id=\"<%= mountId %>\"></div>\n    <%= bodyTemplate %>\n    {/* webpack inject js  */}\n    {/* <?- bottomTemplate ?> */}\n  </body>\n</html>\n\n\nHTML Fragments support the use Lodash template.\n\nFor example, insert a script in body.html:\n\n<script src=\"//example.com/assets/a.js\"></script>\n\n\nINFO\n\nThe implementation of the custom HTML fragment is to merge the fragment with the\nbuilt-in template of the frame. Since <title> already exists in the default\ntemplate of the frame, the <title> in the custom HTML template cannot take\neffect. Please pass html.title to modify the page title.\n\n\nFully Custom HTML Templates\n\nIn some cases, HTML snippets do not meet the customization requirements,\nModern.js provide a fully customized way.\n\nCAUTION\n\nIt is not recommended to override the default HTML template directly, and some\nfeatures may be lost. Even if it needs to be replaced, it is recommended to\nbuild on the built-in template and modify it as needed.\n\nIn the config/html/ directory, create a index.html file that will override the\ndefault HTML template.\n\nINFO\n\nThe internal default HTML template can be viewed in\nnode_modules/.modern-js/${entryName}/index.html.\n\n\nTemplate Params\n\nThe parameters used in the template can be defined by the\nhtml.templateParameters.\n\n\nConfig By Entry\n\nThe fragment in the config/html/ directory are valid for all entries in the\napplication. If you want to customize the HTML by entry, you can create a new\ndirectory named with the entry name in the config/html/ directory, and then\ncustomize the HTML snippets in this directory.\n\nFor example, the following HTML fragment is only valid for entry1:\n\n.\n├── config/\n│   └── html/\n│       └── entry1\n│           ├── head.html\n│           └── body.html\n└── src/\n    ├── entry1/\n    │   └── routes\n    └── entry2/\n        └── routes\n","frontmatter":{"title":"HTML Template","sidebar_position":9}},{"id":203,"title":"Mock","routePath":"/en/guides/basic-features/mock","lang":"en","toc":[{"id":"mock-file","text":"Mock File","depth":2},{"id":"writing-mock-files","text":"Writing Mock Files","depth":2},{"id":"return-random-data","text":"Return Random Data","depth":2},{"id":"delayed-return","text":"Delayed Return","depth":2},{"id":"use-mock-on-demand","text":"Use Mock On Demand","depth":2}],"domain":"","content":"\n\nModern.js provides the ability to quickly generate Mock data, allowing the\nfront-end to develop independently without being blocked by the back-end\ninterface.\n\n\nMock File\n\nBy convention, when there is index.[jt]s in the config/mock/ directory, the Mock\nData will be automatically enabled, as follows:\n\n.\n├── config\n│   └── mock\n│       └── index.ts\n├── src\n│   └── App.tsx\n└── modern.config.ts\n\n\n\nWriting Mock Files\n\nthe config/mock/index.ts file only needs to export an object containing all Mock\nAPIs. The properties of the object are composed of the request configuration\nmethod and url, and the corresponding property values can be Object, Array,\nFunction:\n\nexport default {\n  /* The attribute is the concrete method and request url, and the value is object or array as the result of the request */\n  'GET /api/getInfo': { data: [1, 2, 3, 4] },\n\n  /* the default method is GET */\n  '/api/getExample': { id: 1 },\n\n  /* You can use custom functions to dynamically return data */\n  'POST /api/addInfo': (req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.end('200');\n  },\n};\n\n\nwhen access http://localhost:8080/api/getInfo, the api will return json {\n\"data\": [1, 2, 3, 4] }.\n\n\nReturn Random Data\n\nLibraries such as Mock.js can be used in config/mock/index.js to generate random\ndata, for example:\n\nconst Mock = require('mockjs');\n\nmodule.exports = {\n  '/api/getInfo': Mock.mock({\n    'data|1-10': [{ name: '@cname' }],\n  }) /* => {data: [{name: \"董霞\"}, {name: \"魏敏\"},  {name: \"石磊\"}} */,\n};\n\n\nOther Mock Lib\n\n * Chancejs\n * Mock\n\n\nDelayed Return\n\n * It can be achieved using the function of the browser \"weak connection\n   simulation\".\n * Delays can be set via setTimeout, for example:\n\nexport default {\n  'api/getInfo': (req, res) => {\n    setTimeout(() => {\n      res.end('delay 2000ms');\n    }, 2000);\n  },\n};\n\n\n\nUse Mock On Demand\n\nUnder the config/mock/index.ts, you can also export the config to control the\nMock service.\n\ntype MockConfig = {\n  enable: ((req: IncomingMessage, res: ServerResponse) => boolean) | boolean;\n};\n\nexport const config = {\n  enable: false\n}\n\n\nCurrently only the enable configuration is supported, through which developers\ncan control whether to execute Mock.\n\nNOTE\n\nAfter modifying config, there is no need to restart the service, which will take\neffect immediately.","frontmatter":{"title":"Mock","sidebar_position":6}},{"id":204,"title":"Proxy","routePath":"/en/guides/basic-features/proxy","lang":"en","toc":[{"id":"local-proxy","text":"Local Proxy","depth":2},{"id":"global-proxy","text":"Global Proxy","depth":2},{"id":"set-proxy-rules","text":"Set Proxy Rules","depth":3},{"id":"use-proxy-dashboard","text":"Use Proxy Dashboard","depth":3},{"id":"bff-proxy","text":"BFF Proxy","depth":2}],"domain":"","content":"\n\n\nLocal Proxy\n\nModern.js provides a way to configure the development proxy in\n['tools.devServer'] (/docs/configure/app/tools/dev-server). For example, to\nproxy the local interface to an online address:\n\n\n\nexport default defineConfig({\n  tools: {\n    devServer: {\n      proxy: {\n        '/go/api': {\n          target: 'http://www.example.com/',\n          changeOrigin: true,\n        },\n      },\n    },\n  },\n});\n\n\nwhen access http://localhost:8080/go/api, the response content is returned from\nhttp://www.example.com/.\n\nINFO\n\nFor more detail, see http-proxy-middleware.\n\n\nGlobal Proxy\n\nModern.js provides out-of-the-box global proxy plugin @modern-js/plugin-proxy,\nwhich is based on whistle and can be used to view and modify HTTP/HTTPS requests\nand responses, and can also be used as an HTTP proxy server.\n\n\nSet Proxy Rules\n\nAfter install the proxy plugin and filling in the rules, execute pnpm run dev,\nModern.js will automatically enable the proxy server after the development\nserver starts.\n\nSpecific proxy rules can be set via the dev.proxy or the config/proxy.js file.\n\n\nUse Proxy Dashboard\n\nAfter exec pnpm run dev command:\n\n  App running at:\n\n  Local:    http://localhost:8080/\n  Network:  http://192.168.0.1:8080/\n\nℹ  info      Starting the proxy server.....\n✔  success   Proxy Server start on localhost:8899\n\n\nIn the console you can see that the proxy server started successfully.\n\nAccessing the http://localhost:8899 and, you can set the rules through the\ndashboard.\n\n\n\n\nBFF Proxy\n\nBy configuring bff.proxy, you can proxy BFF API requests to specified services.\nUnlike other proxy above, it can also be used in the production environment:\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api/v1': 'https://cnodejs.org',\n    },\n  },\n});\n\n\nFor example, when a BFF call is used in the code, the final request\nhttp://localhost:8080/api/v1/topics will auto proxy to\nhttps://cnodejs.org/api/v1/topics：\n\n\n\ngetTopics();\n","frontmatter":{"title":"Proxy","sidebar_position":5}},{"id":205,"title":"Routes","routePath":"/en/guides/basic-features/routes","lang":"en","toc":[{"id":"conventional-routing","text":"Conventional routing","depth":2},{"id":"routing-file-convention","text":"Routing file convention","depth":3},{"id":"layout","text":"Layout","depth":4},{"id":"page","text":"Page","depth":4},{"id":"dynamic-routing","text":"Dynamic routing","depth":3},{"id":"catch-all-routing","text":"Catch all routing","depth":3},{"id":"layout-with-no-path","text":"Layout with No Path","depth":3},{"id":"no-layout","text":"No Layout","depth":3},{"id":"wiploading","text":"(WIP)Loading","depth":3},{"id":"errorboundary","text":"ErrorBoundary","depth":3},{"id":"hooks-before-rendering","text":"Hooks before rendering","depth":3},{"id":"runtime-configuration","text":"Runtime Configuration","depth":3},{"id":"self-controlled-routing","text":"Self-controlled routing","depth":2},{"id":"other","text":"Other","depth":2}],"domain":"","content":"\n\nModern.js build-in provides partial support for React Router 6 and provides\nvarious types of routing modes. According to different entry types, routing is\ndivided into three modes, namely Conventional routing, Self-controlled routing\nand Other.\n\nNOTE\n\nThe routes mentioned in this section are client routes, that is, SPA routes.\n\n\nConventional routing\n\nWith routes/ as the agreed entry, Modern.js will automatically generate the\ncorresponding routing structure based on the file system.\n\nModern.js supports the popular convention routing mode in the industry: nested\nrouting. When using nested routing, the routing of the page corresponds the UI\nstructure, and we will introduce this routing mode in detail.\n\n/user/johnny/profile                  /user/johnny/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------>  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n\n\n\nRouting file convention\n\nThere are two file conventions in the routes/ directory layout.[jt]sx and\npage.[jt]sx(abbreviated as .tsx later). These two files determine the layout\nhierarchy of the application, where layout.tsx is used as the layout component,\nand page.tsx is used as the content component, which is the leaf node of the\nentire routing table.\n\nFor example, here routes/layout.tsx will be used as the layout component of all\ncomponents under the / route:\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\nWhen the route is /, there will be the following UI layout:\n\n<Layout>\n  <Page />\n</Layout>\n\n\nSimilarly, routes/user/layout.tsx will be used as a layout component for all\ncomponents under the /user route. When the route is /user, the following UI\nlayout will be available:\n\n<Layout>\n  <UserLayout>\n    <UserPage>\n  <UserLayout>\n</Layout>\n\n\nLayout\n\n<Layout> component refers to all layout.tsx files in the routes/ directory,\nwhich represent the layout of the corresponding route segment, and use <Outlet>\nto represent sub-components.\n\nNOTE\n\n<Outlet> is a new API in React Router 6, see Outlet for details.\n\nIn order to facilitate the introduction of the relationship between <Layout> and\n<Outlet>, the following file directory example:\n\n.\n└── routes\n    ├── blog\n    │   └── page.tsx\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n 1. When the route is /, <Outlet> in routes/layout.tsx represents the component\n    exported in routes/page.tsx, generating the following UI structure:\n\n<Layout>\n  <Page />\n</Layout>\n\n\n 2. When the route is /blog, <Outlet> in routes/layout.tsx represents the\n    component exported in routes/blog/page.tsx, generating the following UI\n    structure:\n\n<Layout>\n  <BlogPage />\n</Layout>\n\n\n 3. When the route is /user, <Outlet> in routes/layout.tsx represents the\n    component exported in routes/user/layout.tsx. <Outlet> in\n    routes/user/layout.tsx represents the component exported in\n    routes/user/page.tsx. Generate the following UI structure:\n\n<Layout>\n  <UserLayout>\n    <UserPage>\n  <UserLayout>\n</Layout>\n\n\nIn summary, if there is a layout.tsx in the file directory of the subroute, the\n<Outlet> in the previous layout.tsx is the layout.tsx under the file directory\nof the subroute, otherwise it is the page.tsx under the file directory of the\nsubroute.\n\nPage\n\nAll routes should end with the <Page> component. In the page.tsx file, if the\ndeveloper introduces the <Outlet> component, it will have no effect.\n\n\nDynamic routing\n\nWith a file directory named [], the generated route will be used as a dynamic\nroute. For example the following file directory:\n\n└── routes\n    ├── [id]\n    │   └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nThe routes/[id]/page.tsx file is converted to the /:id route. Except for the\n/blog route that exactly matches, all other /xxx will match this route.\n\nIn component, you can get the corresponding named parameters through useParams.\n\n\nCatch all routing\n\nIf a $.tsx file is created in the routes directory, this file will act as a\nwildcard route component that will be rendered when there is no matching route.\n\nNOTE\n\n$.tsx can be thought of as a special page routing component that renders $.tsx\nas a child of layout when there is a layoutcomponent in the current directory.\n\nFor example, the following directory structure:\n\n└── routes\n    ├── $.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nThe routes/$.tsx component is rendered when accessing any path that does not\nmatch, and again, the remainder of the url can be captured in $.tsx using\nuseParams.\n\n\n// When the path is `/aaa/bbb`\nconst params = useParams();\nparams['*']  // => 'aaa/bbb'\n\n\n\nLayout with No Path\n\nWhen a directory name begins with __, the corresponding directory name is not\nconverted to the actual routing path, such as the following file directory:\n\n.\n└── routes\n    ├── __auth\n    │   ├── layout.tsx\n    │   ├── login\n    │   │   └── page.tsx\n    │   └── signup\n    │       └── page.tsx\n    ├── layout.tsx\n    └── page.tsx\n\n\nModern.js will generate two routes, /login and /sign, __auth/layout.tsx\ncomponent will be used as the layout component of login/page.tsx and\nsignup/page.tsx, but __auth will not be used as the route path fragment.\n\nThis feature is useful when you need to do separate layouts for certain types of\nroutes, or when you want to categorize routes.\n\n\nNo Layout\n\nIn some cases, the project needs more sophisticated routes, but these routes do\nnot have independent UI layouts. If you create a route like a normal file\ndirectory, the directory level will be deeper.\n\nTherefore Modern.js supports splitting routing fragments by . instead of file\ndirectory. For example, when you need /user/profile/2022/edit, you can directly\ncreate the following file:\n\n└── routes\n    ├── user.profile.[id].edit\n    │      └── page.tsx\n    ├── layout.tsx\n    └── page.tsx\n\n\nWhen accessing a route, you will get the following UI layout:\n\n<RootLayout>\n  <UserProfileEdit /> // routes/user.profile.[id].edit/page.tsx\n</RootLayout>\n\n\n\n(WIP)Loading\n\nIn each layer directory under routes/, developers can create loading.tsx files\nand export a <Loading> component by default.\n\nWhen the component exists in the routing directory, all routing switches under\nthis level of subrouting will use the <Loading> component as the Fallback UI\nwhen JS Chunk is loaded. When the layout.tsx file is not defined in this\ndirectory, the <Loading> component will not take effect. For example, the\nfollowing file directory:\n\n.\n└── routes\n    ├── blog\n    │   ├── [id]\n    │   │   └── page.tsx\n    │   └── page.tsx\n    ├── layout.tsx\n    ├── loading.tsx\n    └── page.tsx\n\n\nWhen a route jumps from / to /blog, if the JS Chunk of the <Blog> component is\nnot loaded, the component UI exported in loading.tsx will be displayed first.\nBut when jumping from /blog to /blog/20220101, it will not be displayed.\n\n\nErrorBoundary\n\nIn each layer directory under routes/, the developer can also define a error.tsx\nfile, and export a <ErrorBoundary> component by default.\n\nWhen the component exists in a routing directory, the component render error is\ncaught by the ErrorBoundary component. The <ErrorBoundary> component does not\ntake effect when the directory does not have a layout.tsx file defined.\n\n<ErrorBoundary> can return the UI view when the error occurred. When the\n<ErrorBoundary> component is not declared at the current level, the error will\nbubble up to the higher component until it is caught or throws an error. At the\nsame time, when a component fails, it will only affect the routed component and\nsub-component that caught the error. The state and view of other components are\nnot affected and can continue to interact.\n\n{/* Todo API 路由 */}\n\nWithin the <ErrorBoundary> component, you can use useRouteError to get the\nspecific information of the error:\n\n\nexport default const ErrorBoundary = () => {\n  const error = useRouteError();\n  return (\n    <div>\n        <h1>{error.status}</h1>\n        <h2>{error.message}</h2>\n    </div>\n  )\n}\n\n\n\nHooks before rendering\n\nIn some scenarios where you need to do some operations before the application\nrenders, you can define init hooks in routes/layout.tsx. init will be executed\non both the client and server side, the basic usage example is as follows:\n\n\n\nexport const init = (context: RuntimeContext) => {\n  // do something\n};\n\n\nThe init hook allows you to mount some global data and access the runtimeContext\nvariable from elsewhere in the application:\n\nNOTE\n\nThis feature is useful when the application requires pre-page data, custom data\ninjection or framework migration (e.g. Next.js)\n\nimport {\n  RuntimeContext,\n} from '@modern-js/runtime';\n\nexport const init = (context: RuntimeContext) => {\n  return {\n    message: 'Hello World',\n  }\n}\n\n\n\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const { message } = context.getInitData();\n\n  return <div>{message}</div>;\n}\n\n\nWhen working with SSR, the browser side can get the data returned by init during\nSSR, and the developer can decide whether to retrieve the data on the browser\nside to overwrite the SSR data, for example:\n\n\n\nexport const init = (context: RuntimeContext) => {\n  if (process.env.MODERN_TARGET === 'node') {\n    return {\n      message: 'Hello World By Server',\n    }\n  } else {\n    const { context } = runtimeContext;\n    const data = context.getInitData();\n    // If do not get the expected data\n    if (!data.message) {\n      return {\n        message: 'Hello World By Client'\n      }\n    }\n  }\n}\n\n\n\nRuntime Configuration\n\nIn each root Layout component (routes/layout.ts), the application runtime\nconfiguration can be dynamically defined:\n\n\n\nexport const config = (): AppConfig => {\n  return {\n    router: {\n      supportHtml5History: false\n    }\n  }\n};\n\n\n\nSelf-controlled routing\n\nWith src/App.tsx as the agreed entry, Modern.js will not do additional\noperations with multiple routes, developers can use the React Router 6 API for\ndevelopment by themselves, for example:\n\n\n\nexport default () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route index element={<div>index</div>} />\n        <Route path=\"about\" element={<div>about</div>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\n\nNOTE\n\nModern.js has a series of resource loading and rendering optimizations to the\ndefault convention-based routing, and provides out-of-the-box SSR capabilities,\nwhen using self-directed routing, need to be packaged by the developer, and it\nis recommended that developers use convention-based routing.\n\n\nOther\n\nBy default, Modern.js turn on the built-in routing scheme, React Router.\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n});\n\n\nModern.js exposes the React Router API from the @modern-js/runtime/router\nnamespace for developers to use, ensuring that developers and Modern.js use the\nsame code. In addition, in this case, the React Router code will be packaged\ninto JS products. If the project already has its own routing scheme, or does not\nneed to use client routing, this feature can be turned off.\n\nexport default defineConfig({\n  runtime: {\n    router: false,\n  },\n});\n","frontmatter":{"title":"Routes","sidebar_position":1}},{"id":206,"title":"Builder","routePath":"/en/guides/concept/builder","lang":"en","toc":[{"id":"build-architecture","text":"Build Architecture","depth":2},{"id":"builder-documentation","text":"Builder Documentation","depth":2},{"id":"builder-config","text":"Builder Config","depth":2},{"id":"building-features","text":"Building Features","depth":2}],"domain":"","content":"\n\nModern.js uses Modern.js Builder to build your Web App.\n\nModern.js Builder is one of the core components of Modern.js. It is A Build\nEngine for web development. and can be used independently of Modern.js.\nModern.js Builder supports multiple bundlers such as webpack and rspack, and it\nuses webpack by default.\n\n\nBuild Architecture\n\nFrom the perspective of building, Modern.js is divided into three layers, from\ntop to bottom:\n\n * Upper-layer framework: Modern.js.\n * Universal build engine: Modern.js Builder.\n * Low-level bundlers: webpack and Rspack.\n\n<img\nsrc=\"https://lf3-static.bytednsdoc.com/obj/eden-cn/zq-uylkvT/ljhwZthlaukjlkulzlp\n/builder-layers-1117.png\" style={{ maxWidth: '540px' }} />\n\n\nBuilder Documentation\n\nSince Modern.js Builder is a module that can be used independently, we provide a\nseparate document for it, the site address is: modernjs.dev/builder.\n\nIn this document, you can learn about the detailed introduction of Modern.js\nBuilder, and you can also find a complete usage guide for each building\nfeatures. When you encounter building issues, it is recommended that you first\nread the Modern.js Builder documentation to solve them.\n\n\nBuilder Config\n\nThe config of Modern.js is inherited from Modern.js Builder, so you can use all\nbuild configs provided by Modern.js Builder in Modern.js.\n\nTake the html.title config of Modern.js Builder as an example, you can directly\nuse this config in the modern.config.ts file, and it will be automatically\npassed to Modern.js Builder.\n\nexport default defineConfig({\n  html: {\n    title: 'example',\n  },\n});\n\n\nFor details of building configs, please refer to 「Modern.js Builder - Builder\nConfig」.\n\n\nBuilding Features\n\nModern.js Builder provides a wealth of building features, including dozens of\nfeatures such as JavaScript compilation, CSS compilation, static resource\nprocessing, hot module replacement, code compression, and TS type checking.\n\nWe recommend you to read 「Modern.js Builder - All Features」 to learn all the\nbuilding features provided by Modern.js Builder.","frontmatter":{"sidebar_position":2}},{"id":207,"title":"Entries","routePath":"/en/guides/concept/entries","lang":"en","toc":[{"id":"single-entry-and-multiple-entries","text":"Single Entry and Multiple Entries","depth":2},{"id":"entry-conditions","text":"Entry conditions","depth":2},{"id":"difference-between-entries","text":"Difference between entries","depth":2},{"id":"routes","text":"routes","depth":3},{"id":"app","text":"App","depth":3},{"id":"index","text":"Index","depth":3},{"id":"configuration","text":"configuration","depth":2}],"domain":"","content":"\n\nEntries are Modern.js default file convention, and each entry in the project is\na separate page, corresponding to a server level route.\n\nMany configurations, such as HTML templates, Meta information, whether SSR is\nenabled, SSG, server level routing rules are divided by the entry dimension.\n\n\nSingle Entry and Multiple Entries\n\nModern.js initialization project is a single entry, the project structure is as\nfollows:\n\n.\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── package.json\n├── modern.config.ts\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\nModern.js can easily switch from single entry to multiple entry. You can execute\npnpm run new under the project to create entry through generator:\n\n? Action: Create project element\n? Create project element: New \"entry\"\n? Entry name: new-entry\n\n\nAfter execution, the src/ directory will become the following structure:\n\n.\n├── modern-app-env.d.ts\n├── myapp\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n└── new-entry\n    └── routes\n        ├── index.css\n        ├── layout.tsx\n        └── page.tsx\n\n\nThe original code was moved to the directory with the same name as the name in\nthe package.json, and a new directory was created.\n\nAfter executing pnpm run dev, you can see that a /new-entry route has been\nadded, and the migrated code route has not changed.\n\nNOTE\n\nModern.js will use the directory with the same name as the name in the\npackage.json as the main entry, the default route is /, and the default route\nfor other entries is /{entryName}.\n\n\nEntry conditions\n\nBy default, the Modern.js entry currently scans the file under src/, identifies\nthe entry, and generates the corresponding server level route.\n\nTIP\n\nYou can change the entry directory to another directory by source.entriesDir.\n\nNot all first-level directories under src/ will become project entrances. The\ndirectory where the entry is located must meet one of the following four\nconditions:\n\n 1. Directory with routes/\n 2. Has the App.[jt]sx? file\n 3. With index.[jt]sx? file\n 4. With pages/ directory (compatible Modern.js 1.0)\n\nWhen the src/ directory satisfies the entry feature, the Modern.js considers the\ncurrent project to be a single entry application.\n\nTIP\n\nSingle entry The default entry name is main.\n\nWhen the project is not a single-entry application, Modern.js further look at\nthe first-level directory under src/.\n\n\nDifference between entries\n\nEntries to different conventions have different behaviors.\n\n\nroutes\n\nIf the entry is the routes/ convention, Modern.js will scan the files under\nroutes at startup, and automatically generate the client route based on the file\nconvention(react-router).\n\nFor details, please refer to Routing.\n\n\nApp\n\nIf the entry is the App.[jt]sx? convention, the developer can freely set the\nclient route in this file, or not set the client route.\n\nFor details, please refer to Routing.\n\n\nIndex\n\nTypically, the above two modes are sufficient, but when developers need to take\nover the React mount logic themselves, or take over the Webpack entry entirely,\nthe index.[jt]sx?convention can be used.\n\nIf the entry is the index.[jt]sx? convention, the Modern.js determines the build\nbehavior based on whether the file has a default component export.\n\nFor details, please refer to customized App.\n\n\nconfiguration\n\nIn Modern.js, you can manually configure the entry in modern.config.[jt]s, in\naddition to using the file convention to generate the entry.\n\nTIP\n\nDetails can be found in source.entries.","frontmatter":{"sidebar_position":1}},{"id":208,"title":"CSS-in-JS","routePath":"/en/guides/css/css-in-js","lang":"en","toc":[],"domain":"","content":"\n\nCSS-in-JS is a technology that can write CSS styles in JS files. Modern.js\nintegrates the CSS-in-JS library styled-components commonly used in the\ncommunity, which uses the new feature of JavaScript Tagged template to write CSS\nstyles for components. You can use the styled-components API directly from\n@modern-js/runtime/styled.\n\nWhen you need to write a div component with an internal font in red, you can do\nthe following implementation:\n\n\n\nconst RedDiv = styled.div`\n  color: red;\n`;\n\n\nWhen you need to dynamically set the component style according to the props of\nthe component, for example, when the attribute primary of props is true, the\ncolor of the button is white, and otherwise it is red. The implementation code\nis as follows:\n\n\n\nconst Button = styled.button`\n  color: ${props => (props.primary ? 'white' : 'red')};\n  font-size: 1em;\n`;\n\n\nFor more usage of styled-components, please refer to [styled-components official\nwebsite ].\n\nAdditional\n\nModern.js uses the Babel plugin babel-plugin-styled-components internally, and\nthe plugin can be configured through tools.styled Components.\n\nTIP\n\nIf you need to use styled-jsx, Emotion and other CSS-in-JS libraries, you need\nto install the dependency of the corresponding library first. For specific\nusage, please refer to the official website of the corresponding library.","frontmatter":{"sidebar_position":1}},{"id":209,"title":"CSS Modules","routePath":"/en/guides/css/css-modules","lang":"en","toc":[{"id":"file-suffix-form-css-modules","text":"File Suffix Form CSS Modules","depth":2},{"id":"global-css-modules","text":"Global CSS Modules","depth":2}],"domain":"","content":"\n\nModern.js out of the box support for CSS Modules.\n\n\nFile Suffix Form CSS Modules\n\nBy default, files ending in .module.(css|scss|sass|less) are treated as CSS\nModules files, for example:\n\n.redColor {\n  color: red;\n}\n\n\n\n\nexport default function Button() {\n  return (\n    <button type=\"button\" className={styles.redColor}>\n      red button\n    </button>\n  );\n}\n\n\nWill eventually be compiled as:\n\n<button type=\"button\" className=\"button_redColor__1-RBg\">\n  red button\n</button>\n\n\n\nGlobal CSS Modules\n\nIf you want to remove the .module suffix from the filename, you can set\noutput.disable CssModuleExtension.\n\nAfter setting, all style files except the style files in the node_modules/\ndirectory and the file name format of [name].global.(css|scss|sass|less) will be\nprocessed as CSS Modules.\n\nIf you need global styles at this point, you can solve it by creating a style\nfile with the filename format [name].global.(css|scss|sass|less), for example:\n\n.bg-blue {\n  background-color: blue;\n}\n\n\n.redColor {\n  color: red;\n}\n\n\nimport './app.global.css';\n\n\nexport default function Button() {\n  return (\n    <button type=\"button\" className={`${styles.redColor} bg-blue`}>\n      button\n    </button>\n  );\n}\n\n\nWill eventually be compiled as:\n\n<button type=\"button\" className=\"button__redColor--JsFYl bg-blue\">\n  button\n</button>\n\n\nThe final effect is as follows:\n\n\n\nTIP\n\nWhen using babel-plugin-react-css-modules, it is important to note that the\nconfiguration option generateScopedName of this plugin needs to be the same as\noutput.css ModuleLocalIdentName.","frontmatter":{"sidebar_position":5}},{"id":210,"title":"Less and Sass","routePath":"/en/guides/css/less-sass","lang":"en","toc":[{"id":"customized-configuration","text":"Customized Configuration","depth":2}],"domain":"","content":"\n\nLess and Sass are two commonly used CSS preprocessors that Modern.js built-in\nsupport for the Less and Sass compile capabilities.\n\n\nCustomized Configuration\n\n * If you need to customize the configuration of less-loader, please refer to\n   the tools.less.\n * If you need to customize the configuration of sass-loader, please refer to\n   the tools.less.\n\nTIP\n\nCSS files pre-compiled by Less and Sass will still undergo Modern.js build-in\nPostCSS conversion, which has good browser compatibility. For related content,\nplease refer to [PostCSS].","frontmatter":{"sidebar_position":4}},{"id":211,"title":"PostCSS","routePath":"/en/guides/css/postcss","lang":"en","toc":[],"domain":"","content":"\n\nPostCSS is a tool for converting CSS code with JavaScript tools and plugins.\nModern.js built-in PostCSS and integrates common PostCSS plugins such as\nAutoprefixer to meet the style development needs of most projects.\n\nBy default, Modern.js compile and transform CSS as follows:\n\n 1. Autoprefixer Automatically add the required browser vendor prefix to CSS\n    rules according to the required browser range. Modern.js default supported\n    browser ranges are: ['> 0.01%', 'not dead', 'not op_mini all'].\n\nNote\n\n * [Supported browser range: > 0.01%] means that the browser market share is\n   greater than 0.01%.\n * Not dead means excluding browsers that are no longer officially supported and\n   browsers that have not been updated in the past 24 months.\n * not op_mini all means exclude Opera Mini.\n\nAdditional\n\nIf you need to modify the default browser support range, you can configure\nbrowserslist in the project's package.json file, and set the rule to refer to\nthe use of Browserslist. The following is an example: json title =\"package.json\"\n{ \"Browserslist\": [ \"The last 1 versions\", \"> 1%\", \"IE 10\" ] }\n\n 2. Provide CSS custom properties support, you can define and use custom\n    variables in CSS, such as:\n\n:root {\n  --main-bg-color: pink;\n}\n\nbody {\n  background-color: var(--main-bg-color);\n}\n\n\n 3. Provide CSS Nesting support, you can use nested writing in CSS, such as:\n\ntable.colortable td {\n  text-align: center;\n}\ntable.colortable td.c {\n  text-transform: uppercase;\n}\n\n\nIt can also be rewritten as CSS nested:\n\ntable.colortable {\n  & td {\n    text-align: center;\n    &.c {\n      text-transform: uppercase;\n    }\n  }\n}\n\n\n 4. Fix known Flexbugs.\n 5. Provide compatibility with the following CSS features:\n    * initial attribute value\n    * break- attribute\n    * font-variant\n    * Media Query Ranges\n\nWhen you need to modify the PostCSS configuration, you can implement it through\nthe underlying configuration tools.postcss, here is an example:\n\nexport default defineConfig({\n  tools: {\n    postcss: {\n      plugins: ['autoprefixer', ('postcss-flexbugs-fixes': {})],\n    },\n  },\n});\n","frontmatter":{"sidebar_position":3}},{"id":212,"title":"Tailwind CSS","routePath":"/en/guides/css/tailwindcss","lang":"en","toc":[{"id":"tailwind-css-version","text":"Tailwind CSS version","depth":2},{"id":"browser-compatibility","text":"Browser Compatibility","depth":3},{"id":"theme-config","text":"Theme config","depth":2}],"domain":"","content":"\n\nTailwind CSS is a CSS framework and design system based on Utility Class, which\ncan quickly add common styles to components, and support flexible extension of\ntheme styles. To use Tailwind CSS in the Modern.js, just execute pnpm run new in\nthe project root directory and turn it on.\n\nChoose as follows:\n\n? Action: Enable features\n? Enable features: Enable Tailwind CSS\n\n\nWhen using, add the following code to the root component of the entry (such as\nsrc/App.jsx):\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\nYou can then use the Utility Class provided by Tailwind CSS in each component:\n\nconst App = () => (\n  <div className=\"h-12 w-48\">\n    <p className=\"text-xl font-medium text-black\">hello world</p>\n  </div>\n);\n\n\nAdditional\n\nAccording to different needs, you can optionally import the CSS files provided\nby Tailwind CSS. Since the use of @taiwind is equivalent to directly importing\nCSS files, you can refer to the content in the annotate in the @tailwind usage\ndocument for the purpose of the CSS files provided by Tailwind CSS.\n\n\nTailwind CSS version\n\nModern.js supports both Tailwind CSS v2 and v3. The framework will recognize the\nversion of tailwindcss in the project package.json and apply the corresponding\nconfiguration. By default, we install Tailwind CSS v3 for you.\n\nIf your project is still using Tailwind CSS v2, we recommend that you upgrade to\nv3 to support JIT and other capabilities. For the differences between Tailwind\nCSS v2 and v3 versions, please refer to the following articles:\n\n * Tailwind CSS v3.0\n * Upgrade Guide\n\n\nBrowser Compatibility\n\nBoth Tailwind CSS v2 and v3 do not support IE 11 browsers. For background,\nplease refer to:\n\n * Tailwind CSS v3 - Browser Support.\n * Tailwind CSS v2 - Browser Support\n\nIf you use Tailwind CSS on IE 11 browser, some styles may not be available,\nplease pay attention.\n\n\nTheme config\n\nWhen you need to customize the theme configuration of Tailwind CSS, you can\nmodify it in the configuration source.designSystem, for example, add a color\ntheme primary:\n\nexport default defineConfig({\n  source: {\n    designSystem: {\n      extend: {\n        colors: {\n          primary: '#5c6ac4',\n        },\n      },\n    },\n  },\n});\n\n\nWhen you need special configuration for Tailwind CSS other than theme, you can\nconfigure it in tools.tailwindcss, for example setting variants:\n\nexport default defineConfig({\n  tools: {\n    tailwindcss: {\n      variants: {\n        extend: {\n          backgroundColor: ['active'],\n        },\n      },\n    },\n  },\n});\n\n\n> When configuring Tailwind CSS for a project, the combination of the two\n> configurations source.designSystem and tools.tailwindcss is equivalent to a\n> separate configuration tailwindcss.config.js file. Where source.designSystem\n> is equivalent to the theme configuration of Tailwind CSS.","frontmatter":{"sidebar_position":2}},{"id":213,"title":"Introduction","routePath":"/en/guides/get-started/introduction","lang":"en","toc":[{"id":"modernjs-introduction","text":"Modern.js Introduction","depth":2},{"id":"why-modernjs","text":"Why Modern.js","depth":2},{"id":"next","text":"Next","depth":2}],"domain":"","content":"\n\n\nModern.js Introduction\n\nModern.js is a progressive modern web development framework based on React.\n\nThe framework has a variety of built-in out-of-the-box tools, excellent build\nperformance, zero-configuration rendering paradigm switching, and integrated API\ncalls. Starting from three solutions (Application solutions, Module solutions,\nMonorepo solutions), it supports front-end research and development of a\ncomplete period.\n\nModern.js is ByteDance's underlying front-end framework, which has directly or\nindirectly served thousands of applications, including middle and back-end, PC\nWeb, H5 and other application scenarios. The framework covers a full life cycle,\nhas a complete plugin system, and provides a high degree of customization\ncapabilities. Support custom solutions exclusive to business lines through\ngenerator plugin, customize various functional extensions and business\nrequirements, and help developers build applications faster.\n\n\nWhy Modern.js\n\nModern.js can provide developers with the ultimate Development Experience，make\nthe app better User Experience.\n\nIn the process of developing React applications, developers often need to design\nimplementations for certain functions, or use other libraries and frameworks to\nsolve these problems.\n\nModern.js support all the configuration and tools required by React\napplications, and have built-in additional functions and optimizations.\nDevelopers can use React to build the UI of the application, and then gradually\nadopt Modern.js functions to solve common application requirements, such as\nrouting, data fetch, state management, etc.\n\nIt mainly contains the following features:\n\n * 🪜 Progressive：Create projects with the most streamlined templates, gradually\n   turn on plugin capabilities through generators, and customize solutions.\n * 🏠 Integration：The development is unique to the production environment Web\n   Server, CSR and SSR are isomorphic development, and the function as the API\n   service call.\n * 📦 Out Of The Box：Default TS support, built-in build core, ESLint, debugging\n   tools, full functionality can be tested.\n * 🌏 Ecology：Self-developed state management, micro frontend, module packaging,\n   Monorepo solution and other peripheral requirements.\n * 🕸 Routing Modes：Contains controlled routing, routing based on file\n   conventions (nested routing), configurable routing, etc.\n * 🚀 Independently Build Core：Support a variety of packaging tools, deep\n   optimization bundle.\n\n\nNext\n\nIf you want to know how to use Modern.js, you can try Create your first app, or\nread Quick Start.","frontmatter":{"title":"Introduction","sidebar_position":1}},{"id":214,"title":"Quick Start","routePath":"/en/guides/get-started/quick-start","lang":"en","toc":[{"id":"environment","text":"Environment","depth":2},{"id":"nodejs","text":"Node.js","depth":3},{"id":"pnpm","text":"pnpm","depth":3},{"id":"installation","text":"Installation","depth":2},{"id":"initialize","text":"Initialize","depth":2},{"id":"development","text":"Development","depth":2},{"id":"configuration","text":"Configuration","depth":2},{"id":"build","text":"Build","depth":2},{"id":"verify","text":"Verify","depth":2},{"id":"deploy","text":"Deploy","depth":2}],"domain":"","content":"\n\n\nEnvironment\n\n\nNode.js\n\nRequires Node.js LTS and ensures that the Node version is greater than or equal\nto 14.19.0, 16.x version is recommended.\n\nModern.js recommend installing nvm in the development environment and\nintegrating script to automatically switch node versions in the shell.\n\nThen there is a .nvmrc file with the content of lts/fermium or lts/gallium in\nthe root directory of the repository, it will automatically install or switch to\nthe correct Node.js version when entering the repository.\n\n\npnpm\n\npnpm is recommended for package management.\n\nnpm install -g pnpm\n\n\nNOTE\n\nModern.js also supports package management with yarn and npm.\n\n\nInstallation\n\nModern.js provides the @modern-js/create tool to create projects. Don't install\nglobally, use npx to run on demand.\n\nProjects can be created using an existing empty directory:\n\nmkdir myapp && cd myapp\nnpx @modern-js/create\n\n\nProjects can also be created directly from the new directory:\n\nnpx @modern-js/create myapp\n\n\n\nInitialize\n\nModern.js generator will provide an interactive Q & A interface, initialization\nitems according to the result, according to the default selection:\n\n? Please select the solution you want to create: Web App Solution\n? Development Language: TS\n? Package Management Tool: pnpm\n\n\nAfter create the project, Modern.js automatically installs dependency and\ncreates a git repository.\n\n[INFO] dependencies are automatically installed\n[INFO] git repository has been automatically created\n[INFO] Success！\nYou can run the following command in the directory of the new project：\npnpm run dev          # Run and debug the project according to the requirements of the development environment\npnpm run build        # Build the project according to the requirements of the product environment\npnpm run serve        # Run the project according to the requirements of the product environment\npnpm run lint         # Check and fix all codes\npnpm run new          # Create more project elements, such as application portals\n\n\nNOTE\n\nIn addition to working during project initialization, the Modern.js generator\ncan also generate modules of the project in subsequent development, which is not\nthrown away as soon as it is used.\n\nNow, the project structure is as follows:\n\n.\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── modern.config.ts\n├── package.json\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\n\nDevelopment\n\nExecute pnpm run dev in the project to start the project:\n\n$ pnpm run dev\n\n> modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n Client ✔ done in 76.10ms\n\n\nOpen http://localhost:8000/ in your browser and you will see the following:\n\n\n\n\nConfiguration\n\nThe modern.config.ts files exist in Modern.js projects created by the generator.\n\nFeatures can be enabled through the configuration file, or the default behavior\nof the coverage Modern.js. For example, add the following configuration to\nenable SSR:\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n});\n\n\nRe-execute pnpm run dev, in the browser Network menu, you can find that the\nproject has completed page rendering at the server level.\n\n\nBuild\n\nExecute pnpm run build in the project to build the project production\nenvironment product:\n\n$ pnpm run build\n\n> modern build\n\ninfo    Create a production build...\n\ninfo    File sizes after production build:\n\n  File                                      Size         Gzipped\n  dist/static/js/lib-corejs.ffeb7fb8.js     214.96 kB    67.23 kB\n  dist/static/js/lib-react.09721b5c.js      152.61 kB    49.02 kB\n  dist/static/js/218.102e2f39.js            85.45 kB     28.5 kB\n  dist/static/js/lib-babel.a7bba875.js      11.93 kB     3.95 kB\n  dist/html/main/index.html                 5.84 kB      2.57 kB\n  dist/static/js/main.3568a38e.js           3.57 kB      1.44 kB\n  dist/static/css/async/304.c3c481a5.css    2.62 kB      874 B\n  dist/asset-manifest.json                  1.48 kB      349 B\n  dist/static/js/async/304.c45706bc.js      1.4 kB       575 B\n  dist/static/js/async/509.fcb06e14.js      283 B        230 B\n\n Client ✔ done in 3.57s\n\n\nThe bundle is generated to dist/ by default, and the directory structure is as\nfollows:\n\n.\n├── asset-manifest.json\n├── html\n│   └── main\n├── loader-routes\n│   └── main\n├── modern.config.json\n├── route.json\n└── static\n    ├── css\n    └── js\n\n\n\nVerify\n\nExecute pnpm run serve in the project to verify locally that the bundle is\nrunning correctly:\n\n$ pnpm run serve\n\n> modern serve\n\nStarting the modern server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\nOpen http://localhost:8000/ in the browser and the content should be the same as\nwhen pnpm run dev.\n\n\nDeploy\n\nAfter the local verification is completed, the products under dist/ can be\norganized into the structure required by the server for deployment.","frontmatter":{"title":"Quick Start","sidebar_position":2}},{"id":215,"title":"Upgrade","routePath":"/en/guides/get-started/upgrade","lang":"en","toc":[{"id":"upgrade-with-command","text":"Upgrade with command","depth":2},{"id":"specify-version-upgrade","text":"Specify version upgrade","depth":2},{"id":"lock-child-dependency","text":"lock child dependency","depth":2},{"id":"pnpm","text":"pnpm","depth":3},{"id":"yarn","text":"Yarn","depth":3},{"id":"npm","text":"Npm","depth":3}],"domain":"","content":"\n\n\nUpgrade with command\n\nModern.js provides the upgrade command to support projects to upgrade to the\nlatest version.\n\nExecute pnpm run upgrade in the project:\n\n$ pnpm run upgrade\n\n> modern upgrade\n\n[INFO] [Project Type]: Application\n[INFO] [Modern.js Latest Version]: 2.0.0\n[INFO] Upgrade Modern.js package version success!\n\n\nYou can see that the dependency in the project package.json has been changed to\nthe latest.\n\n\nSpecify version upgrade\n\nModern.js all packages are published using the unified version number.\n\nAccording to the website Release Note, developers can also manually upgrade the\nproject to the desired version.\n\nTIP\n\nWhen upgrading, you need to upgrade to all packages provided by the Modern.js,\nrather than upgrading a single dependency.\n\n\nlock child dependency\n\nWhen there is a problem with one of the child dependencies of the project, and\nthe Modern.js cannot be updated immediately, you can use the package manager to\nlock the child dependency version.\n\n\npnpm\n\nFor projects using pnpm, add the following configuration to the package.json in\nthe project root directory and re-execute pnpm install:\n\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"package-name\": \"^1.0.0\"\n    }\n  }\n}\n\n\n\nYarn\n\nFor projects using Yarn, add the following configuration to the package.json in\nthe project root directory and re-execute yarn install:\n\n{\n  \"resolutions\": {\n    \"package-name\": \"^1.0.0\"\n  }\n}\n\n\n\nNpm\n\nFor projects using Npm, add the following configuration to the package.json in\nthe project root directory and re-execute npm install:\n\n{\n  \"overrides\": {\n    \"package-name\": \"^1.0.0\"\n  }\n}\n\n\nINFO\n\nFor Monorepo repositories, the dependency version can only be locked in the\npackage.json in the project root directory, and all packages in Monorepo are\naffected.","frontmatter":{"title":"Upgrade","sidebar_position":3}},{"id":216,"title":"扩展插件 Hook","routePath":"/en/guides/topic-detail/framework-plugin/extend","lang":"en","toc":[{"id":"示例","text":"示例","depth":2},{"id":"创建-hook","text":"创建 Hook","depth":3},{"id":"使用-hook","text":"使用 Hook","depth":3}],"domain":"","content":"\n\n本小节介绍如何通过动态注册 Hook 模型 的方式来扩展插件 Hook。\n\n\n示例\n\n这里我们用一个简单的例子演示一下。假设我们要添加一些管理控制台输出信息的 Hook。\n\n首先我们初始化一个空的项目文件，并添加基础依赖：\n\n$ npx @modern-js/create modern-js-demo\n\n\n\n创建 Hook\n\n我们先创建一个 Hook 模型：\n\n\n\nconst message = createWaterfall<string[]>();\n\n\n然后注册它：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  registerHook: {\n    message,\n  },\n});\n\n\n添加 Hook 类型：\n\ndeclare module '@modern-js/core' {\n  export interface Hooks {\n    message: typeof message;\n  }\n}\n\n\n\n使用 Hook\n\n创建插件，通过 commands Hook 函数，添加命令处理逻辑：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    return {\n      commands({ program }) {\n        program.command('message').action(async () => {\n          const hookRunners = api.useHookRunners();\n          const messages = hookRunners.message([]);\n          console.log(messages.join('\\n'));\n        });\n      },\n    };\n  },\n});\n\n\n最后 config/plugin/myPlugin.ts 的状态是：\n\n\n\n\nconst message = createWaterfall<string[]>();\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  registerHook: {\n    message,\n  },\n\n  setup(api) {\n    return {\n      commands({ program }) {\n        program.command('message').action(async () => {\n          const hookRunners = api.useHookRunners();\n          const messages = hookRunners.message([]);\n          console.log(messages.join('\\n'));\n        });\n      },\n    };\n  },\n});\n\ndeclare module '@modern-js/core' {\n  export interface Hooks {\n    message: typeof message;\n  }\n}\n\n\n然后在 modern.config.ts 中添加这个插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n这时运行 npx modern message 就会执行相关逻辑，但由于没有收集到任何信息，所以控制台输出为空。\n\n那这里我们添加一个：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'other-plugin',\n\n  setup(api) {\n    return {\n      message(list) {\n        return [...list, '[foo] line 0', '[foo] line 1'];\n      },\n    };\n  },\n});\n\n\n将它添加到配置中：\n\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin(), otherPlugin()],\n});\n\n\n这时运行 npx modern message 就可以在控制台看到信息了：\n\n$ modern message\n[foo] line 0\n[foo] line 1\n\n\n以上面这种方式就可以扩展出拥有各种能力的插件 Hook。","frontmatter":{"title":"扩展插件 Hook","sidebar_position":5}},{"id":217,"title":"Hook 列表","routePath":"/en/guides/topic-detail/framework-plugin/hook-list","lang":"en","toc":[{"id":"cli","text":"CLI","depth":2},{"id":"config","text":"config","depth":3},{"id":"validateschema","text":"validateSchema","depth":3},{"id":"prepare","text":"prepare","depth":3},{"id":"afterprepare","text":"afterPrepare","depth":3},{"id":"commands","text":"commands","depth":3},{"id":"beforeexit","text":"beforeExit","depth":3},{"id":"beforedev","text":"beforeDev","depth":3},{"id":"afterdev","text":"afterDev","depth":3},{"id":"beforecreatecompiler","text":"beforeCreateCompiler","depth":3},{"id":"aftercreatecompiler","text":"afterCreateCompiler","depth":3},{"id":"beforeprintinstructions","text":"beforePrintInstructions","depth":3},{"id":"beforebuild","text":"beforeBuild","depth":3},{"id":"afterbuild","text":"afterBuild","depth":3},{"id":"modifyentryimports","text":"modifyEntryImports","depth":3},{"id":"modifyentryexport","text":"modifyEntryExport","depth":3},{"id":"modifyentryruntimeplugins","text":"modifyEntryRuntimePlugins","depth":3},{"id":"modifyentryrenderfunction","text":"modifyEntryRenderFunction","depth":3},{"id":"modifyfilesystemroutes","text":"modifyFileSystemRoutes","depth":3},{"id":"modifyserverroutes","text":"modifyServerRoutes","depth":3},{"id":"modifyasyncentry","text":"modifyAsyncEntry","depth":3},{"id":"htmlpartials","text":"htmlPartials","depth":3},{"id":"server","text":"Server","depth":2},{"id":"create","text":"create","depth":3},{"id":"preparewebserver","text":"prepareWebServer","depth":3},{"id":"prepareapiserver","text":"prepareApiServer","depth":3},{"id":"runtime","text":"Runtime","depth":2},{"id":"init","text":"init","depth":3},{"id":"hoc","text":"hoc","depth":3},{"id":"provide","text":"provide","depth":3},{"id":"client","text":"client","depth":3},{"id":"server-1","text":"server","depth":3}],"domain":"","content":"\n\n在 Modern.js 中暴露了三类插件：CLI、Runtime、Server。下面列举下各类中的 Hook：\n\n\nCLI\n\n\nconfig\n\n * 功能：收集配置\n * 执行阶段：解析完 modern.config.ts 中的配置之后\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      config: () => {\n        return {\n          /** some config */\n        };\n      },\n    };\n  },\n});\n\n\n这里返回的配置信息，会被收集和统一处理合并。\n\n\nvalidateSchema\n\n * 功能：收集各个插件中配置的用来校验用户配置的 JSON Schema\n * 执行阶段：config Hook 运行完之后。\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      validateSchema: () => {\n        return {\n          // target is field\n          target: 'foo',\n          schema: {\n            type: 'string',\n          },\n        };\n      },\n    };\n  },\n});\n\n\n这里返回的 JSON Schema 会用来校验 modern.config.js 中的配置信息。\n\n比如这里返回：\n\n{\n  \"target\": \"foo\",\n  \"schema\": {\n    \"type\": \"string\"\n  }\n}\n\n\n就可以在 modern.config.ts 中这样配置：\n\nexport default defineConfig({\n  foo: 'test',\n});\n\n\n如果是别的类型，校验就不通过会报错，比如这样：\n\nexport default defineConfig({\n  foo: {},\n});\n\n\n就会报错：\n\n$ modern dev\n  1 | {\n> 2 |   \"foo\": {},\n    |   ^^^^^  Property foo is not expected to be here\n\n\n\nprepare\n\n * 功能：运行主流程的前置准备流程\n * 执行阶段：校验完配置之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      prepare: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterPrepare\n\n * function：Running tasks after the prepare process\n * Execution Phase：After the prepare process\n * Hook model：AsyncWorkflow\n * type：AsyncWorkflow<void, void>\n * Usage：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterPrepare: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\ncommands\n\n * 功能：为 command 添加新的命令\n * 执行阶段：prepare Hook 运行完之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ program: Command; }, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      commands: ({ program }) => {\n        program.command('foo').action(async () => {\n          // do something\n          console.log('foo');\n        });\n      },\n    };\n  },\n});\n\n\n将上面这个插件添加到 modern.config.ts 中：\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n运行 modern foo 就可以看到控制台输出：\n\n$ modern foo\nfoo\n\n\n\nbeforeExit\n\n * 功能：在退出进程前，重置一些文件状态\n * 执行阶段：进程退出之前\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeExit: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforeDev\n\n * 功能：运行 dev 主流程的之前的任务\n * 执行阶段：dev 命令运行时，项目开始启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeDev: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterDev\n\n * 功能：运行 dev 主流程的之后的任务\n * 执行阶段：dev 命令运行时，项目启动完成之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterDev: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforeCreateCompiler\n\n * 功能：在中间件函数中可以拿到创建 Webpack Compiler 的 Webpack 配置\n * 执行阶段：创建 Webpack Compiler 之前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ webpackConfigs: Configuration[];}, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeCreateCompiler: ({ webpackConfigs }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterCreateCompiler\n\n * 功能：在中间件函数中可以拿到创建的 Webpack Compiler\n * 执行阶段：创建 Webpack Compiler 之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ compiler: Compiler | MultiCompiler | undefined; },\n   unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterCreateCompiler: ({ compiler }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforePrintInstructions\n\n * 功能：在中间件函数中可以拿到即将打印的日志信息，并对其进行修改\n * 执行阶段：打印日志信息之前执行\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ instructions: string }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforePrintInstructions: ({ instructions }) => {\n        // do something\n        return {\n          instructions: [...instructions, 'some new message'],\n        };\n      },\n    };\n  },\n});\n\n\n\nbeforeBuild\n\n * 功能：运行 build 主流程的之前的任务，可以拿到构建的 Webpack 配置\n * 执行阶段：build 命令运行时，项目构建启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ webpackConfigs: Configuration[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeBuild: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterBuild\n\n * 功能：运行 build 主流程的之后的任务\n * 执行阶段：build 命令运行时，项目构建完成之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterBuild: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryImports\n\n * 功能：用于修改、添加生成入口文件中的 import 语句\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ imports: ImportStatement[]; entrypoint: Entrypoint; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryImports({ entrypoint, imports }) {\n        // 添加 ``\n        imports.push({\n          value: 'react',\n          specifiers: [\n            {\n              imported: 'unmountComponentAtNode',\n            },\n          ],\n        });\n\n        return { entrypoint, imports };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryExport\n\n * 功能：用于修改生成入口文件中的 export 语句\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; exportStatement: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryImports({ entrypoint, exportStatement }) {\n        return {\n          entrypoint,\n          exportStatement: [`export const foo = 'test'`, exportStatement].join(\n            '\\n',\n          ),\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryRuntimePlugins\n\n * 功能：用于添加、修改生成入口文件中的 Runtime 插件\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; plugins: RuntimePlugin[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryRuntimePlugins({ entrypoint, plugins }) {\n        const name = 'customPlugin';\n        const options = {\n          /** 可序列化的内容 */\n        };\n\n        return {\n          plugins: [\n            ...plugins,\n            {\n              name,\n              options: JSON.stringify(options),\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryRenderFunction\n\n * 功能：用于修改生成入口文件中 render 函数\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; code: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryRenderFunction({ entrypoint, code }) {\n        const customRender = `/** render function body */`;\n        return {\n          entrypoint,\n          code: customRender,\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyFileSystemRoutes\n\n * 功能：用于修改生成前端页面路由文件中的内容，内容都是需要可序列化的\n * 执行阶段：生成前端路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; routes: Route[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyFileSystemRoutes({ entrypoint, routes }) {\n        return {\n          entrypoint,\n          routes: [\n            ...routes,\n            {\n              path: '/custom_page',\n              component: require.resolve('./Component'),\n              exact: true,\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n这样就为前端新增了一个页面路由。\n\n\nmodifyServerRoutes\n\n * 功能：用于修改生成服务器路由中的内容\n * 执行阶段：生成 Server 路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ routes: ServerRoute[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyServerRoutes({ routes }) {\n        return {\n          routes: [\n            ...routes,\n            {\n              urlPath: '/api/foo',\n              isApi: true,\n              entryPath: '',\n              isSPA: false,\n              isSSR: false,\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyAsyncEntry\n\n * 功能：用于修改包裹入口文件的异步模块，参见 source.enableAsyncEntry\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; code: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyAsyncEntry({ entrypoint, code }) {\n        const customCode = `console.log('hello');`;\n        return {\n          entrypoint,\n          code: `${customCode}${code}`,\n        };\n      },\n    };\n  },\n});\n\n\n\nhtmlPartials\n\n * 功能：用于定制生成的 HTML 页面模版\n * 执行阶段：prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; partials: HtmlPartials; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      async htmlPartials({ entrypoint, partials }) {\n        partials.head.push('<script>console.log(\"test\")</script>');\n        return {\n          entrypoint,\n          partials,\n        };\n      },\n    };\n  },\n});\n\n\n这样就为 HTML 模版中新增了一个 Script 标签。\n\n\nServer\n\nNOTE\n\n目前 Server 插件还未完全开放，API 不保证稳定，使用需谨慎。\n\n应用工程中的 Server 部分也支持了插件。其中的 Hook 将会提供一些特定阶段调用和特殊功能的 Hook。\n\n\ncreate\n\n * 功能：在中间件函数中会拿到 Server 初始化用到的指标测量工具配置 measureOptions 和日志工具配置\n   loggerOptions，并返回自定义的指标测量工具 measure 和日志工具配置 logger\n * 执行阶段：Server 初始化\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<ServerInitInput, InitExtension>\n * 使用示例：\n\n\n\nexport default (): ServerPlugin => ({\n  setup(api) {\n    return {\n      create: ({ measureOptions, loggerOptions }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nprepareWebServer\n\n * 功能：设置 Web 路由的处理函数，在中间件函数中可以拿到 Web Server 的前置中间件\n * 执行阶段：在请求到达的时候\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<WebServerStartInput, Adapter>\n * 使用示例：\n\n\n\nexport default (): ServerPlugin => ({\n  setup(api) {\n    return {\n      prepareWebServer: ({ middleware }) => {\n        // do something\n\n        return (req, res) => {\n          // do response\n        };\n      },\n    };\n  },\n});\n\n\n\nprepareApiServer\n\n * 功能：设置 API 路由的处理函数，在中间件函数中可以拿到 API Server 的前置中间件\n * 执行阶段：请求到达并且 match bff basename 之后执行\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<APIServerStartInput, Adapter>\n * 使用示例：\n\n\n\nexport default (): ServerPlugin => ({\n  setup(api) {\n    return {\n      prepareApiServer: ({ middleware }) => {\n        // do something\n\n        return (req, res) => {\n          // do response\n        };\n      },\n    };\n  },\n});\n\n\n\nRuntime\n\nNOTE\n\n目前 Runtime 插件还未完全开放，API 不保证稳定，使用需谨慎。\n\nRuntime 插件主要用于开发者修改需要渲染的组件与 Element 和定制服务器端、客户端的渲染过程。\n\n\ninit\n\n * 功能：执行 App.init\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ context: RuntimeContext; }, unknown>\n * 使用示例：\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      init({ context }, next) {\n        // do something\n        return next({ context });\n      },\n    };\n  },\n});\n\n\n\nhoc\n\n * 功能：修改需要渲染的组件\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：Pipeline\n * 类型：Pipeline<{ App: React.ComponentType<any>; }, React.ComponentType<any>>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    const FooContext = createContext('');\n    return {\n      hoc({ App }, next) {\n        return next({\n          App: (props: any) => {\n            return (\n              <FooContext.Provider store={'test'}>\n                <App {...props} />\n              </FooContext.Provider>\n            );\n          },\n        });\n      },\n    };\n  },\n});\n\n\n\nprovide\n\n * 功能：修改需要渲染的 Element\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：Pipeline\n * 类型：Pipeline<{ element: JSX.Element; props: AppProps; context: RuntimeContext\n   }, JSX.Element>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    const FooContext = createContext('');\n\n    return {\n      provide: ({ element }) => <div>{element}</div>,\n    };\n  },\n});\n\n\n\nclient\n\n * 功能：定制客户端渲染流程\n * 执行阶段：在浏览器客户端渲染\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ App: React.ComponentType<any>; context?: RuntimeContext;\n   rootElement: HTMLElement; }, void>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      client: async ({ App, rootElement }) => {\n        ReactDOM.render(\n          React.createElement(App, { context: { foo: 'test' } }),\n          rootElement,\n        );\n      },\n    };\n  },\n});\n\n\n\nserver\n\n * 功能：定制服务器端渲染流程\n * 执行阶段：SSR\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ App: React.ComponentType<any>; context?: RuntimeContext;\n   }, string>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      server({ App, context }) {\n        return ReactDomServer.renderToString(\n          React.createElement(App, { context: { foo: 'test' } }),\n        );\n      },\n    };\n  },\n});\n","frontmatter":{"title":"Hook 列表","sidebar_position":8}},{"id":218,"title":"Hook 模型","routePath":"/en/guides/topic-detail/framework-plugin/hook","lang":"en","toc":[{"id":"基础工作方式","text":"基础工作方式","depth":2},{"id":"不同-hook-模型的区别","text":"不同 Hook 模型的区别","depth":2},{"id":"pipeline","text":"Pipeline","depth":3},{"id":"waterfall","text":"Waterfall","depth":3},{"id":"workflow","text":"Workflow","depth":3},{"id":"hook-模型对比","text":"Hook 模型对比","depth":2}],"domain":"","content":"\n\n首先介绍一下 Modern.js 的基础的插件系统中的一些内容，包括 Hook 模型的工作方式、各个 Hook 模型的运行模式、Manager 的工作模式。\n\n每种 Hook 模型都是独立的，可以独立管理运行函数。\n\n\n基础工作方式\n\n先以 Pipeline 为例，简单介绍一下 Hook 模型的工作方式。先看一个简单的例子：\n\n\n\n// 1. 创建\nconst pipeline = createPipeline<number, number>();\n\n// 2. 添加函数\npipeline.use((count, next) => {\n  return next(count + 1);\n});\npipeline.use((count, next) => {\n  return count * 2;\n});\n\n// 3. 执行\npipeline.run(1); // 4\npipeline.run(5); // 12\n\n\n在这个例子中，创建了一个 Pipeline<number, number> 类型的 Pipeline（L3），这意味着运行它的时候，你需要传入一个\nnumber，然后你会得到一个 number，而这个模型管理的函数的类型是：\n\n(count: number, next: (nextCount: number) => number) => number;\n\n\n这里全是 number，是因为我们创建的是 Pipeline<number, number> ，如果创建的是 Pipeline<number, string>\n则运行它入参是 number，返回值是 string，对应管理的函数的类型会是：\n\n(count: number, next: (nextCount: number) => string) => string;\n\n\n创建好 Pipeline 之后，可以通过 use 添加函数（L5、L8），需要注意的是，添加的顺序就是他们默认的运行顺序，在这些函数中，你可以对 count\n进行处理、返回一个值，如果你调用了 next 函数，则会运行后面的函数，即如果你添加了三个函数： A、B、C，如果你在 A 中调用 next 那么就会运行\nB，同样的，如果你在 B 中调用 next 那么就会运行 C，而在上面的例子中，添加的第一个函数（L5）就运行了\nnext，所以这里就会运行第二个函数（L8），并且运行的返回值就是 第二个函数的返回值，如果在第一个函数中没有调用 next，直接返回，例如：\n\n\n\n// 1. 创建\nconst pipeline = createPipeline<number, number>();\n\n// 2. 添加函数\npipeline.use((count, next) => {\n  return count + 1;\n});\npipeline.use((count, next) => {\n  return count * 2;\n});\n\n// 3. 执行\npipeline.run(1); // 2\npipeline.run(5); // 6\n\n\n则在运行 Pipeline 的时候就不会运行第二个函数，那么 Pipeline 的运行结果则就是第一个函数的返回值。\n\n最后，运行 Pipeline 的方式也显而易见就是调用 pipeline.run 。\n\n\n不同 Hook 模型的区别\n\n上面这部分就是 Pipeline 整体的一个工作模式的描述，其他的 Hook 模型的工作模式基本也是这样，主要的区别点，是函数类型、执行顺序，参数。\n\n\nPipeline\n\n上面的例子就是以 Pipeline 为例描述的，这里就不赘述了，在 Pipeline 这个大类中，提供了两个小类：Sync 和\nAsync，顾名思义，它们的区别就是管理的函数的类型是 Sync 的还是 Async 的。\n\nINFO\n\n当 Pipeline 中没有函数或者所有函数都调用了 next 函数，则就需要在运行的时候提供：\n\npipeline(\n  {},\n  {\n    onLast: () => {\n      // do something\n    },\n  },\n);\n\n\n\nWaterfall\n\n这种模型顾名思义，他的特点就是参数的顺序递交，即前面一个函数的返回值，将会成为下一个函数的入参，我们也用一个例子来看一下：\n\n\n\n// 1. 创建\nconst waterfall = createWaterfall<number>();\n\n// 2. 添加函数\nwaterfall.use(count => {\n  return count + 1;\n});\nwaterfall.use(count => {\n  return count * 2;\n});\n\n// 3. 执行\nwaterfall.run(1); // 4\nwaterfall.run(5); // 12\n\n\n这个例子中，创建了一个类型为 Waterfall<number> ，即这个模型执行的入参和返回值是一样的，这个例子中都是 number，而它管理的函数的类型是：\n\n(count: number) => number;\n\n\n可能简单看这个例子感觉和上面的 Pipeline 功能一样，那需要注意的是，首先这里 Waterfall 管理的函数没有 next\n函数作为第二个参数，所以它无法在函数内部通过调用 next 来先运行之后添加的函数，从而修改运行的顺序，其次这里的运行的入参的类型和返回值的类型必须是一样的（而\nPipeline 可以不一样）。\n\n同样的，在 Waterfall 这个大类中，也提供了 Sync 和 Async 的小类，分别对应 Sync 和 Async 的函数。\n\n\nWorkflow\n\n这种 Hook 模型与上面两种 Hook\n模型的区别是，没有那么强的前后参数返回值递交的概念，在这个模型中，每个函数都是基于同样的入参，相对独立运行的，通过一个例子简单看一下：\n\n\n\n// 1. 创建\nconst workflow = createWorkflow<number, number>();\n\n// 2. 添加函数\nworkflow.use(count => {\n  return count + 1;\n});\nworkflow.use(count => {\n  return count * 2;\n});\n\n// 3. 执行\nworkflow.run(1); // [2, 2]\nworkflow.run(5); // [6, 10]\n\n\n在这个例子中，添加了两个函数，所以运行的结果就是这两个函数运行的结果形成的一个数组。\n\n虽然这种模型中没有那么强的前后参数返回值递交的概念，但依旧有执行顺序的区别，在 Workflow\n这个大类中，提供了三个小类：Sync、Async、Parallel。他们之间的区别就是函数的执行顺序，当然默认的都是按照添加顺序执行，而在 Sync、Async\n则是强制按照添加顺序执行，而 Parallel 则是 Async 模式的一个变体，即它使用的是 Promise.all 来执行所有函数，而 Async 则会\nawait 前面的函数运行结束。\n\n\nHook 模型对比\n\n| | 函数类型 | 执行顺序 | 函数参数来源 | 执行返回值来源 | 倾向处理的任务类型 | 函数 TS 类型 | | ---------------- |\n---------- | ---------------------------------------------------------- |\n--------------------------------------------------------------------------------\n---------- | ------------------------ |\n------------------------------------------------------------------- |\n------------------------------------------------------ | | Pipeline | Sync |\n默认执行第一个添加的函数，可以通过 next 调用之后添加的函数 | 第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数向 next\n函数传递的参数 | 第一个函数的返回值 | 需要修改初始参数需要修改函数执行顺序 | (input: I, next: Next<I, O>) => O | |\nAsyncPipeline | Sync/Async | 默认执行第一个添加的函数，可以通过 next 调用之后添加的函数 |\n第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数向 next 函数传递的参数 | 第一个函数的返回值 |\n需要修改初始参数需要修改函数执行顺序 | (input: I, next: AsyncNext<I, O>) => O ｜ Promise<O> | |\nWaterFall | Sync | 一直顺序执行 | 第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数的返回值 | 最后一个函数的返回值\n| 需要修改初始参数不需要修改函数执行顺序 | (I: I) => I | | AsyncWaterFall | Sync/Async | 一直顺序执行 |\n第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数的返回值 | 最后一个函数的返回值 | 需要修改初始参数不需要修改函数执行顺序 | (I:\nI) => I ｜ Promise<I> | | Workflow | Sync | 一直顺序执行 | 所有函数的入参都是运行的参数 |\n所有函数返回值形成的数组 | 不需要修改初始参数不需要修改函数执行顺序 | (I: I) => O | | AsyncWorkflow | Sync/Async\n| 一直顺序执行 | 所有函数的入参都是运行的参数 | 所有函数返回值形成的数组 | 不需要修改初始参数不需要修改函数执行顺序 | (I: I) => O ｜\nPromise<O> | | ParallelWorkFlow | Sync/Async | 异步执行 | 所有函数的入参都是运行的参数 |\n所有函数返回值形成的数组 | 不需要修改初始参数不关心执行顺序 | (I: I) => O ｜ Promise<O> |\n\nWorkflow、Waterfall 其实都是 Pipeline 的变体，Pipeline 可以通过特定的写法来实现\nWorkflow、Waterfall，但都较为麻烦，有许多隐形的约定。为了方便使用，提供了这两种变体来满足这种特殊场景。","frontmatter":{"title":"Hook 模型","sidebar_position":2}},{"id":219,"title":"如何编写插件","routePath":"/en/guides/topic-detail/framework-plugin/implement","lang":"en","toc":[{"id":"实现插件","text":"实现插件","depth":2},{"id":"插件类型","text":"插件类型","depth":3},{"id":"插件配置项","text":"插件配置项","depth":3},{"id":"插件-api","text":"插件 API","depth":3},{"id":"异步-setup","text":"异步 setup","depth":3},{"id":"添加插件","text":"添加插件","depth":2},{"id":"开发本地插件","text":"开发本地插件","depth":3},{"id":"在-npm-上发布插件","text":"在 npm 上发布插件","depth":3}],"domain":"","content":"\n\n上一小节介绍了 Modern.js 插件的 Hook 模型，这一小节介绍如何编写插件。\n\n\n实现插件\n\nModern.js 插件是一个对象，对象包含以下属性：\n\n * name: 插件的名称，唯一标识符。\n * setup: 插件初始化函数，只会执行一次。setup 函数可以返回一个 Hooks 对象，Modern.js 会在特定的时机执行这些 Hooks。\n\nconst myPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    // 执行一些初始化逻辑\n    const foo = '1';\n\n    // 返回一个 Hooks 对象\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n另外，在插件中，允许配置与其他插件的执行顺序。详情可以参考插件关系。\n\n\n插件类型\n\nModern-js 支持多种工程开发，如应用工程(app-tools), 模块工程(module-tools)等。\n\n为了兼顾不同工程开发的差异和通性，Modern-js 将插件如下图进行组织:\n\n\n\n从图可以看出，Modern-js 将插件大致分为两类:\n\n 1. 通用插件: 插件只会包含一些基础的 Hooks\n\n 2. 工程插件: 不同的工程开发会在通用插件的基础上扩展出自己的 Hooks, Config 等类型。\n\n使用 TypeScript 时，可以引入内置的 CliPlugin 等类型，为插件提供正确的类型推导。\n\n\n\nconst myPlugin: CliPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    const foo = '1';\n\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n上述代码为通用插件，只包含一些基础的 Hooks。 Modern.js 支持通过泛型对插件的定义进行扩展：\n\n\n\nconst myPlugin: CliPlugin<AppTools> = {\n  name: 'my-plugin',\n\n  setup() {\n    const foo = '1';\n\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n如果仔细观察 AppTools 这个类型，可以发现 AppTools 由 3 种类型构成.\n\ntype AppTools = {\n  hooks: AppToolsHooks;\n  userConfig: AppToolsUserConfig;\n  normalizedConfig: AppToolsNormalizedConfig;\n};\n\n\n当编写插件时，插件通过泛型扩展在不同的基础上扩展自己的 Hooks 等类型:\n\n// 通用插件上扩展\n\n\n\nconst myPlugin: CliPlugin<{ hooks: MyPluginHook }> = {};\n\n\n// 在 @modern-js/app-tools 基础上扩展\n\n\n\nconst myPlugin: CliPlugin<AppTools & { hooks: MyPluginHook }> = {};\n\n\n详细说明，请参考 扩展 Hook。\n\n\n插件配置项\n\n建议将插件写成函数的形式，使插件能通过函数入参来接收配置项：\n\n\n\ntype MyPluginOptions = {\n  foo: string;\n};\n\nconst myPlugin = (options: MyPluginOptions): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    console.log(options.foo);\n  },\n});\n\n\n\n插件 API\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    // 获取应用原始配置\n    const config = api.useConfigContext();\n    // 获取应用运行上下文\n    const appContext = api.useAppContext();\n    // 获取解析之后的最终配置\n    const resolvedConfig = api.useResolvedConfigContext();\n  },\n});\n\n\n插件 API 的详细说明，请参考 Plugin API。\n\n\n异步 setup\n\nCLI 插件的 setup 可以是一个异步函数，在初始化过程中执行异步逻辑。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  async setup(api) {\n    await doSomething();\n  },\n});\n\n\n\n添加插件\n\n自定义插件的使用方式可以查看：plugins (框架插件)。下面会介绍 Modern.js 中推荐的插件实现方法。\n\n\n开发本地插件\n\n本地插件推荐写在 config/plugin 目录下，并通过 export default 导出：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    // 插件初始化\n  },\n});\n\n\n然后在 modern.config.ts 中注册对应的插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n在 npm 上发布插件\n\n如果需要将 Modern.js 插件发布到 npm，推荐使用 Modern.js 中的模块工程方案来管理和构建。\n\n首先创建一个空的模块工程方案项目，调整 npm 包名称：\n\n{\n  \"name\": \"my-plugin\"\n  ...\n}\n\n\n然后新建对应的插件文件：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    // 插件初始化\n  },\n});\n\n\n发布之后，安装到需要使用的项目 pnpm add my-plugin，这里以一个应用项目为例，然后在 modern.config.ts 中添加：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n如果你发现目前 Modern.js 存在无法满足的场景，欢迎通过编写自定义插件的方式来一起建设 Modern.js 生态。","frontmatter":{"title":"如何编写插件","sidebar_position":3}},{"id":220,"title":"介绍","routePath":"/en/guides/topic-detail/framework-plugin/introduction","lang":"en","toc":[{"id":"modernjs-插件系统","text":"Modern.js 插件系统","depth":2},{"id":"插件可以做什么","text":"插件可以做什么","depth":2}],"domain":"","content":"\n\n\nModern.js 插件系统\n\nModern.js 用于扩展项目运行、请求、渲染等不同阶段功能的系统，主要分为三个部分：Hook 模型、管理器，上下文共享机制。\n\nHook 模型用于确定当前 Hook 的执行方式，不同 Hook 模型的函数拥有不同的执行逻辑。管理器用于控制 Hook 的执行与调度。上下文共享机制用于在不同\nHook 间传递信息。\n\n目前 Modern.js 提供几种不同的 Hook 模型：\n\n * Pipeline\n   * Sync\n   * Async\n * Waterfall\n   * Sync\n   * Async\n * Workflow\n   * Sync\n   * Async\n   * Parallel(Async)\n\nNOTE\n\n后续章节详细介绍各个模型的执行方式。\n\n基于 Hook 模型和管理器，Modern.js 暴露了三套插件：CLI、Runtime、Server。\n\n其中 CLI 插件是 Modern.js 中主要的运行流程控制模型，Modern.js 中绝大部分功能都是主要通过这一套模型运行的。Runtime\n插件主要负责处理 React 组件渲染逻辑。Server 插件主要用于对服务端的生命周期以及用户请求的控制。\n\n\n插件可以做什么\n\nModern.js 的所有功能都是通过这套插件实现的，这意味着 Modern.js\n中的所有能力是都对开发者开放的。开发者可以通过编写插件来扩展更多功能，适配复杂场景，包括但不限于：\n\n * 注册命令\n * 修改 Modern.js 配置、配置校验 Schema\n * 修改编译时的 Webpack/Babel/Less/Sass/Tailwind CSS/... 配置\n * 修改运行时需要渲染的 React 组件、Element\n * 修改页面路由\n * 修改服务器路由\n * 自定义控制台输出\n * 自定义动态 HTML 模版\n * 自定义 Node.js 服务器框架\n * 自定义 React 组件客户端/服务器端渲染\n * ...\n\n当 Modern.js 暂时没有覆盖到你所需要的功能或场景时，可以开发一个自定义插件，来实现适配特殊场景的相关功能。","frontmatter":{"title":"介绍","sidebar_position":1}},{"id":221,"title":"Lifecycle","routePath":"/en/guides/topic-detail/framework-plugin/lifecycle","lang":"en","toc":[],"domain":"","content":"\n\nModern.js application has a complete lifecycle, including CLI, Server Side and\nRuntime three stages.\n\nModern.js lifecycle is as follows:\n\nNOTE\n\nThe rectangle of the pink box represents the plugin hook provided by the\nModern.js, and the light yellow base color ellipse represents the linkage point\nwith the next stage.\n\n","frontmatter":{"title":"Lifecycle","sidebar_position":1}},{"id":222,"title":"插件 API","routePath":"/en/guides/topic-detail/framework-plugin/plugin-api","lang":"en","toc":[{"id":"api","text":"API","depth":2},{"id":"useconfigcontext","text":"useConfigContext","depth":3},{"id":"useappcontext","text":"useAppContext","depth":3},{"id":"useresolvedconfigcontext","text":"useResolvedConfigContext","depth":3},{"id":"usehookrunners","text":"useHookRunners","depth":3}],"domain":"","content":"\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    // 获取应用原始配置\n    const config = api.useConfigContext();\n    // 获取应用运行上下文\n    const appContext = api.useAppContext();\n    // 获取解析之后的最终配置\n    const resolvedConfig = api.useResolvedConfigContext();\n  },\n});\n\n\n\nAPI\n\n\nuseConfigContext\n\n用于获取应用原始配置。\n\nconst useConfigContext: () => UserConfig;\n\ninterface UserConfig {\n  source?: SourceConfig;\n  output?: OutputConfig;\n  server?: ServerConfig;\n  dev?: DevConfig;\n  deploy?: DeployConfig;\n  tools?: ToolsConfig;\n  plugins?: PluginConfig;\n  runtime?: RuntimeConfig;\n  runtimeByEntries?: RuntimeByEntriesConfig;\n}\n\n\n具体配置字段的意义请参考【配置】。\n\n\nuseAppContext\n\n用于获取应用运行上下文。\n\nconst useAppContext: () => IAppContext;\n\ninterface IAppContext {\n  appDirectory: string;\n  configFile: string | false;\n  ip?: string;\n  port?: number;\n  distDirectory: string;\n  packageName: string;\n  srcDirectory: string;\n  sharedDirectory: string;\n  nodeModulesDirectory: string;\n  internalDirectory: string;\n  plugins: {\n    cli?: any;\n    server?: any;\n  }[];\n  entrypoints: Entrypoint[];\n  serverRoutes: ServerRoute[];\n  htmlTemplates: HtmlTemplates;\n}\n\n\n\nuseResolvedConfigContext\n\n用于获取解析之后的最终配置。\n\nconst useResolvedConfigContext: () => NormalizedConfig;\n\ninterface NormalizedConfig {\n  source: NormalizedSourceConfig;\n  output: OutputConfig;\n  server: ServerConfig;\n  dev: DevConfig;\n  deploy: DeployConfig;\n  tools: NormalizedToolsConfig;\n  plugins: PluginConfig;\n  runtime: RuntimeConfig;\n  runtimeByEntries?: RuntimeByEntriesConfig;\n  _raw: UserConfig;\n}\n\n\n具体配置字段的意义请参考【配置】。\n\n\nuseHookRunners\n\n用于获取 Hooks 的执行器，并触发特定的 Hook 执行。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  async setup(api) {\n    const hookRunners = api.useHookRunners();\n    // 触发 afterBuild Hook\n    await hookRunners.afterBuild();\n  },\n});\n","frontmatter":{"title":"插件 API","sidebar_position":6}},{"id":223,"title":"插件之间的关系","routePath":"/en/guides/topic-detail/framework-plugin/relationship","lang":"en","toc":[{"id":"插件排序","text":"插件排序","depth":2},{"id":"前置插件","text":"前置插件","depth":3},{"id":"后置插件","text":"后置插件","depth":3},{"id":"互斥插件","text":"互斥插件","depth":2},{"id":"必需插件","text":"必需插件","depth":2},{"id":"注册插件","text":"注册插件","depth":2}],"domain":"","content":"\n\nModern.js 的插件配置对象提供了一系列的字段，用于控制插件顺序、互斥等能力，可用的字段如下：\n\n * name: string，设置当前插件的名称。\n * pre: string[]，这些插件最终会调整到当前插件前面。\n * post: string[]，这些插件最终会调整到当前插件后面。\n * rivals: string[]，互斥插件，遇到这些插件时会报错。\n * required: string[]，必需插件，插件列表中没有对应的插件时会报错。\n * usePlugin: CliPlugin[]，注册其他插件。\n\n通过以上参数可以实现插件的前置、后置、互斥、必需等逻辑。\n\n\n插件排序\n\nModern.js 的插件通过 pre、post 参数来实现了插件排序的功能。\n\n\n前置插件\n\n默认情况下，插件会按照添加顺序依次执行，通过 pre 字段可以声明前置执行的插件。\n\n比如有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  pre: ['plugin-foo'],\n};\n\n\nbar 插件在 pre 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之前执行。\n\n\n后置插件\n\n同样的，通过 post 字段可以声明后置执行的插件。\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  post: ['plugin-foo'],\n};\n\n\nbar 插件在 post 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之后执行。\n\n\n互斥插件\n\n通过 rivals 字段可以声明插件间的互斥关系。\n\n有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  rivals: ['plugin-foo'],\n};\n\n\nbar 插件在 rivals 字段中配置了 foo 插件，因此同时添加了 foo 插件和 bar 插件就会报错。\n\n\n必需插件\n\n通过 required 字段可以声明插件间的依赖关系。\n\n有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  required: ['plugin-foo'],\n};\n\n\nbar 插件在 required 字段中配置了 foo 插件，因此使用 bar 插件时，如果未配置 foo 插件就会报错。\n\n\n注册插件\n\n当插件之间存在依赖关系时，我们也可以在一个插件中通过 usePlugin 主动注册另一个插件：\n\nconst foo = () => ({\n  name: 'plugin-foo',\n});\n\nconst bar = () => ({\n  name: 'plugin-bar',\n  usePlugin: [foo()],\n});\n\n\n当使用者配置了 bar 插件时，foo 插件也会自动注册生效，使用者就不需要去额外注册 foo 插件了。","frontmatter":{"title":"插件之间的关系","sidebar_position":4}},{"id":224,"title":"@modern-js/codesmith-api-app","routePath":"/en/guides/topic-detail/generator/codesmith/api/app","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"checkenvironment","text":"checkEnvironment","depth":3},{"id":"runinstall","text":"runInstall","depth":3},{"id":"rungitandinstall","text":"runGitAndInstall","depth":3},{"id":"forgetemplate","text":"forgeTemplate","depth":3},{"id":"showsuccessinfo","text":"showSuccessInfo","depth":3},{"id":"runsubgenerator","text":"runSubGenerator","depth":3},{"id":"getinputbyschema","text":"getInputBySchema","depth":3},{"id":"getinputbyschemafunc","text":"getInputBySchemaFunc","depth":3}],"domain":"","content":"\n\nThe combination encapsulation of APIs commonly used in the development of\nmicrogenerators, including APIs encapsulation of other packages such as fs, git,\nnpm, etc. When the requirements can be met, it is recommended to use the API of\nthe npm package.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const appApi = new AppAPI(context, generator);\n  await appApi.runInstall();\n};\n\n\n * Create AppAPI instance, the parameter is the generator of the microgenerator\n   function parameter, please see the composition of the microgenerator project\n   for details.\n * Just call the API on its example.\n\n\nAPI\n\n\ncheckEnvironment\n\nCheck the current generator operating environment, the check items are:\n\n 1. The node and node versions, the default is greater than 12.22.12, and the\n    node version can be executed by passing parameters.\n 2. Yarn, pnpm or npm can be used.\n\nParameter:\n\n * nodeVersion?: string. Node version want to check.\n\n\nrunInstall\n\nTo install dependency, you can pass in the install dependency command, which\ndefaults to the packageManager value in config.\n\nParameter:\n\n * command?: string, Install dependency command.\n\n\nrunGitAndInstall\n\nThis function performs the following actions:\n\n 1. Check whether the current generator execution directory is a git repository.\n 2. If not a git repository, initialization is a git repository.\n 3. Install dependencies.\n 4. Commit the initial commit in a non-monorepo project (judging the condition,\n    isMonorepoSubProject does not exist or is false in the config), the commit\n    information is feat: init, and customize is supported.\n\nParameter:\n\n * commitMessage?: string, Initialization commit message\n * installFunc?: () => Promise<void>. Install dependency function\n\n\nforgeTemplate\n\nRender generator template file.\n\nParameter:\n\n * templatePattern: string. Template files match regularities,for example:\n   templates/base-templates/**/* .\n * filter?: (resourceKey: string) => boolean. Filter function, the parameter is\n   the file path matching the templatePattern, return true to render the file,\n   return false to render the file.\n * rename?: (resourceKey: string) => string. Rename function, the parameter is\n   the file path matching templatePattern, and the new filename is returned. The\n   templates directory at the beginning of resourceKey and the .handlebars\n   suffix at the end will be replaced by default.\n * parameters?: Record<string, any>. Render parameter, when there is a\n   handlebars or ejs variable in the template, use it to pass the corresponding\n   variable value.\n * type?: 'handlebars' | 'ejs'. Template file type, defaults to handlebars.\n\nFor example:\n\nawait appApi.forgeTemplate(\n  'templates/base-templates/**/*',\n  undefined,\n  resourceKey =>\n    resourceKey\n      .replace('templates/base-templates/', '')\n      .replace('.handlebars', ''),\n);\n\nawait appApi.forgeTemplate(\n  'templates/base-template/**/*',\n  resourceKey => !resourceKey.include('eslintrc.json'),\n  resourceKey =>\n    resourceKey\n      .replace('templates/base-template/', projectPath)\n      .replace('language', language as string)\n      .replace('.handlebars', ''),\n  {\n    name: packageName as string,\n    language,\n    isTs: language === Language.TS,\n    packageManager: getPackageManagerText(packageManager as any),\n  },\n);\n\n\n\nshowSuccessInfo\n\nDisplay success information.\n\nParameter:\n\n * successInfo?: string. Default is Success.\n\n\nrunSubGenerator\n\nRun the subgenerator.\n\nParameter:\n\n * subGenerator: string. Subgenerator name or path.\n * relativePwdPath?: string. The relative path to which the'string 'subgenerator\n   runs.\n * config?: Record<string, unknown>. Default config configuration for\n   subgenerator runs.\n\nFor example:\n\nawait appApi.runSubGenerator(\n  getGeneratorPath('@modern-js/repo-generator', context.config.distTag),\n  undefined,\n  { ...context.config, hasPlugin: false },\n);\n\n\n\ngetInputBySchema\n\nUser interaction input is done through schema.\n\nParameter:\n\n * schema: FormilySchema | Question[]. Question list, supports Formily schema\n   and inquirer types.\n * type: 'formily' | 'inquirer'. Schema type, the default value is formily.\n * configValue: Record<string, unknown> = {}. Schema default value, the problem\n   corresponding to the schema field passed in this value will no longer\n   interact with the user.\n * validateMap?: Record<string, (input: unknown, data?: Record<string, unknown>)\n   => { success: boolean; error?: string }>. Validation function for special\n   fields in schema.\n * initValue?: Record<string, any>. Schema the initialization value of the\n   field.\n\nFor Formily Schema type support, please refer to Customize input related type\ndefinition.\n\n\ngetInputBySchemaFunc\n\nBy schema to complete user interaction input, schema parameter value as\nfunction, the user handles globalization problems, and only supports Formily\nschema.\n\nParameter:\n\n * schema: config?: Record<string, any>) => FormilySchema. Get the problem list\n   function, the config parameter is the config configuration information in the\n   current generator.\n * configValue: Record<string, unknown> = {}. Schema default value, the problem\n   corresponding to the schema field passed in this value will no longer\n   interact with the user.\n * validateMap?: Record<string, (input: unknown, data?: Record<string, unknown>)\n   => { success: boolean; error?: string }>. Validation function for special\n   fields in schema.\n * initValue?: Record<string, any>. Schema the initialization value of the\n   field.\n\nFor Formily Schema type support, please refer to Customize input related type\ndefinition.","frontmatter":{"sidebar_position":1}},{"id":225,"title":"@modern-js/codesmith-api-ejs","routePath":"/en/guides/topic-detail/generator/codesmith/api/ejs","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"rendertemplate","text":"renderTemplate","depth":3},{"id":"rendertemplatedir","text":"renderTemplateDir","depth":3}],"domain":"","content":"\n\nAn API wrapper for file operations using [ejs] (https://ejs.co/) in\nmicrogenerators, providing a way to render individual template files and\nfolders.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const ejsAPI = new EjsAPI(generator);\n  await ejsAPI.renderTemplate(\n     material.get('templates/a.js'),\n     target: 'b.js',\n     { data: \"data\" }\n   );\n}\n\n\n * Create EjsAPI instance, the parameter is the generator of the microgenerator\n   function parameter, please see the composition of the microgenerator project\n   for details.\n * Just call the API on its example.\n\n\nAPI\n\n\nrenderTemplate\n\nRender a single template file.\n\nParameter:\n\n * templateResource: FsResource. Template file resource, used by\n   context.materials.get(<filename>).\n * target: string. Target file path name.\n * parameters?: Record<string, string>. Render parameter.\n\n\nrenderTemplateDir\n\nRender template folder.\n\nParameter:\n\n * material: FsMaterial. The material context of the current microgenerator\n   execution.\n * findGlob: string. Template file matches the regular.\n * target: (globMatch: string) => string. The target file path generation\n   function, the parameter is resourceKey.\n * options?: RenderTemplateDirOptions. Glob Find the file configuration, the\n   specific function viewable is here [glob]\n   (https://www.npmjs.com/package/glob).\n\ntype RenderTemplateDirOptions = {\n  nodir?: boolean;\n  dot?: boolean;\n  ignore?: string | readonly string[];\n};\n","frontmatter":{"sidebar_position":6}},{"id":226,"title":"@modern-js/codesmith-api-fs","routePath":"/en/guides/topic-detail/generator/codesmith/api/fs","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"renderfile","text":"renderFile","depth":3},{"id":"renderdir","text":"renderDir","depth":3}],"domain":"","content":"\n\nAPI wrapper for file operations in microgenerators, providing methods to render\nindividual template files and folders. FsAPI is usually used to handle binaries\nor template files that cannot be handled with handlebars, ejs.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const handlebarApi = new HandlebarsAPI(generator);\n  await handlebarsAPI.renderFile(\n     material.get('templates/a.js'),\n     target: 'b.js'\n   );\n}\n\n\n * Create FsAPI instance, the parameter is the generator of the microgenerator\n   function parameter, please see the composition of the microgenerator project\n   for details.\n * Just call the API on its example.\n\n\nAPI\n\n\nrenderFile\n\nRender a single template file.\n\nParameter:\n\n * resource: FsResource. Template file resource, used by\n   context.materials.get(<filename>).\n * target: string. Target file path name.\n\n\nrenderDir\n\nRender template folder.\n\nParameter:\n\n * material: FsMaterial. The material context of the current microgenerator\n   execution.\n * findGlob: string. Template file matches the regular.\n * target: (globMatch: string) => string. The target file path generation\n   function, the parameter is resourceKey.\n * options?: RenderTemplateDirOptions. Glob Find the file configuration, the\n   specific function viewable is here [glob]\n   (https://www.npmjs.com/package/glob).\n\ntype RenderTemplateDirOptions = {\n  nodir?: boolean;\n  dot?: boolean;\n  ignore?: string | readonly string[];\n};\n","frontmatter":{"sidebar_position":3}},{"id":227,"title":"@modern-js/codesmith-api-git","routePath":"/en/guides/topic-detail/generator/codesmith/api/git","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"isingitrepo","text":"isInGitRepo","depth":3},{"id":"initgitrepo","text":"initGitRepo","depth":3},{"id":"addandcommit","text":"addAndCommit","depth":3}],"domain":"","content":"\n\nThe API encapsulation of git-related operations in the micro-generator provides\nmethods for judging git repository, initialization and commit code.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const gitApi = new GitAPI(generatorCore, generatorContext);\n  await gitApi.initGitRepo();\n};\n\n\n * Create GitAPI instance, the parameter is the generator of the microgenerator\n   function parameter, please see the composition of the microgenerator project\n   for details.\n\n * Just call the API on its example.\n\n\nAPI\n\n\nisInGitRepo\n\nWhether the current directory is a git repository.\n\nParameter:\n\n * cwd?: string. The execution directory of the git command, the default is\n   microgenerator outputPath.\n\n\ninitGitRepo\n\nThe initialization is the git repository. The default branch name for init can\nbe configured via defaultBranch in the generator config.\n\nParameter:\n\n * cwd?: string. The execution directory of the git command, the default is\n   microgenerator outputPath.\n * force?: boolean. Use this parameter to force git init when the current\n   directory is already a git repository.\n\n\naddAndCommit\n\nExecute git add . and git commit commit the current changes.\n\nParameter:\n\n * commitMessage: string. Commit information.\n * cwd?: string. The execution directory of the git command, the default is\n   microgenerator outputPath.","frontmatter":{"sidebar_position":4}},{"id":228,"title":"@modern-js/codesmith-api-handlebars","routePath":"/en/guides/topic-detail/generator/codesmith/api/handlebars","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"rendertemplate","text":"renderTemplate","depth":3},{"id":"rendertemplatedir","text":"renderTemplateDir","depth":3}],"domain":"","content":"\n\nAn API wrapper for file operations using [handlebars]\n(https://handlebarsjs.com/) in the microgenerator, providing a way to render\nindividual template files and folders.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const handlebarApi = new HandlebarsAPI(generator);\n  await handlebarsAPI.renderTemplate(\n     material.get('templates/a.js'),\n     target: 'b.js',\n     { data: \"data\" }\n   );\n}\n\n\n * Create HandlebarsAPI instance, the parameter is the generator of the\n   microgenerator function parameter, please see the composition of the\n   microgenerator project for details.\n\n * Just call the API on its example.\n\n\nAPI\n\n\nrenderTemplate\n\nRender a single template file.\n\nParameter:\n\n * templateResource: FsResource. Template file resource, used by\n   context.materials.get(<filename>).\n * target: string. Target file path name.\n * parameters?: Record<string, string>. Render parameter.\n\n\nrenderTemplateDir\n\nRender template folder.\n\nParameter:\n\n * material: FsMaterial. The material context of the current microgenerator\n   execution.\n * findGlob: string. Template file matches the regular.\n * target: (globMatch: string) => string. The target file path generation\n   function, the parameter is resourceKey.\n * options?: RenderTemplateDirOptions. Glob Find the file configuration, the\n   specific function viewable is here [glob]\n   (https://www.npmjs.com/package/glob).\n\ntype RenderTemplateDirOptions = {\n  nodir?: boolean;\n  dot?: boolean;\n  ignore?: string | readonly string[];\n};\n","frontmatter":{"sidebar_position":5}},{"id":229,"title":"@modern-js/codesmith-api-json","routePath":"/en/guides/topic-detail/generator/codesmith/api/json","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"get","text":"get","depth":3},{"id":"extend","text":"extend","depth":3},{"id":"update","text":"update","depth":3}],"domain":"","content":"\n\nThe JSON API encapsulation in the microgenerator provides common JSON file\noperation methods.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const jsonAPI = new JsonAPI(generator);\n  await jsonAPI.update(context.materials.default.get('package.json'), {\n    query: {},\n    update: {\n      $set: {\n        'dependencies.@modern-js/plugin-bff': `^2.0.0`,\n      },\n    },\n  });\n};\n\n\n * Create JsonAPI instance, the parameter is the generator of the microgenerator\n   function parameter, please see the composition of the microgenerator project\n   for details.\n * Just call the API on its example.\n\n\nAPI\n\n\nget\n\nGet the JSON file content.\n\nParameter:\n\n * resource: FsResource. A file resource，get by\n   context.materials.default.get(<filename>).\n\n\nextend\n\nMerge objects into a JSON file.\n\nParameter:\n\n * resource: FsResource. A file resource，get by\n   context.materials.default.get(<filename>).\n * obj: Record<string, any>. Object to be merged.\n\n\nupdate\n\npdate object fields to JSON file.\n\nParameter:\n\n * resource: FsResource. A file resource，get by\n   context.materials.default.get(<filename>).\n * operation: { query: Record<string, any>; update: Record<string, any> }.\n   Update operation, use gesture to view declaration-update in detail.","frontmatter":{"sidebar_position":2}},{"id":230,"title":"@modern-js/codesmith-api-npm","routePath":"/en/guides/topic-detail/generator/codesmith/api/npm","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"api","text":"API","depth":2},{"id":"npminstall","text":"npmInstall","depth":3},{"id":"yarninstall","text":"yarnInstall","depth":3},{"id":"pnpminstall","text":"pnpmInstall","depth":3}],"domain":"","content":"\n\nThe NPM API encapsulation in the microgenerator provides a common method for\ninstalling dependencies of different NPM package management tools.\n\n\nUse\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const npmApi = new NpmAPI(generator);\n  await npmApi.pnpmInstall();\n};\n\n\n * Create NpmAPI instance, the parameter is the generator of the microgenerator\n   function parameter, please see the composition of the microgenerator project\n   for details.\n\n * Just call the API on its example.\n\n\nAPI\n\n\nnpmInstall\n\nInstall dependency using npm.\n\nParameter:\n\n * cwd?: string. The execution directory of the install command, the default is\n   microgenerator outputPath.\n\n\nyarnInstall\n\nInstall dependency using yarn.\n\nParameter:\n\n * cwd?: string. The execution directory of the install command, the default is\n   microgenerator outputPath.\n\n\npnpmInstall\n\nInstall dependency using pnpm.\n\nParameter:\n\n * cwd?: string. The execution directory of the install command, the default is\n   microgenerator outputPath.","frontmatter":{"sidebar_position":7}},{"id":231,"title":"Develop a microgenerator project","routePath":"/en/guides/topic-detail/generator/codesmith/develop","lang":"en","toc":[{"id":"create-project","text":"Create project","depth":2},{"id":"add-template-file","text":"Add template file","depth":2},{"id":"develop-generator-core-logic","text":"Develop generator core logic","depth":2},{"id":"test-microgenerator","text":"Test microgenerator","depth":2},{"id":"run-the-microgenerator","text":"Run the microgenerator","depth":2}],"domain":"","content":"\n\n\nCreate project\n\nModern.js provides a microgenerator to create a microgenerator project, you can\ndirectly create a microgenerator project with the following commands:\n\n$ mkdir <projectDir>\n$ npx @modern-js/codesmith-cli @modern-js/generator-generator\n\n? Package Name <generatorName>\n? Package Management Tool pnpm\n? Development Language TS\n\n\n\nAdd template file\n\nIn the templates folder of the project directory, it is used to store the\ntemplate files required by the generator. If there is no template file, this\nstep can be skipped.\n\n\nDevelop generator core logic\n\nIn the project generated by default, it has been implemented to directly copy\nthe templates directory file to the target project, and the core logic\ndevelopment of the generator can be completed directly in the handleTemplateFile\nfunction.\n\n\nTest microgenerator\n\nAfter the development of the microgenerator is completed, you need to execute\npnpm run build to compile the code. In development mode, you can use pnpm run\nbuild --watch.\n\nCodesmith provides the cli tool for running and testing the microgenerator.\nExecute it in the target directory with the following command:\n\nnpx @modern-js/codesmith-cli <generatorPath>\n\n\nWhere generatorPath is the absolute path of the above generator project.\n\n\nRun the microgenerator\n\nAfter the generator publishes to npm, use the following command to execute:\n\nnpx @modern-js/codesmith-cli <generatorName>\n\n\nWhere generatorName is the generator package name.\n\nINFO\n\n@modern-js/create also supports running micro-generators, you can use npx\n@modern-js/create --generator <generatorName> to run customized\nmicro-generators.","frontmatter":{"sidebar_position":3}},{"id":232,"title":"What is a microgenerator","routePath":"/en/guides/topic-detail/generator/codesmith/introduce","lang":"en","toc":[{"id":"core-concept","text":"Core concept","depth":2},{"id":"generatorcore","text":"GeneratorCore","depth":3},{"id":"materials","text":"Materials","depth":3}],"domain":"","content":"\n\nModern.js provides the @modern-js/create tool and the new command for\ninitialization to create projects and the ability to enable some plugin\nfunctions, respectively, these tools are based on microgenerators, also known as\ncodesmith implementations.\n\nCodesmith is committed to providing a set of micro-generator operating\nmechanism, and maintain the context information in the execution process of the\nmicro-generator, so as to implement various operations based on files, commands,\netc., to complete sophisticated operations.\n\nCodesmith also encapsulates the commonly used methods, and can directly use the\nAPI functions it provides, which can more easily implement its own\nmicro-generator.\n\n\nCore concept\n\n\nGeneratorCore\n\nGeneratorCore is the core of codesmith running generator, maintaining the\ncontext and running methods during the execution of the generator.\n\nclass GeneratorCore {\n  logger: ILogger;\n  materialsManager: MaterialsManager;\n  outputPath: string;\n  output:\n    fs: (file: string | number, data: any, options?: fs.WriteFileOptions | string) => Promise<void>;\n  };\n  _context: GeneratorContext;\n  addMaterial(key: string, material: FsMaterial): void;\n  runGenerator(generator: string, config?: Record<string, unknown>): Promise<void>;\n  runSubGenerator(subGenerator: string, relativePwdPath?: string, config?: Record<string, any>): Promise<void>;\n}\n\n\n\nMaterials\n\nThe micro-generator resource information currently only includes file resources\n(fsMaterials). Through this field, the template resources in the generator\nexecution process can be obtained and operated through the API.\n\nclass MaterialsManager {\n  materialMap: {\n    // 资源映射关系\n    [materialUri: string]: FsMaterial;\n  };\n  loadLocalGenerator(generator: string): Promise<FsMaterial>;\n  loadRemoteGenerator(generator: string): Promise<FsMaterial>;\n}\n","frontmatter":{"sidebar_position":1}},{"id":233,"title":"Execute microgenerator with JS code","routePath":"/en/guides/topic-detail/generator/codesmith/run-in-js","lang":"en","toc":[{"id":"install-codesmith-dependency","text":"install codesmith dependency","depth":2},{"id":"create-codesmith-instance","text":"Create codesmith instance","depth":2},{"id":"call-the-forge-method-to-execute-the-generator","text":"Call the forge method to execute the generator","depth":2}],"domain":"","content":"\n\nIn addition to using the cli method to execute the micro generator, we\ninevitably need to execute the micro generator in the code. The following\ndescribes how to execute the micro generator in the js code.\n\n\ninstall codesmith dependency\n\npnpm add @modern-js/codesmith\n\n\n\nCreate codesmith instance\n\n\n\nconst smith = new CodeSmith({\n  debug: false, //Whether to enable debug mode, if true, the debug information in the generator will be displayed\n});\n\n\n\nCall the forge method to execute the generator\n\ntype RunnerTask = Array<{\n  name: string;\n  config: Record<string, any>;\n}>;\n\nconst task: RunnerTask = [\n  {\n    name: 'generator', // generator npm package name\n    config: {}, //The default configuration performed by the generator\n  },\n];\n\nawait smith.forge({\n  tasks: task.map(runner => ({\n    generator: runner.name,\n    config: runner.config,\n  })),\n  pwd: '.', // generator implementation path\n});\n","frontmatter":{"sidebar_position":4}},{"id":234,"title":"The composition of the microgenerator","routePath":"/en/guides/topic-detail/generator/codesmith/structure","lang":"en","toc":[{"id":"packagejson","text":"package.json","depth":2},{"id":"entry-file","text":"Entry file","depth":2},{"id":"context","text":"context","depth":3},{"id":"generator","text":"generator","depth":3},{"id":"template-file","text":"Template File","depth":2}],"domain":"","content":"\n\nA microgenerator project is a module project or an Npm package that contains\nseveral basic parts:\n\n\npackage.json\n\nNPM package description information, including name, version, main and other\nfields.\n\n\nEntry file\n\nThe js file corresponding to the above main field. The file exports a generator\nfunction by default, and the function format is as follows:\n\nexport default async (\n  context: GeneratorContext,\n  generator: GeneratorCore,\n) => {};\n\n\nThe function parameters are context and generator:\n\n\ncontext\n\nContext provides context information maintained by the codesmith runtime. Its\ntype is defined as:\n\ninterface GeneratorContext {\n  materials: Record<string, FsMaterial>;\n  config: Record<string, any>;\n  data?: Record<string, any>;\n  current: { material: FsMaterial } | null;\n  [key: string]: any;\n}\n\n\nMaterials is an abstract file system for codesmith that maintains the mapping\nbetween generator names and actionable files.\n\nMaterials also maintains this default mapping relationship, which is used to\nmaintain the resource information of the current generator execution directory,\nand can operate on the target project resources through this field.\n\nFor example, when you need to modify a field in the package.json of the current\nproject:\n\nconst resource = context.materials.default.get(\n  path.join(appDir, 'package.json'),\n);\n\n\nPass the acquired resources to the JSON API provided by codesmith to implement\njson operations.\n\nThe currently running generator file resource is maintained on the current field\nof GeneratorContext, and the current FsMaterial can be obtained through\ncurrent.material.\n\nThe get method is provided in FsMaterial to get the resource file and pass the\nresource file to the API supported by the generator to process the template\nfile.\n\nFor example:\n\nconst resourceMap = await material.find('templates/**/*');\n\n\nAll template files in the generator that match to the templates /**/* rules can\nbe obtained in the above way, and the resource files can be operated by\ntraversing the object.\n\n\ngenerator\n\nGenerator provides the function method of the codesmith runtime. Its type is\ndefined as:\n\ninterface GeneratorCore {\n    logger: Logger;\n    outputPath: string;\n    output: {\n        fs: (file: string | number, data: any, options?: string | fs.WriteFileOptions | undefined) => Promise<void>\n    };\n    runSubGenerator: (subGenerator: string, relativePwdPath?: string | undefined, config?: Record<string, any> | undefined): Promise<void>\n}\n\n\nThe outputPath and the materials.default in the context point to the same\ndirectory, the outputPath is used to directly calculate the target path and\noperate, and the materials.default is used to obtain resource files.\n\nrunSubGenerator provides a way to run other microgenerators in one\nmicrogenerator, which will automatically update and maintain new context\ninformation.\n\n\nTemplate File\n\nGenerator template file.\n\nIt is recommended to create a templates directory in the project root directory\nto maintain the template file of the microgenerator. During the execution of the\nmicrogenerator, you can only use your own template file. For template files that\nneed to be shared, it is recommended to use a shared sub-generator\nimplementation.","frontmatter":{"sidebar_position":2}},{"id":235,"title":"Web App","routePath":"/en/guides/topic-detail/generator/config/app","lang":"en","toc":[{"id":"project-creation","text":"Project creation","depth":2},{"id":"new-command","text":"New Command","depth":2},{"id":"actiontype","text":"actionType","depth":3},{"id":"element","text":"element","depth":3},{"id":"name","text":"name","depth":4},{"id":"function","text":"function","depth":3},{"id":"bff-parameters","text":"BFF parameters","depth":4}],"domain":"","content":"\n\n\nProject creation\n\nWhen creating a project, the configuration used by @modern-js/create when using\nthe --config parameter, and the configuration used when modifying and adding\ninput in the generator plugin.\n\nThe application project creation parameters are Generator Configuration.\n\n\nNew Command\n\nThe new command configuration in the application project can be used through the\n--config parameter configuration when executing the new command, or when\ncreating elements and enabling functions in the generator plugin.\n\n\nactionType\n\nThe action type (actionType) of the New command , the type supports two types:\n\n * element: reate engineering elements\n\n * function: enable function\n\nINFO\n\nThis parameter is not required when using the enable function and creating\nelements in the generator plugin, it is automatically added in the generator\nplugin.\n\n\nelement\n\nElement name (element), supports two options:\n\n * Create an application entry(entry)\n\n * Create customized server dir(server)\n\nThe entry also need to be used in conjunction with the specific configuration,\nwhich is described as follows:\n\nname\n\nEntry name (name), character string type.\n\n\nfunction\n\nOptional function name (function), supports the following options:\n\n * Tailwind CSS(tailwindcss)\n\n * BFF(bff)\n\n * SSG(ssg)\n\n * Micro Frontend(micro_frontend)\n\n * Unit Test / Integration Test(test)\n\n * Storybook(mwa_storybook)\n\n * UA-based Polyfill Feature'(polyfill)\n\n * Global Proxy(proxy)\n\nbff also need to be used in conjunction with configuration, as described below:\n\nBFF parameters\n\nbffType\n\nBFF type (bffType), supports two options:\n\n * Function mode(function)\n\n * Framework mode(framework)\n\nframework\n\nBFF runtime framework (framework)，supports two options：\n\n * Express(express)\n\n * Koa(koa)","frontmatter":{"sidebar_position":2}},{"id":236,"title":"Generator Configuration","routePath":"/en/guides/topic-detail/generator/config/common","lang":"en","toc":[{"id":"solution","text":"solution","depth":3},{"id":"scenes","text":"scenes","depth":3},{"id":"language","text":"language","depth":3},{"id":"packagemanager","text":"packageManager","depth":3},{"id":"other-configurations","text":"Other configurations","depth":2},{"id":"noneedinstall","text":"noNeedInstall","depth":3},{"id":"noneedgit","text":"noNeedGit","depth":3},{"id":"successinfo","text":"successInfo","depth":3},{"id":"ismonoreposubproject","text":"isMonorepoSubProject","depth":3},{"id":"istest","text":"isTest","depth":3},{"id":"ispublic","text":"isPublic","depth":3}],"domain":"","content":"\n\n\nsolution\n\nEngineering solution type (solution), the options are as follows:\n\n * Application(mwa)\n\n * Module(module)\n\n * Monorepo\n\nINFO\n\nSolution configuration can only be used in the --config parameter of\n@modern-js/create, not by setting the default value in the generator plugin.\n\n\nscenes\n\nProject scenarios (scenes), when using the generator plugin that creates the\nproject scene type, this value is the key value of the corresponding generator\nplugin.\n\nINFO\n\nscenes configuration can only be used in the --config parameter of\n@modern-js/create, not by setting the default value in the generator plugin.\n\n\nlanguage\n\nDevelopment language (language), the options are as follows:\n\n * TS(ts)\n\n * ES6+(js)\n\n\npackageManager\n\nPackage management tool (packageManager), the options are as follows:\n\n * pnpm(pnpm)\n\n * Yarn(yarn)\n\nINFO\n\nIn the custom type of the generator plugin to create a project scenario, only\nthe packageManager configuration is provided by default.\n\n\nOther configurations\n\n\nnoNeedInstall\n\n * Type: boolean\n * Default: false\n\nWhether to skip the dependency installation.\n\n\nnoNeedGit\n\n * Type: boolean\n * Default: false\n\nWhether to skip git initialization and commit initial commit.\n\n\nsuccessInfo\n\n * Type: string\n * Default: Command operation prompts for different project schemes.\n\nCustomize prompt information to create project success.\n\n\nisMonorepoSubProject\n\n * Type: boolean\n * Default: false\n\nWhether it is a Monorepo subproject.\n\n\nisTest\n\n * Type: boolean\n * Default: false\n\nWorks on an Application project to identify whether it is a test project.\n\n * true: create project to examples/\n * false: create project to apps/\n\n\nisPublic\n\n * Type: boolean\n * Default: false\n\nUsed in the Module project to identify whether it needs to be published to npm.\n\n * true: create project to packages/\n * false: create project to features/","frontmatter":{"sidebar_position":1}},{"id":237,"title":"Module","routePath":"/en/guides/topic-detail/generator/config/module","lang":"en","toc":[{"id":"project-creation","text":"Project creation","depth":2},{"id":"packagename","text":"packageName","depth":3},{"id":"new-command","text":"New Command","depth":2},{"id":"actiontype","text":"actionType","depth":3},{"id":"function","text":"function","depth":3}],"domain":"","content":"\n\n\nProject creation\n\nWhen creating a project, the configuration used by @modern-js/create when using\nthe --config parameter, and the configuration used when modifying and adding\ninput in the generator plugin.\n\nThe application project creation parameters are Generator Configuration.\n\n\npackageName\n\nPackage name (packageName), character string type.\n\n\nNew Command\n\nThe new command configuration in the module project can be used through the\n--config parameter configuration when executing the new command, or when\nenabling functions in the generator plugin.\n\n\nactionType\n\nThe action type (actionType) of the New command, he type supports one:\n\n * function: enable function\n\nINFO\n\nThis parameter is not required when using the enable function and creating\nelements in the generator plugin, it is automatically added in the generator\nplugin.\n\n\nfunction\n\nOptional function name (function), supports the following options:\n\n * Tailwind CSS(tailwindcss)\n\n * Storybook(mwa_storybook)\n\n * Runtime API(runtimeApi)\n\n * Test(test)","frontmatter":{"sidebar_position":3}},{"id":238,"title":"Monorepo","routePath":"/en/guides/topic-detail/generator/config/monorepo","lang":"en","toc":[{"id":"create-subproject","text":"Create subproject","depth":2},{"id":"solution","text":"solution","depth":3},{"id":"packagename","text":"packageName","depth":3},{"id":"packagepath","text":"packagePath","depth":3}],"domain":"","content":"\n\nMonorepo projects only need PackageManager.\n\n\nCreate subproject\n\nThe Monorepo project supports the creation of sub-projects by using the new\ncommand. The sub-project type supports application, test application, module,\ninternal module. In addition to the respective configuration of the application\nand module, some general sub-project configuration is required here.\n\n\nsolution\n\nSubproject type(solution)，the different subproject type fields are:\n\n * Application (mwa)\n * Application (Test) (mwa_test)\n * Module\n * Modules (internal) (inner_module)\n\n\npackageName\n\nSubproject name (packageName), character string type.\n\n\npackagePath\n\nSubproject path (packagePath), character string type.","frontmatter":{"sidebar_position":4}},{"id":239,"title":"Why do you need a generator plugin","routePath":"/en/guides/topic-detail/generator/plugin/abstract","lang":"en","toc":[],"domain":"","content":"\n\nModern.js provides application, modules and Monorepo three engineering\nsolutions, and by using the @modern-js/create tool can create the initial\nproject template of the three engineering solutions, the initial project\ntemplate will provide basic code development environment, simple sample code and\nconfiguration, etc.\n\nModern.js provides an initialization template that is versatile and can meet\nsome general project development needs.\n\nWhen you use Modern.js in depth, you will inevitably find that every time you\ncreate a project, you will make some similar changes specific to your own\nproject, such as modifying the sample code, adding some configuration, enabling\nsome functions, etc.\n\nThe generator plugin can help you precipitate these individual or team-specific\nchanges. Simply bring the --plugin parameter when executing npx\n@modern-js/create to avoid the need to repeatedly modify the project every time\nthe project is created..\n\nThe generator plugin is based on the initialization template project provided by\nthe Modern.js, providing methods to add, delete and modify templates, and\nmodifying package.json, modernConfig configuration and opening functions in a\nfast way.\n\nThe generator plugin provides two ways of customization:\n\n 1. Extended engineering: directly customize the three major engineering\n    provided by default.\n\n 2. Create engineering scenes: Create corresponding engineering scenes based on\n    the default three major engineering.\n\nThe next step will introduce how to use and develop the generator plugin step by\nstep.","frontmatter":{"sidebar_position":1}},{"id":240,"title":"addFile","routePath":"/en/guides/topic-detail/generator/plugin/api/file/addFile","lang":"en","toc":[{"id":"type","text":"type","depth":2},{"id":"file","text":"file","depth":2},{"id":"template","text":"template","depth":2},{"id":"templatefile","text":"templateFile","depth":2},{"id":"force","text":"force","depth":2},{"id":"data","text":"data","depth":2}],"domain":"","content":"\n\nAdd a single file. Use to add a single template file to the templates directory\nor add to a template file directly using templates.\n\nThis method can be used with any file type, for file types other than binary,\nHandlebars render is performed when files are added.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport interface AddFileParams {\n  type: FileType;\n  file: string;\n  template?: string;\n  templateFile?: string;\n  force?: boolean;\n  data?: Record<string, string>;\n}\nexport type ForgedAPI = {\n  addFile: (params: AddFileParams) => Promise<void>;\n  ...\n};\n\n\n\ntype\n\nFile type, specific viewableFile type.\n\n\nfile\n\nThe path to the created target file.\n\n\ntemplate\n\nFile template, configuration This field value can be used directly for template\nrender files. The priority is lower than templateFile.\n\n\ntemplateFile\n\nTemplate file, the template file path used for rendering, its value is the\nrelative path of templates.\n\n\nforce\n\nWhether to force coverage, when the added file already exists, an error will be\nreported in conflict by default. When setting this value to true, coverage can\nbe forced.\n\n\ndata\n\nHandlebars renders data.","frontmatter":{"sidebar_position":4}},{"id":241,"title":"addHelper","routePath":"/en/guides/topic-detail/generator/plugin/api/file/addHelper","lang":"en","toc":[{"id":"name","text":"name","depth":2},{"id":"fn","text":"fn","depth":2}],"domain":"","content":"\n\nFor text files, add a customized Help function of Handlebars，the specific\nviewable documentCustom Helpers.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\n  addHelper: (name: string, fn: Handlebars.HelperDelegate) => void;\n  ...\n};\n\n\n\nname\n\nhelp function name.\n\n\nfn\n\nhelp function.","frontmatter":{"sidebar_position":2}},{"id":242,"title":"addManyFile","routePath":"/en/guides/topic-detail/generator/plugin/api/file/addManyFile","lang":"en","toc":[{"id":"type","text":"type","depth":2},{"id":"destination","text":"destination","depth":2},{"id":"templatefiles","text":"templateFiles","depth":2},{"id":"templatebase","text":"templateBase","depth":2},{"id":"filenamefunc","text":"fileNameFunc","depth":2},{"id":"data","text":"data","depth":2}],"domain":"","content":"\n\nImport in batches file. Multiple files for adding the templates directory.\n\nThis method can be used with any file type, for file types other than binary,\nHandlebars render is performed when files are added.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport interface AddManyFilesParams {\n  type: FileType;\n  destination: string;\n  templateFiles: string[] | (() => string[]);\n  templateBase?: string;\n  fileNameFunc?: (name: string) => string;\n  data?: Record<string, string>; // template data\n}\nexport type ForgedAPI = {\n  addManyFiles: (params: AddManyFilesParams) => Promise<void>;\n  ...\n};\n\n\n\ntype\n\nFile type, specific viewableFile type.\n\n\ndestination\n\nCreate the target folder path. Since it is an import in batches file, fill in\nthe folder path that needs to be written here.\n\n\ntemplateFiles\n\nList of template files.\n\nThis parameter supports the function parameter, as well as globby.\n\n\ntemplateBase\n\nTemplate base path.\n\nThe template path is usually the template file in the same directory. If the\nrender result needs to remove the template file prefix directory, this field can\nbe used.\n\nTemplate render file content will be equal to templateFiles - templateBase\n\n\nfileNameFunc\n\nRename file function, where the file name of render is passed in once, and can\nbe renamed in this function.\n\n\ndata\n\nHandlebars renders data.","frontmatter":{"sidebar_position":5}},{"id":243,"title":"addPartial","routePath":"/en/guides/topic-detail/generator/plugin/api/file/addPartial","lang":"en","toc":[{"id":"name","text":"name","depth":2},{"id":"str","text":"str","depth":2}],"domain":"","content":"\n\nFor text files, add a customized Partial fragment of Handlebars, the specific\nviewable document Partials.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\n  addPartial: (name: string, str: Handlebars.Template) => void;\n  ...\n};\n\n\n\nname\n\npartial name.\n\n\nstr\n\npartial template string.","frontmatter":{"sidebar_position":3}},{"id":244,"title":"Introduction","routePath":"/en/guides/topic-detail/generator/plugin/api/file/introduce","lang":"en","toc":[{"id":"file-type","text":"File type","depth":2}],"domain":"","content":"\n\nThe file operation API can be used in the onForged time to live function, which\ncan add, delete and change the current project file.\n\nFile operation API related path to fill in the project relative path, generator\nplugin will automatically add the current project path prefix.\n\n\nFile type\n\nThe generator plugin divides file types into the following categories:\n\n * Text files: plain text content files, files that can be templated using\n   handlebars.\n\n * Binary files: pictures, audio, video and other files.\n\nWARNING\n\nThe jsx or tsx file using the variable is a binary file, and its syntax\nconflicts with handlebars render, which will cause the template file failed to\ncreate.\n\n * JSON files: Files in JSON format, such as package.json, tsconfig.json.\n\n * Text List File: A file consisting of lines of text, such as .gitignore,\n   .editorconfig, .npmrc.\n\nThe file manipulation API for the generator plugin will operate on these four\nfile types.\n\nIts type is defined as:\n\nexport enum FileType {\n  Text = 'text',\n  Binary = 'binary',\n  Json = 'json',\n  TextRaw = 'textRaw',\n}\n","frontmatter":{"sidebar_position":1}},{"id":245,"title":"rmDir","routePath":"/en/guides/topic-detail/generator/plugin/api/file/rmDir","lang":"en","toc":[{"id":"dirname","text":"dirName","depth":2}],"domain":"","content":"\n\nDelete folder. This method deletes all files under the folder in recursion.\n\nThis method can be used for any file type.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\n  rmDir: (dirName: string) => Promise<void>;\n  ...\n};\n\n\n\ndirName\n\nThe folder name or folder path to delete.","frontmatter":{"sidebar_position":10}},{"id":246,"title":"rmFile","routePath":"/en/guides/topic-detail/generator/plugin/api/file/rmFile","lang":"en","toc":[{"id":"filename","text":"fileName","depth":2}],"domain":"","content":"\n\nDelete the file.\n\nThis method can be used for any file type.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\n  rmFile: (fileName: string) => Promise<void>;\n  ...\n};\n\n\n\nfileName\n\nFile name or file path to delete.","frontmatter":{"sidebar_position":9}},{"id":247,"title":"updateJSONFile","routePath":"/en/guides/topic-detail/generator/plugin/api/file/updateJSONFile","lang":"en","toc":[{"id":"filename","text":"fileName","depth":2},{"id":"updateinfo","text":"updateInfo","depth":2}],"domain":"","content":"\n\nUpdate the JSON file fields.\n\nThis method is suitable for JSON file types, and can batch update field values\nin JSON files.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\n  updateJSONFile: (\n    fileName: string,\n    updateInfo: Record<string, unknown>,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nfileName\n\nThe filename or file path of the JSON file.\n\n\nupdateInfo\n\nField update information.\n\nThis information is represented in Record form.\n\nFor example, the name field needs to be updated:\n\napi.updateJSONFile(file, {\n  name: 'new name',\n});\n\n\nNested fields need to be updated:\n\napi.updateJSONFile(file, {\n  'dependencies.name': 'new name',\n});\n\n\nWARNING\n\nPay attention to the field name when updating the nested field. If it is not a\ntotal volume update, the nested key should also be written into the field name.","frontmatter":{"sidebar_position":6}},{"id":248,"title":"updateModernConfig","routePath":"/en/guides/topic-detail/generator/plugin/api/file/updateModernConfig","lang":"en","toc":[{"id":"updateinfo","text":"updateInfo","depth":2}],"domain":"","content":"\n\nUpdate the modernConfig field in package.json.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\n  updateModernConfig: (updateInfo: Record<string, any>) => Promise<void>;\n  ...\n};\n\n\n\nupdateInfo\n\nField update information.\n\nINFO\n\nThis function is the package of updateJSONFile, which will automatically update\nthe modernConfig field of package.json. Just fill in the update information\nrelative to modernConfig in the updateInfo.","frontmatter":{"sidebar_position":8}},{"id":249,"title":"updateTextRawFile","routePath":"/en/guides/topic-detail/generator/plugin/api/file/updateTextRawFile","lang":"en","toc":[{"id":"filename","text":"fileName","depth":2},{"id":"update","text":"update","depth":2}],"domain":"","content":"\n\nUpdate the text list file content.\n\nThis method works with the text list file type.\n\nThis method is available on the onForged time to live API parameter.\n\nIts type is defined as:\n\nexport type ForgedAPI = {\nupdateTextRawFile: (\n    fileName: string,\n    update: (content: string[]) => string[],\n  ) => Promise<void>;\n  ...\n};\n\n\n\nfileName\n\nThe filename or file path of the text list file.\n\n\nupdate\n\nUpdate function.\n\nThe function parameter is the current file content. The content will be divided\nby \\n and passed into function in the form of array. The return value of\nfunction is also array. The internal will be automatically merged with \\n and\nwritten to the source file.","frontmatter":{"sidebar_position":7}},{"id":250,"title":"gitAddAndCommit","routePath":"/en/guides/topic-detail/generator/plugin/api/git/gitAddAndCommit","lang":"en","toc":[{"id":"commitmessage","text":"commitMessage","depth":2}],"domain":"","content":"\n\nCommit the current repository changes.\n\nIts type is defined as:\n\nexport type AfterForgedAPI = {\n  gitAddAndCommit: (commitMessage: string) => Promise<void>;\n  ...\n};\n\n\n\ncommitMessage\n\nCommit information.","frontmatter":{"sidebar_position":3}},{"id":251,"title":"initGitRepo","routePath":"/en/guides/topic-detail/generator/plugin/api/git/initGitRepo","lang":"en","toc":[],"domain":"","content":"\n\nnitialization The current directory is the Git repository.\n\nIts type is defined as:\n\nexport type AfterForgedAPI = {\n  initGitRepo: () => Promise<void>;\n  ...\n};\n","frontmatter":{"sidebar_position":2}},{"id":252,"title":"isInGitRepo","routePath":"/en/guides/topic-detail/generator/plugin/api/git/isInGitRepo","lang":"en","toc":[],"domain":"","content":"\n\nDetermines whether the current project is a Git repository.\n\nIts type is defined as:\n\nexport type AfterForgedAPI = {\n  isInGitRepo: () => Promise<boolean>;\n  ...\n};\n","frontmatter":{"sidebar_position":1}},{"id":253,"title":"AfterForged","routePath":"/en/guides/topic-detail/generator/plugin/api/hook/afterForged","lang":"en","toc":[{"id":"func","text":"func","depth":2},{"id":"api","text":"api","depth":3},{"id":"inputdata","text":"inputData","depth":3}],"domain":"","content":"\n\nafterForged function is the generator plugin time to live function, which is\nusually used to define operations such as installation dependency and Git.\nProfessional operations will be performed after the onForged function is\nexecuted.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport type PluginAfterForgedFunc = (\n  api: AfterForgedAPI,\n  inputData: Record<string, unknown>,\n) => Promise<void>;\n\nexport interface IPluginContext {\n  afterForged: (func: PluginAfterForgedFunc) => void;\n  ...\n}\n\n\n\nfunc\n\nThe onForged parameter is a callback function, and the function parameters are\napi and inputData.\n\n\napi\n\nA list of supported functions in afterForged time to live, specifically viewabl\nGit API 和 NPM API.\n\n\ninputData\n\nCurrent user input, the user can be used to obtain the current input information\nand configuration information.","frontmatter":{"sidebar_position":2}},{"id":254,"title":"OnForged","routePath":"/en/guides/topic-detail/generator/plugin/api/hook/onForged","lang":"en","toc":[{"id":"func","text":"func","depth":2},{"id":"api","text":"api","depth":3},{"id":"inputdata","text":"inputData","depth":3}],"domain":"","content":"\n\nonForged function is the generator plugin time to live function, which is\nusually used to define file type operations that will be performed after the\ncompletion of the base project solution file operation.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport type PluginForgedFunc = (\n  api: ForgedAPI,\n  inputData: Record<string, unknown>,\n) => void | Promise<void>;\n\nexport interface IPluginContext {\n  onForged: (func: PluginForgedFunc) => void;\n  ...\n}\n\n\n\nfunc\n\nThe onForged parameter is a callback function, and the function parameters are\napi and inputData.\n\n\napi\n\nA list of supported functions in onForged time to live, specifically viewable\n[File API] (/docs/guides/topic-detail/generator/plugin/api/file/introduce) and\n[Enable function API]\n(/docs/guides/topic-detail/generator/plugin/api/new/introduce).\n\n\ninputData\n\nCurrent user input, the user can be used to obtain the current input information\nand configuration information.","frontmatter":{"sidebar_position":1}},{"id":255,"title":"isFileExit","routePath":"/en/guides/topic-detail/generator/plugin/api/info/isFileExit","lang":"en","toc":[{"id":"filename","text":"fileName","depth":2}],"domain":"","content":"\n\nDetermine if the file exists.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport interface IPluginContext {\n  isFileExit: (fileName: string) => Promise<boolean>;\n  ...\n}\n\n\n\nfileName\n\nThe file name or file path that needs to be judged is based on the relative path\nof the created project.","frontmatter":{"sidebar_position":2}},{"id":256,"title":"locale","routePath":"/en/guides/topic-detail/generator/plugin/api/info/locale","lang":"en","toc":[],"domain":"","content":"\n\nCurrent language.\n\nThe method is available directly on the context.\n\nThere are two values for this field:\n\n * zh: Chinese\n\n * en: English\n\nThe generator plugin can adjust the value of the relevant display field\naccording to this field.","frontmatter":{"sidebar_position":1}},{"id":257,"title":"readDir","routePath":"/en/guides/topic-detail/generator/plugin/api/info/readDir","lang":"en","toc":[{"id":"dir","text":"dir","depth":2}],"domain":"","content":"\n\nRead the folder and get the file list.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport interface IPluginContext {\n  readDir: (dir: string) => Promise<string[]>;\n  ...\n}\n\n\n\ndir\n\nIts type is defined as: folder name or path, based on the relative path of the\ncreated project.","frontmatter":{"sidebar_position":3}},{"id":258,"title":"addInputAfter","routePath":"/en/guides/topic-detail/generator/plugin/api/input/addInputAfter","lang":"en","toc":[{"id":"key","text":"key","depth":2},{"id":"input","text":"input","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nAdd input question after default input.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport interface IPluginContext {\n  addInputAfter: (key: string, input: Schema) => void;\n  ...\n}\n\n\n\nkey\n\nModern.js the problem keyword of the configuration of the engineering solution,\nthe specific configuration viewable Generator Configuration.\n\n\ninput\n\nQuestions that need to be added, specific type definition viewable Customize\ninput related type definition.\n\n\nExample\n\nAdd input after package management tool:\n\ncontext.addInputAfter('packageManager', {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: 'Develop Language',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n});\n\n\nNotes\n\n 1. The key of the added question cannot be duplicated with the key of the\n    question of the item type itself provided by the Modern.js.\n\n 2. The priority of adding the problem addInputAfter is higher than\n    addInputBefore. When adding After problem to one key and Before problem to\n    the next key at the same time, After problem will be before Before.\n\n 3. When multiple questions need to be added before or after the same key, the\n    method can be called multiple times, and the order of questions will be\n    permutated in the order in which they are called.","frontmatter":{"sidebar_position":3}},{"id":259,"title":"addInputBefore","routePath":"/en/guides/topic-detail/generator/plugin/api/input/addInputBefore","lang":"en","toc":[{"id":"key","text":"key","depth":2},{"id":"input","text":"input","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nAdd input question before default input.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport interface IPluginContext {\n  addInputBefore: (key: string, input: Schema) => void;\n  ...\n}\n\n\n\nkey\n\nModern.js the problem keyword of the configuration of the engineering solution,\nthe specific configuration viewable Generator Configuration.\n\n\ninput\n\nQuestions that need to be added, specific type definition viewable Customize\ninput related type definition.\n\n\nExample\n\nAdd input before package management tool:\n\ncontext.addInputBefore('packageManager', {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: 'Develop Langauge',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n});\n\n\nNotes\n\n 1. The key of the added question cannot be duplicated with the key of the\n    question of the item type itself provided by the Modern.js.\n\n 2. The priority of adding the problem addInputAfter is higher than\n    addInputBefore. When adding After problem to one key and Before problem to\n    the next key at the same time, After problem will be before Before.\n\n 3. When multiple questions need to be added before or after the same key, the\n    method can be called multiple times, and the order of questions will be\n    permutated in the order in which they are called.","frontmatter":{"sidebar_position":2}},{"id":260,"title":"setInput","routePath":"/en/guides/topic-detail/generator/plugin/api/input/setInput","lang":"en","toc":[{"id":"key","text":"key","depth":2},{"id":"filed","text":"filed","depth":2},{"id":"value","text":"value","depth":2},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nSet the problem attribute.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport interface IPluginContext {\n  setInput: (key: string, field: string, value: unknown) => void;\n  ...\n}\n\n\n\nkey\n\nThe problem keyword can be the problem keyword of the Modern.js project\nsolution, or the keyword of the new problem in the generator plugin.\n\n\nfiled\n\nhe problem field to be set, you can modify other fields except the key of the\ncurrent Input, Input specific type definition viewable Customize input related\ntype definition.\n\n\nvalue\n\nThe value of the problem field to be setted. value supports function, the\nfunction parameter is the current field value, and the return value needs to be\nthe complete new field value.\n\nINFO\n\nFor the input options provided by the Modern.js project type, only delete is\ntemporarily supported, and increase is not supported. The increase will cause\nproblems in the logical judgment in the code.\n\n\nExample\n\nModify the display name of packageName:\n\ncontext.setInput('packageName', 'title', 'Show title');\n","frontmatter":{"sidebar_position":4}},{"id":261,"title":"setInputValue","routePath":"/en/guides/topic-detail/generator/plugin/api/input/setInputValue","lang":"en","toc":[{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\nSets the input default value.\n\nThe method is available directly on the context.\n\nIts type is defined as:\n\nexport interface IPluginContext {\n    setInputValue: (value: Record<string, unknown>) => void;\n  ...\n}\n\n\n\nExample\n\ncontext.setInputValue({\n  moduleRunWay: 'no',\n});\n\n\nWARNING\n\nThis method only supports setting the configuration parameter value\ncorresponding to the project solution integrated by the generator plugin, and\ndoes not support setting the project solution type (solution) and project scene\n(scenes). These two configurations can be set by the --config parameter at\nexecution default value.","frontmatter":{"sidebar_position":7}},{"id":262,"title":"Customize input related type definition","routePath":"/en/guides/topic-detail/generator/plugin/api/input/type","lang":"en","toc":[{"id":"input","text":"Input","depth":2},{"id":"type","text":"type","depth":3},{"id":"name","text":"name","depth":3},{"id":"title","text":"title","depth":3},{"id":"default","text":"default","depth":3},{"id":"enum","text":"enum","depth":3},{"id":"x-validate","text":"x-validate","depth":3},{"id":"x-reactions","text":"x-reactions","depth":3},{"id":"properties","text":"properties","depth":3},{"id":"example","text":"Example","depth":2}],"domain":"","content":"\n\n\nInput\n\nModern.js Input input type uses the open source Formily Schema, with support for\nsome of its Schema fields.\n\n\ntype\n\nschema types. Currently, the input supported by the generator plugin is of type\nstring, number and object. Where object is used for implementation schema\nnested, it needs to be used in conjunction with properties.\n\n\nname\n\nschema keyword.\n\n\ntitle\n\nschema display name.\n\n\ndefault\n\nschema default value.\n\n\nenum\n\nIf the schema is selection type, this field is used to define the option\ncontent.\n\nEach option supports two fields:\n\n * value: option value.\n\n * label: display name.\n\n\nx-validate\n\nschema verification rules. Formily's verification method is supported here, for\ndetails, please refer to Formily Validate.\n\n\nx-reactions\n\nschema field linkage. Formily's linkage method is supported here, for details,\nplease refer to Formily Linkages.\n\n\nproperties\n\nWhen schema type is object, define its subforms.\n\n\nExample\n\nconst schema = {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: 'Develop Langauge',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n};\n","frontmatter":{"sidebar_position":1}},{"id":263,"title":"Introduction","routePath":"/en/guides/topic-detail/generator/plugin/api/introduce","lang":"en","toc":[{"id":"generator-plugin-composition","text":"Generator plugin composition","depth":2},{"id":"classification","text":"Classification","depth":2},{"id":"type-definition","text":"Type definition","depth":3},{"id":"extended-engineering","text":"Extended engineering","depth":4},{"id":"create-engineering-scenes","text":"Create engineering scenes","depth":4},{"id":"custom-type","text":"Custom type","depth":3}],"domain":"","content":"\n\nModern.js supports the customization of the provided engineering solutions by\nmeans of generator plugins or the customization of specific scenarios for\nengineering solutions.\n\n\nGenerator plugin composition\n\nThe generator plugin is a module that can be developed directly using Modern.js\nmodule engineering solutions. Of course, Modern.js also provides the\ncorresponding generator plugin (@modern-js/generator-plugin-plugin) to directly\ncreate a new generator plugin project.\n\nA generator plugin project directory is as follows:\n\n.\n├── README.md\n├── package.json\n├── src\n│   ├── index.ts\n│   └── modern-app-env.d.ts\n├── templates\n└── tsconfig.json\n\n\nThe src/index.ts is the source code directory, which is used to develop the\ngenerator plugin logic. The plugin exports a function by default, and the\nfunction parameter is context. Some methods are provided on the context to\ndirectly operate the current project. These methods will be introduced in detail\nlater in this chapter.\n\nThe templates directory is the template directory used to store template files\nthat need to be used in the generator plugin.\n\n\nClassification\n\nThere are two types of generator plugins:\n\n 1. Extended engineering: directly customize the three major engineering\n    provided by default.\n\n 2. Create engineering scenes: Create corresponding engineering scenes based on\n    the default three major engineering schemes.\n\n\nType definition\n\nThe classification of the generator plugin is provided by the meta information\nin the package.json.\n\nExtended engineering\n\n{\n  \"meta\": {\n    \"extend\": \"mwa\" // The three engineering is mwa, module, monorepo\n  }\n}\n\n\nCreate engineering scenes\n\n{\n  \"meta\": {\n    \"key\": \"new_solution\",\n    \"name\": \"New Solution\",\n    \"type\": \"mwa\" // In addition to the three major engineering solutions, the type here also supports the customize (custom) type\n  }\n}\n\n\nkey is the scene scheme name and the value is a character string. name is the\ndisplay name of the scene scheme, used for the display of the option when used,\nand the value is a character string. type is the project solution type. In\naddition to supporting three project solutions like extend, it also supports the\ncustomize (custom) type.\n\n\nCustom type\n\nThe customize type provides the implementation capability of the full custom\nproject solution. When using this type to create a new project solution\nscenario, only a small amount of code for best practices at the development\nlevel is provided, such as .gitignore, .editorConfig and other files,\nspecifically for the following directory structure:\n\n.\n├── .editorconfig\n├── .gitignore\n├── .idea\n│   ├── codeStyles\n│   │   ├── Project.xml\n│   │   └── codeStyleConfig.xml\n│   ├── inspectionProfiles\n│   │   └── Project_Default.xml\n│   └── jsLinters\n│       └── eslint.xml\n├── .nvmrc\n└── .vscode\n    ├── extensions.json\n    └── settings.json\n\n\nCustomized types ensure flexible configuration according to their needs for\nengineering solutions.","frontmatter":{"sidebar_position":1}},{"id":264,"title":"createElement","routePath":"/en/guides/topic-detail/generator/plugin/api/new/createElement","lang":"en","toc":[{"id":"element","text":"element","depth":2},{"id":"params","text":"params","depth":2}],"domain":"","content":"\n\nCreate engineering elements that only support application engineering solutions.\n\nThis method is available on the onForged API parameter.\n\nIts type is defined as:\n\nexport enum ActionElement {\n  Entry = 'entry',\n  Server = 'server',\n}\nexport type ForgedAPI = {\n  createElement: (\n    element: ActionElement,\n    params: Record<string, unknown>,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nelement\n\nProject element type, supports entry and server.\n\n\nparams\n\nFor other parameters of creating elements, please refer toApp New Command.","frontmatter":{"sidebar_position":2}},{"id":265,"title":"createSubProject","routePath":"/en/guides/topic-detail/generator/plugin/api/new/createSubProject","lang":"en","toc":[{"id":"solution","text":"solution","depth":2},{"id":"params","text":"params","depth":2}],"domain":"","content":"\n\nCreate subprojects and only support Monorepo engineering solutions.\n\nThis method is available on the onForged API parameter.\n\nIts type is defined as:\n\nexport enum SubSolution {\n  MWA = 'mwa',\n  MWATest = 'mwa_test',\n  Module = 'module',\n  InnerModule = 'inner_module',\n}\nexport type ForgedAPI = {\n  createSubProject: (\n    solution: SubSolution,\n    params: Record<string, unknown>,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nsolution\n\nSub-project engineering solution name.\n\n\nparams\n\nFor other parameters of creating subprojects, please refer toMonorepo Create Sub\nProject.","frontmatter":{"sidebar_position":4}},{"id":266,"title":"enableFunc","routePath":"/en/guides/topic-detail/generator/plugin/api/new/enableFunc","lang":"en","toc":[{"id":"func","text":"func","depth":2},{"id":"params","text":"params","depth":2}],"domain":"","content":"\n\nEnable functionality to support application and module engineering scenarios.\n\nThis method is available on the onForged API parameter.\n\nIts type is defined as:\n\nexport enum ActionFunction {\n  UnBundle = 'unbundle',\n  TailwindCSS = 'tailwindcss',\n  BFF = 'bff',\n  MicroFrontend = 'micro_frontend',\n  I18n = 'i18n',\n  Test = 'test',\n  E2ETest = 'e2e_test',\n  Doc = 'doc',\n  Storybook = 'storybook',\n  RuntimeApi = 'runtimeApi',\n  SSG = 'ssg',\n  Polyfill = 'polyfill',\n  Deploy = 'deploy',\n}\nexport type ForgedAPI = {\n  enableFunc: (\n    func: ActionFunction,\n    params?: Record<string, unknown> | undefined,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nfunc\n\nThe function name is passed according to the functions supported by the\ndifferent engineering solutions.\n\n\nparams\n\nFor other parameters when the function is enabled, please refer to App New\nCommand and Module New Command.","frontmatter":{"sidebar_position":3}},{"id":267,"title":"Introduction","routePath":"/en/guides/topic-detail/generator/plugin/api/new/introduce","lang":"en","toc":[],"domain":"","content":"\n\nThe three engineering solutions provided by the Modern.js support executing the\nnew command in the project to create elements and enable functions. In the\ngenerator plugin, the relevant API can be directly called to create some\nelements and enable supported functions by default.\n\nDifferent engineering solutions to support new operations:\n\n * Web App\n\n * Module\n\n * Monorepo","frontmatter":{"sidebar_position":1}},{"id":268,"title":"install","routePath":"/en/guides/topic-detail/generator/plugin/api/npm/install","lang":"en","toc":[],"domain":"","content":"\n\nInstall dependency in the project root directory.\n\nIn the install function, the dependency will be installed using the\ncorresponding package management tool based on the value of packageManager.\n\nIts type is defined as:\n\nexport type AfterForgedAPI = {\n  install: () => Promise<void>;\n  ...\n};\n","frontmatter":{"sidebar_position":1}},{"id":269,"title":"How to develop generator plugins","routePath":"/en/guides/topic-detail/generator/plugin/develop","lang":"en","toc":[{"id":"create-project","text":"Create project","depth":2},{"id":"extension-type","text":"Extension type","depth":3},{"id":"customized-type","text":"Customized type","depth":3},{"id":"develop-plugin-logic","text":"Develop plugin logic","depth":2},{"id":"customize-input","text":"Customize input","depth":3},{"id":"onforged","text":"onForged","depth":3},{"id":"afterforged","text":"afterForged","depth":3}],"domain":"","content":"\n\n\nCreate project\n\nModern.js provides a generator plugin to create a generator plugin project, you\ncan directly execute the following command to create:\n\nnpx @modern-js/create plugin --plugin @modern-js/generator-plugin-plugin\n\n\nDifferent plugin types will ask different questions. You can choose the plugin\ntype according to your needs.\n\n\nExtension type\n\n? Please select the solution you want to create Module Solution\n? Please select the scene you want to create 生成器插件\n? Plugin Package Name plugin\n? Development Language TS\n? Package Management Tool pnpm\n? Plugin Type extend\n? Plugin Base Type Web App Solution\n\n\n\nCustomized type\n\n? Plugin Package Name plugin\n? Development Language TS\n? Package Management Tool pnpm\n? Plugin Type custom\n? Plugin Key mobile-app\n? Plugin Show Name Mobile App\n? Plugin Base Type Web App Solution\n\n\nAfter the execution of the create project command is completed, a project for\ndeveloping the generator plugin will be generated accordingly, and the meta\ninformation will also be generated according to your selection in the\npackage.json.\n\nINFO\n\nFor generator plugin development, please refer to\n@modern-js/generator-plugin-plugin. Source Code\n\n\nDevelop plugin logic\n\nComplete plugin logic development in src/index.ts.\n\nThe plugin exports a function by default, the function parameter is context, and\nsome methods are provided on context to directly operate on the current project.\n\nA brief introduction to the provided methods, the complete API list viewable\nGenerator Plugin API.\n\n\nCustomize input\n\n * addInputBefore\n\nAdd input before the default input, such as adding questions before the Select\npackage management tool question.\n\nSpecific Modern.js configuration viewable for each problem Project Solution\nConfiguration.\n\ncontext.addInputBefore('input2', {\n  type: 'object',\n  properties: {\n    'input1.2': {\n      type: 'string',\n      title: 'input1.2',\n    },\n  },\n});\n\n\n * setInput\n\nSet attributes of existing problems.\n\ncontext.setInput('test', 'type', 'number');\ncontext.setInput('test', 'enum', [{ value: 'option1', label: '选项一' }]);\n\n\n\nonForged\n\nAfter the implementation of the hook related operations of the project plan type\nfile is completed, multiple extended inspection will execute its onForged\nfunction in sequence according to the plugin parameter order.\n\nThe onForged parameter is a callback function, and the function parameters are\napi and input.\n\nSome file manipulation related methods are provided on the api, which can\noperate on the current template file in this hook.\n\ninput is the current user input, which can be used to obtain the current input\ninformation and configuration information of the user.\n\nWhen you need a new template file, you can add it directly in the templates\ndirectory. In the onForged function, you can directly operate the templates\ndirectory file. For example, the templateFile parameter in the addFile below is\nthe file in the templates directory. There is no need to display the declaration\ntemplates here, just write the relative path relative to templates.\n\nAPI functions supported in onForged can also be found in Generator Plugin API.\n\ncontext.onForged(async (api: ForgedAPI, input: Record<string, unknown>) => {\n  const { language } = input;\n  api.addFile({\n    type: FileType.Text,\n    file: `src/index.${language as string}`,\n    templateFile: `index.${language as string}.handlebars`,\n    force: true,\n  });\n});\n\n\n\nafterForged\n\nAfter the onForged function is executed, it can mainly install dependencies, Git\noperations, etc.\n\nIf your project plan is based on the three projects provided by the Modern.js,\nthis hook function may not be required. The default project plan will\nautomatically include the installation dependency and commit code logic.\n\nThe generator plugin also supports a customized custom type, which only provides\na small amount of development-level best practice code, such as .gitignore,\neditorConfig and other files. In this case, you need to manually supplement the\ninstallation dependency and Git operation logic in the afterForged function.\n\nThe afterForged parameter is also a callback function, and the function\nparameters are api and input.\n\nThe api will provide some npm, Git and other methods, which can install\ndependency and Git operations in this hook.\n\ninput is the current user input, which can be used to obtain the current input\ninformation and configuration information of the user.\n\nThe API functions supported in afterForged can also be found in [Generator\nPlugin API] (/docs/guides/topic-detail/generator/plugin/api/hook/afterForged).","frontmatter":{"sidebar_position":3}},{"id":270,"title":"How to use the generator plugin","routePath":"/en/guides/topic-detail/generator/plugin/use","lang":"en","toc":[{"id":"classification","text":"Classification","depth":2},{"id":"type-definition","text":"Type definition","depth":3},{"id":"extended-engineering","text":"Extended engineering","depth":4},{"id":"create-engineering-scenes","text":"Create engineering scenes","depth":4},{"id":"execution-timing","text":"Execution timing","depth":3},{"id":"extended-engineering-1","text":"Extended engineering","depth":4},{"id":"create-engineering-scenes-1","text":"Create engineering scenes","depth":4}],"domain":"","content":"\n\n@modern-js/create provides the --plugin parameter to declare the generator\nplugin used.\n\nYou can use the generator plugin directly by executing the following command:\n\nnpx @modern-js/create --plugin <pluginName>\n\n\nThe plugin parameter supports multiple declarations, which means that multiple\ngenerator plugins are used at the same time.\n\n\nClassification\n\nThere are two types of generator plugins:\n\n 1. Extended engineering: directly customize the three major engineering\n    provided by default.\n\n 2. Create engineering scenes: Create corresponding engineering scenes based on\n    the default three major engineering schemes.\n\n\nType definition\n\nThe classification of the generator plugin is provided by the meta information\nin the package.json.\n\nExtended engineering\n\n{\n  \"meta\": {\n    \"extend\": \"mwa\" // The three engineering is mwa, module, monorepo\n  }\n}\n\n\nCreate engineering scenes\n\n{\n  \"meta\": {\n    \"key\": \"new_solution\",\n    \"name\": \"New Solution\",\n    \"type\": \"mwa\" // In addition to the three major engineering solutions, the type here also supports the customize (custom) type\n  }\n}\n\n\n\nExecution timing\n\nThe execution timing of different types of custom engineering solutions is\ndifferent.\n\nExtended engineering\n\nThe generator plugin of the extended engineering type will execute in sequence\naccording to the declaration order of the plugin parameter after selecting the\ncorresponding extended project scheme.\n\nCreate engineering scenes\n\nThe generator plugin that create engineering scenes will have the option to\nselect the scene after selecting the project solution type. The option list\nincludes the current default project scenes and the project scenes defined by\nthe plugin. If you select the corresponding scene, the corresponding generator\nwill be executed plugin.","frontmatter":{"sidebar_position":2}},{"id":271,"title":"Project Generator","routePath":"/en/guides/topic-detail/generator/project","lang":"en","toc":[{"id":"use","text":"Use","depth":2},{"id":"params","text":"Params","depth":2},{"id":"projectdir","text":"[projectDir]","depth":3},{"id":"--version","text":"--version","depth":3},{"id":"--lang","text":"--lang","depth":3},{"id":"-c---config","text":"-c, --config","depth":3},{"id":"--no-need-install","text":"--no-need-install","depth":3},{"id":"--dist-tag-disttag","text":"--dist-tag <distTag>","depth":3},{"id":"--registry-registry","text":"--registry <registry/>","depth":3},{"id":"--debug","text":"--debug","depth":3},{"id":"--mwa","text":"--mwa","depth":3},{"id":"--module","text":"--module","depth":3},{"id":"--monorepo","text":"--monorepo","depth":3},{"id":"--plugin-plugin","text":"--plugin <plugin>","depth":3},{"id":"--generator-generator","text":"--generator <generator>","depth":3},{"id":"--packages-packages","text":"--packages <packages>","depth":3}],"domain":"","content":"\n\nModern.js provides @modern-js/create as a project generator for Modern.js\nproject creation.\n\n\nUse\n\nThere is no need to install @modern-js/create globally, just execute the tool\ndirectly with npx:\n\nnpx @modern-js/create [projectDir]\n\n\nINFO\n\nUse npx to get the latest version of @modern-js/create every time.\n\n\nParams\n\n\n[projectDir]\n\nProject directory name.\n\nWhen executing the above command, the projectDir folder will be created in the\ncurrent directory by default, and the initialization project will be in this\nfolder. When this parameter is empty, the initialization project will be\ndirectly generated in the current directory.\n\n\n--version\n\nGet the @modern-js/create tool version.\n\n$ npx @modern-js/create --version\n\n[INFO] @modern-js/create v2.0.0\n\n\n\n--lang\n\nSpecifies the execution language, supports zh and en.\n\nBy default, @modern-js/create will automatically identify the user's system\nlanguage, choose to use Chinese or English, if the recognition fails or you want\nto specify the language manually, you can use this parameter.\n\n\n-c, --config\n\nSpecifies the project default configuration.\n\nBy default, @modern-js/create will have interaction problems such as language\nselection and package management tools during execution. When you need to\nspecify these configuration contents in advance, you can pass in this field.\n\nThis field is a JSON character string, for example when running a package\nmanagement tool:\n\nnpx @modern-js/create --config '{\"packageManager\": \"pnpm\"}'\n\n\nSpecific configuration information viewable Project Configuration.\n\n\n--no-need-install\n\nBy default, @modern-js/create automatically installs dependency after the\nproject is created, use this parameter to ignore the install dependency step.\n\n\n--dist-tag <distTag>\n\nSpecifies the generator and Modern.js dependency versions.\n\nA smaller micro-generator will be executed during the execution of\n@modern-js/create, and the version number of the micro-generator that can be\nexecuted with this parameter and the version number of the corresponding\ninstallation Modern.js related dependencies.\n\n\n--registry <registry/>\n\nExecute the npm registry to get the generator and npm packages.\n\n\n--debug\n\nDisplays debug log information during generator execution.\n\n\n--mwa\n\nOne-click to create an application engineering solution project.\n\nWith this parameter, @modern-js/create will create the application project with\nthe configuration default value.\n\n\n--module\n\nOne-click to create a module engineering solution project.\n\nWith this parameter, @modern-js/create will create the module project with the\nconfiguration default value.\n\n\n--monorepo\n\nOne-click to create a Monorepo engineering solution project.\n\nWith this parameter, @modern-js/create will create the Monorepo project with the\nconfiguration default value.\n\n\n--plugin <plugin>\n\nSpecifies the generator plugin.\n\nModern.js support the use of the generator plug-in custom Modern.js the default\nproject type or add the project type scenes, the parameter user specifies the\ncustomized generator plugin.\n\nFor custom generator plugins, please refer to Development Generator Plugin.\n\n\n--generator <generator>\n\nSpecifies the microgenerator.\n\nBy default, @modern-js/create will execute the microgenerator Modern.js\nframework build-in. If you need to execute a customized microgenerator, and you\nneed to use the posture of npx @modern-js/create, you can use this parameter\ndirectly.\n\nFor custom microgenerators, please refer to Develop Microgenerator.\n\n\n--packages <packages>\n\nA project is created by specifying a specific package version dependency.\n\nIf you need to specify a specific package version when creating a project, you\ncan use this parameter. This parameter will lock the package version number in\nthe package.json of the project root directory by configuration pnpm.overrides\n(package management tool selects pnpm) or resolutions.\n\nThe parameter value is a JSON character string.","frontmatter":{"sidebar_position":2}},{"id":272,"title":"微前端介绍","routePath":"/en/guides/topic-detail/micro-frontend/c01-introduction","lang":"en","toc":[{"id":"微前端关键词","text":"微前端关键词","depth":2},{"id":"功能简介","text":"功能简介","depth":2}],"domain":"","content":"\n\n微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来\n仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\n微前端关键词\n\n在微前端研发模式中，应用会被分成 主应用、和 子应用。\n\n * 主应用：微前端项目的基座工程，所有子应用都会由它来加载。\n * 子应用：独立开发、独立部署的应用，最终会被主应用加载。\n\n\n功能简介\n\n * 基于 Garfish\n * 生成器支持微前端应用\n * 支持 React 组件式引用微前端子应用\n * 支持 loading\n * 支持主应用线上、子应用线下调试模式\n\n可以在 体验微前端 一节学习如何开发微前端主子应用。","frontmatter":{"sidebar_position":1,"title":"微前端介绍"}},{"id":273,"title":"体验微前端","routePath":"/en/guides/topic-detail/micro-frontend/c02-development","lang":"en","toc":[{"id":"创建应用","text":"创建应用","depth":2},{"id":"创建约定式路由主应用","text":"创建约定式路由主应用","depth":3},{"id":"加载约定式路由子应用","text":"加载约定式路由子应用","depth":4},{"id":"加载自控式路由子应用","text":"加载自控式路由子应用","depth":4},{"id":"路由跳转","text":"路由跳转","depth":4},{"id":"创建自控式路由主应用","text":"创建自控式路由主应用","depth":3},{"id":"加载子应用","text":"加载子应用","depth":4},{"id":"创建约定式路由子应用","text":"创建约定式路由子应用","depth":3},{"id":"创建自控式路由子应用","text":"创建自控式路由子应用","depth":3},{"id":"调试","text":"调试","depth":2},{"id":"常见问题","text":"常见问题","depth":2}],"domain":"","content":"\n\n通过本章你可以了解到：\n\n * 如何创建微前端项目的主应用、子应用。\n * 微前端项目开发的基本流程。\n\n\n创建应用\n\n目前支持两种路由模式\n\n * 自控式路由\n * 约定式路由\n\n首先明确主应用的路由模式 创建约定式路由主应用 或 创建自控式路由主应用\n\n在本次体验中我们会为主应用创建两个子应用 Table 和 Dashboard (Table 为约定式路由，Dashboard 为自控式路由)\n\n\n创建约定式路由主应用\n\n通过命令行工具初始化项目：\n\nmkdir masterApp && cd masterApp\nnpx @modern-js/create\n\n\n? 请选择你想创建的工程类型 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n然后我们在 routes 文件夹下新建两个目录\n\n * table (用于加载约定式路由子应用)\n * dashboard (用于加载自控式路由子应用)\n\n在这两个目录下我们需要新建一个 $.tsx 文件作为主应用约定式路由的入口($ 代表模糊匹配，即 /table 和 /table/test 都会匹配到这个\n$.tsx 作为该路由的入口文件，这会保证在微前端场景下正确加载子应用路由)\n\n加载约定式路由子应用\n\n\n\nconst Index = () => {\n  const { Table } = useModuleApps();\n\n  return (\n    <div>\n      <Table />\n    </div>\n  )\n}\n\nexport default Index;\n\n\n加载自控式路由子应用\n\n\n\nconst Index = () => {\n  const { Dashboard } = useModuleApps();\n\n  return (\n    <div>\n      <Dashboard />\n    </div>\n  )\n}\n\nexport default Index;\n\n\n路由跳转\n\n此时主应用配置已经完成，通过路由即可加载子应用，修改主应用的 layout.tsx 来跳转路由\n\n\n\nconst Layout = () => (\n  <div>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </div>\n);\n\nexport default Layout;\n\n\n\n创建自控式路由主应用\n\n通过命令行工具初始化项目：\n\nmkdir masterApp && cd masterApp\nnpx @modern-js/create\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n由于是自控式路由，我们删除掉 routes 文件夹并在 src 目录下增加 App.tsx 文件，此处如果使用的 非 MApp 组件，需要通过 React\nRouter v6 的 createBrowserRouter API 来创建路由\n\n加载子应用\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </>\n)\n\nexport default () => {\n  const { apps, MApp, Table, Dashboard } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      <Route path=\"/\" element={<AppLayout />}>\n        <Route key={'table'} path={'table/*'} element={<Table />} />\n        <Route key={'dashboard'} path={'dashboard/*'} element={<Dashboard />} />\n      </Route>\n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // <BrowserRouter>\n    //   <MApp />\n    // </BrowserRouter>\n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      <RouterProvider router={router} />\n    </>\n  );\n};\n\n\n\n创建约定式路由子应用\n\n通过命令行工具初始化项目：\n\nmkdir table && cd table\nnpx @modern-js/create\n\n\n按照如下选择，生成项目：\n\n我们执行 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n\nexport default defineConfig({\n  dev: {\n    port: 8081\n  },\n  runtime: {\n    router: true,\n    state: true,\n  },\n  deploy: {\n    microFrontend: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n添加 src/routes/page.tsx 代码\n\nconst Index = () => {\n  return (\n    <div className=\"container-box\">subApp: 约定式路由的子应用的根路由</div>\n  )\n}\n\nexport default Index;\n\n\n\n创建自控式路由子应用\n\n通过命令行工具初始化项目：\n\nmkdir dashboard && cd dashboard\nnpx @modern-js/create\n\n\n按照如下选择，生成项目：\n\n我们执行 pnpm run new 来开启 微前端：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n\nexport default defineConfig({\n  dev: {\n    port: 8082\n  },\n  runtime: {\n    router: true,\n    state: true,\n  },\n  deploy: {\n    microFrontend: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n自控式路由需要删除掉 routes 文件夹并在 src 目录下新建 App.tsx\n\n并在 src/App.tsx 添加代码，注意需要从 props 中解析并传递 basename 给 BrowserRouter\n\n\n\nexport default (props: {basename: string}) => {\n  const { basename } = props;\n\n  return (\n    <BrowserRouter basename={basename}>\n      <Routes>\n        <Route index element={<div>自控式路由子应用根路由</div>} />\n        <Route path={'path'} element={<div>自控式路由子应用子路由</div>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\n\n\n调试\n\n按顺序在目录执行 pnpm run dev 命令启动应用：\n\n * masterApp 主应用 http://localhost:8080\n * table 子应用(约定式路由) http://localhost:8081\n * dashboard 子应用(自控式路由) http://localhost:8082\n\n访问主应用地址 http://localhost:8080\n\n在完成了微前端整体开发流程的体验后，你可以进一步了解如何 开发主应用\n\n\n常见问题\n\n自查手册: https://www.garfishjs.org/issues/","frontmatter":{"sidebar_position":2,"title":"体验微前端"}},{"id":274,"title":"开发主应用","routePath":"/en/guides/topic-detail/micro-frontend/c03-main-app","lang":"en","toc":[{"id":"注册子应用信息","text":"注册子应用信息","depth":2},{"id":"直接注册子应用信息","text":"直接注册子应用信息","depth":3},{"id":"自定义远程应用列表","text":"自定义远程应用列表","depth":3},{"id":"渲染子应用","text":"渲染子应用","depth":2},{"id":"子应用组件","text":"子应用组件","depth":3},{"id":"集中式路由","text":"集中式路由","depth":3},{"id":"两种模式混用","text":"两种模式混用","depth":3},{"id":"添加-loading","text":"添加 loading","depth":3},{"id":"增加错误状态","text":"增加错误状态","depth":4},{"id":"避免-loading-闪退","text":"避免 loading 闪退","depth":4},{"id":"增加超时状态","text":"增加超时状态","depth":4}],"domain":"","content":"\n\n在上一章 体验微前端 通过一个示例演示了如何创建和配置微前端子应用，通过本章你可以进一步了解如何开发主应用，以及它的常见配置。\n\n在通过 @modern-js/create 命令创建应用工程后，可以在项目中执行 pnpm run new（实际执行了 modern new\n命令），在选择了「微前端」模式后，会安装微前端依赖依赖，只需手动注册插件即可。\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n\n注册子应用信息\n\n当在 masterApp 配置上提供了信息后，将会认为该应用为主应用，目前存在两种子应用信息的配置方式，这两种方式分别应用于不同的场景。\n\n\n直接注册子应用信息\n\n可以直接通过配置注册子应用信息：\n\nTIP\n\n可以通过 API defineConfig 在运行时进行配置。 当参数为函数时无法被序列化到产物代码，所以在涉及到函数之类的配置时请通过\ndefineConfig 来进行配置\n\n\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [{\n      name: 'Table',\n      entry: 'http://localhost:8001',\n      // activeWhen: '/table'\n    }, {\n      name: 'Dashboard',\n      entry: 'http://localhost:8002'\n      // activeWhen: '/dashboard'\n    }]\n  },\n});\n\n\n\n自定义远程应用列表\n\n通过该函数可以拉取远程的子应用列表，并将其注册至运行时框架：\n\ndefineConfig(App, {\n  masterApp: {\n    manifest: {\n      getAppList: async () => {\n        // 可以从其他远程接口获取\n        return [{\n          name: 'Table',\n          entry: 'http://localhost:8001',\n          // activeWhen: '/table'\n        }, {\n          name: 'Dashboard',\n          entry: 'http://localhost:8002'\n          // activeWhen: '/dashboard'\n        }];\n      },\n    },\n  },\n});\n\n\n\n渲染子应用\n\n在微前端中分为两种加载子应用的方式：\n\n 1. 子应用组件 获取到每个子应用的组件，之后就可以像使用普通的 React 组件一样渲染微前端的子应用。\n 2. 集中式路由 通过集中式的路由配置，自动根据当前页面 pathname 激活渲染对应的子应用。\n\n\n子应用组件\n\n开发者使用 useModuleApps 方法可以获取到各个子应用的组件。\n\n再通过 router 组件的结合运用，开发者可以自控式的根据不同的路由渲染不同的子应用。\n\n假设我们的子应用列表配置如下：\n\n编辑主应用 App.tsx 文件如下：\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </>\n)\n\nexport default () => {\n  const { apps, MApp } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      <Route path=\"/\" element={<AppLayout />}>\n        {apps.map(app => {\n          const { Component } = app;\n          // 模糊匹配，path 需要写成类似 abc/* 的模式\n          return (\n            <Route\n              key={app.name}\n              path={`${app.name.toLowerCase()}/*`}\n              element={\n              <Component\n                loadable={{\n                  loading: ({ pastDelay, error }: any) => {\n                    if (error) {\n                      return <div>error: {error?.message}</div>;\n                    } else if (pastDelay) {\n                      return <div>loading</div>;\n                    } else {\n                      return null;\n                    }\n                  },\n                }}\n              />\n              }\n            />\n          )\n        })}\n      </Route>\n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // <BrowserRouter>\n    //   <MApp />\n    // </BrowserRouter>\n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      <RouterProvider router={router} />\n    </>\n  );\n};\n\n\n这里通过 Route 组件自定义了 Table 的激活路由为 /table， Dashboard 的激活路由为 /dashboard。\n\n\n集中式路由\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    <div>\n      <MApp />\n    </div>\n  );\n}\n\n\n这样启动应用后，访问 /table 路由，会渲染 Table 子应用，访问 /dashboard 路由，会渲染 Dashboard 子应用。\n\n\n两种模式混用\n\n当然 子应用组件 和 集中式路由 是可以混合使用的。\n\n * 一部分子应用作为 子应用组件 激活，另外一部分作为 集中式路由 激活。\n * 一部分子应用既可以作为 集中式路由 激活，也可以作为 子应用组件 激活。\n\n\n添加 loading\n\n通过配置 loadable 配置，可以为「集中式路由」、「子应用」添加 loading\n组件，并可以考虑错误、超时、闪烁等情况的出现，从而为用户提供更好的用户体验。该功能的设计与实现参考至 react-loadable，基本功能较为相似。\n\nfunction Loading() {\n  return <div>Loading...</div>;\n}\n\nfunction App(){\n  return <>\n    <Table\n      loadable={{\n        loading: Loading,\n      }}\n    />\n  <>\n}\n\n\n增加错误状态\n\n当微前端子应用加载失败或渲染失败时，loading component 将会接收 error 参数（若没有错误时 error 是 null）\n\nfunction Loading({ error }) {\n  if (error) {\n    return <div>Error msg {error?.message}</div>;\n  } else {\n    return <div>Loading...</div>;\n  }\n}\n\n\n避免 loading 闪退\n\n有时 loading 组件的显示时间可能小于 200ms，这个时候会出现 loading 组件闪退的情况。许多用户研究证明，loading\n闪退的情况会导致用户感知加载内容的耗时比实际耗时更长，在 loading 小于 200ms 时，不展示内容，用户会认为它更快。\n\n所以 loading 组件还提供了 pastDelay 参数，超过设置的延迟展示时才会为 true，可以通过 delay 参数设置延迟的时长\n\nfunction Loading({ error, pastDelay }) {\n  if (error) {\n    return <div>Error! {error?.message}</div>;\n  } else if (pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n\n\ndelay 的默认值为 200ms，可以通过 loadable 中的 delay 来设置延迟展示的时间\n\n\nfunction App(){\n  return <>\n    <Table\n      loadable={{\n        loading: Loading,\n        delay: 300 // 0.3 seconds\n      }}\n    />\n  <>\n}\n\n\n增加超时状态\n\n有时因为网络的原因，从而导致微前端子应用加载失败，从而导致一直展示 loading\n的状态，这对于用户而言非常糟糕，因为他们不知道合适才会获得具体的响应，他们是否需要刷新页面，通过增加超时状态可以很好的解决该问题。\n\nloading 组件在超时时会获得 timeOut 参数，当微前端应用加载超时时将会获得 timeOut 属性值为 true\n\nfunction Loading({ error, timeOut, pastDelay }) {\n  if (error) {\n    return <div>Error! {error?.message}</div>;\n  } else if (timeOut) {\n    return <div>Loading timed out, please refresh the page... </div>;\n  } else if (pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n\n\n超时状态是关闭的，可以通过在 loadable 中设置 timeout 参数开启\n\n\nfunction App(){\n  return <>\n    <Table\n      loadable={{\n        loading: Loading,\n        timeOut: 10000 // 10s\n      }}\n    />\n  <>\n}\n","frontmatter":{"sidebar_position":3,"title":"开发主应用"}},{"id":275,"title":"主子应用通信","routePath":"/en/guides/topic-detail/micro-frontend/c04-communicate","lang":"en","toc":[{"id":"props-通信","text":"props 通信","depth":2},{"id":"channel-通信","text":"channel 通信","depth":2}],"domain":"","content":"\n\n\nprops 通信\n\nModern.js 中，会将子应用包裹成一个 React 组件，直接通过给 React 组件传递 props 即可实现主应用和子应用通信的目的。\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    <div>\n      <MApp count={100} />\n    </div>\n  );\n}\n\n\nfunction App(props) {\n  console.log(props);\n  return ...\n}\n\n\n子应用将会打印 {count: 0}，目前尚未支持子应用渲染响应式，及时在主应用上更改 count 的数据也不会触发视图更新\n\n\nchannel 通信\n\nGarfish.channel 用于应用间的通信。它是 EventEmitter2 的实例\n\n// 子应用监听登录事件\nconst App = () => {\n  const handleLogin = userInfo => {\n    console.log(`${userInfo.name} has login`);\n  };\n\n  useEffect(() => {\n    window?.Garfish.channel.on('login', handleLogin);\n    return () => {\n      window?.Garfish.channel.removeListener('login', handleLogin);\n    };\n  });\n};\n\n// 主应用触发监听事件\napi.getLoginInfo.then(res => {\n  if (res.code === 0) {\n    window.Garfish.channel.emit('login', res.data);\n  }\n});\n","frontmatter":{"sidebar_position":4,"title":"主子应用通信"}},{"id":276,"title":"混合技术栈","routePath":"/en/guides/topic-detail/micro-frontend/c05-mixed-stack","lang":"en","toc":[{"id":"子应用是-modernjs","text":"子应用是 Modern.js","depth":2},{"id":"主应用是-modernjs","text":"主应用是 Modern.js","depth":2}],"domain":"","content":"\n\nModern.js 微前端方案是基于 Garfish 封装的，提供了一些更开箱即用的使用方式。\n\n当你的主应用和子应用不全是 Modern.js 应用的时候，可以参考这篇文档。\n\n 1. 子应用是 Modern.js，主应用使用的原生 Garfish 微前端。\n 2. 主应用是 Modern.js，子应用有的是其它技术栈。\n\n\n子应用是 Modern.js\n\nModern.js 子应用编译后会生成标准的 Garfish 子应用导出。 所以可以直接接入标准的微前端主应用。\n\nINFO\n\n子应用是 Modern.js，主应用使用的原生 Garfish 微前端时，子应用调试模式 不可用。\n\n\n主应用是 Modern.js\n\n主应用是 Modern.js，子应用用的其它技术栈。子应用按照 Garfish 子应用标准 开发即可。","frontmatter":{"sidebar_position":5,"title":"混合技术栈"}},{"id":277,"title":"自动生成 Actions","routePath":"/en/guides/topic-detail/model/auto-actions","lang":"en","toc":[{"id":"原始数据类型","text":"原始数据类型","depth":2},{"id":"数组类型","text":"数组类型","depth":2},{"id":"简单对象类型","text":"简单对象类型","depth":2}],"domain":"","content":"\n\n在 快速上手 中，我们实现最简单的计数器 Model 也需要 10 行代码。 实际上，Modern.js 支持根据声明的 state 类型，自动生成常用的\nActions，从而简化模板代码量。当前支持的类型有：\n\n * 原始数据类型\n * 数组类型\n * 简单对象类型（Plain Object）\n\n\n原始数据类型\n\nconst countModel = model('count').define({ state: 1 });\n\n\n如上我们仅用一行就完成了一个简单的 countModel。使用 Model 的示例代码如下：\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    // 增加 1\n    actions.setState(state + 1);\n  }, []);\n}\n\n\n\n数组类型\n\n当 State 为数组类型时，自动生成 Actions 的示例代码如下：\n\nconst countModel = model('count').define({ state: [] });\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    actions.push(1);\n    actions.pop();\n    actions.shift();\n    actions.unshift(1);\n    actions.concat([1]);\n    actions.splice(0, 1, 2);\n    actions.filter(value => value > 1);\n  }, []);\n}\n\n\n我们可以使用 JavaScript Array 对象的方法，修改 State。\n\n\n简单对象类型\n\n当 State 为简单对象类型时，自动生成 Actions 的示例代码如下：\n\nconst countModel = model('count').define({\n  state: {\n    a: 1,\n    b: [],\n    c: {},\n  },\n});\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    actions.setA(2);\n    actions.setB([1]);\n    actions.setC({ a: 1 });\n  }, []);\n}\n\n\n根据 a、b、c 三个不同的字段分别生成 setA、setB、setC 三个 Actions。\n\nINFO\n\n当用户自定义的 Action 和 Modern.js 自动生成的 Action 名字一致时，用户自定义的 Action 优先级更高。例如， 在\ncountModel 中已经自定义 setA 这个 Action，调用 actions.setA() 时，最终执行的是用户自定义的 setA。\n\n补充信息\n\n相关 API 的更多介绍，请参考这里。","frontmatter":{"sidebar_position":6,"title":"自动生成 Actions"}},{"id":278,"title":"衍生状态","routePath":"/en/guides/topic-detail/model/computed-state","lang":"en","toc":[{"id":"只依赖自身的-state","text":"只依赖自身的 State","depth":2},{"id":"依赖其他-model-的-state","text":"依赖其他 Model 的 State","depth":2},{"id":"函数类型的衍生状态","text":"函数类型的衍生状态","depth":2}],"domain":"","content":"\n\n一些场景中，组件需要对 Model 中的 State 进行进一步计算，才能在组件中使用，这部分逻辑可以直接写在组件内部，也可以通过 Model 的衍生状态实现。\n衍生状态定义在 Model 中的 computed 字段下。根据依赖的 Model 的不同、返回类型的不同，衍生状态的定义方法可以分为以下 3 种。\n\n\n只依赖自身的 State\n\n衍生状态只依赖当前 Model 的 State，State 会作为第一个参数，传入衍生状态的定义函数中。\n\n例如， todo 应用的 State 有 items 和 filter，filter 用于过滤当前页面显示的 todo 项，所以我们定义了一个\nvisibleTodos 的衍生状态可以直接在组件中使用。示例代码如下：\n\n/**\n *  假设 todo item 结构如下：\n{\n    id: string;          // id\n    text: string;        // todo 事项\n    completed: boolean;  // 完成状态：0 代表未完成，1 代表完成\n}\n**/\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    filter: 'ALL', // ALL: 显示全部；COMPLETED：显示完成的事项；ACTIVE：显示未完成的事项\n  },\n  computed: {\n    visibleTodos: state => {\n      switch (state.filter) {\n        case 'ALL':\n          return state.items;\n        case 'COMPLETED':\n          return todos.filter(t => t.completed);\n        case 'ACTIVE':\n          return todos.filter(t => !t.completed);\n        default:\n          return [];\n      }\n    },\n  },\n});\n\n\n衍生状态最终会和 Model 的 State 进行合并，因此，可以通过 Model 的 State 对象访问到衍生状态，例如，visibleTodos\n在组件内的使用方式如下：\n\nfunction Todo() {\n  const [state, actions] = useModel(todoModel);\n\n  return (\n    <div>\n      <div>\n        {state.visibleTodos.map(item => (\n          <div key={item.id}>{item.text}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n\n\n依赖其他 Model 的 State\n\n除了依赖当前 Model 的 State，衍生状态还依赖其他 Model 的 State，这时候衍生状态的定义格式为：\n\n[stateKey]: [...depModels, (selfState, ...depModels) => computedState]\n\n\n下面的示例，演示了 barModel 的衍生状态 combinedValue 是如何依赖 fooModel 的 State 的。\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'foo',\n  },\n  computed: {\n    combinedValue: [\n      fooModel,\n      (state, fooState) => state.value + fooState.value,\n    ],\n  },\n});\n\n\n\n函数类型的衍生状态\n\n衍生状态还可以返回一个函数。这时候衍生状态的定义格式为：\n\n[stateKey]: (state) => (...args) => computedState    // 只依赖自身的 state\n[stateKey]: [...depModels, (selfState, ...depModels) => (...args) => computedState]  // 依赖其他 Model 的 state\n\n\n假设，todo 应用的 state 不存储 filter 状态，而是直接在组件中使用，那么 visibleTodos\n可以是一个函数类型的值，这个函数在组件中使用的时候，接收 filter 参数。如下所示：\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n  },\n  computed: {\n    visibleTodos: state => filter => {\n      switch (filter) {\n        case 'ALL':\n          return state.items;\n        case 'COMPLETED':\n          return todos.filter(t => t.completed);\n        case 'ACTIVE':\n          return todos.filter(t => !t.completed);\n        default:\n          return [];\n      }\n    },\n  },\n});\n\nfunction Todo(props) {\n  // filter 状态通过 props 传入\n  const { filter } = props;\n  const [state, actions] = useModel(todoModel);\n\n  // 计算得到最终要显示的 todos\n  const todos = state.visibleTodos(filter);\n\n  return (\n    <div>\n      <div>\n        {todos.map(item => (\n          <div key={item.id}>{item.text}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":4,"title":"衍生状态"}},{"id":279,"title":"创建 Model","routePath":"/en/guides/topic-detail/model/define-model","lang":"en","toc":[],"domain":"","content":"\n\n上一节的计数器应用中，我们简单演示了如何创建一个 Model。本节我们将详细介绍 Model 的创建方法。\n\n通过 model API 创建 Model，例如，model('foo') 表示要创建一个名为 foo 的 Model，通过调用 model('foo')\n返回的 define 函数，定义 Model 包含的 State、Actions 等：\n\n\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n  actions: {\n    setValue: (state, payload){\n      state.value = payload\n    }\n  }\n});\n\n\nINFO\n\n * Model 中的 Action 中不能包含有副作用的逻辑，如请求 HTTP 接口，访问 localStorage 等。\n * setValue 内部直接修改了入参 State，看起来是违反了纯函数的定义，实际上 Reduck 内部使用 immer\n   来修改不可变对象，保证了这种写法不会影响对象的不可变性，所以 setValue 仍然是一个纯函数。当然，你也可以直接在 Action\n   中返回一个新对象，不过这样的写法会更加复杂一些。\n\ndefine 接收的参数，只是对 Model 原始结构的描述：内部定义的 State、Actions 等。define 返回值 fooModel\n才是真正创建得到的 Model 对象。例如，虽然 setValue，有 2 个参数，但是当真正调用 setValue 这个 Action 时，我们只需要传入\npayload 一个参数，因为我们调用的是 fooModel 上的 Action 方法，而不是 Model 原始结构上描述的 Action 方法。详细参考使用\nModel。\n\ndefine 除了接收对象类型的参数，还可以接收函数类型的参数。例如：\n\n\n\nconst fooModel = model('foo').define((context, utils) => {\n  return {\n    state: {\n      value: 'foo',\n    },\n    actions: {\n      setValue: (state, payload){\n        state.value = payload\n      }\n    }\n  }\n});\n\n\n通过函数定义 Model 时，函数内部会自动传入 context、utils 2 个参数，context 是 Reduck 的上下文对象，可以获取到 store\n对象，utils 提供了一组工具函数，方便实现 Model 通信等复杂功能需求。\n\nModel 支持复制。例如：\n\nconst barModel = fooModel('bar');\n\n\nbarModel 是基于 fooModel 创建出一个的新的 Model 对象，类比面向对象编程语言中的概念，barModel 和 fooModel\n是基于同一个类（Class）创建出的 2 个实例对象。当两个模块的状态管理逻辑相同，例如一个页面中的两个 tab\n模块，使用的数据的结构和逻辑相同，区别只是从不同的接口获取数据，那么可以通过 Model 复制的方式，创建 2 个不同的 Model 对象。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","frontmatter":{"sidebar_position":2,"title":"创建 Model"}},{"id":280,"title":"常见问题","routePath":"/en/guides/topic-detail/model/faq","lang":"en","toc":[{"id":"浏览器兼容性","text":"浏览器兼容性","depth":2},{"id":"微前端子应用-model-访问主应用-model","text":"微前端子应用 Model 访问主应用 Model","depth":2}],"domain":"","content":"\n\n\n浏览器兼容性\n\nReduck 的编译构建产物默认使用 ES6 语法，如果你需要支持更低版本的浏览器，请将 @modern-js-reduck\n命名空间下的所有包加入到应用的编译过程。\n\n补充信息\n\nReduck 使用的 @babel/preset-env 的详细配置。\n\n\n微前端子应用 Model 访问主应用 Model\n\n微前端子应用 Model 访问主应用 Model 时，如果该 Model 在主应用尚未挂载，会自动挂载到子应用上。\n\n示例：\n\n\n\n\nfunction SubModelApp() {\n  const [state, actions] = useModel(parentModel);\n\n  return <div>...</div>;\n}\n\n\n\n\n为了避免意外降级挂载，建议将主应用所需要共享的 Model 预先挂载：\n\n// App 是主应用的入口组件，sharedModel1、sharedModel2 是需要共享的 Model。\nApp.models = [sharedModel1, sharedModel2];\n","frontmatter":{"sidebar_position":13,"title":"常见问题"}},{"id":281,"title":"副作用管理","routePath":"/en/guides/topic-detail/model/manage-effects","lang":"en","toc":[{"id":"副作用对-state-修改","text":"副作用对 State 修改","depth":2},{"id":"副作用不影响-state","text":"副作用不影响 state","depth":2},{"id":"副作用函数返回值","text":"副作用函数返回值","depth":2}],"domain":"","content":"\n\nModel 中的 Action 必须是一个纯函数，执行过程中不会产生任何副作用。但在真实的业务中，我们会遇到很多副作用场景，如：请求 HTTP\n接口获取状态数据，或者在更新状态的同时修改 localStorage、发送事件等。在 Reduck 中，是通过 Model 的 Effects\n函数管理副作用的。\n\n\n副作用对 State 修改\n\n副作用修改 State，最常见的场景就是请求 HTTP 接口，更新状态数据。\n\n我们以一个简单的 todoModel 为例。其有一个 load 的副作用函数，请求远端的 TODO 列表，请求成功之后更新 state.items 字段。\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    load: {\n      pending(state) {\n        state.loading = true;\n      },\n      fulfilled(state, items) {\n        state.items = items;\n        state.loading = false;\n      },\n      rejected(state, error) {\n        state.error = error;\n        state.loading = false;\n      },\n    },\n  },\n  effects: {\n    // Promise 副作用\n    async load() {\n      return new Promise(resolve => {\n        setTimeout(() => resolve(['Learn Modern.js']), 2000);\n      });\n    },\n  },\n});\n\n\n副作用函数统一定义在 effects 字段下。这里我们写了一个 load 函数，它返回一个 Promise，Promise 执行成功后，返回 TODO 列表\n[\"Lerna Modern.js\"]。\n\n副作用函数需要和 actions 配合使用，才能完成状态的修改。因此，我们在 actions 中定义了一个 load（命名需要和 effects\n下的副作用函数的名字保持一致）对象，包含 pending、fulfilled、rejected 3 个 action，分别是对副作用函数 load 返回的\nPromise 的三种状态（ pending、fulfilled、rejected ）的处理：\n\n * pending：接收当前状态 state 作为参数，新的状态中 loading 设为 true。\n * fulfilled：接收当前状态 state 和 Promise fulfilled 状态的值 items 为参数，新的状态中 items 等于参数\n   items、loading 设为 false。\n * rejected：接收当前状态 state 和 Promise rejected 状态的错误 error 为参数，新的状态中 error 等于参数\n   error、loading 设为 false。\n\n组件中如何调用 effects 函数呢？ effects 函数会被合并到 actions 对象上，因此可以通过 actions 对象调用 effects\n函数，如下所示：\n\nfunction Todo() {\n  const [state, actions] = useModel(todoModel);\n\n  useEffect(() => {\n    // 调用 effects 函数\n    actions.load();\n  }, []);\n\n  if (state.loading) {\n    return <div>loading....</div>;\n  }\n\n  return (\n    <div>\n      <div>\n        {state.items.map((item, index) => (\n          <div key={index}>{item}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n\n上面的示例中， pending、fulfilled、rejected 3 个 action，对于用于获取数据的 HTTP\n请求场景下，一般都是需要的。Reduck 提供了一个工具函数 handleEffect，用于简化这种场景下的 action 创建。\n\nhandleEffect 约定这种副作用场景下， Model 的 State 结构包含 result、error、pending 3 个字段，初始值为：\n\n{\n  result: null,\n  error: null,\n  pending: false，\n}\n\n\n调用 handleEffect 会返回如下数据结构:\n\n{\n  pending() { // ... },\n  fulfilled() { // ... },\n  rejected() { // ... }\n}\n\n\n这个数据结构和我们在 actions 下的 load 对象的数据结构是相同的。handleEffect 返回的对象，其实就是对应了 Effects 函数需要的\n3 个 action。\n\n利用 handleEffect，改写 todoModel：\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    load: handleEffect({ result: 'items' }),\n  },\n  effects: {\n    // Promise 副作用\n    async load() {\n      return new Promise(resolve => {\n        setTimeout(() => resolve(['Learn Modern.js']), 2000);\n      });\n    },\n  },\n});\n\n\nhandleEffect 接收的参数对象，将 result 设置为 item。因为 todoModel 的 state，使用 items 作为 key 保存\ntodo 列表数据，而不是使用 handleEffect 默认的 result 作为 key，所以这里需要进行配置。\n\n明显可见，通过 handleEffect 实现的 todoModel 比之前的实现有了很大精简。\n\n如果不希望 pending、fulfilled、rejected 3 种状态都被 handleEffect 自动处理，例如 fulfilled\n需要手动处理较复杂的数据类型，但是 pending、rejected 依旧想进行自动化处理，可以参考如下写法：\n\n  actions: {\n    load: {\n      ...handleEffect(),\n      fulfilled(state, payload) {\n        // 手动处理\n      },\n    },\n  },\n\n\n补充信息\n\nhandleEffect API。\n\nEffects 函数中，也支持手动调用 Actions，例如：\n\nconst todoModel = model('todo').define((context, utils) => ({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    pending(state) {\n      state.loading = true;\n    },\n    fulfilled(state, items) {\n      state.items = items;\n      state.loading = false;\n    },\n  },\n  effects: {\n    async load() {\n      // 通过 utils.use 获取当前 Model 对象的 actions\n      const [, actions] = utils.use(todoModel);\n      // 手动调用 action\n      actions.pending();\n\n      return new Promise(resolve => {\n        setTimeout(() => {\n          const items = ['Learn Modern.js'];\n          // 手动调用 action\n          actions.fulfilled(items);\n          resolve(items);\n        }, 2000);\n      });\n    },\n  },\n}));\n\n\nINFO\n\n可以使用 use 函数加载其它 Model（包括 Model 自身），实现 Model 间通信。\n\n\n副作用不影响 state\n\n有些场景下，我们只需要读取 State，执行相关副作用逻辑，副作用不会修改 State。\n\n例如，存储某些 State 到 localStorage：\n\nconst fooModel = model('foo').define((context, utils) => ({\n  state: {\n    value: 'foo',\n  },\n  effects: {\n    setLocalStorage(key) {\n      const [state] = utils.use(fooModel);\n      localStorage.set(key, state.value);\n      return 'success';\n    },\n  },\n}));\n\n\n或者是向服务端发送数据：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n  effects: {\n    async sendData(data) {\n      const res = await fetch('url', {\n        method: 'POST',\n        body: data,\n      });\n      return res.json();\n    },\n  },\n});\n\n\n\n副作用函数返回值\n\n有时候，我们希望能根据副作用函数的执行结果，直接执行后续逻辑。这时候，就需要使用 Effects 函数的返回。\n\n例如，当点击发送按钮，发送数据成功后，立即关闭当前的弹窗；如果失败，显示错误信息。我们可以通过如下代码实现：\n\n// 代码仅做示意，不能执行\n// 组件内部 发送按钮 的响应函数\nconst handleClick = async () => {\n  // sendData 返回代表状态的字符串\n  const result = await actions.sendData('some data');\n  if (result === 'success') {\n    // 关闭弹窗\n    closeModal();\n  } else {\n    // 显示错误\n    showError(result);\n  }\n};\n\n\n补充信息\n\n示例代码","frontmatter":{"sidebar_position":5,"title":"副作用管理"}},{"id":282,"title":"Model 通信","routePath":"/en/guides/topic-detail/model/model-communicate","lang":"en","toc":[{"id":"model-间通信","text":"Model 间通信","depth":2},{"id":"model-内通信","text":"Model 内通信","depth":2}],"domain":"","content":"\n\nModel 通信，既指不同 Model 间的通信，也指同一个 Model 内部 Effects、Actions 之间的通信。\n\n\nModel 间通信\n\nModel 之间不是孤立的，是可以进行通信的。主要分为两种场景：\n\n 1. 在 Model 中访问其它 Model 的 State 和 Actions。\n 2. 在 Model 中监听其它 Model 变化。\n\n这里将 快速上手 一节的简单计数器应用改造成一个可设置步频的计数器应用。可以通过设置步频，从而影响每次计数器增加的幅度。\n\n我们抽象出两个 Model，分别为 stepModel（步频）、counterModel（计数器）：\n\n\n\nconst stepModel = model('step').define({\n  state: 1,\n});\n\nconst counterModel = model('count').define((context, { use, onMount }) => {\n  const [, , subscribeStep] = use(stepModel);\n\n  onMount(() => {\n    return subscribeStep(() => {\n      console.log(\n        `Subscribe in counterModel: stepModel change to ${use(stepModel)[0]}`,\n      );\n    });\n  });\n\n  return {\n    state: {\n      value: 1,\n    },\n    actions: {\n      add(state) {\n        const step = use(stepModel)[0];\n        state.value += step;\n      },\n    },\n  };\n});\n\nexport { stepModel, counterModel };\n\n\nstepModel 只声明一个 state，初始值为 1。\n\ncounterModel 通过 use 函数加载 stepModel，拿到返回的 subscribeStep 函数，用来监听 stepModel 状态的变更。\nonMount 是 Model 挂载完成后的钩子函数，counterModel 挂载完成后开始订阅 stepModel 状态的变更，打印出 stepModel\n的最新值。\n\ncounterModel 通过 use 函数访问 stepModel，在 add 里可以获取到当前 stepModel 的值（步频），以此值来做自增。\n\n注意\n\n当需要访问其他 Model 的 State 时，必须要在当前 Actions 或 Effects 函数（本例中对应 add 函数 ）真正执行的阶段调用\nuse，以保证获取的 State 是最新值。因此，我们虽然在 define 的回调函数中也调用了 use(stepModel)，但是我们并没有解构\nstepModel 的 state 值，因为 define 的回调函数是在 Model 的挂载阶段执行的，这个时候获取到的 stepModel 的 state\n可能和 add 执行时获取到的值是不同的。\n\n修改 App.tsx\n\n\n\n\nfunction Counter() {\n  const [state, actions] = useModel(counterModel);\n  const [step, stepActions] = useModel(stepModel);\n\n  return (\n    <div>\n      <div>step: {step}</div>\n      <button onClick={() => stepActions.setState(step + 1)}>add step</button>\n      <div>counter: {state.value}</div>\n      <button onClick={() => actions.add()}>add counter</button>\n    </div>\n  );\n}\n\nexport default function App() {\n  return <Counter />;\n}\n\n\n补充信息\n\nModern.js 默认开启 自动生成 actions，所以 stepModel 中虽然没有手动定义 Actions，但可以使用自动生成的 setState。\n\n * 点击 add step 增加步频。\n * 点击 add counter 触发计数器增加。\n\n最终效果如下：\n\n\n\n补充信息\n\n * 本节完整的示例代码。\n * 相关 API 的更多介绍，请参考：model。\n\n前面 counterModel 的例子，我们是在 Actions 的函数内部调用 use 获取其他 Model 对象的。如果只需要调用其它 Model 的\nActions，因为 Actions 都是函数，不存在值过期问题，所以也可以在 define 的回调函数中调用 use 获取 Model 的\nActions。例如：\n\nconst barModel = model('bar').define({\n  // 省略\n});\n\nconst fooModel = model('foo').define((context, utils) => {\n  // 获取 barModel 的 actions\n  const [, actions] = utils.use(barModel);\n  return {\n    // 省略 state、actions\n    effects: {\n      async loadA() {\n        // 省略副作用逻辑\n        // 调用 barModel 的 action\n        barModel.actionA();\n      },\n      async loadB() {\n        // 省略副作用逻辑\n        // 调用 barModel 的 action\n        barModel.actionB();\n      },\n    },\n  };\n});\n\n\n这样，我们不需要在 loadA、loadB 中重复获取 barModel 对象，简化了代码逻辑。\n\n\nModel 内通信\n\nModel 内通信，也主要分为两种场景：\n\n 1. Effects 函数调用自身 Model 的 Actions 函数、或其他 Effects 函数。\n 2. Actions 函数调用自身 Model 的 其他 Actions 函数。\n\n在 副作用管理 一节，我们演示过 Effects 函数如何调用 Actions 函数。\n\n这里我们再来举一个例子：\n\nconst fooModel = model('foo').define((context, { use, onMount }) => ({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.a = payload;\n    },\n  },\n  effects: {\n    async loadA() {\n      // 通过 use 获取当前 Model 的 actions\n      const [, actions] = use(fooModel);\n      const res = await mockFetchA();\n      actions.setA(res);\n    },\n    async loadB() {\n      // 通过 use 获取当前 Model 的 actions\n      const [, actions] = use(fooModel);\n      const res = await mockFetchB();\n      actions.setB(res);\n    },\n  },\n}));\n\n\n这个例子中，fooModel 的两个 Effects 函数，需要调用自身的 Actions 函数。这里我们在每个 Effects 函数中，都调用了一次\nuse，为什么不能像 Model 间通信的例子中，在 define 的回调函数中，统一调用 use 获取 Model 自身的 Actions 呢？这是因为调用\nuse 获取 Model 时，会先检查这个 Model 是否已经挂载，如果还没有挂载，会先执行挂载逻辑，而 define 的回调函数又是在 Model\n的挂载阶段执行的，这样一来，在挂载阶段调用 use 获取 Model 自身，会出现死循环（代码实际执行过程会抛出错误）。所以，一定不能在 define\n的回调函数中，调用 use 获取 Model 自身对象。\n\n不过，我们可以利用 onMount 这个钩子函数，在 Model 挂载完成后，再通过 use 获取 Model 自身对象：\n\nconst fooModel = model('foo').define((context, { use, onMount }) => {\n  let actions;\n\n  onMount(() => {\n    // fooModel 挂载完成后，通过 use 获取当前 Model 的 actions\n    [, actions] = use(fooModel);\n  });\n\n  return {\n    state: {\n      a: '',\n      b: '',\n    },\n    actions: {\n      setA(state, payload) {\n        state.a = payload;\n      },\n      setB(state, payload) {\n        state.a = payload;\n      },\n    },\n    effects: {\n      async loadA() {\n        const res = await mockFetchA();\n        actions.setA(res);\n      },\n      async loadB() {\n        const res = await mockFetchB();\n        actions.setB(res);\n      },\n    },\n  };\n});\n\n\n这样，我们也可以实现代码的简化。","frontmatter":{"sidebar_position":7,"title":"Model 通信"}},{"id":283,"title":"性能优化","routePath":"/en/guides/topic-detail/model/performance","lang":"en","toc":[{"id":"model-拆分","text":"Model 拆分","depth":2},{"id":"状态筛选","text":"状态筛选","depth":2},{"id":"衍生状态缓存","text":"衍生状态缓存","depth":2}],"domain":"","content":"\n\nReduck 内部已经做了大量性能优化工作，一般情况下不需要考虑性能问题。不过当对性能比较敏感、或者遇到了性能问题，可以考虑从以下 3\n个方面，进行更有针对性的性能优化。\n\n\nModel 拆分\n\n当 useModel 返回 Model 对象的完整 State 时，State 任意部分的变化都会导致调用了 useModel 的组件重新渲染。\n\n例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  const [state] = useModel(fooModel);\n\n  return <div>{state.a}</div>;\n}\n\n\n组件 ComponentA 虽然只需要使用 a 状态，但当 b 状态发送变化时， ComponentA 仍然会重新渲染。这种情况，我们可以考虑把\nfooModel 拆分，a、b 分别由不同的 Model 负责管理：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    b: '',\n  },\n  actions: {\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\n\n\n状态筛选\n\nuseModel 支持传入 selector 函数，对返回给组件的 State 和 Actions 做筛选。我们可以通过 selector\n函数，确保返回给组件的 State 是组件直接需要使用的，从而保证组件不会因为其他无关状态的变化而重新渲染。\n\n对于上面同样的例子，我们采用 selector 函数进行性能优化，代码如下：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  // 通过传入 selector 函数，只返回 a 状态给组件\n  const [stateA] = useModel(fooModel, state => state.a);\n\n  return <div>{stateA}</div>;\n}\n\n\n\n衍生状态缓存\n\n当 Model 存在 computed 时，每次调用useModel 都会执行 computed 函数。\n\n考虑如下代码：\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  computed: {\n    combineA: [\n      fooModel, // fooModel 定义同上\n      (state, fooState) => {\n        return state + fooState.a;\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nfunction ComponentB() {\n  const [state, actions] = useModel(fooModel);\n  const [{ combineA }] = useModel(barModel);\n  // 省略\n}\n\n\nbarModel 的衍生状态 combineA 依赖 barModel 自身状态 和 fooModel 的状态 a，但是即使是 fooModel 的状态 b\n发生了变化，组件重新渲染时， combineA （更准确的说法是 combineA 的最后一个函数类型的元素 ）依然会被调用执行。\n\n一般情况下，computed 函数中的逻辑都是非常轻量的，但当 computed 函数逻辑比较复杂时，我们可以考虑对计算逻辑做缓存。例如，我们使用\nreselect 对 barModel 的 combineA 做缓存：\n\n\n\n// 创建缓存函数\nconst selectCombineA = createSelector(\n  (state) => state.bar.value,\n  (state) => state.foo.a,\n  (barState, fooState) => {\n    return barState + fooState;\n  }\n);\n\nconst barModel = model(\"bar\").define({\n  state: {\n    value: \"bar\",\n  },\n  computed: {\n    combineA: [\n      fooModel,\n      (state, fooState) => {\n        return selectCombineA({\n          foo: fooState,\n          bar: state,\n        });\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\n\n我们创建缓存函数 createSelector，仅当 barModel 的状态发生改变或 fooModel 的 a 状态发生改变时，才会重新计算\ncombineA 的值。\n\n补充信息\n\n本节完整的示例代码","frontmatter":{"sidebar_position":8,"title":"性能优化"}},{"id":284,"title":"快速上手","routePath":"/en/guides/topic-detail/model/quick-start","lang":"en","toc":[{"id":"核心概念","text":"核心概念","depth":2},{"id":"基本用法","text":"基本用法","depth":2}],"domain":"","content":"\n\nReduck 是 Modern.js 团队开发的遵循 MVC 模式的状态管理库，底层状态存储基于 Redux 实现，同时提供更高层级的抽象，并完全兼容\nRedux 生态。\n\nReduck 的目标是以 MVC 模式组织 React 应用开发结构，将业务逻辑维护在 Model 层，业务逻辑与 UI\n解耦，让开发业务逻辑更集中、更简单，同时通过更高层级的抽象，减少重复工作（样板代码）。\n\nReduck 在 MVC 模式中，扮演 M(Model) 的角色，React UI Component 对应 V(View)，从 Reduck 中获取\nModel 并修改 Model 的 React Container Component 对应 C(View Controller/Container)。\n\nModern.js 的状态管理解决方案，是通过内置 Reduck 实现的。在 Modern.js 中使用 Reduck，不仅免去了手动集成的环节，而且所有\nReduck API 都可以从 Modern.js 的 Runtime 包中直接导入使用，具有更好的一致性体验。\n\nINFO\n\n 1. Modern.js 中使用 Reduck API，需要先设置 runtime.state 以启用状态管理插件。\n 2. Reduck 也可以脱离 Modern.js 作为状态管理库单独使用。\n\n\n核心概念\n\nReduck 中的核心概念只有 4 个： Model、State、Actions、Effects。\n\nModel: 对独立模块的逻辑和所需状态的封装，由 State、Actions、Effects 组成。\n\nState: Model 中保存的状态。\n\nActions: 用于修改 State 的纯函数，函数必须是同步的。\n\nEffects: 用于修改 State 的带有副作用的函数，函数可以是异步的。Effects 中可以调用自身或其他 Model 的 Actions 和\nEffects。\n\nReduck 数据流如下图所示：\n\n\n\n\n基本用法\n\n下来我们以一个简单的 计数器 应用为例，演示 Reduck 的基本用法。\n\n首先，我们定义一个名为 count 的 Model：\n\n\n\nconst countModel = model('count').define({\n  state: {\n    value: 1,\n  },\n});\n\nexport default countModel;\n\n\n我们使用 API model 创建 countModel，countModel 当前只包含存储计数器值的状态，即代码中的 value。\n\n我们定义一个 action，用于计算器自增加 1：\n\n\n\nconst countModel = model('count').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state.value += 1;\n    },\n  },\n});\n\nexport default countModel;\n\n\n在 add action 中，我们可以直接修改 state 的值，进行加 1 操作，而不需要把 state 作为不可变对象进行操作，这是因为 Reduck\n集成了 immer，可以直接修改原 state 对象。\n\n接下来，我们演示如何在组件中使用 Model。\n\n新建一个组件 Counter，在组件内通过 useModel API 使用 countModel：\n\n\n\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  return (\n    <div>\n      <div>counter: {state.value}</div>\n      <button onClick={() => actions.add()}>add</button>\n    </div>\n  );\n}\n\n\nuseModel 获取 countModel 的 state 和 actions，组件展示当前计算器的值，点击 add 按钮，计数器自增 1。\n\nINFO\n\n由于使用的案例比较简单，这里并没有严格按照 MVC 模式进行分层，组件 Counter 同时起到了 V 和 C 两层的作用。\n\n最终演示效果如下：\n\n\n\n这样，我们就完了一个简单的计数器应用。本节完整的示例代码可以在这里查看。","frontmatter":{"sidebar_position":1,"title":"快速上手"}},{"id":285,"title":"Redux 生态集成","routePath":"/en/guides/topic-detail/model/redux-integration","lang":"en","toc":[],"domain":"","content":"\n\nReduck 基于 Redux 实现，因此可以使用 Redux 生态的库，实现功能增强。通过 Provider 、createApp 和 createStore\n等 API ，可以设置使用 Redux 的 中间件 和 Store Enhancer；使用 createStore 还可以完全掌控 Store 的创建过程。\n\n例如，我们希望使用中间件 redux-logger，示例代码如下：\n\nReactDOM.render(\n  <Provider config={{ middlewares: [logger] }}>\n    // 通过 Provider 的 config 参数设置 中间件\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n\n\nCAUTION\n\nReduck 基于 Redux 底层 API 做了上层封装，屏蔽了 Redux 的一些底层概念，如 Reducer 等。Reduck 对于 Model\n是动态挂载的，而 Redux 是在 Store 创建时就会挂载应用所需的全部状态。基于这些实现上的差异，有些 Redux 生态的库是无法直接在 Reduck\n中使用的。","frontmatter":{"sidebar_position":11,"title":"Redux 生态集成"}},{"id":286,"title":"测试 Model","routePath":"/en/guides/topic-detail/model/test-model","lang":"en","toc":[],"domain":"","content":"\n\n好的测试对代码的稳健性至关重要。下面以 快速上手 的 countModel 为例，演示在 Modern.js 中，如何对 Model 进行单元测试。\n\n使用测试功能，需要先开启该功能。在项目根目录下，执行 pnpm run new，进行如下选择：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「单元测试 / 集成测试」功能\n\n\n即可开启测试功能支持。\n\n新增 count.test.ts 文件，代码如下：\n\n\n\n\ndescribe('test model', () => {\n  it('count value should plus one after add', () => {\n    const store = createStore();\n    const [state, { add }] = store.use(countModel);\n\n    expect(state).toEqual({ value: 1 });\n\n    add();\n\n    expect(store.use(countModel)[0]).toEqual({ value: 2 });\n  });\n});\n\n\nINFO\n\n这里使用的 createStore 是从 @modern-js/runtime/testing 导入的，内部会使用 runtime.state 的配置去创建\nstore。\n\n在测试用例里，我们新建一个 store 来挂载 countModel，通过 store.use 获取 countModel 的 State 和\nActions。然后调用 add Action 更新状态，并断言更新后的状态值。\n\n执行 pnpm run test 命令，触发测试用例的执行。","frontmatter":{"sidebar_position":9,"title":"测试 Model"}},{"id":287,"title":"TS 最佳实践","routePath":"/en/guides/topic-detail/model/typescript-best-practice","lang":"en","toc":[{"id":"定义-model-的-state-类型","text":"定义 Model 的 State 类型","depth":2},{"id":"衍生状态的依赖类型","text":"衍生状态的依赖类型","depth":2},{"id":"获取-model-类型信息的-hooks","text":"获取 Model 类型信息的 Hooks","depth":2}],"domain":"","content":"\n\nReduck 对 TS 提供了良好的支持，大部分使用场景下，无需任何额外工作，就可以直接获得 API 的 TS\n类型提示。本节，将对其他的一些使用场景，做补充介绍。\n\n\n定义 Model 的 State 类型\n\n为 Model 的 State 声明类型信息，是在 TS 中使用 Reduck 的最佳实践。\n\ninterface State {\n  data: string;\n}\n\nexport const foo = model<State>('foo').define({\n  state: {\n    data: '',\n  },\n  computed: {\n    withSuffix: state => state.data + 'suffix',\n  },\n  actions: {\n    setData: (state, payload: string) => {\n      state.data = payload;\n    },\n  },\n});\n\n\n当为 Model 的 State 声明类型信息后，Model 的 computed、actions\n都能获取正确的类型信息。事实上，上面的示例代码中，即使我们不定义 State 类型信息，也会根据 state 的初始值信息自动推导出 State\n的类型信息。不过，仍然建议你在定义 Model 时，声明 State 的类型信息，因为根据 state 的初始值信息推导出的 State\n类型信息可能不完整(缺少字段或字段的类型信息缺少)，而且当使用函数类型定义 Model 时，State 的类型信息也是无法根据 state\n的初始值信息自动推导的。\n\n\n衍生状态的依赖类型\n\n当 Model 的衍生状态依赖其他 Model 时，需要手动指定其他 Model 的 State。\n\ninterface State {\n  data: string;\n}\n\nexport const bar = model<State>('bar').define({\n  state: {\n    data: '',\n  },\n  computed: {\n    // 为 fooState 指定类型\n    withFoo: [foo, (state, fooState: FooState) => state.data + fooState.data],\n  },\n});\n\n\n\n获取 Model 类型信息的 Hooks\n\nReduck 提供了一组用于获取 Model 类型信息的工具类型：\n\n * GetModelState： 获取 Model 的 State（包含衍生状态）类型信息。\n * GetModelActions：获取 Model 的 Actions（包含 Effects 函数）类型信息。\n\nexport const foo = model<State2>('foo').define({\n  // 省略\n});\n\n// 获取 foo 的 State 类型\nlet fooActions: GetModelActions<typeof foo>;\n// 获取 foo 的 Actions 类型\nlet fooState: GetModelState<typeof foo>;\n","frontmatter":{"sidebar_position":10,"title":"TS 最佳实践"}},{"id":288,"title":"使用 Model","routePath":"/en/guides/topic-detail/model/use-model","lang":"en","toc":[{"id":"在组件内使用","text":"在组件内使用","depth":2},{"id":"作为全局状态使用","text":"作为全局状态使用","depth":3},{"id":"作为静态状态使用","text":"作为静态状态使用","depth":3},{"id":"作为局部状态使用","text":"作为局部状态使用","depth":3},{"id":"在组件外使用","text":"在组件外使用","depth":2}],"domain":"","content":"\n\n\n在组件内使用\n\n\n作为全局状态使用\n\n通过 useModel 可以获取 Model 的 State、Actions 等。当 Model 的 State 通过 Actions\n进行修改后，任何其他使用了该 Model 的组件，都会自动重新渲染。\n\n在 快速上手 的计数器案例中，我们已经演示了 useModel 的使用，不再重复。\n\nuseModel 支持传入多个 Model，多个 Model 的 State 和 Actions 会进行合并后作为返回结果。例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state += 1;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    title: 'bar',\n  },\n  actions: {\n    set(state, payload) {\n      state.title = payload;\n    },\n  },\n});\n\nconst [state, actions] = useModel([fooModel, barModel]);\n// 或\nconst [state, actions] = useModel(fooModel, barModel);\n\n\nstate 和 actions 的值分别为：\n\nstate = {\n  value: 1,\n  title: 'bar',\n};\n\nactions = {\n  add(state) {\n    state += 1;\n  },\n  set(state, payload) {\n    state.title = payload;\n  },\n};\n\n\nuseModel 还支持对 State 和 Actions 做 selector 操作，实现对 State 和 Actions 的筛选或重命名，例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state += 1;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  actions: {\n    set(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nconst [state, actions] = useModel(\n  [fooModel, barModel],\n  (fooState, barState) => ({\n    fooValue: fooState.value,\n    barValue: barState.value,\n  }), // stateSelector\n  (fooActions, barActions) => ({ add: fooActions.add }), // actionsSelector\n);\n\n\n我们通过 stateSelector ，把 fooModel 和 barModel 中重名的状态做了命名修改，通过 actionsSelector ，过滤掉了\nbarModel 的 Actions。\n\n如果只需要设置 actionsSelector，可以把 stateSelector 设置为 undefined，作为参数占位。例如：\n\nconst [state, actions] = useModel(\n  [fooModel, barModel],\n  undefined,\n  (fooActions, barActions) => ({ add: fooActions.add }), // actionsSelector\n);\n\n\n\n作为静态状态使用\n\n通过 useStaticModel 获取 Model ，将 Model 中的状态作为静态状态使用。可以保证组件每次访问到的 Model 的 State\n都是最新值，但是 Model 的 State 的变化，并不会引起当前组件的重新渲染。\n\nINFO\n\nuseStaticModel 的使用方式和 useModel 完全一致。\n\n考虑下面一种场景，有一个组件 Input 负责用户输入，另外一个组件 Search\n负责根据用户的输入信息，在点击查询按钮后执行查询操作，我们不希望用户输入过程中的状态变化引起 Search 重新渲染，这时候就可以使用\nuseStaticModel：\n\n\n\nfunction Search() {\n  // 这里注意不要解构 state\n  const [state] = useStaticModel(searchModel);\n\n  return (\n    <div>\n      <button\n        onClick={async () => {\n          const result = await mockSearch(state.input);\n          console.log(result);\n        }}\n      >\n        Search\n      </button>\n    </div>\n  );\n}\n\n\n注意\n\n不要解构 useStaticModel 返回的 state，例如改成如下写法： const [{input}] =\nuseStaticModel(searchModel); 将始终获取到 Input 的初始值。\n\nuseStaticModel 还适合和 react-three-fiber 等动画库一起使用，因为在动画组件 UI\n里绑定会快速变化的状态，容易引起性能问题。这种情况就可以选择使用\nuseStaticModel，它只会订阅状态，但不会引起视图组件的重新渲染。下面是一个简化示例：\n\nfunction ThreeComponent() {\n  const [state, actions] = useStaticModel(modelA);\n\n  useFrame(() => {\n    state.value; // 假设初始化为 0\n    actions.setValue(1);\n    state.value; // 这里会得到1\n  });\n}\n\n\n使用 React 的 refs 也可以实现类似效果，其实 useStaticModel 内部也使用到了 refs。不过直接 useStaticModel\n有助于将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\n完整的示例代码可以在这里查看。\n\n\n作为局部状态使用\n\n通过 useLocalModel 获取 Model ，将 Model 中的状态作为局部状态使用。此时 Model State\n的变化，只会引起当前组件的重新渲染，但是不会引起其他使用了该 Model 的组件重新渲染。效果和通过 React 的 useState\n管理状态类似，但是可以将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\nINFO\n\nuseLocalModel 的使用方式和 useModel 完全一致。\n\n例如，我们修改计数器应用的代码，添加一个有局部状态的计数器组件 LocalCounter：\n\n\n\nfunction LocalCounter() {\n  const [state, actions] = useLocalModel(countModel);\n\n  return (\n    <div>\n      <div>local counter: {state.value}</div>\n      <button onClick={() => actions.add()}>add</button>\n    </div>\n  );\n}\n\n\n分别点击 Counter 和 LocalCounter 的 add 按钮，两者的状态互不影响：\n\n\n\n完整的示例代码可以在这里查看。\n\n\n在组件外使用\n\n在实际业务场景中，有时候我们需要在 React 组件外使用 Model，例如在工具函数中访问 State、执行 Actions 等。这个时候，我们就需要使用\nStore。 Store 是一个底层概念，一般情况下用户接触不到，它负责存储和管理整个应用的状态。Reduck 的 Store 基于 Redux 的 Store\n实现，增加了 Reduck 特有的 API，如 use 。\n\n首先，在组件内调用 useStore 获取当前应用使用的 store 对象，并挂载到组件外的变量上：\n\nlet store; // 组件外部 `store` 对象的引用\nfunction setStore(s) {\n  store = s;\n}\nfunction getStore() {\n  return store;\n}\n\nfunction Counter() {\n  const [state] = useModel(countModel);\n  const store = useStore();\n  // 通过 useMemo 避免不必要的重复设置\n  useMemo(() => {\n    setStore(store);\n  }, [store]);\n\n  return (\n    <div>\n      <div>counter: {state.value}</div>\n    </div>\n  );\n}\n\n\n通过 store.use 可以获取 Model 对象，store.use 的用法同 useModel 相同。以计数器应用为例，我们在组件树外，每 1s\n对计数器值 执行自增操作：\n\nsetInterval(() => {\n  const store = getStore();\n  const [, actions] = store.use(countModel);\n  actions.add();\n}, 1000);\n\n\n完整的示例代码可以在这里查看。\n\nINFO\n\n如果是通过 createStore 手动创建的 Store 对象，无需通过 useStore 在组件内获取，即可直接使用。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","frontmatter":{"sidebar_position":3,"title":"使用 Model"}},{"id":289,"title":"单独使用 Reduck","routePath":"/en/guides/topic-detail/model/use-out-of-modernjs","lang":"en","toc":[],"domain":"","content":"\n\n在 Modern.js 以外，单独集成 Reduck 使用时，主要需要做以下修改：\n\n 1. 安装 Reduck 相关包\n\n在项目中安装 Reduck 包：@modern-js-reduck/react。\n\n 2. API 导入包名\n\n在 Modern.js 中使用时，Reduck 导出 API 的包名为：@modern-js/runtime/model。单独使用 Reduck\n时，导出包名为：@modern-js-reduck/react。\n\n 3. 包裹 Provider 组件\n\nModern.js 自动在应用的入口组件上，包裹了用于注入 Reduck 全局 Store 的 Provider 组件。单独使用 Reduck\n时，需要手动完成。\n\n示例：\n\n// 根组件\nconst Root = () => {\n  return (\n    <Provider>\n      {/* 应用入口组件 */}\n      <App />\n    </Provider>\n  );\n};\n\n\n 4. 功能配置\n\n在 Modern.js 中使用时，可以通过 runtime.state 对 Reduck 功能进行配置。单独使用时，需要通过 Provider 的 config\n或 store 参数配置。\n\n示例：\n\nconst Root = () => {\n  return (\n    {/* 关闭 Redux DevTools */}\n    <Provider config={{ devTools: false }}>\n      <App />\n    </Provider>\n  )\n}\n","frontmatter":{"sidebar_position":12,"title":"单独使用 Reduck"}},{"id":290,"title":"CLI FAQ","routePath":"/en/guides/troubleshooting/cli","lang":"en","toc":[{"id":"cant-pass-command-line-arguments-correctly-when-using-pnpm","text":"Can't pass command line arguments correctly when using pnpm?","depth":3}],"domain":"","content":"\n\n\nCan't pass command line arguments correctly when using pnpm?\n\nThe pnpm v6 and pnpm v7 versions do not use the same posture when executing\ncommands. The following should be noted:\n\npnpm v7：\n\nWhen using pnpm to invoke a command in package.json, if you need to pass\narguments to pnpm, you need to put the arguments before the command.\n\nFor example, execute the prepare command with the pnpm '--filter' parameter:\n\npnpm run --filter \"./packages/**\" prepare\n\n\nIf you need to pass parameters to a command, you need to put the parameters\nafter the command.\n\nFor example, in the following package.json configuration:\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\nThe way to carry parameters when executing the command command is:\n\npnpm run command --options\n\n\npnpm v6:\n\nIn the following package.json configuration:\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\nIf you need to execute modern command --option,\n\nWhen using pnpm, you need to execute the pnpm run command -- --option.\n\nThis is because pnpm does not handle command parameters the same as Yarn, but is\nsimilar to npm: when not adding a -- character string, the parameters of pnpm\nare passed; when using a -- character string, the parameters of the execution\nscript are passed.\n\nIn the above example the parameter --option is passed to modern command. If pnpm\nrun command --option is executed, the parameter --option will be passed to pnpm.\n\nSummary:\n\n** When using pnpm v7, if you pass arguments to pnpm, you need to put the\narguments before the command **\n\n** When using pnpm v6, if the parameter passed to pnpm, you do not need to add\n--; if the parameter passed is for script use, you need to add -- character\nstring **.","frontmatter":{"sidebar_position":2}},{"id":292,"title":"Create Project","routePath":"/en/tutorials/first-app/c01-start","lang":"en","toc":[{"id":"environment-preparation","text":"Environment preparation","depth":2},{"id":"nodejs","text":"Node.js","depth":3},{"id":"pnpm","text":"pnpm","depth":3},{"id":"initialization-project","text":"Initialization project","depth":2},{"id":"debug-project","text":"Debug Project","depth":2},{"id":"modify-the-code","text":"Modify the code","depth":2},{"id":"enable-ssr","text":"Enable SSR","depth":2}],"domain":"","content":"\n\nStarting from this chapter, we will enter the practical tutorial section. In the\npractical tutorial, we will start with environment preparation, starting from\nsimple to complex, building a real project step by step.\n\n\nEnvironment preparation\n\n\nNode.js\n\nRequires [Node.js LTS] (https://github.com/nodejs/Release) and makes sure the\nNode version is greater than or equal to v16.18.1.\n\nModern.js recommend installing nvm in the development environment and\nintegrating script to automatically switch node versions in the shell.\n\nThen whenever there is a .nvmrc file with lts/gallium in the root directory of\nthe repository, entering the repository will automatically install or switch to\nthe correct Node.js version.\n\n\npnpm\n\nIt is recommended to use pnpm to manage dependencies:\n\nnpm install -g pnpm\n\n\nNOTE\n\nModern.js also supports dependency management with yarn and npm.\n\n\nInitialization project\n\nWe create a new directory and initialize the project via the command line tool:\n\nmkdir myapp && cd myapp\nnpx @modern-js/create\n\n\nModern.js generator will provide an interactive Q & A interface, initialization\nitems according to the result, according to the default selection:\n\n? Please select the solution you want to create: Web App Solution\n? Development Language: TS\n? Package Management Tool: pnpm\n\n\nAfter create the project, Modern.js automatically installs dependency and\ncreates a git repository.\n\n[INFO] dependencies are automatically installed\n[INFO] git repository has been automatically created\n[INFO] Success！\nYou can run the following command in the directory of the new project：\npnpm run dev          # Run and debug the project according to the requirements of the development environment\npnpm run build        # Build the project according to the requirements of the product environment\npnpm run serve        # Run the project according to the requirements of the product environment\npnpm run lint         # Check and fix all codes\npnpm run new          # Create more project elements, such as application portals\n\n\nNOTE\n\nIn addition to working during project initialization, the Modern.js generator\ncan also generate modules of the project in subsequent development, which is not\nthrown away as soon as it is used.\n\nNow, the project structure is as follows:\n\n.\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── modern.config.ts\n├── package.json\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\n\nDebug Project\n\nExecute pnpm run dev in the project to start the project:\n\n$ pnpm run dev\n\n> modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n Client ✔ done in 76.10ms\n\n\nOpen http://localhost:8000/ in your browser to see the page content.\n\n\nModify the code\n\nWe delete the original sample code and replace it with a simple point of contact\nlist:\n\nconst getAvatar = (users: Array<{ name: string; email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst mockData = getAvatar([\n  { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n  { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  { name: 'Bradley', email: 'd.wfovsqyo@gpkcjwjgb.fr' },\n  { name: 'Davis', email: '\"t.kqkoj@utlkwnpwk.nu' },\n]);\n\nfunction App() {\n  return (\n    <ul>\n      {mockData.map(({ name, avatar, email }) => (\n        <li key={name}>\n          <img src={avatar} width={60} height={60} /> ---\n          <span>{name}</span> ---\n          <span>{email}</span>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default App;\n\n\nRemove redundant css files and keep the directory free of redundant files:\n\nrm src/routes/index.css\n\n\nSince the framework supports HMR by default, you can see that the content in\nhttp://localhost:8080/ is automatically updated to:\n\n\n\nThe page has no styles at the moment. The next chapter will expand on this\nsection.\n\n\nEnable SSR\n\nNext, we modify the modern.config.ts in the project to enable the SSR\ncapability:\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools()],\n});\n\n\nRe-execute pnpm run dev to find that the project has completed page rendering at\nthe server level.","frontmatter":{"title":"Create Project"}},{"id":293,"title":"Add UI Components","routePath":"/en/tutorials/first-app/c02-component","lang":"en","toc":[],"domain":"","content":"\n\nIn the previous chapter, we learned how to initialize a project and use\nconfiguration to modify the default behavior of Modern.js.\n\nIn this chapter, we continue to use the project code of the previous chapter and\ncontinue to improve the point of contact list.\n\nIn order to do better UI display and interaction, we introduce the component\nlibrary Antd to develop, and use the <List> component instead of the primitive\nlist. Add dependency first:\n\npnpm add antd\n\n\nModify src/routes/page.tsx to import components at the top:\n\n\n\nModify the implementation of the <App> component:\n\nfunction App() {\n  return (\n    <div>\n      <List\n        dataSource={mockData}\n        renderItem={({ name, email, avatar }) => (\n          <List.Item key={name}>\n            <List.Item.Meta\n              avatar={<img alt=\"avatar\" src={avatar} width={60} height={60} />}\n              title={name}\n              description={email}\n            />\n          </List.Item>\n        )}\n      />\n    </div>\n  );\n}\n\n\nExecute pnpm run dev to see the running results:\n\n\n\nYou can see that the components exported by Ant Design already have complete\nstyles.\n\nnote\n\nModern.js Automatically import CSS required by Ant Design component on demand.\n\nNOTE\n\nWe can also use other component libraries to implement the same functionality,\nsuch as Arco Design.","frontmatter":{"title":"Add UI Components"}},{"id":294,"title":"Add Style","routePath":"/en/tutorials/first-app/c03-css","lang":"en","toc":[{"id":"js-components-using-css","text":"JS components using CSS","depth":2},{"id":"utility","text":"Utility","depth":2},{"id":"customized-utility-class","text":"Customized Utility Class","depth":2}],"domain":"","content":"\n\nIn the previous chapter, we learned how to use components from the three-way\nlibrary.\n\nIn this chapter, we will learn how to implement UI components.\n\n\nJS components using CSS\n\nFirst of all, we want to control the display of contact avatars by ourselves,\nand implement this design draft:\n\n\n\nHypothesis has no ready-made components to implement, so you need to write some\nCSS yourself. Here we use [styled-components] (https://styled-components.com/)\nto implement similar requirements. Modern.js out of the box supports\nstyled-components, which requires neither dependency nor configuration.\n\nStyle-components avoids many problems of traditional CSS writing through\nmodularization. For example, writing styles directly on the style attribute of\nelements, the visual details of UI will also be mixed with the details of UI\nstructure and business logic. Or classname needs to avoid global space renaming,\nwhich requires the use of naming conventions.\n\nModify the code at the top in src/routes/page.tsx:\n\n\n\nAdd the following code:\n\nconst Avatar = styled.img`\n  width: 50px;\n  height: 50px;\n  border: 4px solid #0ef;\n  border-radius: 50%;\n`;\n\n\nModify the code of List.Item.Meta:\n\n<List.Item.Meta\n  avatar={<Avatar src={avatar} />}\n  title={name}\n  description={email}\n/>\n\n\nExecute pnpm run dev to see the expected running result:\n\n\n\nNext we do a little refactoring. To enhance legibility and make the code easier\nto maintain, we can split the Avatar component. We execute the following command\nat the end point to create a new file:\n\nmkdir -p src/components/Avatar\ntouch src/components/Avatar/index.tsx\n\n\nmkdir -p src/components/Avatar\nni src/components/Avatar/index.tsx\n\n\nDelete the <Avatar> implementation in src/routes/page.tsx and change it to:\n\n\n\nThe content of src/components/Avatar/index.tsx is modified to:\n\n\n\nconst Avatar = styled.img`\n  width: 50px;\n  height: 50px;\n  border: 4px solid #0ef;\n  border-radius: 50%;\n`;\n\nexport default Avatar;\n\n\nExecute pnpm run dev, the result should be the same.\n\nnote\n\nThe reason for using the directory form Avatar/index.tsx instead of the\nsingle-file form Avatar.tsx is that you can easily add sub-files inside the\ndirectory later, including dedicated resources (pictures, etc.), dedicated\nsub-components, CSS files, etc.\n\n\nUtility\n\nWe have used the style-components implementation <Avatar> component, but the\ncurrent UI is still unsatisfactory and lacks professionalism, such as the list\nitem inhouse layout is a bit rough and misaligned in many places.\n\nNow, let's implement a better Item component ourselves, implementing a design\ndraft like this:\n\n\n\nThe UI to be implemented this time is more complex and has an internal\nstructure, but on the other hand, there is no very thick bright blue border of\nthe <Avatar> component such a very special UI, which is a very conventional\nhorizontal and vertical layout, centering, font style, etc. In this case, there\nis actually no need to write CSS at all. There is a more efficient\nimplementation method that complements styled-components: Utility Class.\n\nModern.js integrates the mainstream, light, general-purpose Utility Class\nlibrary Tailwind CSS.\n\nExecute pnpm run new and select the following to start Tailwind CSS:\n\n? Action: Enable features\n? Enable features: Enable Tailwind CSS\n\n\nRegister the Tailwind plugin in modern.config.ts:\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools(), tailwindcssPlugin()],\n});\n\n\nImport the Tailwind CSS css file at the top of src/routes/page.tsx to start a\nquick implementation of the professional UI:\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\nCreate the Item component first:\n\nmkdir -p src/components/Item\ntouch src/components/Item/index.tsx\n\n\nmkdir -p src/components/Item\nni src/components/Item/index.tsx\n\n\nModify src/routes/page.tsx to pass the render implementation of List to Item\ncomponent:\n\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\nconst getAvatar = (users: Array<{ name: string, email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst mockData = getAvatar([\n  { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n  { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  { name: 'Bradley', email: 'd.wfovsqyo@gpkcjwjgb.fr' },\n  { name: 'Davis', email: '\"t.kqkoj@utlkwnpwk.nu' },\n]);\n\nfunction Index() {\n  return (\n    <div className=\"container lg mx-auto\">\n      <List\n        dataSource={mockData}\n        renderItem={info => <Item key={info.name} info={info} />}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\nUtility Class(https://tailwindcss.com/docs/container) is used on the parent\ncontainer for a quick implementation of the most basic maximum width, center,\nand other styles.\n\nNext implementation src/components/Item/index.tsx:\n\n\n\ntype InfoProps = {\n  avatar: string;\n  name: string;\n  email: string;\n  archived?: boolean;\n};\n\nconst Item = ({ info }: { info: InfoProps }) => {\n  const { avatar, name, email, archived } = info;\n  return (\n    <div className=\"flex p-4 items-center border-gray-200 border-b\">\n      <Avatar src={avatar} />\n      <div className=\"ml-4 flex-1 flex justify-between\">\n        <div className=\"flex-1\">\n          <p>{name}</p>\n          <p>{email}</p>\n        </div>\n        <button\n          type=\"button\"\n          disabled={archived}\n          className={`bg-blue-500  text-white font-bold\n            py-2 px-4 rounded-full hover:bg-blue-700`}\n        >\n          Archive\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Item;\n\n\nExecute pnpm run dev to see the expected running result:\n\n\n\nWe only use a few Utility Classes, such as Flex, Padding, Margin, Text, Font,\nBorder, without writing a single CSS implementation Professional UI that\nconforms to the design draft.\n\n\nCustomized Utility Class\n\nWe can also implement the new Utility Class ourselves to facilitate reuse\nbetween codes.\n\nUtility Class itself is also a component-oriented technology (using different\nclasses on a component is equivalent to setting some attributes from the base\nclass for this component), but the classname of Utility Class is global (because\nit is used on arbitrary components/elements), it is very suitable for\nimplementation with separate CSS files.\n\nCreate a new CSS file:\n\nmkdir -p src/styles\ntouch src/styles/utils.css\n\n\nmkdir -p src/styles\nni src/styles/utils.css\n\n\n在 src/routes/page.tsx 里导入 utils.css：\n\nimport '../styles/utils.css';\n\n\nA Utility Class named custom-text-gray is implemented in\nsrc/routes/styles/utils.css.\n\n:root {\n  --custom-text-color: rgb(113, 128, 150);\n}\n\n.custom-text-gray {\n  color: var(--custom-text-color);\n}\n\n\nnote\n\nModern.js integrates with PostCSS and supports modern CSS syntax features such\nas custom properties.\n\nUse in src/routes/components/Item/index.tsx:\n\n<div className=\"ml-4 flex-1 flex justify-between\">\n\n\nChange to:\n\n<div className=\"ml-4 custom-text-gray flex-1 flex justify-between\">\n\n\nExecute pnpm run dev, you can see that the font color has changed:\n\n\n\nnote\n\nThis is just to demonstrate Utility Class usage. In a real project, with\nTailwind CSS, this Utility Class is of little value and should be added to the\nfont color through the theme of the configuration Design System.\n\nutils.css can also be written as utils.scss or utils.less, Modern.js out of the\nbox support for SCSS and Less.\n\nHowever, with the support of PostCSS, modern CSS should be sufficient to meet\nthese development needs, and the performance is also better than that of the\npreprocessor. It is recommended to use .css files first.","frontmatter":{"title":"Add Style"}},{"id":295,"title":"Add Client Route","routePath":"/en/tutorials/first-app/c04-routes","lang":"en","toc":[],"domain":"","content":"\n\nIn the previous chapter, we learned how to create UI components and add styles.\n\nIn this chapter, we will learn how to add Client Route.\n\nPreviously we have added the Archive button to the point of contact list, next\nwe add a route /archives, when accessing this route, only the point of contact\nof the saved file is displayed, while the original / continues to display all\npoints of contact.\n\nCreate a new src/routes/archives/page.tsx file:\n\nmkdir -p src/routes/archives\ntouch src/routes/archives/page.tsx\n\n\nmkdir -p src/routes/archives\nni src/routes/archives/page.tsx\n\n\nAdd the following code:\n\n\n\n\n\nconst getAvatar = (users: Array<{ name: string; email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst getMockArchivedData = () =>\n  getAvatar([\n    { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n    { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  ]);\nfunction Index() {\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>Archives</title>\n      </Helmet>\n      <List\n        dataSource={getMockArchivedData()}\n        renderItem={info => <Item key={info.name} info={info} />}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\nThe Helmet component of React Helmet is used here, and the Helmet component is\nalso added in src/routes/page.tsx:\n\n\n\nfunction Index() {\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      ...\n    </div>\n  );\n}\n\n\nnote\n\nModern.js integrates react-helmet by default, and can also be used in\nconjunction with SSR to meet SEO needs.\n\nSince there are multiple pages now, all of which need to use the previous\nUtility Class, we need to move the style file to src/routes/layout.tsx:\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\nimport '../styles/utils.css';\n\n\nExecute pnpm run dev, visit http://localhost:8080, you can see the full point of\ncontact, the title of the page is All:\n\n\n\nVisit http://localhost:8080/archives and you will only see the point of contact\nof the saved file with the title Archives:\n\n\n\nLooking at the HTML source code of the page, you can see that the content of the\ntwo pages is the same, and different content is rendered for different URLs.\n\nNext we add a simple navigation bar that allows the user to toggle between the\ntwo lists.\n\nOpen src/routes/layout.tsx and import the Radio component at the top:\n\n\n\nThen modify the top of the UI to add a set of radio group:\n\nexport default function Layout() {\n  return (\n    <div>\n      <div className=\"h-16 p-2 flex items-center justify-center\">\n        <Radio.Group onChange={handleSetList} value={currentList}>\n          <Radio value=\"/\">All</Radio>\n          <Radio value=\"/archives\">Archives</Radio>\n        </Radio.Group>\n      </div>\n      <Outlet />\n    </div>\n  );\n}\n\n\nThen we come to the implementation of currentList and handleSetList.\n\nIntroducing three React Hooks: useState and useNavigate and useParams, as well\nas Ant Design's event type definition:\n\n\n\n\n\n\nFinally, add local state and related logic to the Layout component:\n\nexport default function Layout() {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [currentList, setList] = useState(location.pathname || '/');\n  const handleSetList = (e: RadioChangeEvent) => {\n    const { value } = e.target;\n    setList(value);\n    navigate(value);\n  };\n  return (\n  ...\n}\n\n\nAt this point, the page navigation bar implementation has been completed, and\nexecute pnpm run dev to see the effect:\n\n\n\nClick Archives in the navigation bar, you can see that the selected state and\nURL of the radio box will change, the page is not refreshed, only CSR occurs.\n\nAccessing the two pages through the URL, you can see that the HTML content is\ndifferent, because the page executes the logic of client routing in the SSR\nstage, and the HTML already contains the final render result.","frontmatter":{"title":"Add Client Route"}},{"id":296,"title":"Add Loader","routePath":"/en/tutorials/first-app/c05-loader","lang":"en","toc":[],"domain":"","content":"\n\nIn the previous chapter, we learned how to add client route.\n\nIn this chapter, we will learn how to add Loader to the routing component.\n\nBy far, we have provided data to components through hardcoding. If you want to\nget data from the remote, you usually use useEffect to do it. But when SSR is\nenabled, useEffect will not be executed at the server level, so this SSR can\nonly render a very limited UI.\n\nModern.js provides the ability of Data Loader to support homogeneous data\nacquisition in components to maximize the value of SSR.\n\nBelow we demonstrate how to add Data Loader to the routing component and\nsimulate remote data acquisition. We use faker to mock the required data, first\ninstall dependency:\n\npnpm add faker@5\npnpm add @types/faker@5 -D\n\n\nCreate src/routes/page.loader.ts:\n\n\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport default async (): Promise<LoaderData> => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\n\nNOTE\n\nData Loader doesn't just work for SSR. In CSR projects, Data Loader can also\navoid data acquisition dependency UI rendering, which solves the problem of\nrequesting dynamic grid layout. In the future, Modern.js will also add more\ncapabilities to this feature, such as pre-fetching, data caching, etc.\n\nModern.js also provides a hooks API called useLoaderData, we modify the exported\ncomponent of src/routes/page.tsx:\n\n\n\nfunction Index() {\n  const { data } = useLoaderData() as LoaderData;\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      <List\n        dataSource={data}\n        renderItem={info => <Item key={info.name} info={info} />}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\n{/* Todo 重新截图，SSR 内容 */}\n\nRe-execute pnpm run dev, view view-source: http://localhost:8080/, or view the\n\"Preview\" of the HTML request in the Network panel of devtools, you can see that\nthe HTML rendered by SSR already contains the complete UI:\n\n","frontmatter":{"title":"Add Loader"}},{"id":297,"title":"Add Model","routePath":"/en/tutorials/first-app/c06-model","lang":"en","toc":[{"id":"model-implementation","text":"Model implementation","depth":2},{"id":"use-model","text":"Use Model","depth":2}],"domain":"","content":"\n\nIn the previous chapter, we changed the hardcoding mockData to load from Data\nLoader.\n\nIn this chapter, we will further implement the functions of the project, such as\nthe implementation of the function of the Archive button to put the point of\ncontact archive.\n\nTherefore, we will start to write some business logic that has nothing to do\nwith the UI at all. If we continue to write in the component code, more and more\nnoodle code will be generated. To this end, we introduced a code module called\nModel to decoupling these business logic and UI.\n\nnote\n\nTo use the Model API, you need to opt in runtime.state:\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: true,\n  },\n});\n\n\n\nModel implementation\n\nTo create a complete Model, you first need to define state, including the name\nand initial value of data in the state.\n\nWe use Model to manage the data of the point of contact list, so define the\nfollowing data state:\n\nconst state = {\n  items: [],\n};\n\n\nUsing TS syntax, you can define more complete type information, such as items in\neach object should have a name, email field. In order to implement archive\nfunction, also need to create the archived field to hold the point of contact\nhas been archived state.\n\nWe also need a field to access all archived points of contact. We can define a\nfield of type computed to convert the existing data:\n\nconst computed = {\n  archived: ({ items }) => {\n    return items.filter(item => item.archived);\n  },\n};\n\n\nFields of type computed are defined as function, but can be accessed through\nstate just like normal fields.\n\nINFO\n\nModern.js integrates Immer and can write such state transfer logic just like\nnormal mutable data in JS.\n\nWhen implementing the Archive button, we need an archive function, which is\nresponsible for modifying the archived field of the specified contact. We call\nthis function action:\n\nconst actions = {\n  archive(draft, payload) {\n    const target = draft.items.find(item => item.email === payload);\n    if (target) {\n      target.archived = true;\n    }\n  },\n};\n\n\nAn action function is a pure function, where a defined input gets a defined\noutput (a shifted state) and should not have any side effects.\n\nThe first parameter of the function is the Draft State provided by Immer, and\nthe second parameter is the parameter passed in when the action is called (more\non how to call it later).\n\nWe try to implement them completely:\n\nconst state = {\n  items: [],\n  pending: false,\n  error: null,\n};\n\nconst computed = {\n  archived: ({ items }) => {\n    return items.filter(item => item.archived);\n  },\n};\n\nconst actions = {\n  archive(draft, payload) {\n    const target = draft.items.find(item => item.email === payload);\n    if (target) {\n      target.archived = true;\n    }\n  },\n};\n\n\nNext we connect the above code and put it in the same Model file. First execute\nthe following command to create a new file directory:\n\nmkdir -p src/models/\ntouch src/models/contacts.ts\n\n\nAdd src/models/contacts.ts:\n\n\n\ntype State = {\n  items: {\n    avatar: string;\n    name: string;\n    email: string;\n    archived?: boolean;\n  }[];\n  pending: boolean;\n  error: null | Error;\n};\n\nexport default model<State>('contacts').define({\n  state: {\n    items: [],\n    pending: false,\n    error: null,\n  },\n  computed: {\n    archived: ({ items }: State) => items.filter(item => item.archived),\n  },\n  actions: {\n    archive(draft, payload) {\n      const target = draft.items.find(item => item.email === payload)!;\n      if (target) {\n        target.archived = true;\n      }\n    },\n  },\n});\n\n\nWe call a plain object containing elements such as state, action, etc. as Model\nSpec, Modern.js provides Model API, which can generate Model from Model Spec.\n\n\nUse Model\n\nNow let's use this Model directly to complement the logic of the project.\n\nFirst modify src/components/Item/index.tsx and add the UI and interaction of the\nArchive button, the content is as follows:\n\n\n\ntype InfoProps = {\n  avatar: string;\n  name: string;\n  email: string;\n  archived?: boolean;\n};\n\nconst Item = ({\n  info,\n  onArchive,\n}: {\n  info: InfoProps;\n  onArchive?: () => void;\n}) => {\n  const { avatar, name, email, archived } = info;\n  return (\n    <div className=\"flex p-4 items-center border-gray-200 border-b\">\n      <Avatar src={avatar} />\n      <div className=\"ml-4 custom-text-gray flex-1 flex justify-between\">\n        <div className=\"flex-1\">\n          <p>{name}</p>\n          <p>{email}</p>\n        </div>\n        <button\n          type=\"button\"\n          disabled={archived}\n          onClick={onArchive}\n          className={`text-white font-bold py-2 px-4 rounded-full ${\n            archived\n              ? 'bg-gray-400 cursor-default'\n              : 'bg-blue-500 hover:bg-blue-700'\n          }`}\n        >\n          {archived ? 'Archived' : 'Archive'}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Item;\n\n\nNext, we modify src/routes/page.tsx to pass more parameters to the <Item>\ncomponent:\n\n\n\n\n\n\n\n\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport const loader = async (): Promise<LoaderData> => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n      archived: false,\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\nfunction Index() {\n  const { data } = useLoaderData() as LoaderData;\n  const [{ items }, { archive, setItems }] = useModel(contacts);\n  if (items.length === 0) {\n    setItems(data);\n  }\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      <List\n        dataSource={items}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\nuseModel is the hooks API provided by the Modern.js. You can provide the state\ndefined in the Model in the component, or call the side effects and actions\ndefined in the Model through actions to change the state of the Model.\n\nModel is business logic, a computational process that does not create or hold\nstate itself. Only after being used by the component with the hooks API, the\nstate is created in the specified place.\n\nExecute pnpm run dev and click the Archive button to see that the page UI has\nchanged.\n\nNOTE\n\nIn the above example, useLoaderData is actually executed every time the route is\nswitched. Because we used fake data in the Data Loader, the data returned each\ntime is different. But we use the data in the Model first, so the data does not\nchange when switching routes.","frontmatter":{"title":"Add Model"}},{"id":298,"title":"Add Container","routePath":"/en/tutorials/first-app/c07-container","lang":"en","toc":[{"id":"use-the-full-model","text":"Use the full Model","depth":2},{"id":"withdraw-container-components","text":"Withdraw container components","depth":2}],"domain":"","content":"\n\nIn the previous chapter, we initially introduced the model to split this part of\nthe logic from the UI component. The page.tsx no longer contains UI-independent\nbusiness logic implementation details, and only needs to use the Model to\nimplement the same function.\n\nIn this chapter, we will further use the business logic of implementation in\nModel to let page.tsx and archived/page.tsx get the same data. And\nimplementation Archive button, click the button to display the point of contact\narchive only in the Archives list, not in the All list.\n\n\nUse the full Model\n\nBecause the two pages need to share the same set of state (point of contact\ntabular data, point of contact is archived or not), both need to contain the\nlogic to load the initial data, so we need to complete the data acquisition at a\nhigher level.\n\nModern.js support obtaining data through Data Loader in layout.tsx, we first\nmove the data acquisition part of the code to src/routes/layout.tsx:\n\n\nimport {\n  Outlet,\n  useLoaderData,\n  useLocation,\n  useNavigate,\n} from '@modern-js/runtime/router';\n\n\n\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\nimport '../styles/utils.css';\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport const loader = async (): Promise<LoaderData> => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\nexport default function Layout() {\n  const { data } = useLoaderData() as LoaderData;\n  const [{ items }, { setItems }] = useModel(contacts);\n  if (items.length === 0) {\n    setItems(data);\n  }\n\n  const navigate = useNavigate();\n  ...\n}\n\n\nIn src/routes/page.tsx, use Model directly to get data:\n\n\n\n\n\n\n\nfunction Index() {\n  const [{ items }, { archive }] = useModel(contacts);\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      <List\n        dataSource={items}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\nAlso in archived/page.tsx, delete the original mockData logic and use the\narchived value computed in Model as the data source:\n\n\n\n\n\n\n\nfunction Index() {\n  const [{ archived }, { archive }] = useModel(contacts);\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>Archives</title>\n      </Helmet>\n      <List\n        dataSource={archived}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\nExecute pnpm run dev, visit http://localhost:8080/, click the Archive button,\nyou can see the button grey out:\n\n\n\nNext, click the top navigation and switch to the Archives list. You can find\nthat the point of contact of Archive just now has appeared in the list:\n\n\n\n\nWithdraw container components\n\nIn the previous chapters, we split the business logic in the project into two\nlayers, one is the view component, and the other is the module. The former is\nresponsible for UI display, interaction, etc., and the latter is responsible for\nthe implementation of UI-independent business logic, which specializes in\nmanaging state.\n\nLike src/routes/page.tsx and src/routes/archives/page.tsx use the component of\nthe useModel API, which is responsible for linking the two layers of View and\nModel, similar to the role of the Controller in the traditional MVC\narchitecture. In the Modern.js, we follow the habit and call them Container.\n\nThe container component is recommended to be placed in a special containers/\ndirectory. We execute the following command to create a new file:\n\nmkdir -p src/containers\ntouch src/containers/Contacts.tsx\n\n\nmkdir -p src/containers\nni src/containers/Contacts.tsx\n\n\nWe extracted the common part of the original two page.tsx, and the code of\nsrc/containers/Contacts.tsx is as follows:\n\n\n\n\n\n\n\n\n\n\n\nfunction Contacts({\n  title,\n  source,\n}: {\n  title: string;\n  source: 'items' | 'archived';\n}) {\n  const [state, { archive }] = useModel(contacts);\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n      <List\n        dataSource={state[source]}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Contacts;\n\n\nModify the code for src/routes/page.tsx and src/routes/archives/page.tsx:\n\n\n\nfunction Index() {\n  return <Contacts title=\"All\" source=\"items\" />;\n}\n\nexport default Index;\n\n\n\n\nfunction Index() {\n  return <Contacts title=\"Archives\" source=\"archived\" />;\n}\n\nexport default Index;\n\n\nThe refactoring is complete, and the current project structure is:\n\n.\n├── README.md\n├── dist\n├── modern.config.ts\n├── node_modules\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── components\n│   │   ├── Avatar\n│   │   │   └── index.tsx\n│   │   └── Item\n│   │       └── index.tsx\n│   ├── containers\n│   │   └── Contacts.tsx\n│   ├── models\n│   │   └── contacts.ts\n│   ├── modern-app-env.d.ts\n│   ├── routes\n│   │   ├── archives\n│   │   │   └── page.tsx\n│   │   ├── layout.tsx\n│   │   └── page.tsx\n│   └── styles\n│       └── utils.css\n└── tsconfig.json\n\n\nThe view components in components/ dir are in the form of directories, such as\nAvatar/index.tsx. And the container components in containers/ dir are in the\nform of single files, such as contacts.tsx. This is a best practice we\nrecommend.\n\nAs mentioned in the chapter Add UI component, the view component is in the form\nof a directory, because the view component is responsible for the implementation\nof UI display and interaction details, and can evolve in complexity. In the form\nof a directory, it is convenient to add sub-files, including dedicated resources\n(pictures, etc.), dedicated sub-components, CSS files, etc. You can reconstruct\nat will within this directory, considering only the smallest parts.\n\nThe container component is only responsible for linkage and is a glue layer. The\nsophisticated business logic and implementation details are handed over to the\nView layer and the Model layer for implementation. The container component\nitself should be kept simple and clear, and should not contain complex\nimplementation details, so there should be no internal structure. The\nsingle-file form is not only more concise, but also acts as a constraint,\nreminding developers not to write complicated container components.","frontmatter":{"title":"Add Container"}},{"id":299,"title":"Add Application Entry","routePath":"/en/tutorials/first-app/c08-entries","lang":"en","toc":[{"id":"new-entry","text":"New entry","depth":2},{"id":"modify-the-configuration-by-entry","text":"Modify the configuration by entry","depth":2},{"id":"next-step","text":"Next step","depth":2}],"domain":"","content":"\n\nIn the last chapter, we basically completed the development of the point of\ncontact list application, introduced the usage of some functions in the\nModern.js, and recommended best practices.\n\nIn this chapter, we will describe how to add a new entry to the application.\n\n\nNew entry\n\nA complete project may require multiple entries, Modern.js supports the\nautomatic creation of new entries, as mentioned in the previous section, pnpm\nrun new can enable optional features.\n\nWe can also use it to create new project elements and execute pnpm run new in\nthe project root directory:\n\n? Action Create project element\n? Create project element New \"entry\"\n? Entry name (entry) landing-page\n\n\nWhen created, the project will look like this:\n\n.\n├── README.md\n├── modern.config.ts\n├── node_modules\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── modern-app-env.d.ts\n│   ├── landing-page\n│   │   └── routes\n│   │       ├── index.css\n│   │       ├── layout.tsx\n│   │       └── page.tsx\n│   └── myapp\n│       ├── components\n│       │   ├── Avatar\n│       │   │   └── index.tsx\n│       │   └── Item\n│       │       └── index.tsx\n│       ├── containers\n│       │   └── Contacts.tsx\n│       ├── models\n│       │   └── contacts.ts\n│       ├── routes\n│       │   ├── archives\n│       │   │   └── page.tsx\n│       │   ├── layout.tsx\n│       │   └── page.tsx\n│       └── styles\n│           └── utils.css\n└── tsconfig.json\n\n\nYou can see that the files of the contact list application are automatically\nrefactored into src/myapp/.\n\nAt the same time, a new src/landing-page/ is created, which also has routes/*\n(the pnpm run new command only does these things, so you can also easily create\nnew entries or modify entries manually).\n\nExecute pnpm run dev to display:\n\n\n\nAccess http://localhost:8080/ to see the application as before.\n\nVisit http://localhost:8080/landing-page to see the landing-page for the new\nentry you just created (Modern.js automatically generated default page).\n\nOne of the design principles of the Modern.js framework is [Convention over\nConfiguration ]. In most cases, you can write code directly by convention\nwithout any configuration. The directory structure in src/ is a convention:\n\nsrc/myapp/ and src/landing-page/ are automatically identified as two application\nportals: myapp and landing-page.\n\nThe directory name of src/myapp/ is the same as the project name (name in\npackage.json), which will be considered as the main entry of the project, and\nthe root path of the project URL (the default in the development environment is\nhttp://localhost:8080/) will automatically point to the main entry.\n\nThe URL of other entries is to append the entry name after the root path, such\nas http://localhost:8080/landing-page.\n\nNext, we rename src/myapp/ to src/contacts/:\n\nmv src/myapp src/contacts\n\n\nExecute pnpm run dev again, the result becomes:\n\n\n\nThere is no longer a main entry, the point of contact list is now a normal entry\nthat needs to be accessed with http://localhost:8080/contacts.\n\n\nModify the configuration by entry\n\nIn the Modern.js configuration file, we can write our own code to control the\nconfiguration of the project.\n\nNow, modify the modern.config.ts to add something:\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n    ssrByEntries: {\n      'landing-page': false,\n    },\n  },\n  plugins: [appTools(), tailwindcssPlugin()],\n});\n\n\nExecute pnpm run dev, and then open view-source:\nhttp://localhost:8080/landing-page with the browser, you can see that the\ncontent of the landing-page web page is dynamically loaded through js, and the\nSSR function of this page is turned off.\n\nIf ssrByEntries and its value are annotated, the SSR function of landing-page is\nrestored.\n\nOther times, you need some more sophisticated logic to do the setup, such as JS\nvariables, expressions, import modules, etc., for example, only in the\ndevelopment environment to enable SSR:\n\nexport default defineConfig({\n  server: {\n    ssrByEntries: {\n      'landing-page': process.env.NODE_ENV !== 'production',\n    },\n  },\n};\n\n\nSo far, the prototype of our point of contact list application is almost\ncomplete 👏👏👏.\n\n\nNext step\n\nThen you can further refine your application by following more tutorials like\nGuides, configuration, and more.","frontmatter":{"title":"Add Application Entry"}},{"id":300,"title":"Introduction","routePath":"/en/tutorials/foundations/introduction","lang":"en","toc":[{"id":"what-is-modernjs","text":"What is Modern.js?","depth":2},{"id":"tutorial","text":"Tutorial","depth":2}],"domain":"","content":"\n\nWelcome to Modern.js tutorials!\n\nAfter reading this section, you will have an initial understanding of Modern.js\nand use Modern.js to create your first application.\n\n\nWhat is Modern.js?\n\nIf you don't know Modern.js yet, please can read Modern.js Introduction first.\n\n\nTutorial\n\nWe have prepared a tutorial on creating a \"contact list app\" that you can follow\nstep by step to create an app and learn about the following practices in\nModern.js:\n\n * Creating a project\n * Using the antd component library\n * Integrating Tailwind CSS\n * Client-side routing\n * Data fetching\n * State Management\n * Container components\n * New portal\n * ...\n\nTranslated with www.DeepL.com/Translator (free version)","frontmatter":{"title":"Introduction","sidebar_position":1}},{"id":301,"title":"build","routePath":"/apis/app/commands/build","lang":"zh","toc":[{"id":"分析构建产物体积","text":"分析构建产物体积","depth":2}],"domain":"","content":"\n\nUsage: modern build [options]\n\nbuild application\n\nOptions:\n  -c --config <config>  指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help  显示命令帮助\n  --analyze   分析构建产物体积，查看各个模块打包后的大小\n\n\nmodern build 命令默认会在 dist/ 目录下构建出可用于生产环境的产物。\n\n可以通过修改配置 output.distPath 指定产物的输出目录。\n\n\n分析构建产物体积\n\n执行 npx modern build --analyze 命令，可以在打包生产环境代码的同时，产出一个分析构建产物体积的 HTML 文件：\n\nBundle Analyzer saved report to /example/dist/report.html\nFile sizes after production build:\n\n  122.35 KB  dist/static/js/885.1d4fbe5a.js\n  2.3 KB     dist/static/js/main.4b8e8d64.js\n  761 B      dist/static/js/runtime-main.edb7cf35.js\n  645 B      dist/static/css/main.0dd3ecc1.css\n\n\n手动在浏览器中打开上述 HTML 文件，可以看到打包产物的瓦片图，并进行包体积分析和优化：\n\n> 该功能基于 webpack-bundle-analyzer 实现。","frontmatter":{"sidebar_position":5}},{"id":302,"title":"dev / start","routePath":"/apis/app/commands/dev","lang":"zh","toc":[{"id":"编译部分页面","text":"编译部分页面","depth":2},{"id":"通过参数指定页面","text":"通过参数指定页面","depth":3}],"domain":"","content":"\n\nUsage: modern dev / modern start [options]\n\n本地开发命令\n\nOptions:\n  -e --entry <entry>    指定入口，只编译特定的页面\n  -c --config <config>  指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n  --analyze             分析构建产物体积，查看各个模块打包后的大小\n  --api-only            仅启动 API 接口服务\n\n\nmodern dev 命令用于启动一个本地开发服务器，对源代码进行开发环境编译，同时监听源文件变化，默认支持模块热更新和 React Fast Refresh。\n\nmodern start 是 modern dev 命令的别名，两者的功能和用法完全一致。\n\n$ modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n\n编译部分页面\n\n在多页面（MPA）项目中，可以添加 --entry 参数来指定编译其中的一个或多个页面。这样可以只编译项目中的部分代码，从而提升 dev 启动速度。\n\n比如执行 modern dev --entry，在命令行界面中会展示入口选择框：\n\n$ modern dev --entry\n\n? 请选择需要构建的入口\n❯ ◯ foo\n  ◯ bar\n  ◯ baz\n\n\n比如选择 foo 入口，那么只有 foo 入口相关的代码会进行编译，其他页面的代码将不会参与构建。\n\n\n通过参数指定页面\n\n你也可以在 --entry 后面通过参数来指定页面名称，多个页面的名称使用逗号分隔。\n\n# 编译 foo 页面\nmodern dev --entry foo\n\n# 编译 foo 和 bar 页面\nmodern dev --entry foo,bar\n","frontmatter":{"sidebar_position":1}},{"id":303,"title":"inspect","routePath":"/apis/app/commands/inspect","lang":"zh","toc":[{"id":"指定环境","text":"指定环境","depth":2},{"id":"完整内容","text":"完整内容","depth":2},{"id":"ssr-构建配置","text":"SSR 构建配置","depth":2}],"domain":"","content":"\n\nUsage: modern inspect [options]\n\nOptions:\n  --env <env>           查看指定环境下的配置 (default: \"development\")\n  --output <output>     指定在 dist 目录下输出的路径 (default: \"/\")\n  --verbose             在结果中展示函数的完整内容\n  -c --config <config>  指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n\n\nmodern inspect 命令，用于查看项目的 Modern.js Builder 配置 以及 webpack 配置。\n\n在项目根目录下执行命令 npx modern inspect 后，会在项目的 dist 目录生成以下文件：\n\n * builder.config.js: 表示在构建时使用的 Modern.js Builder 配置。\n * webpack.config.web.js: 表示在构建时使用的 webpack 配置。\n\n➜ npx modern inspect\n\nInspect config succeed, open following files to view the content:\n\n  - Builder Config: /root/my-project/dist/builder.config.js\n  - Webpack Config (web): /root/my-project/dist/webpack.config.web.js\n\n\n\n指定环境\n\n默认情况下，inspect 命令会输出开发环境的配置，你可以添加 --env production 选项来输出生产环境的配置：\n\nmodern inspect --env production\n\n\n\n完整内容\n\n默认情况下，inspect 命令会省略配置对象中的函数内容，你可以添加 --verbose 选项来输出函数的完整内容：\n\nmodern inspect --verbose\n\n\n\nSSR 构建配置\n\n如果项目开启了 SSR 能力，则在 dist 目录会另外生成一份 webpack.config.node.js 文件，对应 SSR 构建时的 webpack\n配置。\n\n➜ npx modern inspect\n\nInspect config succeed, open following files to view the content:\n\n  - Builder Config: /root/my-project/dist/builder.config.js\n  - Webpack Config (web): /root/my-project/dist/webpack.config.web.js\n  - Webpack Config (node): /root/my-project/dist/webpack.config.node.js\n","frontmatter":{"sidebar_position":7}},{"id":304,"title":"lint","routePath":"/apis/app/commands/lint","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern lint [options] [...files]\n\nlint and fix source files\n\nOptions:\n  --no-fix    disable auto fix source file\n  -h, --help  display help for command\n\n\n运行 ESLint 检查代码语法情况。通常情况下，我们只需要在 git commit 阶段通过 lint-staged 检查本次提交修改的部分代码。\n\n * --no-fix 参数设置后可以关闭自动修复 lint 错误代码的能力。","frontmatter":{"sidebar_position":4,"title":"lint"}},{"id":305,"title":"new","routePath":"/apis/app/commands/new","lang":"zh","toc":[{"id":"添加入口","text":"添加入口","depth":3},{"id":"启用可选功能","text":"启用可选功能","depth":3}],"domain":"","content":"\n\nUsage: modern new [options]\n\n应用工程中执行生成器\n\nOptions:\n  -d, --debug            开启 Debug 模式，打印调试日志信息 (default: false)\n  -c, --config <config>  生成器运行默认配置(JSON 字符串)\n  --dist-tag <tag>       生成器使用特殊的 npm Tag 版本\n  --registry             生成器运行过程中定制 npm Registry\n  -h, --help             显示命令帮助\n\n\nmodern new 命令用于在已有项目中添加项目元素。\n\n比如添加应用入口、启用启用一些可选功能如 Tailwind CSS、微前端开发模式等。\n\n\n添加入口\n\n在应用工程中，执行 new 命令添加入口如下：\n\n$ npx modern new\n? 请选择你想要的操作 创建工程元素\n? 创建工程元素 新建「应用入口」\n? 请填写入口名称 entry\n\n\n\n启用可选功能\n\n在应用工程中，执行 new 命令启用可选能力如下：\n\n$ npx modern new\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 (Use arrow keys)\n❯ 启用 Tailwind CSS 支持\n  启用「BFF」功能\n  启用「微前端」模式\n  启用「单元测试 / 集成测试」功能\n  启用「Visual Testing (Storybook)」模式\n\n\n注意\n\n--config 参数对应参数值需要使用 JSON 字符串。\n\npnpm 暂不支持使用 JSON 字符串作为参数值，可使用 npm new 开启相关功能。【相关 Issue】","frontmatter":{"sidebar_position":2}},{"id":306,"title":"serve","routePath":"/apis/app/commands/serve","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern serve [options]\n\nrun server\n\nOptions:\n  -c --config <config>  指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n  --api-only            仅启动 API 接口服务\n\n\n通常使用 modern serve 命令在生产环境下启用应用工程, 需要提前执行 build 命令构建出对应产物。\n\n默认情况下，应用将会在 localhost:8080 启动，可以通过 server.port 修改 Server 端口号：\n\nexport default defineConfig({\n  server: {\n    port: 8081,\n  },\n});\n","frontmatter":{"sidebar_position":6}},{"id":307,"title":"test","routePath":"/apis/app/commands/test","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern test [options]\n\nOptions:\n  -h, --help  显示命令帮助\n\n\n注意\n\nmodern test 命令需要先通过 new 命令启用「单元测试 / 集成测试」功能\n\nmodern test 命令会自动运行项目下的测试用例，效果如下：\n\n$ npx modern test\n PASS  src/tests/index.test.ts\n  The add method\n    ✓ should work fine. (2ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.994 s, estimated 1 s\n\n\nINFO\n\nsrc 和 api 目录下面 *.test.(js|ts) 都会默认识别为测试用例。","frontmatter":{"sidebar_position":3}},{"id":308,"title":"upgrade","routePath":"/apis/app/commands/upgrade","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern upgrade [options]\n\n升级 Modern.js 到最新版本\n\nOptions:\n  --registry <registry>  定制 npm registry (default: \"\")\n  -d,--debug             开启 Debug 模式，打印调试日志信息 (default: false)\n  --cwd <cwd>            项目路径 (default: \"\")\n  -h, --help             display help for command\n\n\n在项目根目录下执行命令 npx modern upgrade，会默认将当前执行命令项目的 package.json 中的 Modern.js\n相关依赖更新至最新版本。","frontmatter":{"sidebar_position":8}},{"id":309,"title":"lambda/*.[tj]s","routePath":"/apis/app/hooks/api/framework/lambda","lang":"zh","toc":[{"id":"路由规则","text":"路由规则","depth":2},{"id":"默认路由","text":"默认路由","depth":3},{"id":"多级路由","text":"多级路由","depth":3},{"id":"动态路由","text":"动态路由","depth":3},{"id":"白名单","text":"白名单","depth":3},{"id":"函数定义","text":"函数定义","depth":2}],"domain":"","content":"\n\n在 BFF 框架写法下，声明 API 路由的文件。除了某些约定文件外，api/ 目录下的文件会被注册为接口的路由。\n\nINFO\n\n使用 api 目录需要开启 BFF 功能，需要在项目下执行 new 命令启用「BFF」功能。\n\nTIP\n\n该文件支持使用 js 或 ts 语言，但必须使用 esm 语法导出函数。\n\n\n路由规则\n\n\n默认路由\n\n路由系统会将以 index 命名的文件会被映射到上一层目录。\n\n * api/lambda/index.ts -> $BASENAME/\n * api/lambda/user/index.ts -> $BASENAME/user\n\n\n多级路由\n\n路由系统也支持解析多级的文件，如果创建文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/lambda/hello.ts -> $BASENAME/hello\n * api/lambda/user/list.ts -> $BASENAME/user/list\n\n\n动态路由\n\n同样的，你可以通过创建带有 [xxx] 的文件夹或者文件来支持动态的命名路由参数。\n\n * api/lambda/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/lambda/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/lambda/article/[id]/info.ts -> $BASENAME/article/:id/info\n\n其中的 $BASENAME 可以在 modern.config.js 中进行配置，默认值为 /api。\n\n\n白名单\n\n默认 api 目录下所有文件都会当作 BFF 函数文件去解析，但同样我们也设置了白名单，这些文件不被被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\n函数定义\n\n和函数写法下函数定义完全一致。","frontmatter":{"title":"lambda/*.[tj]s","sidebar_position":1}},{"id":310,"title":"**/*.[tj]s","routePath":"/apis/app/hooks/api/functions/api","lang":"zh","toc":[{"id":"该文件约定路由如下","text":"该文件约定路由如下：","depth":2},{"id":"默认路由","text":"默认路由","depth":3},{"id":"嵌套路由","text":"嵌套路由","depth":3},{"id":"动态路由","text":"动态路由","depth":3},{"id":"白名单","text":"白名单","depth":3},{"id":"函数定义","text":"函数定义","depth":2}],"domain":"","content":"\n\n在 BFF 函数写法下，声明 API 路由的文件。除了某些约定文件外，api 目录下的文件会被注册为接口的路由。\n\nINFO\n\n使用 api 目录需要开启 BFF 功能，需要在项目下执行 new 命令启用「BFF」功能。\n\n该文件支持使用 js 或 ts 语言，但必须使用 esm 语法导出函数。\n\n\n该文件约定路由如下：\n\n\n默认路由\n\n路由系统会将以 index 命名的文件会被映射到上一层目录。\n\n * api/index.ts -> $BASENAME/\n * api/user/index.ts -> $BASENAME/user\n\n\n嵌套路由\n\n路由系统也支持解析嵌套的文件，如果创建嵌套文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/hello.ts -> $BASENAME/hello\n * api/user/list.ts -> $BASENAME/user/list\n\n\n动态路由\n\n同样的，你可以通过创建带有 [xxx] 的文件夹或者文件来支持动态的命名路由参数。\n\n * api/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/article/[id]/info.ts -> $BASENAME/article/:id/info\n\n其中的 $BASENAME 可以在 modern.config.js 中进行配置，默认值为 /api。\n\n\n白名单\n\n默认 api 目录下所有文件都会当作 BFF 函数文件去解析，但同样我们也设置了白名单，这些文件不被被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\n函数定义\n\n除了上面的路由规则之外，代码中函数定义与导出也有相应的约定。\n\n函数通过具名导出，导出函数的名字为对应接口接受的 HTTP Method，即：\n\nexport const get = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n这样导出函数，则会得到一个 POST 接口。\n\n应用工程中支持了 9 个 Method\n定义，即：GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTION、HEAD，即可以用这些 Method\n作为函数导出的名字。\n\n名字是大小不敏感的，就是说，如果是 GET，写成 get、Get、GEt、GET，都可以准确识别。而默认导出，即 export default xxx\n则会被映射为 Get。\n\n因为 delete 是 JavaScript 中的关键字，可以使用 del 或者 DELETE 代替。\n\n可以在一个文件中定义多个不同 Method 的函数，但如果定义多个相同 Method 的函数，则只有第一个会生效。\n\nINFO\n\n需要注意的是，定义的函数都应该是异步的，这个与函数调用时类型有关，这个后面会提到。","frontmatter":{"title":"**/*.[tj]s","sidebar_position":1}},{"id":311,"title":"_app.[tj]s","routePath":"/apis/app/hooks/api/functions/app","lang":"zh","toc":[],"domain":"","content":"\n\n在函数写法下，该文件可以为 BFF 函数添加前置中间件。\n\nNOTE\n\n具体示例请参考 hook","frontmatter":{"title":"_app.[tj]s","sidebar_position":3}},{"id":312,"title":"**/_*.[tj]s, _*/**","routePath":"/apis/app/hooks/api/functions/common","lang":"zh","toc":[],"domain":"","content":"/_.[tj]s, _/\n\n在 BFF 函数写法下，这些文件不会注册为路由。\n\n你可以在这种目录或文件下放任意项目中需要的代码，文件等。","frontmatter":{"title":"**/_*.[tj]s, _*/**","sidebar_position":2}},{"id":313,"title":"test.[tj]s","routePath":"/apis/app/hooks/api/test","lang":"zh","toc":[],"domain":"","content":"\n\n应用的 BFF 测试文件，支持在 api/ 目录后缀为 .test.[tj]sx? 的文件中编写测试用例。\n\nINFO\n\n使用单元测试、集成测试需要提前在项目下执行 new 命令启用「单元测试 / 集成测试」功能。","frontmatter":{"title":"test.[tj]s","sidebar_position":2}},{"id":314,"title":"html/","routePath":"/apis/app/hooks/config/html","lang":"zh","toc":[],"domain":"","content":"\n\n通过 config/html 目录可以在内部默认 html 模板的不同位置注入自定义的 html 片段。\n\n具体使用方式请参考: 自定义 HTML","frontmatter":{"title":"html/","sidebar_position":1}},{"id":315,"title":"icon.png","routePath":"/apis/app/hooks/config/icon","lang":"zh","toc":[],"domain":"","content":"\n\n应用工程方案 App Icon 文件。\n\n项目根目录下 config/icon.png 时，可以在构建时向 html 页面注入 app icon 信息：\n\n./config\n└── icon.png\n\n\n最终 html 中会注入 app icon link 标签, 如下:\n\n","frontmatter":{"title":"icon.png","sidebar_position":2}},{"id":316,"title":"mock/","routePath":"/apis/app/hooks/config/mock","lang":"zh","toc":[],"domain":"","content":"\n\n项目根目录下存在 config/mock/index.js 时，在开发环节自动开启 Mock 服务。","frontmatter":{"title":"mock/","sidebar_position":5}},{"id":317,"title":"public/","routePath":"/apis/app/hooks/config/public","lang":"zh","toc":[{"id":"说明","text":"说明","depth":2},{"id":"场景","text":"场景","depth":2},{"id":"代码压缩","text":"代码压缩","depth":2}],"domain":"","content":"\n\npublic/ 目录中可以放置任意格式的静态资源文件，文件会被 Serve 在 Web 应用域名下。\n\n\n说明\n\n被 Serve 的文件路由基于目录结构的约定，其中，public/ 为根目录，对应 Web 应用根路径。\n\n例如 config/public/sdk/index.js 文件，在部署后将会被 Serve 在 ${domain}/sdk/index.js 下。\n\n\n场景\n\n例如 robots.txt，auth.xml 等第三方系统需要的认证文件。\n\n或者是给其他业务方（要求路由不变）的 SDK，也可以是无需入口的 HTML 文件等。\n\nINFO\n\n对于需要在源码中通过 import 引用的静态资源（比如 SVG 图片），建议放到 src/assets 目录下进行管理。\n\n\n代码压缩\n\n如果目录下的文件是一个 .js 文件，在生产环境构建时，会自动对其进行代码压缩。\n\n如果该文件以 .min.js 结尾，则不会经过代码压缩处理。","frontmatter":{"title":"public/","sidebar_position":3}},{"id":318,"title":"storybook/","routePath":"/apis/app/hooks/config/storybook","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 支持使用 Storybook 进行调试，当需要对 Storybook 进行配置时，需要在项目 config/storybook\n目录进行配置。\n\nStorybook 配置请查看：Storybook 配置\n\nINFO\n\n使用 Storybook 进行调试需要提前在项目下执行 new 命令启用「Visual Testing (Storybook)」模式功能。","frontmatter":{"title":"storybook/","sidebar_position":7}},{"id":319,"title":"upload/","routePath":"/apis/app/hooks/config/upload","lang":"zh","toc":[{"id":"说明","text":"说明","depth":2},{"id":"场景","text":"场景","depth":2},{"id":"代码压缩","text":"代码压缩","depth":2},{"id":"更多用法","text":"更多用法","depth":2}],"domain":"","content":"\n\nupload/ 目录中可以放置任意格式的静态资源文件。\n\n\n说明\n\n在开发环境下，该目录下的静态资源文件会被托管在 /upload 路径下。构建应用产物后，该目录下的文件会被复制到产物目录中。\n\n该文件约定主要用于开发者使用插件，主动上传静态资源文件到 CDN。\n\n\n场景\n\n例如 google-analysis.js 等项目自用的 SDK（通常需要 http 缓存）。\n\n图片、字体文件、通用 CSS 等。\n\n\n代码压缩\n\n如果目录下的文件是一个 .js 文件，在生产环境构建时，会自动对其进行代码压缩。\n\n如果该文件以 .min.js 结尾，则不会经过代码压缩处理。\n\n\n更多用法\n\n不论是在自定义 HTML 中，或是在 config/public/ 下的任意 HTML 文件中，都可以直接使用 HTML 标签引用 config/upload/\n目录下的资源：\n\n<script src=\"/upload/index.js\"></script>\n\n\n如果设置了 output.assetPrefix 前缀，也可以直接使用模板语法添加该前缀：\n\n<script src=\"<%=assetPrefix %>/upload/index.js\"></script>\n\n\nINFO\n\nModern.js 没有支持在 config/public/*.css（例如 background-image）中通过 URL 使用\nconfig/upload/ 下的文件。","frontmatter":{"title":"upload/","sidebar_position":4}},{"id":320,"title":"modern.config.js","routePath":"/apis/app/hooks/modern-config","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 配置文件, 通过该文件可以对当前项目的各个方面进行个性化配置。\n\n了解配置的具体用法，请参考 配置使用。","frontmatter":{"title":"modern.config.js","sidebar_position":8}},{"id":321,"title":"index.[tj]s","routePath":"/apis/app/hooks/server/index_","lang":"zh","toc":[],"domain":"","content":"\n\n扩展 Modern.js Web Server 的文件，在此文件中可以给应用工程启动的 Web Server 添加 Hook 或 Middleware。\n\n可以对请求和响应进行拦截处理，鉴权与角色、请求预处理、异常兜底等。也可在内置处理逻辑（包括路由匹配、资源寻址、头部注入、页面渲染，静态 Web\n托管）插入特定的业务逻辑。\n\nINFO\n\n具体使用示例可查看 Hook & Middleware。","frontmatter":{"title":"index.[tj]s","sidebar_position":1}},{"id":322,"title":"test.[tj]s","routePath":"/apis/app/hooks/server/test","lang":"zh","toc":[],"domain":"","content":"\n\n自定义 Web Server 测试目录。\n\n应用支持对自定义 Web Server 逻辑进行测试，可直接在项目 server/ 目录下创建后缀为 .test.[tj]s 文件进行编写测试用例。\n\nINFO\n\n使用单元测试、集成测试需要提前在项目下执行 new 命令启用「单元测试 / 集成测试」功能。","frontmatter":{"title":"test.[tj]s","sidebar_position":2}},{"id":323,"title":"shared/","routePath":"/apis/app/hooks/shared","lang":"zh","toc":[],"domain":"","content":"\n\n共享源码目录。当项目在 api/、server/、src/ 下有公共代码时，可将这些代码放到 shared 目录下，而不是直接引用。","frontmatter":{"title":"shared/","sidebar_position":5}},{"id":324,"title":"App.[tj]sx","routePath":"/apis/app/hooks/src/app","lang":"zh","toc":[],"domain":"","content":"\n\n应用使用自控路由时的入口标识符。\n\nApp.[tj]sx 并不是实际的应用入口，Modern.js 会自动生成真正的构建打包的入口文件, 内容大致如下：\n\n\n\n// App.[jt]sx\n\n\nimport {\n  immer,\n  effects,\n  autoActions,\n  devtools,\n} from '@modern-js/runtime/model';\n\nconst createStatePlugins = config => {\n  const plugins = [];\n  plugins.push(immer(config['immer']));\n  plugins.push(effects(config['effects']));\n  plugins.push(autoActions(config['autoActions']));\n  plugins.push(devtools(config['devtools']));\n  return plugins;\n};\nlet AppWrapper = null;\nfunction render() {\n  AppWrapper = createApp({\n    plugins: [\n      state({\n        ...{ plugins: createStatePlugins(true) },\n        ...App?.config?.state,\n      }),\n    ],\n  })(App);\n  if (IS_BROWSER) {\n    bootstrap(AppWrapper, MOUNT_ID);\n  }\n  return AppWrapper;\n}\nAppWrapper = render();\nexport default AppWrapper;\n\n\nNOTE\n\n在多入口的场景下，每个入口都可以拥有独立的 App.[jt]sx，详见入口。","frontmatter":{"title":"App.[tj]sx","sidebar_position":1}},{"id":325,"title":"index.[tj]s","routePath":"/apis/app/hooks/src/index_","lang":"zh","toc":[],"domain":"","content":"\n\n应用项目自定义路由入口标识。\n\n通常情况下 src/App.[tj]sx, src/[entry]/App.[tj]sx 钩子文件已经能满足我们的需求，当我们需要在 bootstrap\n之前添加自定义行为或者完全接管 webpack 打包入口时，可以在 src 或者入口目录下放置 index.[tj]s。 下面有分两种情况进行讨论:\n\n 1. 在 bootstrap 之前添加自定义行为：\n\n只需要 src/index.[tj]s 默认导出函数:\n\n\n\n\nexport default (App: React.ComponentType) => {\n  // do something before bootstrap...\n  bootstrap(App, 'root', undefined, ReactDOM);\n};\n\n\n 2. 完全接管 webpack 入口:\n\n当 src/index.[tj]sx? 下没有默认导出函数时，该文件即为真正的 webpack 打包入口文件, 可以直接像使用 create-react-app\n等脚手架一样组织代码:\n\n\n\n\n\nReactDOM.createRoot(document.getElementById('root')!).render(<App />);\n","frontmatter":{"title":"index.[tj]s","sidebar_position":4}},{"id":326,"title":"pages/","routePath":"/apis/app/hooks/src/pages","lang":"zh","toc":[{"id":"动态路由","text":"动态路由","depth":3},{"id":"全局-layout","text":"全局 layout","depth":3},{"id":"部分-layout","text":"部分 layout","depth":3},{"id":"404-路由","text":"404 路由","depth":3}],"domain":"","content":"\n\n应用使用基于文件系统路由时的入口标识。\n\n当项目结构为 Pages 入口 类型时， 会分析 src/pages 目录下的文件得到客户端路由配置。\n\n举例说明，例如以下目录结构：\n\n.\n└── src\n    └── pages\n        ├── about\n        │   └── index.jsx\n        ├── index.jsx\n        └── info.jsx\n\n\n对应生成的路由配置为:\n\n[\n  { path: '/', component: 'pages/index.jsx' },\n  { path: '/info' component: 'pages/info.jsx' },\n  { path: '/about', component: 'pages/about/index.jsx' }\n]\n\n\npages 目录下的文件满足以下条件的不会被当做路由文件\n\n * 后缀不是 .(j|t)sx? 的文件。\n * .d.ts 类型定义文件。\n * 以 .(test|spec|e2e).(j|t)sx? 结尾的测试文件。\n\n提示\n\n推荐 pages 目录下只写入口代码，把业务逻辑写到 pages 外面独立的 features 目录里。这样 pages\n目录下大部分文件都会是路由文件，也就不需要额外的过滤规则。\n\n\n动态路由\n\n使用 [ ] 包裹的目录或文件会被视为动态路由\n\n例如以下目录结构:\n\n.\n└── src\n    └── pages\n        ├── [post]\n        │   ├── detail.jsx\n        │   └── index.js\n        ├── users\n        │   └── [id].jsx\n        ├── index.jsx\n        └── info.jsx\n\n\n对应生成的路由配置为:\n\n[\n  { path: '/', component: 'pages/index.jsx' },\n  { path: '/info', component: 'pages/info.jsx' },\n  { path: '/:post/', component: 'pages/[post]/index.js' },\n  { path: '/:post/detail' components: 'pages/[post]/detail.jsx'},\n  { path: '/users/:id', components: 'pages/users/[id].jsx'}\n]\n\n\n动态路由的基础上，支持添加特殊的路由后缀 (*、?、+)。\n\n例如：src/pages/users/[id]*.tsx 最终路由为 /users/:id*\n\n\n全局 layout\n\n整个应用需要全局的 layout 时， 可以通过 pages/_app.tsx 实现，具体写法如下:\n\n\n\n\nexport default const App = ({Component, ...pageProps}:{ Component: React.ComponentType}) => {\n  return (\n    <UserLayout>\n      <Component {...pageProps} />\n    </UserLayout>\n  );\n}\n\n\n上述 Component 为访问具体路由匹配到的组件。\n\n例如以下目录结构:\n\n.\n└── pages\n    ├── a\n    │   ├── b\n    │   │   └── index.js\n    │   └── index.js\n    └── index.js\n\n\n * 访问 / 时，对应的 Component 组件为 pages/index.js。\n * 访问 /a 时，对应的 Component 组件为 pages/a/index.js。\n * 访问 /a/b 时，对应的 Component 组件为 pages/a/b/index.js。\n\n全局 layout 有以下优点\n\n * 页面变化时，保留全局布局的状态\n * 添加全局样式\n * ComponentDidCatch 错误处理\n * 使用 defineConfig(/docs/apis/app/runtime/app/define-config) 动态配置运行时配置。\n\n\n部分 layout\n\n开发应用时，存在同一路由下的子路由共用 layout 的场景。\n\n针对这一场景，Modern.js 约定，当目录下存在 _layout.js ，就会有类似全局 layout 的效果。\n\n例如以下目录结构:\n\n└── pages\n    ├── a\n    │   ├── b\n    │   │   └── index.js\n    │   ├── _layout.js\n    │   └── index.js\n    └── index.js\n\n\n\n\nconst ALayout = ({ Component, ...pageProps }) => {\n  return <Component {...pageProps} />;\n};\nexport default ALayout;\n\n\nComponent 参数为访问具体路由对应的组件，例如\n\n * 访问 /a 时，对应的 Component 组件为 pages/a/index.js。\n * 访问 /a/b 时，对应的 Component 组件为 pages/a/b/index.js。\n\n这样就可以用 pages/a/_layout.js 满足 a 目录下路由共用 layout 的需求。\n\n\n404 路由\n\n约定 pages/404.[tj]sx 为默认的 404 路由。\n\n例如以下目录结构:\n\n.\n└── src\n    └── pages\n        ├── user.js\n        ├── home.js\n        ├── 404.js\n\n\n生成路由配置如下:\n\n[\n { path: '/user', component: './pages/user.js'},\n { path: '/home', component: './pages/home.js' },\n { path: '*', component: './pages/404.js'}\n]\n\n\n所有未匹配的路由，都将匹配到 pages/404.[tj]s。","frontmatter":{"title":"pages/","sidebar_position":3}},{"id":327,"title":"routes/","routePath":"/apis/app/hooks/src/routes","lang":"zh","toc":[{"id":"基本示例","text":"基本示例","depth":2},{"id":"动态路由","text":"动态路由","depth":2},{"id":"布局组件","text":"布局组件","depth":2}],"domain":"","content":"\n\n应用使用基于文件系统路由时的入口标识。\n\n当项目结构为 Routes 入口 类型时， 会分析 src/routes 目录下的文件得到客户端路由配置。具体用法请查看约定式路由\n\n任何在 src/routes 下的 layout.[tj]sx 和 page.[tj]sx 都会作为应用的路由：\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n\n基本示例\n\nroutes 目录下的目录名会作为路由 url 的映射，其中 layout.tsx 中作为布局组件，page.tsx\n作为内容组件，是整条路由的叶子节点，例如以下目录结构：\n\n.\n└── routes\n    ├── page.tsx\n    └── user\n        └── page.tsx\n\n\n会产出下面两条路由：\n\n * /\n * /user\n\n\n动态路由\n\n如果路由文件的目录名以 [] 命名，生成的路由会作为动态路由。例如以下文件目录：\n\n└── routes\n    ├── [id]\n    │   └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nroutes/[id]/page.tsx 文件会转为 /:id 路由。除了可以确切匹配的 /blog 路由，其他所有 /xxx 都会匹配到该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在 loader 中，params 会作为 loader 的入参，通过 params 的属性可以获取到对应的参数。\n\n\n布局组件\n\n如下面的例子，可以通过添加 layout.tsx，为所有路由组件添加公共的布局组件：\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n在布局组件中可以通过使用 <Outlet> 表示子组件：\n\n\n\nexport default () => {\n  return (\n    <>\n      <Outlet></Outlet>\n    </>\n  );\n};\n\n\nNOTE\n\n<Outlet> 是 React Router 6 中新的 API，详情可以查看 Outlet.","frontmatter":{"title":"routes/","sidebar_position":2}},{"id":328,"title":"*.[server|node].[tj]sx","routePath":"/apis/app/hooks/src/server","lang":"zh","toc":[],"domain":"","content":"\n\n应用项目中使用，用于放置服务端代码，一般有以下两个作用：\n\n 1. 当 *.tsx 和 *.[server|node].tsx 共存时，SSR 在服务端执行渲染时，会优先使用 *.[server|node].tsx\n    文件，而不是 *.tsx 文件。\n\n 2. 在使用 data loader 时，需要将服务端的依赖从该文件中做重导出\n\n// routes/user/avatar.tsx\n\n\n\ntype ProfileData = {\n  /* some type declarations */\n};\n\nexport const loader = async (): ProfileData => {\n  const profile = await readFile('profile.json');\n  return profile;\n};\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return <div>{profileData}</div>;\n}\n\n// routes/user/utils.server.ts\nexport * from 'fs-extra';\n","frontmatter":{"title":"*.[server|node].[tj]sx","sidebar_position":8}},{"id":329,"title":"**/*.stories.[tj]sx","routePath":"/apis/app/hooks/src/stories","lang":"zh","toc":[],"domain":"","content":"\n\n应用项目 Storybook 调试文件。\n\n可以在项目源码目录 src/ 下创建 *.stories.[tj]sx 格式的文件作为 Storybook 的调试文件。\n\n在项目下执行 dev story 命令，支持使用这些文件在 Storybook 中对相关内容进行调试。\n\nINFO\n\n使用 Storybook 需要提前在项目下执行 new 命令启用「Visual Testing (Storybook)」模式。","frontmatter":{"title":"**/*.stories.[tj]sx","sidebar_position":7}},{"id":330,"title":"**/*.test.[tj]sx?","routePath":"/apis/app/hooks/src/test","lang":"zh","toc":[],"domain":"","content":"\n\n应用项目测试文件。\n\n应用项目支持在项目源码目录(src)下创建后缀为 .test.[tj]sx? 文件进行编写测试用例。\n\nINFO\n\n使用单元测试、集成测试需要提前在项目下执行 new 命令启用「单元测试 / 集成测试」功能。","frontmatter":{"title":"**/*.test.[tj]sx?","sidebar_position":6}},{"id":331,"title":"defineConfig","routePath":"/apis/app/runtime/app/define-config","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于动态配置应用。\n\n\n使用姿势\n\n\n\nRuntime 配置通常可以在 modern.config.js 的 runtime 空间下配置，如 router 配置。\n\nmodern.config.js 中的配置是构建时确定的，如果一些配置参数是运行时获取的，或者配置参数是来自于源码中的一个模块（如组件），就需要使用\ndefineConfig API 进行运行时配置。\n\nINFO\n\n@modern-js/app-tools 拥有同名 API，用于为配置提供 TS 类型，请开发者加以区分。\n\n\n函数签名\n\nfunction defineConfig(Component, config): any;\n\n\n\n参数\n\n * Component：React.ComponentType<any>，App 根组件。\n * config：Record<string, any>，运行时的配置。\n\n\n示例\n\nfunction App () {\n  ...\n}\n\ndefineConfig(App, {\n  router: {\n    supportHtml5History: false\n  }\n})\n\n\n 1. defineConfig 里可配置 runtime.state、runtime.router 等运行时配置。\n\n 2. defineConfig 在配置某个属性之前，如 router，需要确保 modern.config.js 已经配置开启了该功能。\n\n 3. defineConfig 传入的配置会和 modern.config.js 中的配置浅 merge，以 router 为例，最终应用的配置如下：\n\n{\n  // 来自 `modern.config.js` 配置\n  ...runtime.router\n  // 来自 `defineConfig` 配置\n  ...config.router\n}\n","frontmatter":{"sidebar_position":1,"title":"defineConfig"}},{"id":332,"title":"hook","routePath":"/apis/app/runtime/bff/hook","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于在 BFF 函数写法下添加框架中间件，添加的中间件的执行会在 BFF 函数定义的路由之前。\n\n\n使用姿势\n\n根据使用的框架拓展插件，从对应的命名空间中导出：\n\n\n\n\n函数签名\n\ntype HookOptions = {\n  addMiddleware: string | function;\n};\n\nfunction hook(options: HookOptions): void;\n\n\n\n参数\n\n * options: Modern.js 提供的一系列钩子。\n   * addMiddleware: 添加 BFF 中间件的钩子。\n\n\n示例\n\n使用不同的框架，应添加不同框架的中间件（示例为使用 koa 框架时）：\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(async (ctx, next) => {\n    ctx.req.query.id = 'koa';\n    await next();\n  });\n});\n","frontmatter":{"title":"hook"}},{"id":333,"title":"useContext","routePath":"/apis/app/runtime/bff/use-context","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于在一体化 BFF 函数中获取请求上下文。\n\n\n使用姿势\n\n根据使用的框架拓展插件，从对应的命名空间中导出：\n\n\n\n\n函数签名\n\nfunction useContext(): any\n\n\n示例\n\n开发者可以通过 context 获取更多的请求信息，例如获取请求 UA（示例为使用 koa 框架时）：\n\n\n\nexport async function get() {\n  const ctx = useContext();\n  return ctx.req.headers['user-agent'];\n}\n\n\n注意\n\n只有在一体化 BFF 函数中，你才可以使用 useContext API 。\n\n使用不同的运行时框架时，虽然均支持 useContext API，但它们的返回值的类型是不同的。","frontmatter":{"title":"useContext"}},{"id":334,"title":"bootstrap","routePath":"/apis/app/runtime/core/bootstrap","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于启动和挂载应用，通常情况下不做手动调用。只有在使用自定义 App 时，才需要使用该 API。\n\n\n使用姿势\n\n\n\n\nbootstrap(App, 'root', undefined, ReactDOM);\n\n\n\n函数签名\n\ntype BootStrap<T = unknown> = (\n  App: React.ComponentType,\n  id: string | HTMLElement | RuntimeContext,\n  root?: any,\n  ReactDOM?: {\n    render?: Renderer;\n    hydrate?: Renderer;\n    createRoot?: typeof createRoot;\n    hydrateRoot?: typeof hydrateRoot;\n  },\n) => Promise<T>;\n\n\n\n参数\n\n * AppComponent：通过 createApp 创建的 ReactElement 实例。\n * id：要挂载的 DOM 根元素 id，如 \"root\"。\n * root: ReactDOM.createRoot 的返回值，用于 bootstrap 函数外需要 root 销毁组件的场景。\n * ReactDOM: ReactDOM 对象，用于区分 React 18 和 React 17 API。\n\n\n示例\n\n\n\n\nfunction App() {\n  return <div>Hello Modern.js</div>;\n}\n\nconst WrappedApp = createApp({\n  // 传入自定义插件\n  plugins: [customPlugin()],\n})(App);\n\nbootstrap(WrappedApp, 'root', undefined, ReactDOM);\n\n\nINFO\n\n由于 @modern-js/runtime/plugins 是别名处理的，在 ts 项目中使用时需要声明其类型， 只需要在\nsrc/modern-app-env.d.ts 添加以下类型声明即可：\n\ndeclare module '@modern-js/runtime/plugins';\n\n\nWARNING\n\nbootstrap 只支持在 CSR 场景下使用。","frontmatter":{"title":"bootstrap"}},{"id":335,"title":"createApp","routePath":"/apis/app/runtime/core/create-app","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2},{"id":"创建自定义入口","text":"创建自定义入口","depth":3}],"domain":"","content":"\n\n用于创建自定义入口，定制运行时插件。只有在使用自定义 App 时，才需要使用该 API。\n\n\n使用姿势\n\n\n\n\n函数签名\n\n\n\nfunction createApp(options: { plugins: Plugin[] }): React.ComponentType<any>;\n\n\n\n参数\n\n * options: 可选的参数。\n   * plugins：自定义的插件扩展。\n\n\n示例\n\n\n创建自定义入口\n\n详见 bootstrap。","frontmatter":{"title":"createApp"}},{"id":336,"title":"useLoader","routePath":"/apis/app/runtime/core/use-loader","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"返回值","text":"返回值","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n一个同构的 API，通常会用来做异步请求。当 SSR 的时候，服务端使用 useLoader 预加载数据，同时浏览器端也会复用这部分数据。\n\n\n使用姿势\n\n\n\n\n函数签名\n\ntype LoaderFn = (context: runtimeContext) => Promise<unknow>;\ntype Options = {\n  onSuccess: (data: Record<string, any>) => void;\n  onError: (error: Error) => void;\n  initialData: Record<string, any>;\n  skip: boolean;\n  params: Record<string, any>;\n  static: boolean;\n};\ntype ReturnData = {\n  data: Record<string, any>;\n  loading: boolean;\n  error: Error;\n  reload: (params?: Record<string, any>) => Promise<any> | undefined;\n  reloading: boolean;\n};\n\nfunction useLoader(loaderFn: LoaderFn, options: Options): ReturnData;\n\n\nINFO\n\nruntimeContext 类型可以参考 useRuntimeContext。\n\n\n参数\n\n * loaderFn：用于加载数据的函数，返回 Promise。\n * options：可选配置项。\n   * onSuccess：执行成功的回调。\n   * onError：执行失败的回调。\n   * initialData：首次执行前的初始数据，对应返回值中的 data 字段。\n   * skip：当值为 true 时，函数不执行。\n   * params：当 params 序列化结果发生改变时，函数会重新执行。同时，params 也会作为函数的第二个参数被传入。\n   * static：当值为 true 时，useLoader 用于 SSG 编译阶段数据的获取。\n\n\n返回值\n\n * data：执行成功时的返回数据。\n * loading：表示函数是否处于执行过程中。\n * error：函数执行失败时的错误信息。\n * reload：调用后可以重新执行函数。\n   * params：当值为 undefined 时，函数执行时将复用上次的值；否则会使用新的值重新执行函数。\n * reloading：调用 reload 的执行过程中，reloading 值为 true。\n\n\n示例\n\nfunction Container() {\n  const { data, error, loading } = useLoader(\n    async (context, params) => {\n      console.log(params) // nicole\n      return fetch(user);\n    },\n    {\n      onSuccess: data => {\n        console.log('I did success:(',  data);\n      },\n      onError: error => {\n        console.log('I met error:)',  error);\n      },\n      initialData: { name: 'nicole', gender: 'female' },\n      params: 'nicole'\n    }\n  );\n\n  return ...;\n}\n","frontmatter":{"title":"useLoader"}},{"id":337,"title":"useModuleApps","routePath":"/apis/app/runtime/core/use-module-apps","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"示例","text":"示例","depth":2},{"id":"集中式路由","text":"集中式路由","depth":3},{"id":"加载动画","text":"加载动画","depth":2}],"domain":"","content":"\n\n返回所有微前端子应用的 React 组件，用于可自由控制路由。\n\n\n使用姿势\n\n\n\n\n函数签名\n\nfunction useModuleApps(): Record<string, React.FC<any>>\n\n分别返回包裹每个子应用后的 React 组件。\n\n\n示例\n\n需要先配置微前端子应用信息。\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n这里演示主应用为自控式路由的场景，全部场景参考 体验微前端\n\nfunction App() {\n  const { apps, MApp, Table, Dashboard } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      <Route path=\"/\" element={<AppLayout />}>\n        <Route key={'table'} path={'table/*'} element={<Table />} />\n        <Route key={'dashboard'} path={'dashboard/*'} element={<Dashboard />} />\n      </Route>\n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // <BrowserRouter>\n    //   <MApp />\n    // </BrowserRouter>\n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      <RouterProvider router={router} />\n    </>\n  );\n}\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        // name 区分大小写，name 提供的是什么 useModuleApps 返回的就是什么\n        name: 'Table',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\n通过 useModuleApps() 获取到 Table 和 Dashboard 子应用组件（名称和配置里的 name 字段对应），之后就可以像使用普通的\nReact 组件一样去加载子应用。\n\n\n集中式路由\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [{\n      name: 'Table',\n      entry: 'http://localhost:8001',\n      // activeWhen: '/table'\n    }, {\n      name: 'Dashboard',\n      entry: 'http://localhost:8002'\n      // activeWhen: '/dashboard'\n    }]\n  },\n});\n\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    <div>\n      <MApp />\n    </div>\n  );\n}\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [\n      {\n        // name 区分大小写，name 提供的是什么 useModuleApps 返回的就是什么\n        name: 'Table',\n        activeWhen: '/table',\n        entry: 'http://127.0.0.1:8081/',\n      },\n      {\n        name: 'Dashboard',\n        activeWhen: '/dashboard',\n        entry: 'http://localhost:8082',\n      },\n    ],\n  },\n});\n\n\n这样启动应用后，访问 /dashboard 路由，会渲染 Dashboard 子应用，访问 /table 路由，会渲染 Table 子应用。\n\n\n加载动画\n\n可以通过以下方式，自定义组件加载过程的过渡动画。\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </>\n)\n\nexport default () => {\n  const { apps } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      <Route path=\"/\" element={<AppLayout />}>\n        {apps.map(app => {\n          const { Component } = app;\n          // 模糊匹配，path 需要写成类似 abc/* 的模式\n          return (\n            <Route\n              key={app.name}\n              path={`${app.name.toLowerCase()}/*`}\n              element={\n              <Component\n                loadable={{\n                  loading: ({ pastDelay, error }: any) => {\n                    if (error) {\n                      return <div>error: {error?.message}</div>;\n                    } else if (pastDelay) {\n                      return <div>loading</div>;\n                    } else {\n                      return null;\n                    }\n                  },\n                }}\n              />\n              }\n            />\n          )\n        })}\n      </Route>\n    )\n  );\n\n  return (\n    <>\n      <RouterProvider router={router} />\n    </>\n  );\n};\n","frontmatter":{"title":"useModuleApps"}},{"id":338,"title":"useRuntimeContext","routePath":"/apis/app/runtime/core/use-runtime-context","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"返回值","text":"返回值","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n该函数主要用于获取 Runtime 上下文，只能在函数组件中使用。\n\n\n使用姿势\n\n\n\nexport function App() {\n  const runtimeContext = useRuntimeContext();\n  return <div>Hello World</div>;\n}\n\n\n\n函数签名\n\ntype RuntimeContext = {\n  request: {\n    params: Record<string, string>;\n    pathname: string;\n    query: Record<string, string>;\n    headers: IncomingHttpHeaders;\n    cookie: string;\n  };\n  store: ReduckStore;\n};\n\nfunction useRuntimeContext(): RuntimeContext;\n\n\n\n返回值\n\n * request：请求上下文中的附加信息。\n   * params：请求路径中的动态参数。\n   * pathname：请求的 pathname。\n   * query：请求的查询字符串对象。\n   * headers：请求头信息。\n   * cookie：请求的 cookie 信息。\n * store：在开启了 state 插件的时候，该值为 reduck 全局 store。\n\n\n示例\n\n\n\n\nfunction App() {\n  const { store } = useRuntimeContext();\n\n  const [state, actions] = store.use(fooModel);\n\n  return <div>state: {state}</div>;\n}\n","frontmatter":{"title":"useRuntimeContext"}},{"id":339,"title":"Provider","routePath":"/apis/app/runtime/model/Provider","lang":"zh","toc":[{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nProvider 是一个组件，它将 Reduck 的 Store 注入到应用的组件树中，使组件树内部的组件可以访问 Model。一般情况下，Provider\n会定义在组件树的最顶层。\n\n\n函数签名\n\ninterface ProviderProps {\n  store?: ReduckStore;\n  config?: AppConfig;\n}\n\n\n\n参数\n\n * store：createStore 创建的 Store 对象。\n * config：创建 Reduck Store 的配置，同 createApp 的 config 参数。\n\n\n示例\n\nReactDOM.render(\n  <Provider>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n","frontmatter":{"sidebar_position":8,"title":"Provider"}},{"id":340,"title":"Auto actions","routePath":"/apis/app/runtime/model/auto-actions","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2},{"id":"基础数据类型","text":"基础数据类型","depth":3},{"id":"数组-array","text":"数组 Array","depth":3},{"id":"简单对象-plainobject","text":"简单对象 PlainObject","depth":3}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nReduck 可以根据 State 的类型，自动生成相应的 Actions，为修改 State 提供便利。\n\n提示\n\n可通过 runtime.state.autoActions 关闭 auto actions 功能。\n\n\n示例\n\n\n基础数据类型\n\nState 类型为 string、number、boolean、null 时，生成 setState Action。\n\nconst fooModel = model('foo').define({\n  state: 1,\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  return (\n    <div>\n      <div>State: {state}</div>\n      <button\n        type=\"button\"\n        onClick={() => {\n          // 调用自动生成的 setState Action\n          actions.setState(state + 1);\n        }}\n      >\n        add\n      </button>\n    </div>\n  );\n}\n\n\n\n数组 Array\n\nState 类型为 Array 时，生成下列 Actions：\n\n * push：将一个或多个元素添加到数组的末尾。\n * pop：从数组中删除最后一个元素。\n * shift：从数组中删除第一个元素。\n * unshift：将一个或多个元素添加到数组的开头。\n   * 语法：arr.unshift(element1, ..., elementN)\n   * elementN：要添加到数组开头的元素或多个元素。\n * filter：过滤元素。 {/* 语义与原生方法不同，待修改 API */}\n * concat：拼接数组。 {/* 语义与原生方法不同，待修改 API */}\n * splice：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回修改后的数组（注意和原生 splice 返回值不同）。\n   * 语法：splice(start[, deleteCount[, item1[, item2[, ...]]]])\n   * start：指定修改的开始位置（从 0 计数）。\n   * deleteCount：可选，整数，表示要移除的数组元素的个数。\n   * item, item2, ...：可选，要添加进数组的元素，从 start 位置开始。如果不指定，则 splice 将只删除数组元素。\n\nconst fooModel = model('foo').define({\n  state: [1, 2, 3],\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  useEffect(() => {\n    actions.push(4);\n    actions.pop();\n    actions.shift(0);\n    actions.unshift();\n    actions.filter(val => val <= 2);\n    actions.splice(0, 1, 1, 2);\n  }, []);\n\n  return (\n    <div>\n      <div>State: {state}</div>\n    </div>\n  );\n}\n\n\n\n简单对象 PlainObject\n\nState 类型为 PlainObject 时，根据 State 包含的属性名，生成 set${key}（小驼峰命名）Actions。\n\nconst fooModel = model('foo').define({\n  state: {\n    a: 1,\n    b: { value: 1 },\n    c: 'c',\n  },\n});\n\nfunction App() {\n  const [state, actions] = useModel(fooModel);\n\n  useEffect(() => {\n    actions.setA(2);\n    actions.setB({ value: 2 });\n    actions.setC('d');\n  }, []);\n\n  return (\n    <div>\n      <div>State: {state}</div>\n    </div>\n  );\n}\n","frontmatter":{"sidebar_position":6,"title":"Auto actions"}},{"id":341,"title":"connect","routePath":"/apis/app/runtime/model/connect","lang":"zh","toc":[{"id":"类型","text":"类型","depth":2},{"id":"参数","text":"参数","depth":2},{"id":"返回值","text":"返回值","depth":2},{"id":"示例","text":"示例","depth":2},{"id":"简单用法","text":"简单用法","depth":3},{"id":"筛选-state-和-actions","text":"筛选 State 和 Actions","depth":3},{"id":"转发组件的-ref","text":"转发组件的 ref","depth":3}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 connect。\n\nconnect 功能上同 useModel 一致，是对应的 HOC 风格的 API。建议优先使用 Hook 风格的 useModel。\n\n\n类型\n\ntype SelectStateToProps = (\n  ...modelStates: State[],\n  ownProps?: any,\n) => PlainObject;\ntype SelectActionsToProps = (\n  ...modelActions: Actions[],\n  ownProps?: any,\n) => PlainObject;\n\nfunction connect(models: Model, options?: ConnectOptions);\nfunction connect(\n  models: [...Model[], SelectStateToProps?, SelectActionsToProps?],\n  options?: ConnectOptions,\n);\n\n\n\n参数\n\n * models：传入的 1 个或多个 Model，当 models 为数组类型参数时，最后两项元素可以是用于筛选 State 的函数（\n   SelectStateToProps 类型）和用于筛选 Actions 的函数（ SelectActionsToProps 类型）。\n   \n   * SelectStateToProps： modelStates 是传入的 Model 对象的 State 组成的数组，ownProps\n     是当前组件接收外部传递的 props，SelectStateToProps 返回的数据会传递到组件的 props 上。当 models 中没有传入\n     SelectStateToProps 参数时，所有 Model 的 State 进行合并后传递到组件的 props 上。\n   * SelectActionsToProps： modelActions 是传入的 Model 对象的 Actions 组成的数组，ownProps\n     是当前组件接收外部传递的 props，SelectActionsToProps 返回的数据也会传递到组件的 props 上。当 models\n     中没有传入 SelectActionsToProps 参数时，所有 Model 的 Actions 进行合并后传递到组件的 props 上。\n\n * options：可选参数，用于辅助配置。目前支持设置 forwardRef，用于控制是否转发组件的 ref，默认值为 false，表示不转发\n   ref。设置为 {forwardRef: true}，表示转发 ref。\n\n\n返回值\n\n返回一个高阶组件：接收一个传入的组件，返回一个在 props 上注入了额外 State 和 Actions 的组件。\n\n\n示例\n\n\n简单用法\n\nconst modelA = model('modelA').define({\n  state: {\n    a: 1,\n  },\n  actions: {\n    incA(state) {\n      return {\n        ...state,\n        a: state.a + 1,\n      };\n    },\n  },\n});\n\nconst modelB = model('modelB').define({\n  state: {\n    b: 10,\n  },\n  actions: {\n    incB(state) {\n      return {\n        ...state,\n        b: state.b + 1,\n      };\n    },\n  },\n});\n\nfunction Test(props) {\n  props.incA(); // 调用 modelA 的 action\n  props.incB(); // 调用 modelB 的 action\n\n  props.a; // 获取 modelA 的 state: a\n  props.b; // 获取 modelB 的 state: b\n}\n\nexport default connect([modelA, modelB])(Test);\n\n\n\n筛选 State 和 Actions\n\nfunction Test(props) {\n  props.incAll();\n  props.c;\n}\n\nconst stateSelector = (stateA, stateB) => ({\n  ...stateA,\n  ...stateB,\n  c: stateA.a + stateA.b,\n});\nconst actionsSelector = (actionsA, actionsB) => ({\n  ...actionsA,\n  ...actionsB,\n  incAll: () => {\n    actionsA.incA();\n    actionsB.incB();\n  },\n});\n\nexport default connect([modelA, modelB, stateSelector, actionsSelector])(Test);\n\n\n\n转发组件的 ref\n\n\n\nfunction Test(props, ref) {\n  const { a, b } = props;\n\n  return (\n    <div ref={ref}>\n      <span>{a}</span>\n      <span>{b}</span>\n    </div>\n  );\n}\n\nconst TestWrapper = connect([modelA, modelB], { forwardRef: true })(\n  forwardRef(Test),\n);\n\nfunction App() {\n  const testRef = useRef();\n\n  return <TestWrapper ref={testRef} />;\n}\n","frontmatter":{"sidebar_position":5,"title":"connect"}},{"id":342,"title":"createApp","routePath":"/apis/app/runtime/model/create-app","lang":"zh","toc":[{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"返回值","text":"返回值","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nReduck 内部默认会使用 createApp 创建一个全局应用，如果整个应用只需要共享一个 Store，那么是不需要使用 createApp\n的。只有当需要在应用局部创建共享 Store 时，才需要使用 createApp。\n\n注意\n\n注意 @modern-js/runtime/model 中导出的 createApp 用于管理状态，而 @modern-js/runtime 导出的\ncreateApp 用于管理整个应用的运行时环境，两者功能不同。\n\n\n函数签名\n\ninterface AppConfig extends StoreConfig {\n  devTools?: boolean | DevToolsOptions;\n  autoActions?: boolean;\n}\n\nfunction createApp(config: AppConfig): object;\n\n\n\n参数\n\n * config：Record<string, any>\n   * StoreConfig：同 createStore 的参数。\n   * devTools：默认值为 true。是否开启 Redux DevTools，当为对象类型时，支持配置 Redux DevTools 的\n     Options。\n   * autoActions：默认值为 true。是否自动生成 Actions。\n\n\n返回值\n\nReduck App，有以下属性组成：\n\n * Provider：为应用局部的组件树注入共享 Store 的组件。用法同 Provider。\n * useModel：获取应用局部 Store 挂载的 Model 对象。用法同 useModel。\n * useStaticModel：获取应用局部 Store 挂载的 Model 对象。用法同 useStaticModel。\n * useLocalModel：获取应用局部 Store 挂载的 Model 对象。用法同 useLocalModel。\n * useStore：获取应用局部使用的 Store 对象。用法同 useStore。\n\n\n示例\n\n通过 createApp 可以创建局部状态，将不同 Reduck 应用间的状态隔离。\n\nconst { Provider: LocalFooProvider, useModel: useLocalFooModel } = createApp();\nconst { Provider: LocalBarProvider, useModel: useLocalBarModel } = createApp();\n\nfunction Foo() {\n  const [fooState] = useLocalFooModel(fooModel);\n  const [barState] = useLocalBarModel(fooModel);\n\n  return (\n    <div>\n      <div>Foo: {fooState}</div>\n      <div>Bar: {barState}</div>\n    </div>\n  );\n}\n\nfunction Container() {\n  return (\n    <LocalFooProvider>\n      <LocalBarProvider>\n        <Foo />\n      </LocalBarProvider>\n    </LocalFooProvider>\n  );\n}\n","frontmatter":{"sidebar_position":11,"title":"createApp"}},{"id":343,"title":"createStore","routePath":"/apis/app/runtime/model/create-store","lang":"zh","toc":[{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"返回值","text":"返回值","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\ncreateStore 用于创建一个 Store 对象。Reduck 的 Store 基于 Redux 的 Store\n实现，用于存储应用的状态，同时提供一组用于管理状态和 Model 的方法。\n\n一般情况下，不需要使用这个 API，只有需要完全掌控 Store 的创建时，才会使用这个 API。例如，自定义一个 Store，传入 Provider\n组件使用。\n\n\n函数签名\n\ninterface StoreConfig {\n  initialState?: Record<string, any>;\n  middlewares?: Middleware[];\n  models?: Model[];\n  plugins?: Plugin[];\n  enhancers?: StoreEnhancer[];\n}\n\ninterface ReduckStore extends ReduxStore {\n  use: typeof useModel;\n  unmount: (model: Model) => void;\n}\n\nfunction createStore(config: StoreConfig): ReduckStore;\n\n\n\n参数\n\n * config?：store 配置选项\n   * initialState?: 设置全局 Store 的初始状态。\n   * models?: 设置提前（Store 创建后）挂载到 Store 的 Model。（正常使用无需提前挂载）\n   * middlewares?: 设置 Redux 中间件。\n   * enhancers?: 设置 Redux 的 Store enhancer 。\n   * plugins?: 设置 Reduck 插件。试验性配置，不推荐使用。\n\n\n返回值\n\nReduck Store 对象：\n\n * use：动态挂载和获取 Model 对象。用法与 useModel 相同，但可以在 React 组件外使用。\n * unmount：卸载 Model 对象，Model 的 State 会从 Store 中清除。\n * ReduxStore：Redux Store 对象具有的方法，详见。\n\n\n示例\n\nconst store = createStore();\n\nfunction load() {\n  const [, actions] = store.use(fooModel);\n\n  actions.load();\n}\n","frontmatter":{"sidebar_position":10,"title":"createStore"}},{"id":344,"title":"handleEffect","routePath":"/apis/app/runtime/model/handle-effect","lang":"zh","toc":[{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"返回值","text":"返回值","depth":3}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n一个异步函数类型的 Effect，通常有三种需要处理的状态: 请求中、请求成功、请求处理失败。这些状态处理的方式，就是编写对应的 Action\n函数(pending、fulfilled、rejected)。\n\n借助 handleEffect API，我们可以生成默认的 Action 函数来处理异步请求各个阶段的不同结果。handleEffect 生成的 Action\n返回的 State 的结构如下：\n\ninterface State {\n  result: any; // 存储 fulfilled 状态的返回结果\n  pending: boolean; // 请求是否结束\n  error: string; // 请求失败的结果\n}\n\n\n\n函数签名\n\ninterface EffectActions {\n  pending: Action;\n  fulfilled: Action;\n  rejected: Action;\n}\n\ninterface Config {\n  ns?: string;\n  result?: string | false;\n  error?: string | false;\n  pending?: string | false;\n  combineMode?: 'merge' | 'replace';\n  omitResultNamespace?: boolean;\n}\n\nfunction handleEffect(config: Config): EffectActions;\n\n\n\n参数\n\n * ns：默认返回的 State 结构扁平地挂载到 Model 的 State 上，通过设置该参数可以将返回的 State 挂载到 ns\n   值命名的字段下。例如，ns 设置为 data，返回的 State 结构为：\n\ninterface State {\n  data: {\n    pending: boolean;\n    result: any;\n    error: string;\n  };\n}\n\n\n * result：默认值为 \"result\"。该参数对应存储异步请求 fulfilled 状态结果的字段名称。例如，设置 result 为\n   \"items\"，返回的 State 结构为：\n\ninterface State {\n  items: any; // 默认的 result -> items\n  pending: boolean;\n  error: string;\n}\n\n\nresult 为 false，返回的 State 结构中不存在 result：\n\ninterface State {\n  pending: boolean;\n  error: string;\n}\n\n\n * pending：默认值为 \"pending\"。改变返回 State 中的 pending 字段名。用法同上。\n\n * error： 默认值为 \"error\"。改变返回 State 中的 error 字段名。用法同上。\n\n * combineMode：默认值为 \"merge\"。获取 fulfilled 状态的返回数据后，对 result 的处理方式：merge（合并）和\n   replace（替换）。这里能自动处理的数据类型也仅限为简单的对象或者数组类型。\n   \n   * merge：前一次的数据与当前的数据合并。数据为数组类型，内部操作类似于 [].concat(lastData,\n     currentData)；数据为对象类型，内部操作类似于 {...lastData, ...curData}。\n   * replace：当前的数据直接替换之前的数据。\n\n * omitResultNamespace：默认值为 \"false\"。当异步请求的结果为对象类型，希望把该结果直接挂载到 Model 的 State\n   上，而不是挂载到 \"result\" 上，可以设置为 true。例如：\n\n// 一个异步请求得到的数据为一个对象：{user: 'xx', email: 'xx'}，\n// 配置 handleEffect({ omitResultNamespace: true })\n// 则得到的 State 结构如下：\n{\n  user: 'xx',\n  email: 'xx',\n  pending: false,\n  error: null,\n}\n\n\n\n返回值\n\n分别处理 pending、fulfilled、rejected 三种状态的 Action 组成的对象。\n\n更多参考\n\n副作用管理","frontmatter":{"sidebar_position":7,"title":"handleEffect"}},{"id":345,"title":"model","routePath":"/apis/app/runtime/model/model_","lang":"zh","toc":[{"id":"model","text":"model","depth":2},{"id":"define","text":"define","depth":2},{"id":"对象类型","text":"对象类型","depth":3},{"id":"函数类型","text":"函数类型","depth":3},{"id":"参数","text":"参数","depth":3},{"id":"modeldescstate","text":"ModelDesc.state","depth":4},{"id":"modeldescactions","text":"ModelDesc.actions","depth":4},{"id":"modeldesccomputed","text":"ModelDesc.computed","depth":4},{"id":"modeldesceffects","text":"ModelDesc.effects","depth":4}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 model。\n\n\nmodel\n\n用于创建管理应用状态的 Model。\n\nfunction model(name: string): { define: function }\n\n * name：string，创建的 Model 的唯一标识。\n\nmodel('foo');\n\n\n\ndefine\n\n用于定义 Model 的详细结构，支持传入一个对象类型或函数类型的参数。\n\n\n对象类型\n\nfunction define(modelDesc: ModelDesc): Model;\n\n * modelDesc: ModelDesc，对 Model 结构的定义，包含 state、computed、actions、effects 等属性。\n\nconst fooModel = model('foo').define({\n  state: 'foo',\n  computed: {\n    cFoo: state => `c${state}`,\n  },\n  actions: {\n    setState: (state, value) => {\n      return value;\n    },\n  },\n  effects: {\n    loadState: async () => {\n      // 从服务端获取 state\n    },\n  },\n});\n\n\n\n函数类型\n\nfunction define((context: Context, utils: Utils) => ModelDesc): Model;\n\n * context: Context，Reduck 上下文对象，可以获取底层的 store 对象。store 除支持 Redux Store 的所有 API\n   以外，还挂载了用于消费 Model 的 use 的方法，和用于卸载 Model 的 unmount 方法。\n * utils: Utils，定义 Model 时，常用的工具函数：use、onMount。use 作用同 store 对象上的 use，onMount 是\n   Model 挂载后的钩子函数。\n\n{/* TODO: @anchao 调整类型 */}\n\ninterface Utils {\n  use: UseModel;\n  onMount: OnMountHook;\n}\n\ninterface Context {\n  store: ReduxStore & {\n    use: UseModel;\n    unmount: (model: Model) => void;\n  };\n}\n\n\n如通过 use，可以获取 Model 自身及其它 Model 的 state，actions。\n\nconst fooModel = model('foo').define(() => {\n  return {\n    state: 'foo',\n    actions: {\n      setState: (state, value) => {\n        return value;\n      },\n    },\n  };\n});\n\nconst barModel = model('bar').define((_, { use }) => {\n  return {\n    state: 'bar',\n    effects: {\n      syncFoo() {\n        const [state, actions] = use(fooModel);\n        actions.setState(state);\n      },\n    },\n  };\n});\n\n\n\n参数\n\nModelDesc.state\n\n定义 Model 的状态。技术上，支持任意类型的 State，但是实践中建议使用可进行 JSON 序列化的类型。\n\ninterface ModelDesc {\n  state: any;\n}\n\n\nModelDesc.actions\n\n定义 Model 的 Actions。Actions 的函数类型为：\n\ninterface ModelDesc {\n  actions: {\n    [actionKey: string]: (state: State, payload: any) => State | void;\n  };\n}\n\n\nReduck 内部集成了 immer，可以直接原始的 state，当 Action 没有显式返回值时，Reduck 内部会返回修改过的新的 State 对象。\n\nModelDesc.computed\n\n定义 Model 的衍生状态。衍生状态的定义支持两种类型：\n\n 1. 只依赖 Model 自身的状态\n\ninterface ModelDesc {\n  computed: {\n    [computedKey: string]: (state: State) => any;\n  };\n}\n\n\n 2. 依赖其他 Model 的状态\n\ninterface ModelDesc {\n  computed: {\n    [computedKey: string]: [\n      ...models: Model[],\n      (state: State, ...args: ModelState[]) => any,\n    ];\n  };\n}\n\n\nconst fooModel = model('foo').define({\n  state: 'foo',\n});\n\nconst barModel = model('bar').define({\n  state: 'bar',\n  computed: {\n    combineFoo: [fooModel, (state, fooState) => state + fooState],\n  },\n});\n\n\nModelDesc.effects\n\n定义 Model 的 Effects。Effects 中定义的函数类型为：\n\ninterface ModelDesc {\n  effects: {\n    [effectKey: string]: (...args: any[]) => any;\n  };\n}\n\n\nconst fooModel = model('foo').define((context, { use }) => ({\n  state: 'foo',\n  effects: {\n    persist() {\n      const [state] = use(fooModel);\n      localStorage.setItem('state', state);\n    },\n  },\n}));\n\n\n更多参考\n\n创建 Model","frontmatter":{"sidebar_position":1,"title":"model"}},{"id":346,"title":"useLocalModel","routePath":"/apis/app/runtime/model/use-local-model","lang":"zh","toc":[{"id":"示例","text":"示例","depth":4}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n用于把 Model 中的 State 作为局部状态使用，效果类似 React 的 useState。useLocalModel API 形式上与\nuseModel 完全一致。具体使用请参考 useModel。\n\n示例\n\nfunction Container() {\n  const [state, actions] = useLocalModel(modelA);\n  const [state1, actions1] = useLocalModel(modelA);\n\n  // ...\n}\n\n\n上面通过 useLocalModel 加载了两次 modelA，因为 useLocalModel 消费的是局部状态，所以 state 和 state1\n也是完全隔离的。\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":4,"title":"useLocalModel"}},{"id":347,"title":"useModel","routePath":"/apis/app/runtime/model/use-model","lang":"zh","toc":[{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"返回值","text":"返回值","depth":3},{"id":"示例","text":"示例","depth":2},{"id":"基本用法","text":"基本用法","depth":3},{"id":"selector-用法","text":"selector 用法","depth":3}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 model。\n\n\n函数签名\n\nfunction useModel(\n  models: Models[],\n  stateSelector?: StateSelector,\n  actionSelector?: ActionSelector,\n): [state, actions, subscribe];\nfunction useModel(\n  ...models: Models[],\n  stateSelector?: (...args: State[]) => any,\n  actionSelector?: (...args: Actions[]) => any,\n): [state, actions, subscribe];\n\n\n\n参数\n\n * models：Model 对象数组，可以作为一个数组类型的参数传入，也可以所有 Model 逐个作为参数传入。\n * stateSelector：可选参数，用于筛选 State 计算。前 n 个参数为 n 个 Model 对应的 State，返回的数据作为\n   useModel 返回值数组的第一个元素。\n * actionSelector：可选参数，用于筛选 Actions 计算。前 n 个参数为 n 个 Model 对应的 Actions，返回的数据作为\n   useModel 返回值数组的第二个元素。\n\n\n返回值\n\n返回一个数组，每一项元素分别为：\n\n * state：stateSelector 的返回值。如果未传 stateSelector，会把传入的所有 Model 的 State\n   (包含衍生状态)合并后返回。如果不同 Model 的 State 中存在同名属性，后面的 State 会覆盖前面的 State。当 state\n   发生变化时，调用 useModel 的组件会重新渲染。\n * actions：第二个元素为 actionSelector 的返回值。如果未传 actionSelector，会把传入的所有 Model 的\n   Actions (包含 Effects) 合并后返回。如果不同 Model 的 Actions 中存在同名属性，后面的 Actions 会覆盖前面的\n   Actions。\n * subscribe：订阅 State 变化的函数。当传入的任意 Model 的 State 发生改变时，该函数会被调用。\n\n\n示例\n\n\n基本用法\n\n\n\n\nfunction Test(props) {\n  const [state, actions] = useModel([todoModel, filterModel]);\n  actions.add(); // 调用 todoModel add action\n  actions.setVisibleStatus(); // 调用 filterModel filterModel action\n\n  state.items; // 获取 todoModel state items\n  state.visibleStatus; // 获取 filterModel state visibleStatus\n}\n\n\n\nselector 用法\n\nfunction Test(props) {\n  const [state, actions] = useModel(\n    [todoModel, filterModel],\n    (todoState, filterState) => ({\n      items: todoState.items,\n      visibleStatus: `${props.prefix}-${filterState.visibleStatus}`,\n    }),\n    (todoActions, filterActions) => ({\n      ...todoActions,\n      ...filterActions,\n    }),\n  );\n  actions.add(); // 调用 todoModel add action\n  actions.setVisibleStatus(); // 调用 filterModel filterModel action\n\n  state.items; // 获取 todoModel state items\n  state.visibleStatus; // 获取 filterModel state visibleStatus\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":2,"title":"useModel"}},{"id":348,"title":"useStaticModel","routePath":"/apis/app/runtime/model/use-static-model","lang":"zh","toc":[{"id":"示例","text":"示例","depth":4}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n如果想在组件里以 React Hook 的形式消费某个 Model，并能随时获取到当前最新的状态，但又不希望 Model\n状态更新的时候，引起组件的重新渲染，可以使用 useStaticModel。useStaticModel API 形式上与 useModel\n完全一致。具体使用请参考 useModel。\n\n为了保证总是能获取到最新状态，注意不要对返回的 state 解构。\n\nfunction App() {\n  // ❌ 不能解构 state，但可以解构 actions。\n  const [{ username }, { logout }] = useStaticModel(userModel);\n\n  // ✅ 这才是正确使用姿势。\n  const [state, { logout }] = useStaticModel(userModel);\n\n  useEffect(() => {\n    state.username;\n  }, []);\n}\n\n\n示例\n\n如下 App 组件消费了 userModel 的状态，但没有直接在 JSX 里使用。可以发现，userModel\n状态的改变没有必要引起组件重新渲染，这种情况可以使用 useStaticModel 进行优化。\n\nfunction App() {\n  const [state] = useStaticModel(userModel);\n\n  useEffect(() => {\n    // 统计 UV 数据\n    send('pageview', { user: state.user });\n  }, [state]);\n\n  return <div>Hello</div>;\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":3,"title":"useStaticModel"}},{"id":349,"title":"useStore","routePath":"/apis/app/runtime/model/use-store","lang":"zh","toc":[{"id":"函数签名","text":"函数签名","depth":2},{"id":"返回值","text":"返回值","depth":3}],"domain":"","content":"\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nuseStore 用于获取当前组件树共享的 Store。常用于在组件外访问 Model 的场景。注意，useStore 是一个 React\nHook，只能在组件内使用。\n\n\n函数签名\n\nfunction useStore(): ReduckStore;\n\n\n\n返回值\n\n * ReduckStore：Reduck Store，类型参考 createStore 返回值。\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":9,"title":"useStore"}},{"id":350,"title":"router","routePath":"/apis/app/runtime/router/router","lang":"zh","toc":[{"id":"hooks","text":"hooks","depth":2},{"id":"usenavigate","text":"useNavigate","depth":3},{"id":"uselocation","text":"useLocation","depth":3},{"id":"useparams","text":"useParams","depth":3},{"id":"组件","text":"组件","depth":2},{"id":"link","text":"Link","depth":3},{"id":"navlink","text":"NavLink","depth":3},{"id":"outlet","text":"Outlet","depth":3},{"id":"route","text":"Route","depth":3},{"id":"更多-api","text":"更多 API","depth":2}],"domain":"","content":"\n\n补充信息\n\n基于 react-router 的路由解决方案。\n\n\nhooks\n\n\nuseNavigate\n\ndeclare function useNavigate(): NavigateFunction;\n\ninterface NavigateFunction {\n  (\n    to: To,\n    options?: {\n      replace?: boolean;\n      state?: any;\n      relative?: RelativeRoutingType;\n    },\n  ): void;\n  (delta: number): void;\n}\n\n\nuseNavigate 返回一个可以用于执行导航操作的函数。\n\n\n\nexport function HomeButton() {\n  let navigate = useNavigate();\n\n  function handleClick() {\n    navigate('/home');\n  }\n\n  return (\n    <button type=\"button\" onClick={handleClick}>\n      Go home\n    </button>\n  );\n}\n\n\n\nuseLocation\n\ndeclare function useLocation(): Location;\n\ninterface Location extends Path {\n  state: unknown;\n  key: Key;\n}\n\n\nuseLocation 返回当前 url 对应的 location 对象。每当路由更新的时候，都会拿到一个新的 location 对象。\n\n\n\nfunction usePageViews() {\n  let location = useLocation();\n  React.useEffect(() => {\n    ga.send([\"pageview\", location.pathname]);\n  }, [location]);\n}\n\nfunction App() {\n  usePageViews();\n  return (\n    //...\n  );\n}\n\n\n\nuseParams\n\ndeclare function useParams<K extends string = string>(): Readonly<Params<K>>;\n\n\nuseParams 返回一个 key/value 的键值对，表示当前匹配的路由 <Route path> 中的参数信息。\n\n\n\nfunction BlogPost() {\n  const { slug } = useParams();\n  return <div>Now showing post {slug}</div>;\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<div>home</div>} />\n      <Route path=\"/blog/:slug\" element={<BlogPost />} />\n    </Routes>\n  );\n}\n\n\n\n组件\n\n\nLink\n\ndeclare function Link(props: LinkProps): React.ReactElement;\n\ninterface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href'> {\n  replace?: boolean;\n  state?: any;\n  to: To;\n  reloadDocument?: boolean;\n}\n\ntype To = string | Partial<Path>;\n\n\n可以使用 Link 组件进行路由跳转。\n\n<Link to=\"/about\">About</Link>\n\n\n\nNavLink\n\ndeclare function NavLink(props: NavLinkProps): React.ReactElement;\n\ninterface NavLinkProps\n  extends Omit<LinkProps, 'className' | 'style' | 'children'> {\n  caseSensitive?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean }) => React.ReactNode);\n  className?: string | ((props: { isActive: boolean }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: { isActive: boolean }) => React.CSSProperties);\n}\n\n\n<NavLink> 是一种特殊的 <Link>，当 <NavLink> 对应的链接和当前 URL 匹配时，会给 <NavLink>\n所渲染的元素添加“激活”态样式。\n\n\nOutlet\n\ninterface OutletProps {\n  context?: unknown;\n}\ndeclare function Outlet(props: OutletProps): React.ReactElement | null;\n\n\n<Outlet> 用于嵌套路由场景。在父路由的元素中使用，代表待渲染的子路由的元素在父组件中的位置。\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n\n      {/* This element will render either <DashboardMessages> when the URL is\n          \"/messages\", <DashboardTasks> at \"/tasks\", or null if it is \"/\"\n      */}\n      <Outlet />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Dashboard />}>\n        <Route path=\"messages\" element={<DashboardMessages />} />\n        <Route path=\"tasks\" element={<DashboardTasks />} />\n      </Route>\n    </Routes>\n  );\n}\n\n\n\nRoute\n\ninterface RouteObject {\n  path?: string;\n  index?: boolean;\n  children?: React.ReactNode;\n  caseSensitive?: boolean;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  handle?: RouteObject['handle'];\n  shouldRevalidate?: ShouldRevalidateFunction;\n}\n\n\nRoute 用于定义路由。一个 Route 对象，将 URL 片段和组件、数据获取关联起来。\n\nRoute 可以作为普通对象，传给创建 router 的函数的参数：\n\nconst router = createBrowserRouter([\n  {\n    // it renders this element\n    element: <Team />,\n\n    // when the URL matches this segment\n    path: 'teams/:teamId',\n\n    // with this data loaded before rendering\n    loader: async ({ request, params }) => {\n      return fetch(`/fake/api/teams/${params.teamId}.json`, {\n        signal: request.signal,\n      });\n    },\n\n    // performing this mutation when data is submitted to it\n    action: async ({ request }) => {\n      return updateFakeTeam(await request.formData());\n    },\n\n    // and renders this element in case something went wrong\n    errorElement: <ErrorBoundary />,\n  },\n]);\n\n\nRoute 还可以作为组件使用，通过 createRoutesFromElements 转换后，再传给创建 router 的函数的参数：\n\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route\n      element={<Team />}\n      path=\"teams/:teamId\"\n      loader={async ({ params }) => {\n        return fetch(`/fake/api/teams/${params.teamId}.json`);\n      }}\n      action={async ({ request }) => {\n        return updateFakeTeam(await request.formData());\n      }}\n      errorElement={<ErrorBoundary />}\n    />,\n  ),\n);\n\n\n\n更多 API\n\n若想要了解完整的路由 API 信息，可至 react-router 官网 查看。","frontmatter":{"title":"router","sidebar_position":1}},{"id":351,"title":"NoSSR","routePath":"/apis/app/runtime/ssr/no-ssr","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"示例","text":"示例","depth":2},{"id":"使用场景","text":"使用场景","depth":2}],"domain":"","content":"\n\n被 NoSSR 包裹的内容在服务端不会进行渲染，在客户端 hydrate 阶段也不会渲染，等到整个 App 渲染完成后便会立即渲染。\n\n\n使用姿势\n\n\n\nexport default () => <NoSSR>...</NoSSR>;\n\n\n\n示例\n\n下列代码中，Time 组件用于展示当前的时间，由于服务端渲染和客户端 hydrate 时获取到的时间是不一致的，React 就会抛出异常。针对这种情况可以使用\nNoSSR 进行优化：\n\n\n\nfunction Time() {\n  return (\n    <NoSSR>\n      <div>Time: {Date.now()}</div>\n    </NoSSR>\n  );\n}\n\n\n\n使用场景\n\n在 CSR 中，常常需要根据当前浏览器 UA，或是当前页面 URL 的某个参数的不同，来渲染不同的内容。如果此时应用直接切换到\nSSR，很有可能出现不符合预期的结果。\n\nModern.js 在 SSR 上下文中提供了完整的浏览器端信息，可以利用上下文信息来决定组件在服务端的渲染结果。\n\n即便如此，如果应用里有太多的判断，开发者希望以后再使用上下文，或者不希望某些内容在服务端被渲染，可以使用 NoSSR 组件将这一部分剔除在服务端渲染外。","frontmatter":{"title":"NoSSR"}},{"id":352,"title":"PreRender","routePath":"/apis/app/runtime/ssr/pre-render","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n无展示内容的高阶组件，通过类似 Helmet 的方式实现 SPA 路由级的缓存，无需额外配置。\n\n\n使用姿势\n\n\n\nexport default () => (\n  <>\n    <PreRender interval={5} />\n  </>\n);\n\n\n\n函数签名\n\nPreRender 组件提供了一套常用的配置参数，用于控制缓存的规则、过期时间、缓存算法等。\n\ntype Props {\n  interval: number;\n  staleLimit: number;\n  level: number;\n  include: { header?: string[], query?: string[] };\n  matches: { header?: Record<string, any>, query?: Record<string, any> }\n}\n\nfunction PreRender(props: Props): React.Component\n\n\n\n参数\n\n * interval：设置缓存保持新鲜的时间，单位秒。在该时间内，将直接使用缓存，并且不做异步渲染。\n * staleLimit：设置缓存完全过期的时间，单位秒。在该时间内，缓存可以被返回，并且会做一步渲染，否则必须使用重新渲染的结果。\n * level：设置缓存标识的计算规则等级，通常配合 includes 与 matches 使用。默认值为 0。\n\n0：路由路径\n1：路由路径 + 查询字符串\n2：路由路径 + 请求头\n3：路由路径 + 查询字符串 + 请求头\n\n\n * includes：设置需要被纳入缓存标识的内容，在 level 非 0 时使用。默认值为 null。\n * matches：设置 query 或 header 的值在缓存标识计算中的重写规则，通常用在缓存分类时，支持正则表达式。默认值为 null。\n\n\n示例\n\n\n\nexport default function App() {\n  return (\n    <>\n      <PreRender interval={10} />\n      <div>Hello Modern</div>\n    </>\n  );\n}\n\n\n下面例子展示了如何将 query、header 中指定的参数纳入缓存计算中：\n\n/* 使用 query 中的 channel 和 header 中的 language 计算缓存标识 */\n<PreRender\n  interval={10}\n  level={2}\n  includes={{\n    query: ['channel'],\n    header: ['language'],\n  }}\n/>\n\n\n下面例子展示了如何不让测试频道影响线上缓存：\n\n/* 将 query 中 channel 值为 test_ 开头的重写为 testChannel，否则重写为 otherChannel */\n<PreRender interval={10} level={2} includes={{\n  query: [\"channel\"],\n  header: [\"language\"]\n}} matches={{\n  query: {\n    channel: {\n      \"testChannel\", \"^test_\",\n      \"otherChannel\", \".*\"\n    }\n  }\n}} />\n","frontmatter":{"title":"PreRender"}},{"id":353,"title":"act","routePath":"/apis/app/runtime/testing/act","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于确保渲染、事件、数据获取等行为已经应用在 DOM 上。\n\n\n使用姿势\n\n\n\n\n函数签名\n\nact 和 react-dom/test-utils act 函数 是一致的。\n\n\n示例\n\n\n\n\n\ndescribe('test act', () => {\n  it('it should be foo', () => {\n    const el = document.createElement('div');\n    act(() => {\n      ReactDOM.render(<Foo />, el);\n    });\n\n    expect(el.innerHTML).toBe('<div>Foo</div>');\n  });\n});\n","frontmatter":{"title":"act"}},{"id":354,"title":"cleanup","routePath":"/apis/app/runtime/testing/cleanup","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于卸载掉当前已渲染的所有组件。\n\n\n使用姿势\n\n\n\n\n函数签名\n\nfunction cleanup(): void\n\n\n示例\n\nINFO\n\n请注意，如果你使用的测试框架支持 afterEach，并且它被注入到你的测试环境中（如 mocha、Jest 和 Jasmine），会默认在 afterEach\n钩子里执行 cleanup。否则，你将需要在每次测试后进行手动清理。\n\n例如，如果你使用ava测试框架，那么你需要像这样使用 test.afterEach 钩子。\n\n\n\n\ntest.afterEach(cleanup);\n\ntest('renders into document', () => {\n  render(<div />);\n  // ...\n});\n\n// ... more tests ...\n","frontmatter":{"title":"cleanup","sidebar_position":3}},{"id":355,"title":"render","routePath":"/apis/app/runtime/testing/render","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"返回值","text":"返回值","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n用于在测试用例中渲染组件，完成测试。\n\n\n使用姿势\n\n\n\n\n函数签名\n\ntype Options = {\n  container: DOMElement;\n  baseElement: DOMElement;\n  hydrate: boolean;\n  warpper: React.ComponentType<{children: ReactNode}>;\n  queries: any;\n};\n\ntype RenderResult = {\n  {...queries}: any;\n  container: DOMElement;\n  baseElement: DOMElement;\n  debug: function;\n  rerender: function;\n  unmount: function;\n  asFragment: function;\n}\n\nfunction render(ui: React.ReactElement<any>, options: Options): RenderResult;\n\n\n\n参数\n\n * ui：需要被渲染的 React 组件。\n * options：render 可选配置。\n   * container：表示组件所要挂载到的 DOM 节点，默认是会创建一个 div 元素，并自动添加到 document.body 上。这个 div\n     元素就是组件要挂载的节点。默认值是 document.body.append(document.createElement('div'))。\n   * baseElement：用于指定 queries 中使用到的 basename。如果指定了 container, 则默认值为 container\n     的值，否则就是 document.body。\n   * hydrate：如果设置为 true，则会使用 ReactDOM.hydrate 渲染组件。默认值为 false。\n   * wrapper：是一个 react 组件，可用于自定义渲染逻辑。\n   * queries：自定义一些自己的 queries。\n\n\n返回值\n\n * {...queries}：所有可用的 queries。\n * container：挂载 React 组件的 DOM 节点。\n * baseElement\n * debug\n * rerender：如果想测试一个已渲染的组件在其 props 更新时的一些场景，可以使用 rerender 来现实。\n * unmount：会卸载掉已渲染的组件。如果想测试组件卸载后的情况（如，绑定的事件是否在 unmount 阶段被卸载掉），那么这个 API 是很帮助的。\n * asFragment：返回当前渲染的组件的 DocumentFragment 对象。可用于测试 react 事件触发后 DOM 结构的响应。\n\n\n示例\n\n\n\n\ntest('renders a message', () => {\n  const { container, getByText } = render(<App />);\n  expect(getByText('Hello, world!')).toBeInTheDocument();\n  expect(container.firstChild).toMatchInlineSnapshot(`\n    <h1>Hello, World!</h1>\n  `);\n});\n","frontmatter":{"title":"render"}},{"id":356,"title":"renderApp","routePath":"/apis/app/runtime/testing/renderApp","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\nrender 函数用于测试普通组件，renderApp 函数用于测试应用组件。\n\n\n使用姿势\n\n\n\n应用组件指包含一些 Modern.js 上下文的组件，如 App 根组件，使用了 Model 的 Container 等。对于这类组件的测试，可以使用\nrenderApp 函数，会自动按照当前 modern.config.js 配置，包裹上对应的上下文信息。\n\n\n函数签名\n\nrenderApp 和 render 完全一致。\n\n\n示例\n\n\n\n\ndescribe('test', () => {\n  it('test App', () => {\n    const { getByText } = renderApp(<App />);\n    expect(getByText('Hello Modern!')).toBeInTheDocument();\n  });\n});\n","frontmatter":{"title":"renderApp"}},{"id":357,"title":"CSS-In-JS API","routePath":"/apis/app/runtime/utility/css-in-js","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n使用 Style Component 来编写组件 CSS。\n\n\n使用姿势\n\n\n\n\n函数签名\n\n请看 styled-component API。\n\n\n示例\n\n\n\nconst Button = styled.button`\n  background: palevioletred;\n  border-radius: 3px;\n  border: none;\n  color: white;\n`;\n\nconst TomatoButton = styled(Button)`\n  background: tomato;\n`;\n\nfunction ButtonExample() {\n  return (\n    <>\n      <Button>I'm purple.</Button>\n      <br />\n      <TomatoButton>I'm red.</TomatoButton>\n    </>\n  );\n}\n","frontmatter":{"title":"CSS-In-JS API"}},{"id":358,"title":"Head","routePath":"/apis/app/runtime/utility/head","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"示例","text":"示例","depth":2},{"id":"更多用法","text":"更多用法","depth":2}],"domain":"","content":"\n\n用于给 <head> 元素内添加 html 元素（如 title、meta、script 等），支持 SSR。\n\n\n使用姿势\n\n\n\nexport default () => <Helmet>...</Helmet>;\n\n\n\n示例\n\n\n\nfunction IndexPage() {\n  return (\n    <div>\n      <Helmet>\n        <title>My page title</title>\n        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n      </Helmet>\n      <p>Hello Modern.js!</p>\n    </div>\n  );\n}\n\nexport default IndexPage;\n\n\n\n更多用法\n\n详见 react-helmet。","frontmatter":{"title":"Head"}},{"id":359,"title":"loadable","routePath":"/apis/app/runtime/utility/loadable","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"loadfn","text":"loadFn","depth":4},{"id":"optionsresolvecomponent","text":"options.resolveComponent","depth":4},{"id":"optionsfallback","text":"options.fallback","depth":4},{"id":"optionsssr","text":"options.ssr","depth":4},{"id":"返回值","text":"返回值","depth":3},{"id":"loadablecomponent","text":"LoadableComponent","depth":4}],"domain":"","content":"\n\n用于创建 Loadable 的组件。\n\n\n使用姿势\n\n\n\n\n函数签名\n\ntype Options = {\n  resolveComponent?: (\n    module: Module,\n    props: Props,\n  ) => React.ComponentType<Props>,\n  fallback?: JSX.Element;\n  ssr?: boolean;\n}\n\nfunction loadable(loadFn: Function, options?: Options) => LoadableComponent\n\n\n\n参数\n\nloadFn\n\n用于加载组件。\n\n\n\nconst OtherComponent = loadable(() => import('./OtherComponent'));\n\n\noptions.resolveComponent\n\n类型：(module: Module, props: Props) => React.ComponentType<Props>\n\nmodule 为 loadFn 返回的组件，props 是 loadable 返回的组件接受的 props 参数。默认的话，我们认为 import\n的文件都是默认导出 react 组件，这时候直接渲染该组件即可。但当组件是具名导出的，或者我们需要根据具体的 props\n动态判断需要渲染哪个组件的时候，可以使用 resolveComponent 来实现。下面是一个示例：\n\nexport const Apple = () => 'Apple!';\nexport const Orange = () => 'Orange!';\n\n\nconst LoadableApple = loadable(() => import('./components'), {\n  resolveComponent: components => components.Apple,\n});\nconst LoadableOrange = loadable(() => import('./components'), {\n  resolveComponent: components => components.Orange,\n});\nconst LoadableFruit = loadable(() => import('./components'), {\n  resolveComponent: (components, props) => components[props.fruit],\n});\n\n\noptions.fallback\n\n是否在 loading 阶段显示 fallback 内容。\n\noptions.ssr\n\n是否支持 SSR，默认值是 true。\n\n\n返回值\n\nLoadableComponent\n\ntype LoadableComponent<Props> = React.ComponentType<\n  Props & { fallback?: JSX.Element }\n> & {\n  preload(props?: Props): void;\n  load(props?: Props): Promise<React.ComponentType<Props>>;\n};\n","frontmatter":{"title":"loadable"}},{"id":360,"title":"Hook","routePath":"/apis/app/runtime/web-server/hook","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2},{"id":"redirect","text":"Redirect","depth":3},{"id":"rewrite","text":"Rewrite","depth":3},{"id":"html-内容注入","text":"HTML 内容注入","depth":3}],"domain":"","content":"\n\n用于拓展 Modern.js 内置的 Web Server，非 BFF 请求会经过这些中 Hook 的处理。\n\nNOTE\n\n更多内容可以查看自定义 Web Server。\n\n\n使用姿势\n\n\n\nexport const afterMatch: AfterMatchHook = (context, next) => {};\nexport const afterRender: AfterRenderHook = (context, next) => {};\n\n\n自定义 Web Server\n\n使用该 API 前，请先执行 pnpm run new 新建「自定义 Web Serve」源码目录。\n\npnpm run new\n? 请选择你想要的操作 创建工程元素\n? 新建「自定义 Web Server」源码目录\n\n\n\n函数签名\n\ntype HookContext = {\n  response: {\n    set: (key: string, value: string) => void;\n    status: (code: number) => void;\n    cookies: {\n      get: (key: string) => string;\n      set: (key: string, value: string) => void;\n      delete: () => void;\n      clear: () => void;\n    };\n    raw: (\n      body: string,\n      { status, headers }: { status: number; headers: Record<string, any> },\n    ) => void;\n  };\n  request: {\n    url: string;\n    host: string;\n    pathname: string;\n    query: Record<string, any>;\n    cookie: string;\n    cookies: {\n      get: (key: string) => string;\n    };\n    headers: IncomingHttpHeaders;\n  };\n};\n\nfunction Hook(context: HookContext, next: NextFunction): Promsie<void> | void;\n\n\n另外，不同 Hook 额外提供了不同的上下文。目前 Modern.js 支持 AtferMatch 和 AfterRender 两个 Hook。\n\ntype AfterMatchContext = HookContext & {\n  router: {\n    redirect: (url: string, status: number) => void;\n    rewrite: (entry: string) => void;\n  };\n};\n\ntype AfterRenderContext = {\n  template: {\n    get: () => string;\n    set: (html: string) => void;\n    prependHead: (fragment: string) => void;\n    appendHead: (fragment: string) => void;\n    prependBody: (fragment: string) => void;\n    appendBody: (fragment: string) => void;\n  };\n};\n\n\n\n参数\n\n * context：提供当前 Hook 上下文。\n   * response：提供一系列处理响应的操作\n   * request：提供一系列获取请求信息的操作\n   * router：提供对响应路由的快捷操作\n   * template：提供对响应内容的快捷操作\n * next：执行当前 Hook 的下一个监听函数（不影响整体服务端流程）。\n\n\n示例\n\n\nRedirect\n\n将页面重定向到站点外的页面，例如跳转到统一登录页：\n\n\n\nexport const afterMatch: AfterMatch = async (ctx, next) => {\n  ctx.router.redirect('https://website.com/login', 302);\n};\n\n\n\nRewrite\n\n将页面重写到当前站点的其他页面，例如同一个路由根据 UA 返回适配不同端的页面：\n\n\n\nexport const afterMatch: AfterMatch = async (ctx, next) => {\n  ctx.router.rewrite('mobile');\n};\n\n\n\nHTML 内容注入\n\n为页面注入某些与渲染主体无关的 HTML 内容，如脚本、页面骨架等：\n\n\n\nexport const afterRender: AfterRenderHook = (context, next) => {\n  ctx.template.prependBody('<div>Footer</div>');\n};\n","frontmatter":{"title":"Hook"}},{"id":361,"title":"Middleware","routePath":"/apis/app/runtime/web-server/middleware","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"函数签名","text":"函数签名","depth":2},{"id":"参数","text":"参数","depth":3},{"id":"示例","text":"示例","depth":2},{"id":"服务端耗时打点","text":"服务端耗时打点","depth":3},{"id":"注入服务端工具--数据","text":"注入服务端工具 & 数据","depth":3}],"domain":"","content":"\n\n用于拓展 Modern.js 内置的 Web Server，只有 SSR 请求会经过这些中间件。\n\n与 Hook 不同的是，Middleware 可以使用 Server 运行时框架拓展。\n\nNOTE\n\n更多内容可以查看自定义 Web Server。\n\n\n使用姿势\n\n\n\nexport const middleware: Middleware = async (context, next) => {};\nexport const middleware: Middleware[] = [\n  async (context, next) => {},\n  async (context, next) => {},\n];\n\n\n自定义 Web Server\n\n使用该 API 前，请先执行 pnpm run new 新建「自定义 Web Server」源码目录。\n\npnpm run new\n? 请选择你想要的操作 创建工程元素\n? 新建「自定义 Web Server」源码目录\n\n\n\n函数签名\n\ntype MiddlewareContext = {\n  response: {\n    set: (key: string, value: string) => void;\n    status: (code: number) => void;\n    cookies: {\n      get: (key: string) => string;\n      set: (key: string, value: string) => void;\n      delete: () => void;\n      clear: () => void;\n      apply: () => void;\n    };\n    raw: (\n      body: string,\n      { status, headers }: { status: number; headers: Record<string, any> },\n    ) => void;\n    locals: Record<string, any>;\n  };\n  request: {\n    url: string;\n    host: string;\n    pathname: string;\n    query: Record<string, any>;\n    cookie: string;\n    cookies: {\n      get: (key: string) => string;\n    };\n    headers: IncomingHttpHeaders;\n  };\n  source: {\n    req: IncomingMessage;\n    res: ServerResponse;\n  };\n};\n\ntype RequestHandler = (\n  context: Context,\n  next: NextFunction,\n) => Promise<void> | void;\n\n\n\n参数\n\n * context：提供当前 Hook 上下文。\n   * response：提供一系列处理响应的操作\n   * request：提供一系列获取请求信息的操作\n   * source：提供 Node.js 原生的 req 与 res 对象。\n * next：执行当前 Hook 的下一个监听函数（不影响整体服务端流程）。\n\n\n示例\n\n\n服务端耗时打点\n\nexport const Middleware = () => async (ctx, next) => {\n  const start = Date.now();\n  ctx.res.once('finish', () => {\n    console.log(Date.now() - start);\n  });\n};\n\n\n\n注入服务端工具 & 数据\n\nModern.js 提供了 res.locals 属性用来存放当前请求的局部变量。\n\nexport const Middleware = () => async (ctx, next) => {\n  ctx.res.locals.id = 'Modern.js';\n  ctx.res.locals.rpc = createRpcInstance();\n});\n","frontmatter":{"title":"Middleware"}},{"id":363,"title":"change","routePath":"/apis/monorepo/commands/change","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern change [options]\n\n创建变更集\n\nOptions:\n  --empty     创建空变更集 (default: false)\n  --open      使用编辑器中打开创建的变更集 (default: false)\n  -h, --help  display help for command\n\n\nINFO\n\nchange、pre、bump、release 命令集成了工具 changesets 管理版本变更和 Changelog。\n\nmodern change 命令添加 changeset：\n\n$ npx modern change\n🦋  Which packages would you like to include? · package-a, package-b\n🦋  Which packages should have a major bump? · No items were selected\n🦋  Which packages should have a minor bump? · No items were selected\n🦋  The following packages will be patch bumped:\n🦋  package-a@0.1.0\n🦋  package-b@0.1.0\n🦋  Please enter a summary for this change (this will be in the changelogs). Submit empty line to open external editor\n🦋  Summary · test publish\n🦋  === Releasing the following packages ===\n🦋  [Patch]\n🦋    package-a, package-b\n🦋  ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n🦋  ║                                                      ========= NOTE ========                                                       ║\n🦋  ║All dependents of these packages that will be incompatible with the new version will be patch bumped when this changeset is applied.║\n🦋  ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n🦋  Is this your desired changeset? (Y/n) · true\n🦋  Changeset added! - you can now commit it\n🦋\n🦋  If you want to modify or expand on the changeset summary, you can find it here\n🦋  info /xxxx/monorepo/.changeset/long-lizards-talk.md\n\n\n上面我们给 package-a 和 package-b 都选择了 patch 变更，具体的变更信息在 monorepo 根目录下的\n.changeset/long-lizards-talk.md 中:\n\n---\n'package-a': patch\n'package-b': patch\n---\n\ntest publish\n","frontmatter":{"sidebar_position":2}},{"id":364,"title":"clear","routePath":"/apis/monorepo/commands/clear","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern clear [options]\n\nclear project dirs\n\nOptions:\n  --remove-dirs [dirs...]  remove dirs, default is node_modules\n  -h, --help               display help for command\n\n\n默认对 Monorepo 以及 Monorepo 子项目的 node_modules 进行清理。\n\n可以通过参数 --remove-dirs 来指定要删除的目录，例如执行：\n\n$ npx modern clear --remove-dirs dist\n\n\n则会清理所有 Monorepo 子项目的 dist 目录。","frontmatter":{"sidebar_position":8}},{"id":365,"title":"deploy","routePath":"/apis/monorepo/commands/deploy","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern deploy [options]\n\ndeploy project\n\nOptions:\n  -p, --path [path]  Specify the path of the product output (default: \"output\")\n  -h, --help         display help for command\n\n\n对指定的项目进行部署，会通过指定项目分析其依赖的 Monorepo 下的子项目。\n\n在执行命令之后，会首先生成 output 目录，在目录当中包含了指定部署的项目以及其依赖的子项目，形成一个最小集合的 Monorepo。\n\n补充信息\n\noutput 目录是默认目录，可以通过 -p 参数进行自定义。\n\n然后会在 output 目录下进行依赖的安装以及必要文件的复制。\n\n最后当依赖安装完成后，便完成了对指定项目的部署任务。\n\n例如部署项目名称为 app 的应用，则可以执行：\n\npnpm deploy app\n\n\n补充信息\n\n其中 app 为项目的 package.json 的 name 值。","frontmatter":{"sidebar_position":7}},{"id":366,"title":"gen-release-note","routePath":"/apis/monorepo/commands/gen-release-note","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern gen-release-note [options]\n\n根据当前仓库 changeset 文件生成 Release Note\n\nOptions:\n  --repo <repo>      仓库名称，用于生成 Pull Request 链接， 例如： modern-js-dev/modern.js\n  --custom <cumtom>  自定义 Release Note 生成函数\n  -h, --help         display help for command\n\n\n根据当前仓库的 changeset 信息自动生成 Release Note。\n\n注意\n\n需要在 bump 命令之前执行。\n\n## Features:\n\n[[#1160](https://github.com/modern-js-dev/modern.js/pull/1160)] export ExecaError type\n\n## Bug Fix:\n\n[[#1264](https://github.com/modern-js-dev/modern.js/pull/1264)] fix: conventional router app use App.init not work\n","frontmatter":{"sidebar_position":9}},{"id":367,"title":"命令","routePath":"/apis/monorepo/commands/","lang":"zh","toc":[],"domain":"","content":"\n\n本节涵盖了使用 Monorepo 工程的所有命令。","frontmatter":{"type":"ref"}},{"id":368,"title":"lint","routePath":"/apis/monorepo/commands/lint","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern lint [options] [...files]\n\nlint and fix source files\n\nOptions:\n  --no-fix    disable auto fix source file\n  -h, --help  display help for command\n\n\n运行 ESLint 检查 monorepo 中代码语法情况， 通长情况下，我们只需要在 git commit 阶段通过 lint-staged\n检查本次提交修改的部分代码。\n\n * --no-fix 参数设置后可以关闭自动修复 lint 错误代码的能力。","frontmatter":{"sidebar_position":6}},{"id":369,"title":"new","routePath":"/apis/monorepo/commands/new","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern new [options]\n\nMonorepo 创建子项目\n\nOptions:\n  -d, --debug            开启 Debug 模式，打印调试日志信息 (default: false)\n  -c, --config <config>  生成器运行默认配置(JSON 字符串)\n  --dist-tag <tag>       生成器使用特殊的 npm Tag 版本\n  --registry             生成器运行过程中定制 npm Registry\n  -h, --help             display help for command\n\n\nmodern new 命令在 monorepo 中可以用来添加应用工程和可复用的模块：\n\n$ modern new\n? 请选择你想创建的工程类型 (Use arrow keys)\n❯ 应用\n  应用（测试）\n  模块\n  模块（内部）\n\n\n应用工程默认会添加到 apps 目录， 测试应用会添加到 examples 目录，公共模块默认会添加到 packages 目录， 内部模块默认会添加到\nfeatures 目录。\n\n内部模块在 monorepo 的应用里面使用时，可以无需构建直接使用源码。\n\n注意\n\n--config 参数对应参数值需要使用 JSON 字符串。\n\npnpm 暂不支持使用 JSON 字符串作为参数值，可使用 npm new 开启相关功能。【相关 Issue】","frontmatter":{"sidebar_position":1}},{"id":370,"title":"pre","routePath":"/apis/monorepo/commands/pre","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern pre [options] <enter|exit> [tag]\n\n进入和退出预发布模式\n\nOptions:\n  -h, --help  display help for command\n\n\n可以使用 modern pre 命令在正式发布前预发布一个版本。\n\n首先 modern pre enter <tag> 进入预发布模式:\n\n$ npx modern pre enter next\n🦋  success Entered pre mode with tag next\n🦋  info Run `changeset version` to version packages with prerelease versions\n\n\n之后通过 modern change 命令添加 changeset:\n\n$ npx modern change\n🦋  Which packages would you like to include? · package-a, package-b\n🦋  Which packages should have a major bump? · No items were selected\n🦋  Which packages should have a minor bump? · No items were selected\n🦋  The following packages will be patch bumped:\n🦋  package-a@0.1.1\n🦋  package-b@0.1.1\n🦋  Please enter a summary for this change (this will be in the changelogs). Submit empty line to open external editor\n🦋  Summary · test pre publish\n🦋  === Releasing the following packages ===\n🦋  [Patch]\n🦋    package-a, package-b\n🦋  ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n🦋  ║                                                      ========= NOTE ========                                                       ║\n🦋  ║All dependents of these packages that will be incompatible with the new version will be patch bumped when this changeset is applied.║\n🦋  ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n🦋  Is this your desired changeset? (Y/n) · true\n🦋  Changeset added! - you can now commit it\n🦋\n🦋  If you want to modify or expand on the changeset summary, you can find it here\n🦋  info /xxxxxx/monorepo/.changeset/beige-paws-rule.md\n\n\n接着可以使用 modern bump 命令更新具体的版本号：\n\n$ npx modern bump\n🦋  warn ===============================IMPORTANT!===============================\n🦋  warn You are in prerelease mode\n🦋  warn If you meant to do a normal release you should revert these changes and run `changeset pre exit`\n🦋  warn You can then run `changeset version` again to do a normal release\n🦋  warn ----------------------------------------------------------------------\n🦋  All files have been updated. Review them and commit at your leisure\n\n\n可以看到 package-a 和 package-b 的 package.json 中版本号均已更新到 0.1.2-next.0。\n\n提交完变更之后，我们可以通过 modern pre exit 命令退出预发布模式。","frontmatter":{"sidebar_position":3}},{"id":371,"title":"release","routePath":"/apis/monorepo/commands/release","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern release [options]\n\npublish changes to npm\n\nOptions:\n  --tag <tag>  publish use special tag (default: \"\")\n  -h, --help   display help for command\n\n\n发布当前仓库的 Packages 至 NPM。","frontmatter":{"sidebar_position":5}},{"id":372,"title":"upgrade","routePath":"/apis/monorepo/commands/upgrade","lang":"zh","toc":[],"domain":"","content":"\n\nUsage: modern upgrade [options]\n\n升级 Modern.js 到最新版本\n\nOptions:\n  --registry <registry>  定制 npm registry (default: \"\")\n  -d,--debug             开启 Debug 模式，打印调试日志信息 (default: false)\n  --cwd <cwd>            项目路径 (default: \"\")\n  -h, --help             display help for command\n\n\nmodern upgrade 命令，用于升级项目 Modern.js 相关依赖至最新版本。\n\n在项目根目录下执行命令 npx modern upgrade，会默认将当前执行命令项目的 package.json 中的 Modern.js\n相关依赖更新至最新版本。","frontmatter":{"sidebar_position":11}},{"id":373,"title":"apps/*","routePath":"/apis/monorepo/hooks/apps","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案应用类型项目目录。\n\nModern.js Monorepo 工程方案约定将应用类型子项目放置在 apps 目录下进行统一管理，apps 目录下每一个文件夹都是一个完整的应用项目。\n\nINFO\n\n可直接在项目下执行 new 命令创建应用类型子项目。","frontmatter":{"title":"apps/*","sidebar_position":1}},{"id":374,"title":"monorepo.code-workspace","routePath":"/apis/monorepo/hooks/code-workspace","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案 VS Code 配置文件。\n\nMonorepo 工程方案支持 VS Code Workspace 配置，可以通过该配置文件打开的一个或多个文件夹的集合。\n\nVS Code workspace 协议详情可查看: VS Code Workspace","frontmatter":{"title":"monorepo.code-workspace","sidebar_position":7}},{"id":375,"title":"examples/*","routePath":"/apis/monorepo/hooks/examples","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案测试应用类型项目目录。\n\nModern.js Monorepo 工程方案约定将测试的应用类型子项目放置在 examples 目录下进行统一管理，examples\n目录下每一个文件夹都是一个完整的应用项目。\n\n测试类型的应用项目不包含部署相关的 scripts 命令，用于开发过程中进行测试项目、测试案例的编写。\n\nINFO\n\n可直接在项目下执行 new 命令创建测试应用类型子项目。","frontmatter":{"title":"examples/*","sidebar_position":2}},{"id":376,"title":"features/","routePath":"/apis/monorepo/hooks/features","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案内部模块类型项目目录。\n\nModern.js Monorepo 工程方案约定将内部模块类型子项目放置在 features 目录下进行统一管理，features\n目录下每一个文件夹都是一个完整的模块项目。\n\n内部模块项目用于一些不需要编译的公共的组件和工具的编写，这类型的项目不包含编译、发布命令，在应用类型项目中引用时，应用类型项目会默认对其进行编译。\n\nINFO\n\n可直接在项目下执行 new 命令内部模块类型子项目。","frontmatter":{"title":"features/","sidebar_position":3}},{"id":377,"title":"命令","routePath":"/apis/monorepo/hooks/","lang":"zh","toc":[],"domain":"","content":"\n\n本节涵盖了使用 Monorepo 工程所有的文件约定","frontmatter":{"type":"ref"}},{"id":378,"title":"packages/","routePath":"/apis/monorepo/hooks/packages","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案公共模块类型项目目录。\n\nModern.js Monorepo 工程方案约定将公共模块类型子项目放置在 packages 目录下进行统一管理，packages\n目录下每一个文件夹都是一个完整的模块项目。\n\n公共模块项目用户一些公共的组件和工具的编写，这些公共包可自行进行编译和发布，也可在应用类型项目中引用。\n\nINFO\n\n可直接在项目下执行 new 命令创建模块类型子项目。","frontmatter":{"title":"packages/","sidebar_position":4}},{"id":379,"title":"pnpm-workspace.yaml","routePath":"/apis/monorepo/hooks/pnpm-workspace","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案 pnpm workspace 配置文件。\n\nMonorepo 工程方案支持使用 pnpm 作为包管理工具对项目进行管理，支持 pnpm 的 workspace 协议。\n\npnpm workspace 配置详情可查看: pnpm workspace","frontmatter":{"title":"pnpm-workspace.yaml","sidebar_position":5}},{"id":380,"title":".pnpmfile.cjs","routePath":"/apis/monorepo/hooks/pnpmfile","lang":"zh","toc":[],"domain":"","content":"\n\nMonorepo 工程方案 pnpm 钩子文件。\n\nMonorepo 工程方案支持使用 pnpm 作为包管理工具对项目进行管理，支持使用 pnpm 的钩子文件对安装过程进行自定义。\n\npnpm .pnpmfile.cjs 使用详情可查看: pnpmfile","frontmatter":{"title":".pnpmfile.cjs","sidebar_position":6}},{"id":381,"title":"Modern.js 2.0","routePath":"/blog/","lang":"zh","toc":[],"domain":"","content":"\n\n> 即将到来","frontmatter":{"title":"Modern.js 2.0"}},{"id":382,"title":"社区","routePath":"/community/","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 社区正在建设中，敬请关注！","frontmatter":{}},{"id":383,"title":"autoLoadPlugins (自动注册插件)","routePath":"/configure/app/auto-load-plugin","lang":"zh","toc":[{"id":"手动注册插件","text":"手动注册插件","depth":3},{"id":"自动注册插件","text":"自动注册插件","depth":3}],"domain":"","content":"\n\n * 类型： boolean\n * 默认值： false\n\n用于配置 Modern.js 是否开启自动注册插件。\n\n\n手动注册插件\n\n默认情况下，安装插件后，你需要在 modern.config.ts 文件中手动注册插件。\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), i18nPlugin()],\n});\n\n\n\n自动注册插件\n\n除了手段注册，Modern.js 还提供自动注册插件的方式: 将 autoLoadPlugin 配置项置为 true。\n\n\n\nexport default defineConfig({\n  autoLoadPlugins: true,\n});\n\n\nModern.js 将通过以下几个步骤帮你自动注册插件\n\n 1. Modern.js 在内部维护一份官方插件列表。\n\nconst InternalPlugins = ['@modern-js/app-tools', '@modern-js/plugin-i18n', ...];\n\n\n 2. Modern.js 将读取你的 package.json 文件，收集依赖信息。\n\n\"dependencies\": {\n  \"@modern-js/plugin-i18n\": \"x.x.x\"\n  ...\n},\n\"devDependencies\": {\n  \"@modern-js/app-tools\": \"x.x.x\"\n  ...\n}\n\n\n 3. Modern.js 观察到你安装了 @modern-js/plugin-i18n 和 @modern-js/app-tools\n    等依赖后，将会引入插件自动注册。\n\n可以注意到这种方式相对黑盒，你甚至对加载插件的过程是无感知的。我们希望更多的细节暴露给开发者，能让开发者去控制这一过程。\n\n因此我们更加推荐你手动注册插件。","frontmatter":{"title":"autoLoadPlugins (自动注册插件)","sidebar_position":11}},{"id":384,"title":"bff.prefix","routePath":"/configure/app/bff/prefix","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： string\n * 默认值： /api\n\n注意\n\n请先在当前应用项目根目录使用【new】 启用 BFF 功能。\n\n默认情况下，BFF API 目录下的路由访问前缀是 /api, 如下目录结构：\n\napi\n└── hello.ts\n\n\napi/hello.ts 访问时对应的路由为 localhost:8080/api/hello。\n\n该配置选项可以修改默认的路由前缀：\n\nexport default defineConfig({\n  bff: {\n    prefix: '/api-demo',\n  },\n});\n\n\n对应的 api/hello.ts 访问路由为 localhost:8080/api-demo/hello。","frontmatter":{"sidebar_label":"prefix"}},{"id":385,"title":"bff.proxy","routePath":"/configure/app/bff/proxy","lang":"zh","toc":[{"id":"常见用法","text":"常见用法","depth":2},{"id":"解决接口跨域问题","text":"解决接口跨域问题","depth":3}],"domain":"","content":"\n\n * 类型： Record<string, string>\n * 默认值： {}\n\n补充信息\n\n请先在当前应用项目根目录使用【new】 启用 BFF 功能。\n\n通过简单配置，无需编写代码，Modern.js 会自动转发请求。发送给 Modern.js BFF server 的请求，会代理到指定的服务上。 BFF\nProxy 使用了强大的 http-proxy-middleware，如果需要更多高级的用法， 可以查看它的文档。\n\n在 modern.server-runtime.config.js 中加入以下配置；即可开启代理：\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api': 'https://cnodejs.org',\n    },\n  },\n});\n\n\n假设启动的 Modern.js BFF server 的服务地址是 localhost:8080，所有 path 以 api 开头的请求都会被拦截，如发送到\nlocalhost:8080/api/v1/topics 的请求会被代理到 https://cnodejs.org/api/v1/topics。\n\n你可以做路径的重写，如将发送到 localhost:8080/api/topics 的请求代理到\nhttps://cnodejs.org/api/v1/topics。\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api': {\n        target: 'https://cnodejs.org',\n        pathRewrite: { '/api/topics': '/api/v1/topics' },\n        changeOrigin: true,\n      },\n    },\n  },\n});\n\n\n与 dev.proxy 不同，本节所介绍的代理只作用于进入 BFF/API 服务的请求；同时，这一配置不但可以在开发环境中使用，在生产环境中也会代理相应的请求。\n\n\n常见用法\n\n\n解决接口跨域问题\n\n在项目开发过程中，因为 web 页面和接口服务不是部署在同一个域名下，常常会遇到跨域问题。 解决跨域问题的方式有很多，在这里我们使用 bff.proxy\n可以轻松解决跨域问题。\n\nINFO\n\nBFF proxy 模式下，如果不需要写 BFF 的接口， API 目录可以删除；此时 BFF proxy 仍会开启。\n\n如下所示，在 modern.server-runtime.config.ts 中，写入如下配置；我们将所有 web 页面发送到同域的以 /api\n开头的请求代理到另一个域名的服务上。\n\nexport default defineServerConfig({\n  bff: {\n    proxy: {\n      '/api': 'https://cnodejs.org',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"proxy"}},{"id":386,"title":"builderPlugins (构建插件)","routePath":"/configure/app/builder-plugins","lang":"zh","toc":[{"id":"注意事项","text":"注意事项","depth":2},{"id":"何时使用","text":"何时使用","depth":2},{"id":"示例","text":"示例","depth":2},{"id":"使用-npm-上的插件","text":"使用 npm 上的插件","depth":3},{"id":"使用本地插件","text":"使用本地插件","depth":3},{"id":"插件配置项","text":"插件配置项","depth":3}],"domain":"","content":"\n\n * 类型： BuilderPlugin[]\n * 默认值： []\n\n用于配置 Modern.js Builder 构建插件。\n\nModern.js Builder 是 Modern.js 底层的构建引擎，请阅读 构建能力 了解相关背景。\n\n如果你想了解 Builder 插件的编写方式，可以参考 Modern.js Builder - 插件系统。\n\n\n注意事项\n\n该选项用于配置 Modern.js Builder 构建插件，如果你需要配置其他类型的插件，请选择对应的配置方式：\n\n * 配置 Modern.js 框架插件，请使用 plugins 配置项。\n * 配置 webpack 插件，请使用 tools.webpack 或 tools.webpackChain 配置项。\n * 配置 Babel 插件，请使用 tools.babel 配置项。\n\n\n何时使用\n\n大部分场景下，我们推荐你使用 Modern.js 框架插件，框架插件可以通过 plugins 字段进行注册。因为框架插件提供的 API 更丰富、能力更强，而\nBuilder 插件提供的 API 只能用于构建场景。\n\n当你需要引用一些现有的 Builder 插件（并且在 Modern.js 中没有相关能力），或是在不同的框架之间复用 Builder 插件时，你可以使用\nbuilderPlugins 字段进行注册。\n\n\n示例\n\n下面是 Builder 插件的使用示例。\n\n\n使用 npm 上的插件\n\n使用 npm 上的插件，需要通过包管理器安装插件，并通过 import 引入。\n\n\n\nexport default defineConfig({\n  builderPlugins: [myBuilderPlugin()],\n});\n\n\n\n使用本地插件\n\n使用本地代码仓库中的插件，直接通过相对路径 import 引入即可。\n\n\n\nexport default defineConfig({\n  builderPlugins: [myBuilderPlugin()],\n});\n\n\n\n插件配置项\n\n如果插件提供了一些自定义的配置项，可以通过插件函数的参数传入配置。\n\n\n\nexport default defineConfig({\n  builderPlugins: [\n    myBuilderPlugin({\n      foo: 1,\n      bar: 2,\n    }),\n  ],\n});\n","frontmatter":{"title":"builderPlugins (构建插件)","sidebar_position":10}},{"id":387,"title":"deploy.microFrontend","routePath":"/configure/app/deploy/microFrontend","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2},{"id":"配置项","text":"配置项","depth":2},{"id":"enablehtmlentry","text":"enableHtmlEntry","depth":3},{"id":"externalbasiclibrary","text":"externalBasicLibrary","depth":3}],"domain":"","content":"\n\n * 类型： object\n * 默认值： { enableHtmlEntry: true, externalBasicLibrary: false }\n\ninterface MicroFrontend {\n  enableHtmlEntry?: boolean;\n  externalBasicLibrary?: boolean;\n  moduleApp?: string;\n}\n\n\n开发者可使用 deploy.microFrontend 属性来配置微前端子应用的信息。\n\n注意\n\n需要先通过 pnpm run new 启用「微前端」 功能。\n\n\n示例\n\nexport default defineConfig({\n  deploy: {\n    microFrontend: {\n      enableHtmlEntry: true,\n    },\n  },\n});\n\n\n\n配置项\n\n\nenableHtmlEntry\n\n * 类型： boolean\n\n * 默认值： true\n\n是否启用 html 入口的功能，默认为 true，将子应用构建成 HTML 模式，Garfish 支持了 html 入口，可以开启开选项，体验对应功能，为\nHTML 入口时直接将子应用 entry 指向子应用的 html 即可。\n\n可以通过设置为 false, 表明子应用构建为 js，构建为 js 后子应用无法独立运行，为 JS 入口时将子应用的入口文件指向子应用的 JS\n\n\nexternalBasicLibrary\n\n * 类型： boolean\n\n * 默认值： false\n\n是否 external 基础库，当设置为 true 时，当前子应用将会 external：react、react-dom，EdenX 主应用会自动\nsetExternal 这两个基础库，如果其他类型的框架请通过 Garfish.setExternal 增加 react、react-dom 依赖","frontmatter":{"sidebar_label":"microFrontend"}},{"id":388,"title":"dev.assetPrefix","routePath":"/configure/app/dev/asset-prefix","lang":"zh","toc":[{"id":"boolean-类型","text":"Boolean 类型","depth":4},{"id":"string-类型","text":"String 类型","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.assetPrefix。\n\n * 类型： boolean | string\n * 默认值： '/'\n\n设置开发环境下的静态资源 URL 前缀，对应 webpack 的 output.publicPath 配置。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于开发环境。在生产环境下，请使用 output.assetPrefix 配置项进行设置。\n\nBoolean 类型\n\n如果设置 assetPrefix 为 true，Builder 会自动计算出 //ip:port/ 作为 URL 前缀：\n\nexport default {\n  dev: {\n    assetPrefix: true,\n  },\n};\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n<script defer src=\"//${ip}:8080/static/js/main.js\"></script>\n\n\n如果设置 assetPrefix 为 false 或不设置，则默认使用 / 作为访问前缀。\n\nString 类型\n\n当 assetPrefix 的值为 string 类型时，字符串会作为前缀，自动拼接到静态资源访问 URL 上：\n\nexport default {\n  dev: {\n    assetPrefix: 'http://example.com/assets/',\n  },\n};\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n<script defer src=\"http://example.com/assets/static/js/main.js\"></script>\n","frontmatter":{"sidebar_label":"assetPrefix"}},{"id":389,"title":"dev.hmr","routePath":"/configure/app/dev/hmr","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.hmr。\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\n当 hmr 设置为 false 时，将不再提供热更新和 react-refresh 功能。\n\nexport default {\n  dev: {\n    hmr: false,\n  },\n};\n","frontmatter":{"sidebar_label":"hmr"}},{"id":390,"title":"dev.https","routePath":"/configure/app/dev/https","lang":"zh","toc":[{"id":"自动生成证书","text":"自动生成证书","depth":4},{"id":"手动设置证书","text":"手动设置证书","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.https。\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n配置该选项后，可以开启 Dev Server 对 HTTPS 的支持，同时会禁用 HTTP 服务器。\n\n开启前：\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n开启后：\n\n  > Local:    https://localhost:8080/\n  > Network:  https://192.168.0.1:8080/\n\n\n自动生成证书\n\n你可以直接将 https 设置为 true，Builder 会基于 devcert 来自动生成 Dev Server 所需的 HTTPS 证书。\n\n使用这种方式时，你需要在当前项目中手动安装 devcert 依赖：\n\n# npm\nnpm install devcert@1.2.2 -D\n\n# yarn\nyarn add devcert@1.2.2 -D\n\n# pnpm\npnpm add devcert@1.2.2 -D\n\n\n然后配置 dev.https 为 true 即可：\n\nexport default {\n  dev: {\n    https: true,\n  },\n};\n\n\n该方式有一定局限性，由于 devcert 目前不支持 IP addresses，因此访问 Network 域名时，会遇到「您的连接不是私密连接」的问题。\n\n此问题的解决方法为：点击 Chrome 浏览器问题页面的「高级」->「继续前往 192.168.0.1（不安全）」。\n\nTIP\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。 密码仅在信任证书时使用，不会泄漏或者用于其他环节。\n\n手动设置证书\n\n你也可以在 dev.https 选项中手动传入 HTTPS 服务器所需要的证书和对应的私钥，这个参数将直接传递给 Node.js 中 https 模块的\ncreateServer。\n\n具体可以参考 https.createServer。\n\n\n\nexport default {\n  dev: {\n    https: {\n      key: fs.readFileSync('certificates/private.pem'),\n      cert: fs.readFileSync('certificates/public.pem'),\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"https"}},{"id":391,"title":"dev.port","routePath":"/configure/app/dev/port","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.port。\n\n * 类型： number\n * 默认值： 8080\n\n设置 Dev Server 监听的端口号。\n\n默认情况下，Dev Server 会监听 8080 端口，并在端口被占用时自动递增端口号。\n\n\n示例\n\n将端口设置为 3000：\n\nexport default {\n  dev: {\n    port: 3000,\n  },\n};\n","frontmatter":{"sidebar_label":"port"}},{"id":392,"title":"dev.progressBar","routePath":"/configure/app/dev/progress-bar","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.progressBar。\n\n * 类型：\n\ntype ProgressBar =\n  | boolean\n  | {\n      id?: string;\n    };\n\n\n * 默认值： true\n\n是否在编译过程中展示进度条。\n\nexport default {\n  dev: {\n    progressBar: false,\n  },\n};\n\n\n如果需要修改进度条左侧显示的文本内容，可以设置 id 选项：\n\nexport default {\n  dev: {\n    progressBar: {\n      id: 'Some Text',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"progressBar"}},{"id":393,"title":"dev.proxy","routePath":"/configure/app/dev/proxy","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： string | Object\n * 默认值： null\n\n配置该选项后，开发环境时会启动全局代理，类似 Fiddler, Charles 等 web 代理调试工具，可以用来查看、修改 HTTP/HTTPS\n请求、响应、也可以用作代理服务器。\n\n提示\n\n使用该选项需要提前安装 @modern-js/plugin-proxy。\n\n值为 Object 时，对象的 key 对应匹配的 pattern，对象的 value 对应匹配的 target。\n\n例如：\n\nexport default defineConfig({\n  dev: {\n    proxy: {\n      'https://www.baidu.com': 'https://google.com.hk',\n      //可以通过 file 协议直接返回静态文件。\n      'https://example.com/api': 'file://./data.json',\n    },\n  },\n});\n\n\n值为 string 时， 可以用来指定单独的代理文件，例如：\n\nexport default defineConfig({\n  dev: {\n    proxy: './proxy.js',\n  },\n});\n\n\nmodule.exports = {\n  name: 'my-app',\n  rules: `\n    ^example.com:8080/api/***   http://localhost:3001/api/$\n  `,\n};\n\n\nINFO\n\nModern.js 全局代理实现底层基于 whistle, 更多匹配模式请参考: 匹配模式\n\n执行 dev, 提示如下时，即代理服务器启动成功：\n\n  App running at:\n\n  Local:    http://localhost:8080/\n  Network:  http://192.168.0.1:8080/\n\nℹ  info      Starting the proxy server.....\n✔  success   Proxy Server start on localhost:8899\n\n\n访问 localhost:8899, 可以在 UI 界面上查看 Network 以及配置代理规则：\n\n\n\n注意\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。密码仅在信任证书时使用，不会泄漏或者用于其他环节。","frontmatter":{"sidebar_label":"proxy"}},{"id":394,"title":"dev.startUrl","routePath":"/configure/app/dev/start-url","lang":"zh","toc":[{"id":"端口号占位符","text":"端口号占位符","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 dev.startUrl。\n\n * 类型： boolean | string | string[] | undefined\n * 默认值： undefined\n\ndev.startUrl 用于设置 Dev Server 启动时自动在浏览器中打开的页面 URL。\n\n默认情况下，Dev Server 启动时不会打开任何页面。\n\n你可以设置为如下的值：\n\nexport default {\n  dev: {\n    // 打开项目的默认页面，等价于 `http://localhost:<port>`\n    startUrl: true,\n    // 打开指定的页面\n    startUrl: 'http://localhost:8080',\n    // 打开多个页面\n    startUrl: ['http://localhost:8080', 'http://localhost:8080/about'],\n  },\n};\n\n\n\n端口号占位符\n\n由于端口号可能会发生变动，你可以使用 <port> 占位符来指代当前端口号，Builder 会自动将占位符替换为实际监听的端口号。\n\nexport default {\n  dev: {\n    startUrl: 'http://localhost:<port>/home',\n  },\n};\n","frontmatter":{"sidebar_label":"startUrl"}},{"id":395,"title":"experiments.lazyCompilation","routePath":"/configure/app/experiments/lazy-compilation","lang":"zh","toc":[{"id":"延迟编译异步模块","text":"延迟编译异步模块","depth":3},{"id":"延迟编译入口模块","text":"延迟编译入口模块","depth":3},{"id":"局限性","text":"局限性","depth":3},{"id":"禁用拆包规则","text":"禁用拆包规则","depth":4},{"id":"使用代理","text":"使用代理","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 experiments.lazyCompilation。\n\n * 类型：\n\ntype LazyCompilationOptions =\n  | boolean\n  | {\n      // 是否为异步模块开启延迟编译\n      imports?: boolean;\n      // 是否为入口模块开启延迟编译\n      entries?: boolean;\n    };\n\n\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用于开启延迟编译（即按需编译）的能力。当开启此配置项时，Builder 会进行延迟编译，提升项目的编译启动速度。\n\n延迟编译只在开发环境下生效。\n\n\n延迟编译异步模块\n\n延迟编译 Dynamic Import 引入的异步模块：\n\nexport default {\n  experiments: {\n    lazyCompilation: {\n      imports: true,\n      entries: false,\n    },\n  },\n};\n\n\n开启 imports 选项后，所有的异步模块只有在被请求时才触发编译。如果你的项目是一个单页应用（SPA），并通过 Dynamic Import\n进行了路由拆分，那么会有明显的编译提速效果。\n\n\n延迟编译入口模块\n\n除了延迟编译异步模块，你也可以选择同时延迟编译入口模块和异步模块。\n\nexport default {\n  experiments: {\n    lazyCompilation: {\n      imports: true,\n      entries: true,\n    },\n  },\n};\n\n\n以上配置也可以简化为：\n\nexport default {\n  experiments: {\n    lazyCompilation: true,\n  },\n};\n\n\n开启 entries 选项后，当启动编译时，不会编译所有的页面，而是仅在路由跳转到对应的页面时，才对该页面进行编译。\n\n使用延迟编译入口模块时，有以下注意事项：\n\n * 只适用于多页应用（MPA），对单页应用（SPA）没有优化效果。\n * 当你访问一个页面时，由于要等待页面编译完成，会有一段时间的白屏。\n\n\n局限性\n\n禁用拆包规则\n\n当你开启延迟编译时，为了保证编译结果正常，Builder\n会在开发环境下禁用拆包规则。这不会影响生产环境的打包产物，但会导致开发环境和生产环境的打包产物有一定差异。\n\n使用代理\n\nLazy Compilation 依赖 webpack 在本地启动的开发服务器，当你将某个域名代理到 localhost 进行开发时，Lazy\nCompilation 将无法正常工作。因此，如果你需要使用代理时，请禁用 Lazy Compilation。","frontmatter":{"sidebar_label":"lazyCompilation"}},{"id":396,"title":"html.appIcon","routePath":"/configure/app/html/app-icon","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.appIcon。\n\n * 类型： string\n * 默认值： undefined\n\n设置 app icon 的文件路径，可以设置为相对于项目根目录的相对路径，也可以设置为文件的绝对路径。暂不支持设置为 CDN URL。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例\n\n设置为相对路径：\n\nexport default {\n  html: {\n    appIcon: './src/assets/icon.png',\n  },\n};\n\n\n设置为绝对路径：\n\n\n\nexport default {\n  html: {\n    appIcon: path.resolve(__dirname, './src/assets/icon.png'),\n  },\n};\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n<link rel=\"apple-touch-icon\" sizes=\"180*180\" href=\"/static/image/icon.png\" />\n","frontmatter":{"sidebar_label":"appIcon"}},{"id":397,"title":"html.crossorigin","routePath":"/configure/app/html/crossorigin","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.crossorigin。\n\n * 类型： boolean | 'anonymous' | 'use-credentials'\n * 默认值： false\n\n用于设置 <script> 标签的 crossorigin 属性。\n\n传入 true 时，会自动设置为 crossorigin=\"anonymous\"。\n\n\n示例\n\nexport default {\n  html: {\n    crossorigin: 'anonymous',\n  },\n};\n\n\n编译后，HTML 中的 <script> 标签变为：\n\n<script defer src=\"/static/js/main.js\" crossorigin=\"anonymous\"></script>\n","frontmatter":{"sidebar_label":"crossorigin"}},{"id":398,"title":"html.disableHtmlFolder","routePath":"/configure/app/html/disable-html-folder","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.disableHtmlFolder。\n\n * 类型： boolean\n * 默认值： false\n\n移除 HTML 产物对应的文件夹。开启该选项后，生成的 HTML 文件目录会从 [name]/index.html 变为 [name].html。\n\n\n示例\n\n默认情况下，HTML 产物在 dist 目录下的结构为：\n\n/dist\n└── html\n    └── main\n        └── index.html\n\n\n开启 html.disableHtmlFolder 配置:\n\nexport default {\n  html: {\n    disableHtmlFolder: true,\n  },\n};\n\n\n重新编译后，HTML 产物在 dist 中的目录结构如下：\n\n/dist\n└── html\n    └── main.html\n\n\n> 如果需要设置 HTML 文件在 dist 目录中的路径，请使用 output.distPath.html 配置。","frontmatter":{"sidebar_label":"disableHtmlFolder"}},{"id":399,"title":"html.faviconByEntries","routePath":"/configure/app/html/favicon-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.faviconByEntries。\n\n * 类型： Record<string, string>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 favicon。\n\n整体用法与 favicon 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\nfaviconByEntries 的优先级高于 favicon，因此会覆盖 favicon 中设置的值。\n\n\n示例\n\nexport default {\n  html: {\n    favicon: './src/assets/default.png',\n    faviconByEntries: {\n      foo: './src/assets/foo.png',\n    },\n  },\n};\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 favicon 为 ./src/assets/foo.png。\n * 其他页面的 favicon 为 ./src/assets/default.png。","frontmatter":{"sidebar_label":"faviconByEntries"}},{"id":400,"title":"html.favicon","routePath":"/configure/app/html/favicon","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.favicon。\n\n * 类型： string\n * 默认值： undefined\n\n设置页面的 favicon 图标路径，可以设置为相对于项目根目录的相对路径，也可以设置为文件的绝对路径。暂不支持设置为 CDN URL。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例\n\n设置为相对路径：\n\nexport default {\n  html: {\n    favicon: './src/assets/icon.png',\n  },\n};\n\n\n设置为绝对路径：\n\n\n\nexport default {\n  html: {\n    favicon: path.resolve(__dirname, './src/assets/icon.png'),\n  },\n};\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n<link rel=\"icon\" href=\"/favicon.ico\" />\n","frontmatter":{"sidebar_label":"favicon"}},{"id":401,"title":"html.injectByEntries","routePath":"/configure/app/html/inject-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.injectByEntries。\n\n * 类型： Record<string, boolean | string>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 script 标签插入位置。\n\n整体用法与 inject 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ninjectByEntries 的优先级高于 inject，因此会覆盖 inject 中设置的值。\n\n\n示例\n\nexport default {\n  html: {\n    inject: 'head',\n    injectByEntries: {\n      foo: 'body',\n    },\n  },\n};\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 script 标签会插入到 body 标签内。\n * 其他页面的 script 标签会插入到 head 标签内。","frontmatter":{"sidebar_label":"injectByEntries"}},{"id":402,"title":"html.inject","routePath":"/configure/app/html/inject","lang":"zh","toc":[{"id":"默认插入位置","text":"默认插入位置","depth":4},{"id":"插入至-body-标签","text":"插入至 body 标签","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.inject。\n\n * 类型： 'head' | 'body'| 'true' | false\n * 默认值： 'head'\n\n修改构建产物中 <script> 标签在 HTML 中的插入位置。\n\n可以设置为以下值：\n\n * 'head': script 标签会插入在 HTML 的 head 标签内。\n * 'body': script 标签会插入在 HTML 的 body 标签尾部。\n * true: 最终表现取决于 html-webpack-plugin 的 scriptLoading 配置项。\n * false: script 标签不插入 HTML 中。\n\n默认插入位置\n\nscript 标签默认在 head 标签内：\n\n<html>\n  <head>\n    <title></title>\n    <script defer src=\"/static/js/runtime-main.js\"></script>\n    <script defer src=\"/static/js/main.js\"></script>\n    <link href=\"/static/css/main.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n\n插入至 body 标签\n\n添加如下配置，可以将 script 插入至 body 标签：\n\nexport default {\n  html: {\n    inject: 'body',\n  },\n};\n\n\n可以看到 script 标签生成在 body 标签尾部：\n\n<html>\n  <head>\n    <title></title>\n    <link href=\"/static/css/main.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script defer src=\"/static/js/runtime-main.js\"></script>\n    <script defer src=\"/static/js/main.js\"></script>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"inject"}},{"id":403,"title":"html.metaByEntries","routePath":"/configure/app/html/meta-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.metaByEntries。\n\n * 类型： Record<string, Meta>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 meta 标签。\n\n整体用法与 meta 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\nmetaByEntries 的优先级高于 meta，因此会覆盖 meta 中设置的值。\n\n\n示例\n\nexport default {\n  html: {\n    meta: {\n      description: 'ByteDance',\n    },\n    metaByEntries: {\n      foo: {\n        description: 'TikTok',\n      },\n    },\n  },\n};\n\n\n编译后，可以看到页面 foo 的 meta 为：\n\n<meta name=\"description\" content=\"TikTok\" />\n\n\n其他页面的 meta 为：\n\n<meta name=\"description\" content=\"ByteDance\" />\n","frontmatter":{"sidebar_label":"metaByEntries"}},{"id":404,"title":"html.meta","routePath":"/configure/app/html/meta","lang":"zh","toc":[{"id":"字符串用法","text":"字符串用法","depth":4},{"id":"对象用法","text":"对象用法","depth":4},{"id":"移除默认值","text":"移除默认值","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.meta。\n\n * 类型： Record<string, false | string | Record<string, string | boolean>>\n * 默认值： undefined\n\n配置 HTML 页面的 <meta> 标签。\n\n字符串用法\n\n当 meta 对象的 value 为字符串时，会自动将对象的 key 映射为 name，value 映射为 content。\n\n比如设置 description：\n\nexport default {\n  html: {\n    meta: {\n      description: 'a description of the page',\n    },\n  },\n};\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n<meta name=\"description\" content=\"a description of the page\" />\n\n\n对象用法\n\n当 meta 对象的 value 为对象时，会将该对象的 key: value 映射为 meta 标签的属性。\n\n这种情况下默认不会设置 name 和 content 属性。\n\n比如设置 http-equiv：\n\nexport default {\n  html: {\n    meta: {\n      'http-equiv': {\n        'http-equiv': 'x-ua-compatible',\n        content: 'ie=edge',\n      },\n    },\n  },\n};\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n<meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n\n\n\n移除默认值\n\n将 meta 对象的 value 设置为 false，则表示不生成对应的 meta 标签。\n\n比如移除框架预设的 imagemode：\n\nexport default {\n  html: {\n    meta: {\n      imagemode: false,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"meta"}},{"id":405,"title":"html.mountId","routePath":"/configure/app/html/mount-id","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.mountId。\n\n * 类型： string\n * 默认值： 'root'\n\n默认情况下，HTML 模板中包含了 root 节点用于组件挂载，通过 mountId 可以修改该节点的 id。\n\n<body>\n  <div id=\"root\"></div>\n</body>\n\n\n\n示例\n\n修改 DOM 挂载节点 id 为 app：\n\nexport default {\n  html: {\n    mountId: 'app',\n  },\n};\n\n\n编译后：\n\n<body>\n  <div id=\"app\"></div>\n</body>\n\n\nTIP\n\n如果自定义了 HTML 模板，请确保模板中包含 <div id=\"<%= mountId %>\"></div>，否则该配置项无法生效。","frontmatter":{"sidebar_label":"mountId"}},{"id":406,"title":"html.tagsByEntries","routePath":"/configure/app/html/tags-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.tagsByEntries。\n\n * 类型： Record<string, ArrayOrNot<HtmlInjectTag | HtmlInjectTagHandler>>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面注入不同的标签。\n\n整体用法与 tags 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntagsByEntries 的优先级高于 tags，因此会覆盖 tags 中设置的值。\n\n\n示例\n\nexport default {\n  html: {\n    tags: [\n      { tag: 'script', attrs: { src: 'a.js' } }\n    ],\n    tagsByEntries: {\n      foo: [\n        { tag: 'script', attrs: { src: 'b.js' } }\n      ],\n    },\n  },\n};\n\n\n编译后，可以看到页面 foo 注入标签：\n\n<script src=\"b.js\"></script>\n\n\n其他页面则注入了：\n\n<script src=\"a.js\"></script>\n","frontmatter":{"sidebar_label":"tagsByEntries"}},{"id":407,"title":"html.tags","routePath":"/configure/app/html/tags","lang":"zh","toc":[{"id":"对象形式","text":"对象形式","depth":4},{"id":"函数形式","text":"函数形式","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.tags。\n\n * 类型： ArrayOrNot<HtmlInjectTag | HtmlInjectTagHandler>\n * 默认值： undefined\n\n添加和修改最终注入到 HTML 页面的标签。\n\n对象形式\n\nexport interface HtmlInjectTag {\n  tag: string;\n  attrs?: Record<string, string | boolean | null | undefined>;\n  children?: string;\n  /** @default false */\n  hash?: boolean | string | ((url: string, hash: string) => string);\n  /** @default true */\n  publicPath?: boolean | string | ((url: string, publicPath: string) => string);\n  /** @default false */\n  append?: boolean;\n  /**\n   * 仅对于允许包含在 head 中的元素会默认启用\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head#see_also}\n   */\n  head?: boolean;\n}\n\n\n对象形式的配置项可以用于描述需要注入的标签，并可以通过参数控制注入的位置：\n\nexport default {\n  output: {\n    assetPrefix: '//example.com/'\n  },\n  html: {\n    tags: [\n      {\n        tag: 'script',\n        attrs: { src: 'a.js' },\n        head: true,\n        append: true,\n        publicPath: true,\n        hash: true,\n      },\n    ],\n  },\n};\n\n\n这样的配置将会在 HTML 的 head 最后添加一个 script 标签：\n\n<html>\n  <head>\n    <!-- some other headTags... -->\n    <script src=\"//example.com/a.js?8327ec63\"></script>\n  </head>\n  <body>\n    <!-- some other bodyTags... -->\n  </body>\n</html>\n\n\n标签最终的插入位置由 head 和 append 选项决定，两个配置相同的元素将被插入到相同区域，并且维持彼此之间的相对位置。\n\n标签中表示外部资源文件路径的字段会受到 publicPath 和 hash 选项的影响， 这些字段包括 script 标签的 src 和 link 标签的\nhref。\n\n启用 publicPath 会让标签中表示路径的属性被拼接上 output.assetPrefix 字段。 而 hash\n字段会让文件名后多出一个哈希查询用于控制浏览器缓存，哈希字符串与 HTML 文件产物的哈希值相同。\n\n用户也可以向这两个配置传入函数，以自行控制路径拼接的逻辑。\n\n函数形式\n\nexport type HtmlInjectTagUtils = {\n  outputName: string;\n  publicPath: string;\n  hash: string;\n};\n\nexport type HtmlInjectTagHandler = (\n  tags: HtmlInjectTag[],\n  utils: HtmlInjectTagUtils,\n) => HtmlInjectTag[] | void;\n\n\nhtml.tags 也支持传入回调函数，通过在回调中编写逻辑可以任意修改标签列表，常用于修改标签列表或是在插入标签的同时确保其相对位置。\n\n回调函数接受 tags 列表作为参数，并需要修改或直接返回新的 tags 数组：\n\nexport default {\n  html: {\n    tags: [\n      tags => { tags.splice(0, 1); },\n      /* ^?\n       *   { tag: 'script', attrs: { src: 'b.js' } },\n       *   ... some other headTags\n       *   { tag: 'script', attrs: { src: 'c.js' } },\n       *   ... some other bodyTags\n       *   { tag: 'script', attrs: { src: 'a.js' }, head: false },\n       */\n      { tag: 'script', attrs: { src: 'a.js' }, head: false },\n      { tag: 'script', attrs: { src: 'b.js' }, append: false },\n      { tag: 'script', attrs: { src: 'c.js' } },\n      tags => [...tags, { tag: 'script', attrs: { src: 'd.js' } }],\n      /* ^?\n       *   ... some other headTags\n       *   { tag: 'script', attrs: { src: 'c.js' } },\n       *   ... some other bodyTags\n       *   { tag: 'script', attrs: { src: 'a.js' }, head: false },\n       */\n    ],\n  },\n};\n\n\n函数将在 HTML 处理流程的最后被执行，即如下的例子中不管回调函数在配置项中的位置如何， 参数 tags 都会包含配置项中所有的对象形式配置。\n\n也因此在回调中修改 append publicPath hash 等属性都不会生效，因为这些属性都已经分别应用到了标签的位置和路径属性。\n\n于是最终产物将会类似：\n\n<html>\n  <head>\n    <!-- some other headTags... -->\n    <script src=\"//example.com/c.js\"></script>\n    <script src=\"//example.com/d.js\"></script>\n  </head>\n  <body>\n    <!-- some other bodyTags... -->\n    <script src=\"//example.com/a.js\"></script>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"tags"}},{"id":408,"title":"html.templateByEntries","routePath":"/configure/app/html/template-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.templateByEntries。\n\n * 类型： Object\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 HTML 模板。\n\n整体用法与 template 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntemplateByEntries 的优先级高于 template，因此会覆盖 template 设置的值。\n\n\n示例\n\nexport default {\n  output: {\n    template: './static/index.html',\n    templateByEntries: {\n      foo: './src/pages/foo/index.html',\n      bar: './src/pages/bar/index.html',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"templateByEntries"}},{"id":409,"title":"html.templateParametersByEntries","routePath":"/configure/app/html/template-parameters-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.templateParametersByEntries。\n\n * 类型： Object\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的模板参数。\n\n整体用法与 templateParameters 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntemplateParametersByEntries 的优先级高于 templateParameters，因此会覆盖 templateParameters\n中设置的值。\n\n\n示例\n\nexport default {\n  html: {\n    templateParametersByEntries: {\n      foo: {\n        type: 'a',\n      },\n      bar: {\n        type: 'b',\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"templateParametersByEntries"}},{"id":410,"title":"html.templateParameters","routePath":"/configure/app/html/template-parameters","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.templateParameters。\n\n * 类型： Object | Function\n * 默认值：\n\ntype DefaultParameters = {\n  meta: string; // 对应 html.meta 配置\n  title: string; // 对应 html.title 配置\n  mountId: string; // 对应 html.mountId 配置\n  entryName: string; // 入口名称\n  assetPrefix: string; // 对应 output.assetPrefix 配置\n  compilation: webpack.Compilation; // 对应 webpack 的 compilation 对象\n  webpackConfig: Configuration; // webpack 配置\n  // htmlWebpackPlugin 内置的参数\n  // 详见 https://github.com/jantimon/html-webpack-plugin\n  htmlWebpackPlugin: {\n    tags: object;\n    files: object;\n    options: object;\n  };\n};\n\n\n定义 HTML 模板中的参数，对应 html-webpack-plugin 的 templateParameters 配置项。你可以使用配置为对象或者函数。\n\n如果是对象，会和默认参数合并。比如：\n\nexport default {\n  html: {\n    templateParameters: {\n      title: 'My App',\n    },\n  },\n};\n\n\n如果是函数，会传入默认参数，你可以返回一个对象，用于覆盖默认参数。比如：\n\nexport default {\n  html: {\n    templateParameters: defaultParameters => {\n      console.log(defaultParameters.compilation);\n      console.log(defaultParameters.title);\n      return {\n        title: 'My App',\n      };\n    },\n  },\n};\n\n\n\n示例\n\n如果需要在 HTML 模板中使用 foo 参数，可以添加如下设置：\n\nexport default {\n  html: {\n    templateParameters: {\n      foo: 'bar',\n    },\n  },\n};\n\n\n或者使用函数配置：\n\nexport default {\n  html: {\n    templateParameters: defaultParameters => {\n      return {\n        foo: 'bar',\n      };\n    },\n  },\n};\n\n\n接下来，你可以在 HTML 模板中，通过 <%= foo %> 来读取参数：\n\n<script>window.foo = '<%= foo %>'</script>\n\n\n经过编译后的最终 HTML 代码如下：\n\n<script>window.foo = 'bar'</script>\n","frontmatter":{"sidebar_label":"templateParameters"}},{"id":411,"title":"html.template","routePath":"/configure/app/html/template","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.template。\n\n * 类型： string\n * 默认值：\n\n定义 HTML 模板的文件路径，对应 html-webpack-plugin 的 template 配置项。\n\n\n示例\n\n使用自定义的 HTML 模板文件替代默认模板，可以添加如下设置：\n\nexport default {\n  html: {\n    template: './static/index.html',\n  },\n};\n","frontmatter":{"sidebar_label":"template"}},{"id":412,"title":"html.titleByEntries","routePath":"/configure/app/html/title-by-entries","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.titleByEntries。\n\n * 类型： Record<string, string>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 title。\n\n整体用法与 title 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntitleByEntries 的优先级高于 title，因此会覆盖 title 中设置的值。\n\n\n示例\n\nexport default {\n  html: {\n    title: 'ByteDance',\n    titleByEntries: {\n      foo: 'TikTok',\n    },\n  },\n};\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 title 为 TikTok。\n * 其他页面的 title 为 ByteDance。","frontmatter":{"sidebar_label":"titleByEntries"}},{"id":413,"title":"html.title","routePath":"/configure/app/html/title","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 html.title。\n\n * 类型： string\n * 默认值： undefined\n\n配置 HTML 页面的 title 标签，例如：\n\nexport default {\n  html: {\n    title: 'example',\n  },\n};\n","frontmatter":{"sidebar_label":"title"}},{"id":414,"title":"output.assetPrefix","routePath":"/configure/app/output/asset-prefix","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.assetPrefix。\n\n * 类型： boolean | string\n * 默认值： '/'\n\n在生产环境使用 CDN 部署时，可使用该选项设置静态资源的 URL 前缀，对应 webpack 的 output.publicPath 配置。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于生产环境。在开发环境下，请使用 dev.assetPrefix 配置项进行设置。\n\n设置后，项目的 JavaScript、CSS、图片等静态资源的 URL 都会加上 output.assetPrefix 作为前缀：\n\n\n示例\n\nexport default {\n  output: {\n    assetPrefix: 'https://cdn.example.com/assets/',\n  },\n};\n\n\n构建之后，可以看到 JS 文件从以下地址加载：\n\n<script\n  defer\n  src=\"https://cdn.example.com/assets/static/js/main.ebc4ff4f.js\"\n></script>\n","frontmatter":{"sidebar_label":"assetPrefix"}},{"id":415,"title":"output.assetsRetry","routePath":"/configure/app/output/assets-retry","lang":"zh","toc":[{"id":"assetsretrymax","text":"assetsRetry.max","depth":3},{"id":"assetsretrydomain","text":"assetsRetry.domain","depth":3},{"id":"assetsretrytype","text":"assetsRetry.type","depth":3},{"id":"assetsretrytest","text":"assetsRetry.test","depth":3},{"id":"assetsretrycrossorigin","text":"assetsRetry.crossOrigin","depth":3},{"id":"assetsretryonretry","text":"assetsRetry.onRetry","depth":3},{"id":"assetsretryonsuccess","text":"assetsRetry.onSuccess","depth":3},{"id":"assetsretryonfail","text":"assetsRetry.onFail","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.assetsRetry。\n\n * 类型： Object\n\noutput.assetsRetry 用于配置资源加载失败时的重试逻辑。配置类型如下:\n\nexport type AssetsRetryHookContext = {\n  times: number;\n  domain: string;\n  url: string;\n  tagName: string;\n};\n\nexport type AssetsRetryOptions = {\n  type?: string[];\n  domain?: string[];\n  max?: number;\n  test?: string | ((url: string) => boolean);\n  crossOrigin?: boolean;\n  onRetry?: (options: AssetsRetryHookContext) => void;\n  onSuccess?: (options: AssetsRetryHookContext) => void;\n  onFail?: (options: AssetsRetryHookContext) => void;\n};\n\n\n默认值如下:\n\nexport const defaultAssetsRetryOptions: AssetsRetryOptions = {\n  type: ['script', 'link', 'img'],\n  domain: [],\n  max: 3,\n  test: '',\n  crossOrigin: false,\n  onRetry: () => {},\n  onSuccess: () => {},\n  onFail: () => {},\n};\n\n\n * 打包工具： 仅支持 webpack\n\n\nassetsRetry.max\n\n * 类型： number\n * 默认值： 3\n\n单个资源的最大重试次数。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      max: 3,\n    },\n  },\n};\n\n\n\nassetsRetry.domain\n\n * 类型： string[]\n * 默认值： []\n\n指定资源加载失败时的重试域名，如果为空则使用当前页面的域名。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      domain: ['https://cdn1.example.com', 'https://cdn2.example.com'],\n    },\n  },\n};\n\n\n\nassetsRetry.type\n\n * 类型： string[]\n * 默认值： ['script', 'link', 'img']\n\n可重试的资源类型。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      type: ['script', 'link'],\n    },\n  },\n};\n\n\n\nassetsRetry.test\n\n * 类型： string | ((url: string) => boolean) | undefined\n * 默认值： undefined\n\n匹配资源 URL 的正则表达式或函数，默认匹配所有资源。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      test: /cdn\\.example\\.com/,\n    },\n  },\n};\n\n\n\nassetsRetry.crossOrigin\n\n * 类型： undefined | boolean\n * 默认值： false\n\n用于向 <script> 资源标签中注入 crossorigin 属性，传入 true 则会启用默认值 anonymous。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      crossOrigin: true,\n    },\n  },\n};\n\n\n\nassetsRetry.onRetry\n\n * 类型： undefined | (options: AssetsRetryHookContext) => void\n\n资源重试时的回调函数。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      onRetry: ({ times, domain, url, tagName }) => {\n        console.log(\n          `Retry ${times} times, domain: ${domain}, url: ${url}, tagName: ${tagName}`,\n        );\n      },\n    },\n  },\n};\n\n\n\nassetsRetry.onSuccess\n\n * 类型： undefined | (options: AssetsRetryHookContext) => void\n\n资源重试成功时的回调函数。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      onSuccess: ({ times, domain, url, tagName }) => {\n        console.log(\n          `Retry ${times} times, domain: ${domain}, url: ${url}, tagName: ${tagName}`,\n        );\n      },\n    },\n  },\n};\n\n\n\nassetsRetry.onFail\n\n * 类型： undefined | (options: AssetsRetryHookContext) => void\n\n资源重试超过最大重试次数时的回调函数。比如：\n\nexport default {\n  output: {\n    assetsRetry: {\n      onFail: ({ times, domain, url, tagName }) => {\n        console.log(\n          `Retry ${times} times, domain: ${domain}, url: ${url}, tagName: ${tagName}`,\n        );\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"assetsRetry"}},{"id":416,"title":"output.charset","routePath":"/configure/app/output/charset","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.charset。\n\n * 类型： 'ascii' | 'utf8'\n * 默认值： 'ascii'\n\n默认情况下，Builder 的产物内容是纯 ASCII 的，并且会转义所有非 ASCII 字符。\n\n如果不希望进行转义，而是输出所有原始字符，可以将 output.charset 设置为 utf8。\n\nexport default {\n  output: {\n    charset: 'utf8',\n  },\n};\n\n\n当 output.charset 为 utf8 时，Builder 会自动将 <meta charset=\"utf-8\"> 添加到生成的 HTML 文件中。","frontmatter":{"sidebar_label":"charset"}},{"id":417,"title":"output.cleanDistPath","routePath":"/configure/app/output/clean-dist-path","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.cleanDistPath。\n\n * 类型： boolean\n * 默认值： true\n\n是否在构建开始前清理 dist 目录下的所有文件。\n\n默认情况下，Builder 会自动清理 dist 目录下的文件，你可以把 cleanDistPath 设置为 false 来禁用该行为。\n\nexport default {\n  output: {\n    cleanDistPath: false,\n  },\n};\n","frontmatter":{"sidebar_label":"cleanDistPath"}},{"id":418,"title":"output.convertToRem","routePath":"/configure/app/output/convert-to-rem","lang":"zh","toc":[{"id":"boolean-类型","text":"Boolean 类型","depth":4},{"id":"object-类型","text":"Object 类型","depth":4},{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.convertToRem。\n\n * 类型： boolean | object\n * 默认值： false\n\n通过设置 output.convertToRem，Builder 可进行如下处理：\n\n * 将 CSS 中的 px 转成 rem\n * 在 HTML 模版中插入运行时代码，对根元素 fontSize 进行设置\n\nBoolean 类型\n\n当设置 output.convertToRem 为 true，将开启 rem 处理能力。\n\nexport default {\n  output: {\n    convertToRem: true,\n  },\n};\n\n\n此时，rem 配置默认如下：\n\n{\n  enableRuntime: true,\n  rootFontSize: 50,\n  screenWidth: 375,\n  rootFontSize: 50,\n  maxRootFontSize: 64,\n  widthQueryKey: '',\n  excludeEntries: [],\n  supportLandscape: false,\n  useRootFontSizeBeyondMax: false,\n  pxtorem: {\n    rootValue: 50,\n    unitPrecision: 5,\n    propList: ['*'],\n  }\n}\n\n\nObject 类型\n\n当 output.convertToRem 的值为 object 类型时，Builder 会根据当前配置进行 rem 处理。\n\n选项：\n\n| 名称 | 类型 | 默认值 | 描述 | | ------------------------ | ---------- |\n--------------------------------------------------------------------------------\n------------------------------------------------------- |\n--------------------------------------------------------------------------------\n--------- | | enableRuntime | boolean | true | 开启 HTML 模版插入功能，动态计算根元素字体大小 | |\nrootFontSize | number | 50 | 根元素字体值 | | maxRootFontSize | number | 64 | 最大根元素字体值\n| | widthQueryKey | string | '' | 根据 widthQueryKey 的值去 url query 中取 client width\n| | screenWidth | number | 375 | UI 设计图宽度 | | excludeEntries | string[] | [] |\n不进行调整的页面入口 | | supportLandscape | boolean | false | 横屏时使用 height 计算 rem | |\nuseRootFontSizeBeyondMax | boolean | false | 超过 maxRootFontSize 时，是否使用\nrootFontSize | | pxtorem | object | rootValue。默认与 rootFontSize 相同 unitPrecision:\n5。精确位数 propList: ['*']。支持转换的 CSS 属性 | postcss-pxtorem 插件属性 |\n\n\n示例\n\nexport default {\n  output: {\n    convertToRem: {\n      rootFontSize: 30,\n      excludeEntries: ['404', 'page2'],\n      pxtorem: {\n        propList: ['font-size'],\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"convertToRem"}},{"id":419,"title":"output.copy","routePath":"/configure/app/output/copy","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.copy。\n\n * 类型： CopyPluginOptions | CopyPluginOptions['patterns']\n * 默认值： undefined\n\n将指定的文件或目录拷贝到构建输出目录中。\n\n例如，将 src/assets 下的文件直接拷贝到 dist 目录：\n\nexport default {\n  output: {\n    copy: [{ from: './src/assets', to: '' }],\n  },\n};\n\n\n更详细的配置项请参考：copy-webpack-plugin 文档。","frontmatter":{"sidebar_label":"copy"}},{"id":420,"title":"output.cssModuleLocalIdentName","routePath":"/configure/app/output/css-module-local-ident-name","lang":"zh","toc":[{"id":"默认值","text":"默认值","depth":3},{"id":"模板字符串","text":"模板字符串","depth":3},{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.cssModuleLocalIdentName。\n\n * 类型： string\n * 默认值：\n\n// isProd 表示生产环境构建\nconst localIdentName = isProd\n  ? '[hash:base64:5]'\n  : '[path][name]__[local]--[hash:base64:5]';\n\n\n设置 CSS Modules 编译后生成的 className 格式。\n\n\n默认值\n\ncssModuleLocalIdentName 在开发环境和生产环境有不同的默认值。\n\n在生产环境，Builder 会生成更简短的类名，从而减少构建产物的体积。\n\n\n\n// 在开发环境下，值为 `.src-index-module__header--xxxxx`\n// 在生产环境下，值为 `.xxxxx`\nconsole.log(styles.header);\n\n\n\n模板字符串\n\n在 cssModuleLocalIdentName 中，你可以使用以下模板字符串：\n\n * [name] - 源文件名称。\n * [local] - 原始类名。\n * [hash] - 字符串的哈希值。\n * [folder] - 文件夹的相对路径。\n * [path] - 源文件的相对路径。\n * [file] - 文件名和路径。\n * [ext] - 文件后缀名，包含点号。\n * [hash:<hashDigest>:<hashDigestLength>] - 带有哈希设置的哈希。\n\n\n示例\n\n将 cssModuleLocalIdentName 设置为其他值：\n\nexport default {\n  output: {\n    cssModuleLocalIdentName: '[hash:base64:4]',\n  },\n};\n","frontmatter":{"sidebar_label":"cssModuleLocalIdentName"}},{"id":421,"title":"output.dataUriLimit","routePath":"/configure/app/output/data-uri-limit","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.dataUriLimit。\n\n * 类型\n\ntype DataUriLimitConfig = {\n  svg?: number;\n  font?: number;\n  image?: number;\n  media?: number;\n};\n\n\n * 默认值\n\nconst defaultDatUriLimit = {\n  svg: 10000,\n  font: 10000,\n  image: 10000,\n  media: 10000,\n};\n\n\n设置图片、字体、媒体等静态资源被自动内联为 base64 的体积阈值。\n\n默认情况下，体积小于 10KB 的图片、字体、媒体等文件，会自动经过 Base64 编码，内联到页面中，不再会发送独立的 HTTP 请求。\n\n你可以通过修改 dataUriLimit 参数来调整这个阈值。\n\n其中：\n\n * svg：表示 SVG 图片的体积阈值。\n * font：表示字体文件的体积阈值。\n * image：表示非 SVG 图片的体积阈值。\n * media：表示视频等媒体资源的体积阈值。\n\n\n示例\n\n修改图片资源的阈值为 5000 Bytes，设置视频资源不内联：\n\nexport default {\n  output: {\n    dataUriLimit: {\n      image: 5000,\n      media: 0,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"dataUriLimit"}},{"id":422,"title":"output.disableCssExtract","routePath":"/configure/app/output/disable-css-extract","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableCssExtract。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否禁用 CSS 提取逻辑，并将 CSS 文件内联到 JS 文件中。\n\n默认情况下，Builder 会把 CSS 提取为独立的 .css 文件，并输出到构建产物目录。设置该选项为 true 后，CSS 文件会被内联到 JS\n文件中，并在运行时通过 <style> 标签插入到页面上。\n\n\n示例\n\nexport default {\n  output: {\n    disableCssExtract: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableCssExtract"}},{"id":423,"title":"output.disableCssModuleExtension","routePath":"/configure/app/output/disable-css-module-extension","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3},{"id":"规则","text":"规则","depth":3},{"id":"未开启-disablecssmoduleextension默认","text":"未开启 disableCssModuleExtension（默认）","depth":4},{"id":"开启-disablecssmoduleextension","text":"开启 disableCssModuleExtension","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableCssModuleExtension。\n\n * 类型： boolean\n * 默认值： false\n\n是否将源码目录下的所有样式文件当做 CSS Modules 模块进行处理。\n\n在默认情况下，只有 *.module.css 结尾的文件才被视为 CSS Modules 模块。开启该配置项之后，会将源码目录下的所有 *.css 样式文件当做\nCSS Modules 模块。\n\n.sass、.scss 和 .less 文件的处理规则与 .css 文件一致，也会受到 disableCssModuleExtension 的影响。\n\nTIP\n\n我们不推荐开启此配置项，因为开启 disableCssModuleExtension后，CSS Modules 文件和普通 CSS\n文件无法得到明确的区分，不利于长期维护。\n\n\n示例\n\nexport default {\n  output: {\n    disableCssModuleExtension: true,\n  },\n};\n\n\n\n规则\n\n以下是对 CSS Modules 判断规则的详细解释：\n\n未开启 disableCssModuleExtension（默认）\n\n以下文件会视为 CSS Modules：\n\n * 所有 *.module.css 文件\n\n以下文件会视为普通 CSS：\n\n * 所有 *.css 文件（不含 .module）\n * 所有 *.global.css 文件\n\n开启 disableCssModuleExtension\n\n以下文件会视为 CSS Modules：\n\n * 源码目录下的 *.css 和 *.module.css 文件\n * node_modules 下的 *.module.css 文件\n\n以下文件会视为普通 CSS：\n\n * 所有 *.global.css 文件\n * node_modules 下的 *.css 文件（不含 .module）\n\nTIP\n\n对于 node_modules 中的 CSS Modules 文件，请始终使用 *.module.css后缀。","frontmatter":{"sidebar_label":"disableCssModuleExtension"}},{"id":424,"title":"output.disableFilenameHash","routePath":"/configure/app/output/disable-filename-hash","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableFilenameHash。\n\n * 类型： boolean\n * 默认值： false\n\n移除生产环境的构建产物名称中的 hash 值。\n\n在生产环境构建后，会自动在文件名中间添加 hash 值，如果不需要添加，可以通过 output.disableFilenameHash 配置来禁用该行为。\n\n\n示例\n\n默认情况下，构建后的产物名称为：\n\nFile                                     Size         Gzipped\ndist/static/css/187.7879e19d.css         126.99 KB    9.17 KB\ndist/static/js/main.18a568e5.js          2.24 KB      922 B\n\n\n添加 output.disableFilenameHash 配置：\n\nexport default {\n  output: {\n    disableFilenameHash: true,\n  },\n};\n\n\n重新构建，产物的名称变为：\n\nFile                            Size         Gzipped\ndist/static/css/187.css         126.99 KB    9.17 KB\ndist/static/js/main.js          2.24 KB      922 B\n","frontmatter":{"sidebar_label":"disableFilenameHash"}},{"id":425,"title":"output.disableInlineRuntimeChunk","routePath":"/configure/app/output/disable-inline-runtime-chunk","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableInlineRuntimeChunk。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用于控制是否内联 runtimeChunk 到 HTML 中。\n\n在生产环境下，runtime chunk 文件将会默认被内联到 HTML 文件中，而不是写到产物目录中，这样可以减少文件请求的数量。\n\n这个选项用来关闭这个默认行为。\n\nexport default {\n  output: {\n    disableInlineRuntimeChunk: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableInlineRuntimeChunk"}},{"id":426,"title":"output.disableMinimize","routePath":"/configure/app/output/disable-minimize","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableMinimize。\n\n * 类型： boolean\n * 默认值： false\n\n是否禁用生产环境下的代码压缩。\n\n默认情况下，JS 代码和 CSS 代码会在生产环境构建时被自动压缩。如果不希望执行代码压缩，可以将 disableMinimize 设置为 true。\n\nexport default {\n  output: {\n    disableMinimize: true,\n  },\n};\n","frontmatter":{"sidebar_label":"disableMinimize"}},{"id":427,"title":"output.disableNodePolyfill","routePath":"/configure/app/output/disable-node-polyfill","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： boolean\n * 默认值： true\n\n该配置项用于控制是否在代码中注入 Node 模块的 Polyfill。\n\n默认情况下，我们不会将 Node Polyfill 注入到代码中，以避免造成代码体积增大。如果你需要注入 Node Polyfill，可以将\noutput.disableNodePolyfill 设置为 false：\n\nexport default defineConfig({\n  output: {\n    disableNodePolyfill: false,\n  },\n});\n\n\n该配置项基于 Modern.js Builder 的 Node Polyfill 插件实现，你可以阅读 Modern.js Builder - Node\nPolyfill 插件 文档来了解详细信息。","frontmatter":{"sidebar_label":"disableNodePolyfill"}},{"id":428,"title":"output.disableSourceMap","routePath":"/configure/app/output/disable-source-map","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableSourceMap。\n\n * 类型：\n\ntype DisableSourceMap =\n  | boolean\n  | {\n      js?: boolean;\n      css?: boolean;\n    };\n\n\n * 默认值：\n\nconst defaultDisableSourceMap = {\n  js: false,\n  css: process.env.NODE_ENV === 'production',\n};\n\n\n是否禁用 Source Map 生成。\n\n什么是 Source Map\n\nSource Map 是保存源代码映射关系的信息文件，它记录了编译后的代码的每一个位置，以及所对应的编译前的位置。通过 Source\nMap，可以在调试编译后的代码时，直接查看对应的源代码。\n\n默认情况下，Builder 的 Source Map 生成规则如下：\n\n * 在开发环境构建时，会生成 JS 文件和 CSS 文件的 SourceMap，便于进行开发调试。\n * 在生产环境构建时，会生成 JS 文件的 Source Map，用于调试和排查线上问题；不会生成 CSS 文件的 Source Map。\n\n如果项目不需要 Source Map，可以关闭该功能，从而提升构建的速度。\n\nexport default {\n  output: {\n    disableSourceMap: true,\n  },\n};\n\n\n如果需要开启开发环境的 Source Map，并在生产环境禁用，可以设置为：\n\nexport default {\n  output: {\n    disableSourceMap: process.env.NODE_ENV === 'production',\n  },\n};\n\n\n如果需要单独控制 JS 文件或 CSS 文件的 Source Map，可以参考下方设置：\n\nexport default {\n  output: {\n    disableSourceMap: {\n      js: false,\n      css: true,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"disableSourceMap"}},{"id":429,"title":"output.disableTsChecker","routePath":"/configure/app/output/disable-ts-checker","lang":"zh","toc":[{"id":"阻塞编译","text":"阻塞编译","depth":3},{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.disableTsChecker。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否禁用编译过程中的 TypeScript 类型检查。\n\n默认情况下，Builder 执行构建的过程中，会在一个独立的进程里运行 TypeScript 类型检查工具，它的检查逻辑与 TypeScript 原生的 tsc\n命令一致，你可以通过 tsconfig.json 或是 Builder 的 tools.tsChecker 配置项来自定义检查行为。\n\n\n阻塞编译\n\n * 在开发环境构建时，类型错误不会阻塞编译流程。\n * 在生产环境构建时，类型错误会导致构建失败，以保证生产环境代码的稳定性。\n\n\n示例\n\n禁用 TypeScript 类型检查：\n\nexport default {\n  output: {\n    disableTsChecker: true,\n  },\n};\n\n\n禁用开发环境构建时的类型检查：\n\nexport default {\n  output: {\n    disableTsChecker: process.env.NODE_ENV === 'development',\n  },\n};\n\n\n禁用生产环境构建时的类型检查：\n\nexport default {\n  output: {\n    disableTsChecker: process.env.NODE_ENV === 'production',\n  },\n};\n\n\nTIP\n\n不建议在生产环境构建时禁用类型检查，这会导致线上代码的稳定性下降，请谨慎使用。","frontmatter":{"sidebar_label":"disableTsChecker"}},{"id":430,"title":"output.distPath","routePath":"/configure/app/output/dist-path","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.distPath。\n\n * 类型\n\ntype DistPathConfig = {\n  root?: string;\n  js?: string;\n  css?: string;\n  svg?: string;\n  font?: string;\n  html?: string;\n  image?: string;\n  media?: string;\n  server?: string;\n};\n\n\n * 默认值\n\nconst defaultDistPath = {\n  root: 'dist',\n  html: 'html',\n  js: 'static/js',\n  css: 'static/css',\n  svg: 'static/svg',\n  font: 'static/font',\n  image: 'static/image',\n  media: 'static/media',\n  server: 'bundles',\n};\n\n\n设置构建产物的输出目录，Builder 会根据产物的类型输出到对应的子目录下。\n\n其中：\n\n * root: 表示所有构建产物输出的根目录。\n * html：表示 HTML 文件的输出目录。\n * js：表示 JavaScript 文件的输出目录。\n * css：表示 CSS 样式文件的输出目录。\n * svg：表示 SVG 图片的输出目录。\n * font：表示字体文件的输出目录。\n * image：表示非 SVG 图片的输出目录。\n * media：表示视频等媒体资源的输出目录。\n * server: 表示服务端产物的输出目录，仅在 target 为 node 时有效。\n\n\n示例\n\n以 JavaScript 文件为例，会输出到 distPath.root + distPath.js 目录，即为 dist/static/js。\n\n如果需要将 JavaScript 文件输出到 build/resource/js 目录，可以这样设置：\n\nexport default {\n  output: {\n    distPath: {\n      root: 'build',\n      js: 'resource/js',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"distPath"}},{"id":431,"title":"output.enableAssetFallback","routePath":"/configure/app/output/enable-asset-fallback","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableAssetFallback。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n开启该选项后，当编译过程中遇到无法识别的文件类型时，会直接将该文件直接输出到产物目录；否则会抛出一个异常。\n\n\n示例\n\n开启配置项：\n\nexport default {\n  output: {\n    enableAssetFallback: true,\n  },\n};\n\n\n在代码中引用一个未知类型的模块：\n\nimport './foo.xxx';\n\n\n编译后，foo.xxx 会被自动输出到 dist/static/media 目录下。\n\n你可以通过 output.distPath.media 和 output.filename.media 配置项来控制 fallback 后的输出路径和文件名称。\n\nTIP\n\n开启该配置会导致 webpack 配置中的 rules 结构变化，增加一层额外的 oneOf嵌套结构。大多数情况下，我们不推荐你使用此配置。","frontmatter":{"sidebar_label":"enableAssetFallback"}},{"id":432,"title":"output.enableAssetManifest","routePath":"/configure/app/output/enable-asset-manifest","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableAssetManifest。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否生成 manifest 文件，该文件包含所有构建产物的信息。\n\n\n示例\n\n添加以下配置来开启：\n\nexport default {\n  output: {\n    enableAssetManifest: true,\n  },\n};\n\n\n开启后，当编译完成时，会自动生成 dist/manifest.json 文件：\n\n{\n  \"files\": {\n    \"main.css\": \"/static/css/main.45b01211.css\",\n    \"main.js\": \"/static/js/main.52fd298f.js\",\n    \"html/main/index.html\": \"/html/main/index.html\"\n  },\n  \"entrypoints\": [\"static/css/main.45b01211.css\", \"static/js/main.52fd298f.js\"]\n}\n","frontmatter":{"sidebar_label":"enableAssetManifest"}},{"id":433,"title":"output.enableCssModuleTSDeclaration","routePath":"/configure/app/output/enable-css-module-tsdeclaration","lang":"zh","toc":[{"id":"example","text":"Example","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableCssModuleTSDeclaration。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否生成 CSS Modules 的 TypeScript 声明文件。\n\n\nExample\n\n启用 CSS Module TypeScript 声明，比如：\n\nexport default {\n  output: {\n    enableCssModuleTSDeclaration: true,\n  },\n};\n\n\n项目构建完成后，每个 CSS Module 文件都会生成一个 .d.ts 文件。例如：\n\ninterface CssExports {\n  title: string;\n}\nexport const cssExports: CssExports;\nexport default cssExports;\n","frontmatter":{"sidebar_label":"enableCssModuleTSDeclaration"}},{"id":434,"title":"output.enableInlineScripts","routePath":"/configure/app/output/enable-inline-scripts","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableInlineScripts。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用来控制生产环境中是否用 <script> 标签将产物中的 script 文件（.js 文件）inline 到 HTML 中。\n\n注意，如果开启了这个选项，那么 script 文件将不会被写入产物目录中，而只会以 inline 脚本的形式存在于 HTML 文件中。\n\n\n示例\n\n默认情况下，我们有这样的产物文件：\n\ndist/html/main/index.html\ndist/static/css/style.css\ndist/static/js/main.js\n\n\n开启 output.enableInlineScripts 选项后：\n\nexport default {\n  output: {\n    enableInlineScripts: true,\n  },\n};\n\n\n产物文件将变成：\n\ndist/html/main/index.html\ndist/static/css/style.css\n\n\n同时，dist/static/js/main.js 文件将被 inline 到 index.html 中：\n\n<html>\n  <body>\n    <script>\n      // content of dist/static/js/main.js\n    </script>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"enableInlineScripts"}},{"id":435,"title":"output.enableInlineStyles","routePath":"/configure/app/output/enable-inline-styles","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableInlineStyles。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用来控制生产环境中是否用 <style> 标签将产物中的 style 文件（.css 文件）inline 到 HTML 中。\n\n注意，如果开启了这个选项，那么 style 文件将不会被写入产物目录中，而只会以 inline 样式的形式存在于 HTML 文件中。\n\n\n示例\n\n默认情况下，我们有这样的产物文件：\n\ndist/html/main/index.html\ndist/static/css/style.css\ndist/static/js/main.js\n\n\n开启 output.enableInlineStyles 选项后：\n\nexport default {\n  output: {\n    enableInlineStyles: true,\n  },\n};\n\n\n产物文件将变成：\n\ndist/html/main/index.html\ndist/static/js/main.js\n\n\n同时，dist/static/css/style.css 文件将被 inline 到 index.html 中：\n\n<html>\n  <head>\n    <style>\n      /* content of dist/static/css/style.css */\n    </style>\n  </head>\n  <body>\n  </body>\n</html>\n","frontmatter":{"sidebar_label":"enableInlineStyles"}},{"id":436,"title":"output.enableLatestDecorators","routePath":"/configure/app/output/enable-latest-decorators","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.enableLatestDecorators。\n\n * 类型： boolean\n * 默认值： false\n\n是否要使用 新版 decorator 提案 进行编译。\n\n默认情况下，Builder 在编译装饰器时采用 旧版 decorator 提案。\n\n将 output.enableLatestDecorators 设置为 true 时，Builder 会采用新版 decorator 提案 (2018-09\n版本) 进行编译。\n\nexport default {\n  output: {\n    enableLatestDecorators: true,\n  },\n};\n","frontmatter":{"sidebar_label":"enableLatestDecorators"}},{"id":437,"title":"output.externals","routePath":"/configure/app/output/externals","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.externals。\n\n * 类型： string | object | function | RegExp\n * 默认值： undefined\n\n在构建时，防止将代码中某些 import 的依赖包打包到 bundle 中，而是在运行时再去从外部获取这些依赖。\n\n详情请见: webpack 外部扩展 (Externals)\n\n\n示例\n\n将 react-dom 依赖从构建产物中剔除。为了在运行时获取这个模块, react-dom 的值将全局检索 ReactDOM 变量。\n\nexport default {\n  output: {\n    externals: {\n      'react-dom': 'ReactDOM',\n    },\n  },\n};\n\n\nTIP\n\n当构建 Web Worker 产物时，externals 将不会生效。这是因为 Worker 环境不支持通过访问全局变量。","frontmatter":{"sidebar_label":"externals"}},{"id":438,"title":"output.filename","routePath":"/configure/app/output/filename","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.filename。\n\n * 类型\n\ntype FilenameConfig = {\n  js?: string;\n  css?: string;\n  svg?: string;\n  font?: string;\n  image?: string;\n  media?: string;\n};\n\n\n * 默认值\n\n// 开发环境\nconst devDefaultFilename = {\n  js: '[name].js',\n  css: '[name].css',\n  svg: '[name].[contenthash:8].svg',\n  font: '[name].[contenthash:8][ext]',\n  image: '[name].[contenthash:8][ext]',\n  media: '[name].[contenthash:8][ext]',\n};\n\n// 生产环境\nconst prodDefaultFilename = {\n  js: '[name].[contenthash:8].js',\n  css: '[name].[contenthash:8].css',\n  svg: '[name].[contenthash:8].svg',\n  font: '[name].[contenthash:8][ext]',\n  image: '[name].[contenthash:8][ext]',\n  media: '[name].[contenthash:8][ext]',\n};\n\n\n设置构建产物的名称。\n\n在生产环境构建后，会自动在文件名中间添加 hash 值，如果不需要添加，可以通过 output.disableFilenameHash 配置来禁用该行为。\n\n其中：\n\n * js：表示 JavaScript 文件的名称。\n * css：表示 CSS 样式文件的名称。\n * svg：表示 SVG 图片的名称。\n * font：表示字体文件的名称。\n * image：表示非 SVG 图片的名称。\n * media：表示视频等媒体资源的名称。\n\n\n示例\n\n修改 JavaScript 文件的名称为 [name]_script.js：\n\nexport default {\n  output: {\n    filename: {\n      js:\n        process.env.NODE_ENV === 'production'\n          ? '[name]_script.[contenthash:8].js'\n          : '[name]_script.js',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"filename"}},{"id":439,"title":"output.legalComments","routePath":"/configure/app/output/legal-comments","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.legalComments。\n\n * 类型： 'linked' | 'inline' | 'none'\n * 默认值： 'linked'\n * 打包工具： 仅支持 webpack\n\n配置 legal comment 的处理方式。\n\nlegal comment 是 JS 或 CSS 文件中的一些特殊注释，这些注释包含 @license 或 @preserve，或是以 //!\n开头。默认情况下，这些注释保留在输出文件中，因为这遵循了代码原作者的意图。\n\n你可以通过 legalComments 来配置相关行为：\n\n * linked：将所有 legal comments 移至 .LEGAL.txt 文件并通过注释链接到它们。\n * inline：保留所有 legal comments。\n * none：移除所有 legal comments。\n\n\n示例\n\n移除所有 legal comments。\n\nexport default {\n  output: {\n    legalComments: 'none',\n  },\n};\n","frontmatter":{"sidebar_label":"legalComments"}},{"id":440,"title":"output.overrideBrowserslist","routePath":"/configure/app/output/override-browserslist","lang":"zh","toc":[{"id":"优先级","text":"优先级","depth":4},{"id":"默认值","text":"默认值","depth":4},{"id":"示例","text":"示例","depth":3},{"id":"根据产物类型设置","text":"根据产物类型设置","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.overrideBrowserslist。\n\n * 类型： string[] | Record<BuilderTarget, string[]>\n * 默认值： undefined\n\n指定项目兼容的目标浏览器范围。该值会被 @babel/preset-env 和 autoprefixer 用来确定需要转换的 JavaScript\n语法特性和需要添加的 CSS 浏览器前缀。\n\n优先级\n\noverrideBrowserslist 配置的优先级高于项目中的 .browserslistrc 配置文件和 package.json 中的\nbrowserslist 字段。\n\n大多数场景下，推荐优先使用 .browserslistrc 文件，而不是使用 overrideBrowserslist 配置。因为\n.browserslistrc 文件是官方定义的配置文件，通用性更强，可以被社区中的其他库识别。\n\n默认值\n\n如果项目中没有定义任何 browserslist 相关的配置，也没有定义 overrideBrowserslist，那么 Builder 会设置默认值为：\n\n['> 0.01%', 'not dead', 'not op_mini all'];\n\n\n\n示例\n\n下面是兼容移动端 H5 场景的示例：\n\nexport default {\n  output: {\n    overrideBrowserslist: [\n      'iOS 9',\n      'Android 4.4',\n      'last 2 versions',\n      '> 0.2%',\n      'not dead',\n    ],\n  },\n};\n\n\n可以查看 browserslist 文档 来了解如何自定义浏览器范围。\n\n根据产物类型设置\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的目标浏览器范围。此时，你需要把 overrideBrowserslist 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的范围：\n\nexport default {\n  output: {\n    overrideBrowserslist: {\n      web: ['iOS 9', 'Android 4.4', 'last 2 versions', '> 0.2%', 'not dead'],\n      node: ['node >= 14'],\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"overrideBrowserslist"}},{"id":441,"title":"output.polyfill","routePath":"/configure/app/output/polyfill","lang":"zh","toc":[{"id":"配置项","text":"配置项","depth":3},{"id":"entry","text":"entry","depth":4},{"id":"usage","text":"usage","depth":4},{"id":"ua","text":"ua","depth":4},{"id":"off","text":"off","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.polyfill。\n\n * 类型： 'entry' | 'usage' | 'ua' | 'off'\n * 默认值： 'entry'\n\n通过 output.polyfill 你可以配置 Polyfill 的注入方式。\n\n\n配置项\n\nentry\n\n当 output.polyfill 配置为 'entry' 时，会在每个入口文件中注入 Polyfill。\n\n等价于 @babel/preset-env 的 useBuiltIns: 'entry' 配置。\n\nusage\n\n当 output.polyfill 配置为 'usage' 时，会在每个文件中根据代码中使用的 API 注入 Polyfill。\n\n等价于 @babel/preset-env 的 useBuiltIns: 'usage' 配置。\n\nua\n\n根据当前请求的 UA 信息，动态下发 Polyfill 代码。\n\noff\n\n不注入 Polyfill。使用此选项时，需要自行保证代码的兼容性。","frontmatter":{"sidebar_label":"polyfill"}},{"id":442,"title":"output.ssg","routePath":"/configure/app/output/ssg","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2},{"id":"单入口","text":"单入口","depth":3},{"id":"多入口","text":"多入口","depth":3},{"id":"配置路由","text":"配置路由","depth":3},{"id":"阻止默认行为","text":"阻止默认行为","depth":3},{"id":"添加动态路由参数","text":"添加动态路由参数","depth":3}],"domain":"","content":"\n\n * 类型： boolean | object | function\n * 默认值： undefined\n\n开启自控式路由或约定式路由 SSG 功能的配置。\n\n客户端路由\n\n相关内容可以查看路由。\n\n\n示例\n\n\n单入口\n\n当该配置设置为 true 时，将会默认开启所有入口的 SSG 功能。\n\n对自控式路由而言，将会渲染入口的根路由。对约定式路由而言，将会渲染入口中每一条路由。\n\n例如 src/ 目录下有以下满足约定式路由的文件结构：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\n在 modern.config.js 中做以下设置：\n\nexport default defineConfig({\n  output: {\n    ssg: true,\n  },\n});\n\n\n执行 pnpm build 构建应用后。dist/ 目录将会生成三张 HTML 分别对应三条路由（不开启 SSG 时只有一张 HTML），并且所有 HTML\n都已经渲染。\n\n而例如下面的自控式路由：\n\n\n\n\n\n\nconst Router = typeof window === 'undefined' ? StaticRouter : BrowserRouter;\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const pathname = context?.request?.pathname;\n  return (\n    <Router location={pathname}>\n      <Routes>\n        <Route index element={<div>index</div>} />\n        <Route path=\"about\" element={<div>about</div>} />\n      </Routes>\n    </Router>\n  );\n};\n\n\n同样使用上面的配置，在执行 pnpm run build 后，只有入口路由 / 会生成渲染后的 HTML。\n\n\n多入口\n\noutput.ssg 也可以按照入口配置，配置生效的规则同样由入口路由方式决定。\n\n例如以下目录结构：\n\n。\n├── src\n│   ├── entryA\n│   │   └── routes\n│   │       ├── layout.tsx\n│   │       ├── page.tsx\n│   │       └── user\n│   │           ├── layout.tsx\n│   │           ├── page.tsx\n│   │           └── profile\n│   │               └── page.tsx\n│   └── entryB\n│       └── App.tsx\n\n\n默认情况下，所有约定式路由的入口，在设置 output.ssg 配置为 true 后都会在构建阶段渲染。可以配置 false\n来取消指定入口的的默认行为，例如取消上述 entryA 入口在构建时的渲染：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      entryA: true,\n      entryB: false,\n    },\n  },\n});\n\n\n\n配置路由\n\n上述内容中提到，自控式路由默认只会开启入口路由的 SSG 配置。\n\n可以在 output.ssg 中设置具体的路由，告知 Modern.js 开启这些客户端路由的 SSG 功能。例如上述 src/App.tsx 的文件内容为：\n\n在 modern.config.js 中这样设置后，/about 路由也会开启 SSG 功能：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: ['/', '/about'],\n    },\n  },\n});\n\n\nModern.js 将会自动根据入口拼接完整的 URL 并交给 SSG 插件完成渲染。\n\n也可以为具体入口或路由配置请求头，例如：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      headers: {},\n      routes: [\n        '/',\n        {\n          url: '/about',\n          headers: {},\n        },\n      ],\n    },\n  },\n});\n\n\nINFO\n\n路由中设置的 headers 会覆盖入口中设置的 headers。\n\n\n阻止默认行为\n\n默认情况下，约定式路由的路由会全部开启 SSG。Modern.js 提供了另一个字段，用来阻止默认的 SSG 行为。\n\n例如以下目录结构，/、/user、/user/profle 三条路由都开启 SSG：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\n可以这样设置，禁用某一条客户端路由的默认行为：\n\nexport default defineConfig({\n  output: {\n    preventDefault: ['/user'],\n  },\n});\n\n\n\n添加动态路由参数\n\n部分路由可能是动态的，例如自控式路由中的 /user/:id 或是约定式路由中 user/[id]/page.tsx 文件生成的路由。\n\n可以在 output.ssg 中配置具体的参数，渲染指定参数的路由，例如：\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: [\n        {\n          url: '/user/:id',\n          params: [\n            {\n              id: 'modernjs',\n            },\n          ],\n        },\n      ],\n    },\n  },\n});\n\n\n动态路由和 SSG 的组合，在根据 CMS 系统数据变更，实时生成静态页面时非常有用。","frontmatter":{"sidebar_label":"ssg"}},{"id":443,"title":"output.svgDefaultExport","routePath":"/configure/app/output/svg-default-export","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 output.svgDefaultExport。\n\n * 类型： url | component\n * 默认值： url\n\noutput.svgDefaultExport 可以用来配置 SVG 文件的默认导出。\n\n当 output.svgDefaultExport 配置为 url 时，SVG 文件的默认导出是文件的 URL。例如：\n\n\n\nconsole.log(logo); // => 资源 url\n\n\n当 output.svgDefaultExport 配置为 component 时，SVG 文件的默认导出是文件的 React 组件。例如：\n\n\n\nconsole.log(Logo); // => React 组件\n\n\n此时，你也可以通过指定 ?url 的 query 来导入 url，比如：\n\n\n\nconsole.log(logo); // => 资源 url\n","frontmatter":{"sidebar_label":"svgDefaultExport"}},{"id":444,"title":"performance.buildCache","routePath":"/configure/app/performance/build-cache","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.buildCache。\n\n * 类型：\n\ntype BuildCacheConfig =\n  | {\n      /**\n       * webpack 文件缓存系统的缓存目录\n       */\n      cacheDirectory?: string;\n    }\n  | boolean;\n\n\n * 默认值：\n\nconst defaultBuildCacheConfig = {\n  cacheDirectory: './node_modules/.cache/webpack',\n};\n\n\n * 打包工具： 仅支持 webpack\n\n控制 Builder 在构建过程中的缓存行为。\n\nBuilder 默认会开启构建缓存来提升二次构建的速度，并默认把生成的缓存文件写到 ./node_modules/.cache/webpack 目录下。\n\n你可以通过 buildCache 配置缓存路径，比如：\n\nexport default {\n  performance: {\n    buildCache: {\n      cacheDirectory: './node_modules/.custom_cache/webpack',\n    },\n  },\n};\n\n\n如果不希望缓存，你也可以将 buildCache 置为 false 将其禁用掉：\n\nexport default {\n  performance: {\n    buildCache: false,\n  },\n};\n","frontmatter":{"sidebar_label":"buildCache"}},{"id":445,"title":"performance.bundleAnalyze","routePath":"/configure/app/performance/bundle-analyze","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.bundleAnalyze。\n\n * 类型： Object | undefined\n\n你有两种方式开启 webpack-bundle-analyzer 来分析构建产物的体积:\n\n * 添加环境变量 BUNDLE_ANALYZE=true；\n * 配置 performance.bundleAnalyze。\n\n默认情况下，不会开启 webpack-bundle-analyzer，当开启之后它的配置如下:\n\n{\n  analyzerMode: 'static',\n  openAnalyzer: false,\n  // target 为编译目标，如 `web`、`node` 等\n  reportFilename: `report-${target}.html`,\n}\n\n\n你可以通过 performance.bundleAnalyze 来覆盖默认配置，比如：\n\nexport default {\n  performance: {\n    bundleAnalyze: {\n      analyzerMode: 'server',\n      openAnalyzer: true,\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"bundleAnalyze"}},{"id":446,"title":"performance.chunkSplit","routePath":"/configure/app/performance/chunk-split","lang":"zh","toc":[{"id":"chunksplitstrategy","text":"chunkSplit.strategy","depth":3},{"id":"chunksplitminsize","text":"chunkSplit.minSize","depth":3},{"id":"chunksplitmaxsize","text":"chunkSplit.maxSize","depth":3},{"id":"chunksplitforcesplitting","text":"chunkSplit.forceSplitting","depth":3},{"id":"chunksplitsplitchunks","text":"chunkSplit.splitChunks","depth":3},{"id":"chunksplitoverride","text":"chunkSplit.override","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.chunkSplit。\n\n * 类型： Object\n * 默认值： { strategy: 'split-by-experience' }\n\nperformance.chunkSplit 用于配置 Builder 的拆包策略。配置项的类型 ChunkSplit 如下:\n\ninterface BaseChunkSplit {\n  strategy?:\n    | 'split-by-module'\n    | 'split-by-experience'\n    | 'all-in-one'\n    | 'single-vendor';\n  override?: SplitChunks;\n  forceSplitting?: Array<RegExp>;\n}\n\ninterface SplitBySize {\n  strategy?: 'split-by-size';\n  minSize?: number;\n  maxSize?: number;\n  override?: SplitChunks;\n  forceSplitting?: Array<RegExp>;\n}\n\ninterface SplitCustom {\n  strategy?: 'custom';\n  splitChunks?: SplitChunks;\n  forceSplitting?: Array<RegExp>;\n}\n\nexport type ChunkSplit = BaseChunkSplit | SplitBySize | SplitCustom;\n\n\n\nchunkSplit.strategy\n\nBuilder 支持六种类型的拆包策略:\n\n * split-by-experience: 根据经验内置拆分策略\n * split-by-module: 根据 NPM 包拆分，每个 NPM 包一个 chunk\n * split-by-size: 根据 chunk 大小拆分\n * all-in-one: 所有代码打包到一个 chunk\n * single-vendor: node_modules 中的代码打包到一个单独的 chunk\n * custom: 自定义拆包配置\n\nBuilder 默认采用 split-by-experience 策略，具体来说，以下的 NPM 包分组会被拆分为单独的 chunk:\n\n * react 和 react-dom\n * react-router、history 和 react-router-dom\n * antd 组件库\n * semi 组件库\n * arco 组件库\n * @babel/runtime 的代码(也包括 @babel/runtime-corejs2、 @babel/runtime-corejs3)\n * lodash 和 lodash-es\n * core-js\n\n如果你想使用其他拆包策略，可以通过 performance.chunkSplit.strategy 配置项来指定。\n\n\nchunkSplit.minSize\n\n * 类型： number\n * 默认值： 10000\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.minSize 配置项来指定 chunk 的最小大小，单位为字节。默认值为 10000。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-size',\n      minSize: 20000,\n    },\n  },\n};\n\n\n\nchunkSplit.maxSize\n\n * 类型： number\n * 默认值： Infinity\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.maxSize 配置项来指定 chunk 的最大大小，单位为字节。默认值为 Infinity。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'split-by-size',\n      maxSize: 50000,\n    },\n  },\n};\n\n\n\nchunkSplit.forceSplitting\n\n * 类型： Array<RegExp>\n * 默认值： []\n\n通过 performance.chunkSplit.forceSplitting 配置项可以指定强制拆包的 NPM 包。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      forceSplitting: [/^@arco-design\\/web-react/],\n    },\n  },\n};\n\n\n相比直接配置 webpack 的 splitChunks，这是一个更加简便的方式。\n\n\nchunkSplit.splitChunks\n\n当 performance.chunkSplit.strategy 为 custom 时，可以通过\nperformance.chunkSplit.splitChunks 配置项来指定自定义的 webpack 拆包配置。此配置会和 webpack 的\nsplitChunks 配置进行合并（cacheGroups 配置也会合并）。比如:\n\nexport default {\n  performance: {\n    chunkSplit: {\n      strategy: 'custom',\n      splitChunks: {\n        cacheGroups: {\n          react: {\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n            name: 'react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n  },\n};\n\n\n\nchunkSplit.override\n\n当 performance.chunkSplit.strategy 为\nsplit-by-experience、split-by-module、split-by-size 或 single-vendor 时，可以通过\nperformance.chunkSplit.override 配置项来自定义 webpack 拆包配置，此配置会和 webpack 的 splitChunks\n配置进行合并（cacheGroups 配置也会合并）。比如:\n\nexport default {\n  performance: {\n    strategy: 'split-by-experience',\n    chunkSplit: {\n      override: {\n        cacheGroups: {\n          react: {\n            test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n            name: 'react',\n            chunks: 'all',\n          },\n        },\n      },\n    },\n  },\n};\n\n\n> 当 Builder 构建 \"node\" 类型的产物时，由于 Node Bundles 不需要通过拆包来优化加载性能，因此 chunkSplit\n> 规则不会生效。","frontmatter":{"sidebar_label":"chunkSplit"}},{"id":447,"title":"performance.printFileSize","routePath":"/configure/app/performance/print-file-size","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.printFileSize。\n\n * 类型： boolean\n * 默认值： true\n\n是否在生产环境构建后输出所有静态资源文件的体积。\n\ninfo    File sizes after production build:\n\n  File                                     Size         Gzipped\n  dist/static/js/lib-corejs.1c836fe7.js    212.89 kB    66.57 kB\n  dist/static/js/lib-react.fcafbc5c.js     134.65 kB    43.45 kB\n  dist/static/js/main.6ff06f70.js          8.93 kB      3.73 kB\n  dist/static/css/main.9f48031b.css        2.64 kB      927 B\n  dist/html/main/index.html                1.64 kB      874 B\n\n\n\n示例\n\n禁用相关日志：\n\nexport default {\n  performance: {\n    printFileSize: false,\n  },\n};\n","frontmatter":{"sidebar_label":"printFileSize"}},{"id":448,"title":"performance.profile","routePath":"/configure/app/performance/profile","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.profile。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否捕获每个模块的耗时信息，对应 webpack 的 profile 配置。\n\n\n示例\n\nexport default {\n  performance: {\n    profile: true,\n  },\n};\n\n\n开启后，Webpack 生成一些有关模块的统计数据的 JSON 文件会将模块构建的耗时信息也包含进去。","frontmatter":{"sidebar_label":"profile"}},{"id":449,"title":"performance.removeConsole","routePath":"/configure/app/performance/remove-console","lang":"zh","toc":[{"id":"移除所有-console","text":"移除所有 console","depth":4},{"id":"移除特定的-console","text":"移除特定的 console","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.removeConsole。\n\n * 类型： boolean | ConsoleType[]\n * 默认值： false\n\n在生产环境构建时，是否自动移除代码中的 console.xx。\n\n移除所有 console\n\n当 removeConsole 被设置为 true 时，会移除所有类型的 console.xx：\n\nexport default {\n  performance: {\n    removeConsole: true,\n  },\n};\n\n\n移除特定的 console\n\n你也可以指定仅移除特定类型的 console.xx，比如移除 console.log 和 console.warn：\n\nexport default {\n  performance: {\n    removeConsole: ['log', 'warn'],\n  },\n};\n\n\n目前支持配置以下类型的 console：\n\ntype ConsoleType = 'log' | 'info' | 'warn' | 'error' | 'table' | 'group';\n","frontmatter":{"sidebar_label":"removeConsole"}},{"id":450,"title":"performance.removeMomentLocale","routePath":"/configure/app/performance/remove-moment-locale","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 performance.removeMomentLocale。\n\n * 类型： boolean\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n是否移除 moment.js 的语言包文件。\n\nmoment.js 默认包含了大量的语言包文件，会导致打包后的包体积增大。\n\n当项目中使用了 moment.js 时，推荐开启此选项，自动排除所有的语言包文件：\n\nexport default {\n  performance: {\n    removeMomentLocale: true,\n  },\n};\n\n\n开启后，可以通过以下方式来加载语言包文件：\n\n\nimport 'moment/locale/zh-cn';\n\nmoment.locale('zh-cn');\n","frontmatter":{"sidebar_label":"removeMomentLocale"}},{"id":451,"title":"plugins (插件)","routePath":"/configure/app/plugins","lang":"zh","toc":[{"id":"注意事项","text":"注意事项","depth":2},{"id":"插件类型","text":"插件类型","depth":2},{"id":"插件执行顺序","text":"插件执行顺序","depth":2},{"id":"示例","text":"示例","depth":2},{"id":"使用-npm-上的插件","text":"使用 npm 上的插件","depth":3},{"id":"使用本地插件","text":"使用本地插件","depth":3},{"id":"插件配置项","text":"插件配置项","depth":3}],"domain":"","content":"\n\n * 类型： CliPlugin[]\n * 默认值： []\n\n用于配置自定义的 Modern.js 框架插件。\n\n自定义插件的编写方式请参考 如何编写插件。\n\n\n注意事项\n\n该选项用于配置框架插件，如果你需要配置其他类型的插件，请选择对应的配置方式：\n\n * 配置 Modern.js Builder 插件，请使用 builderPlugins 配置项。\n * 配置 webpack 插件，请使用 tools.webpack 或 tools.webpackChain 配置项。\n * 配置 Babel 插件，请使用 tools.babel 配置项。\n\n\n插件类型\n\nModern.js 中内置了三种不同的框架插件：\n\n * CLI 插件，适用于本地开发、编译构建阶段，可以在命令行和编译阶段扩展各种能力。\n * Server 插件，适用于服务端。\n * Runtime 插件，适用于前端运行时。\n\n目前 Modern.js 开放了自定义 CLI 插件的能力，Server 插件和 Runtime 插件会在后续开放。\n\n\n插件执行顺序\n\n默认情况下，自定义插件会按照 plugins 数组的顺序依次执行，Modern.js 内置插件的执行时机早于自定义插件。\n\n当插件内部使用了控制顺序的相关字段，比如 pre、post 时，会基于声明的字段对执行顺序进行调整，详见 插件之间的关系。\n\n\n示例\n\n下面是 CLI 插件的使用示例。\n\n\n使用 npm 上的插件\n\n使用 npm 上的插件，需要通过包管理器安装插件，并通过 import 引入。\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n使用本地插件\n\n使用本地代码仓库中的插件，直接通过相对路径 import 引入即可。\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n插件配置项\n\n如果插件提供了一些自定义的配置项，可以通过插件函数的参数传入配置。\n\n\n\nexport default defineConfig({\n  plugins: [\n    myPlugin({\n      foo: 1,\n      bar: 2,\n    }),\n  ],\n});\n","frontmatter":{"title":"plugins (插件)","sidebar_position":9}},{"id":452,"title":"总览","routePath":"/configure/app/runtime/intro","lang":"zh","toc":[{"id":"配置方式","text":"配置方式","depth":2},{"id":"runtime","text":"runtime","depth":3},{"id":"基本用法","text":"基本用法","depth":4},{"id":"运行时配置","text":"运行时配置","depth":4},{"id":"runtimebyentries","text":"runtimeByEntries","depth":3},{"id":"说明","text":"说明","depth":4}],"domain":"","content":"\n\n此节将介绍 Runtime 插件的配置。\n\n\n配置方式\n\n\nruntime\n\n * 类型： Object\n\nruntime 配置方式如下：\n\n基本用法\n\n在 modern.config.ts 中配置\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: true,\n    router: true,\n  },\n});\n\n\n运行时配置\n\n通过 defineConfig API 配置：\n\nINFO\n\n当 runtime 配置中存在函数时，只能使用该方式进行配置。\n\n\n\nexport const config = (): AppConfig => {\n  return {\n    router: {\n      supportHtml5History: false\n    }\n  }\n};\n\n\n\n\nconst App = () => {\n  /** */\n};\n\ndefineConfig(App, {\n  router: {\n    supportHtml5History: false,\n  },\n});\n\nexport default App;\n\n\nINFO\n\n使用运行时配置，可以解决 Runtime 插件配置需要在运行时才能获取到具体内容问题。\n\nRuntime 插件运行时配置和直接在 modern.config.ts 中的配置默认会进行合并，且运行时配置优先级更高。\n\nWARNING\n\ndefineConfig 中只能定义 Runtime 插件的具体配置内容，确认是否开启插件还需要通过 package.json 中的 modernConfig\n或者 modern.config.ts 中的配置决定。\n\n\nruntimeByEntries\n\n * 类型： Object\n * **默认值：**无\n\n说明\n\n按入口添加 runtime 配置，选项属性同 runtime 一致，指定值会和 runtime 属性内容做替换合并操作。\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: false,\n  },\n  runtimeByEntries: {\n    entry1: {\n      state: true, // { state: true }\n    },\n    entry2: {\n      // { state: false, router: true }\n      router: true,\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"总览","sidebar_position":1}},{"id":453,"title":"runtime.masterApp","routePath":"/configure/app/runtime/master-app","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2},{"id":"manifest","text":"manifest","depth":2},{"id":"getapplist","text":"getAppList?","depth":3},{"id":"apps","text":"apps","depth":3},{"id":"其他配置项","text":"其他配置项","depth":3}],"domain":"","content":"\n\n * 类型： Object\n\nINFO\n\n需要先通过 pnpm run new 启用「微前端」 功能。\n\n\n示例\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n\nmanifest\n\ninterface Manifest {\n  getAppList?: () => Array<AppInfo>;\n}\n\n\n\ngetAppList?\n\n通过 getAppList 配置，可以自定义如何获取远程列表数据\n\ntype GetAppList = () => Promise<Array<AppInfo>>;\n\n\n\napps\n\n当 apps 为对象类型的时候，表示子应用模块的信息 Array<AppInfo>\n\ninterface AppInfo {\n  name: string;\n  entry: string;\n  activeWhen?: string | ()=> boolean;\n}\n\n\n * name: 子应用的名称。\n * entry: 子应用的入口。\n * activeWhen?: 子应用激活路径。\n\n\n其他配置项\n\n在 masterApp 配置下，开发者可以透传 Garfish 的配置项。\n\n所有支持的配置项点此查看。","frontmatter":{"sidebar_label":"masterApp"}},{"id":454,"title":"runtime.router","routePath":"/configure/app/runtime/router","lang":"zh","toc":[{"id":"basename","text":"basename","depth":2},{"id":"supporthtml5history","text":"supportHtml5History","depth":2}],"domain":"","content":"\n\n * 类型： boolean | Object\n * 默认值： false\n\n开启 router 之后，支持使用 Modern.js 默认提供的约定式路由进行路由管理。Modern.js 的路由模块基于 React Router 6\n实现。\n\n具体配置如下：\n\n\nbasename\n\n * 类型： string\n * 默认值： ``\n\n设置客户端路由的 basename，通常用于应用需要部署在域名非根路径下的场景。\n\n\nsupportHtml5History\n\n * 类型： boolean\n * 默认值： true\n\n值为 true，使用 BrowserRouter；否则使用 HashRouter。推荐使用 BrowserRouter。\n\nWARNING\n\n当开启 SSR 时，不支持设置 supportHtml5History。","frontmatter":{"sidebar_label":"router"}},{"id":455,"title":"runtime.state","routePath":"/configure/app/runtime/state","lang":"zh","toc":[{"id":"models","text":"models","depth":2},{"id":"initialstate","text":"initialState","depth":2},{"id":"immer","text":"immer","depth":2},{"id":"effects","text":"effects","depth":2},{"id":"autoactions","text":"autoActions","depth":2},{"id":"devtools","text":"devtools","depth":2}],"domain":"","content":"\n\n * 类型： boolean | object\n * 默认值： false\n\n开启 state 后就可以使用 Model 来做状态管理。\n\n具体配置项如下：\n\n\nmodels\n\n * 类型： Array<Model>\n * 默认值： []\n\n注册提前挂载的 model 对象，这些 model 会在 Reduck store 创建完成后立即执行挂载。一般使用无需提前挂载。\n\n\ninitialState\n\n * 类型： Object\n * 默认值： {}\n\n用于设置全局 store 的初始状态。一般用于 SSR 在 hydration 阶段初始化数据。\n\n\nimmer\n\n * 类型： boolean\n * 默认值： true\n\n是否启用以 mutable 更新 state 的方式，默认启用，若想禁用则设置为 false。\n\n\neffects\n\n * 类型： boolean\n * 默认值： true\n\n是否启用副作用管理特性，默认启用，若想禁用则设置为 false。\n\n\nautoActions\n\n * 类型： boolean\n * 默认值： true\n\n是否启用自动生成 actions 特性，默认启用，若想禁用则设置为 false。\n\n\ndevtools\n\n * 类型： boolean | EnhancerOptions\n * 默认值： true\n\n是否启用 devtools，默认启用，同时支持 redux-devtools-extension 的所有参数，若想禁用则设置为 false。","frontmatter":{"sidebar_label":"state"}},{"id":456,"title":"security.checkSyntax","routePath":"/configure/app/security/check-syntax","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3},{"id":"错误日志","text":"错误日志","depth":3},{"id":"解决方法","text":"解决方法","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 security.checkSyntax。\n\n * 类型：\n\ntype CheckSyntax =\n  | boolean\n  | {\n      targets: string[];\n    };\n\n\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n分析构建产物中是否存在当前浏览器范围下不兼容的高级语法。如果存在，会将详细信息打印在终端。\n\n\n示例\n\nexport default {\n  security: {\n    checkSyntax: true,\n  },\n};\n\n\n如果将 security.checkSyntax 指定为 true 的话，则 targets 会被认定为项目设定的 browserslist，详情请参考\n设置浏览器范围。\n\n开启后将在生产环境下进行检测，当检测到不兼容的高级语法后，会将错误日志打印在终端，并退出当前构建流程。\n\n\n错误日志\n\n错误日志的格式如下所示，包含代码来源文件、产物位置、错误原因、源代码等信息：\n\nerror   [Syntax Checker] Find some syntax errors after production build:\n\n  ERROR#1:\n  source - /node_modules/foo/index.js:1:0\n  output - /Project/dist/static/js/main.3f7a4d7e.js:2:39400\n  reason - The keyword 'const' is reserved (2:39400)\n  code   - const foo = 'bar';\n\n\n\n解决方法\n\n当检测到语法错误后，你可以通过以下方式来处理：\n\n * 如果你希望降级该语法，以保证代码具备良好的兼容性，可以通过 source.include 配置来编译相应的模块。\n * 如果你不希望降级该语法，可以调整项目的 browserslist 范围，调整至与该语法相匹配的范围。","frontmatter":{"sidebar_label":"checkSyntax"}},{"id":457,"title":"security.sri","routePath":"/configure/app/security/sri","lang":"zh","toc":[{"id":"sri-介绍","text":"SRI 介绍","depth":4},{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 security.sri。\n\n * 类型：\n\ntype SRIOptions =\n  | {\n      hashFuncNames?: string[];\n      enabled?: 'auto' | boolean;\n      hashLoading?: 'eager' | 'lazy';\n    }\n  | boolean;\n\n\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n为 HTML 所引入的子资源添加完整性属性 —— integrity，使浏览器能够验证引入资源的完整性，以此防止下载的资源被篡改。\n\n启动该选项后会将 webpack 的 output.crossOriginLoading 配置项设置为 anonymous。\n\nSRI 介绍\n\n子资源完整性 Subresource Integrity（SRI）是专门用来校验资源的一种方案，它读取资源标签中的 integrity\n属性，将其中的信息摘要值，和资源实际的信息摘要值进行对比，如果发现无法匹配，那么浏览器就会拒绝执行资源。\n\n对于 script 标签来说，结果为拒绝执行其中的代码；对于 CSS link 来说，结果为不加载其中的样式。\n\n关于 SRI 的更多内容，可以查看 Subresource Integrity - MDN。\n\n\n示例\n\n默认情况下，不会开启 SRI，当开启之后它的默认配置如下：\n\n{\n  hashFuncNames: ['sha384'];\n  enabled: \"auto\",\n  hashLoading: \"eager\",\n}\n\n\n你可以按照你自己的需求自定义配置项:\n\nexport default {\n  security: {\n    sri: {\n      hashFuncNames: ['sha-256'],\n      enabled: true,\n      hashLoading: 'lazy',\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"sri"}},{"id":458,"title":"server.baseUrl","routePath":"/configure/app/server/base-url","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： string | string[]\n * 默认值： undefined\n\n统一设置服务端路由前缀（常用于共享域名的情况，区分流量)。\n\nexport default defineConfig({\n  server: {\n    // 所有生成的路由前面都会自动加上前缀 `/base`\n    // 生成的服务端路由文件路径：dist/route.json\n    baseUrl: '/base'\n\n    // 多 baseUrl\n    baseUrl: ['/base-new', '/base-old']\n  }\n})\n\n\ndev 之后可以看到路由访问会加上对应前缀:\n\nApp running at:\n\n  > Local:    http://localhost:8080/base/\n  > Network:  http://192.168.0.1:8080/base/\n","frontmatter":{"sidebar_label":"baseUrl"}},{"id":459,"title":"server.enableFrameworkExt","routePath":"/configure/app/server/enable-framework-ext","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n * 类型： boolean\n * 默认值： false\n\n默认情况下，开启自定义 Web Server 功能后，Middleware 会使用 Modern.js 本身的语法。\n\n开启 server.enableFrameworkExt 可以使用其他框架扩展的语法。\n\nexport default defineConfig({\n  server: {\n    enableFrameworkExt: true,\n  },\n});\n\n\n\n示例\n\n默认的使用方式：\n\n\n\nexport const middleware: Middleware = (ctx, next) => {\n  console.log(ctx.request.url);\n  next();\n};\n\n\n开启后，Middleware 类型将从其他命名空间下导出，并且可以使用框架拓展的语法：\n\n\n\nexport const middleware: SomeType = (...args) => {\n  console.log(args[0].url);\n  next();\n};\n\n\nNOTE\n\n上述代码为伪代码，具体使用方式需要参考对应的框架拓展。","frontmatter":{"sidebar_label":"enableFrameworkExt"}},{"id":460,"title":"server.port","routePath":"/configure/app/server/port","lang":"zh","toc":[{"id":"与-devport-的区别","text":"与 dev.port 的区别","depth":3}],"domain":"","content":"\n\n * 类型： number\n * 默认值： 8080\n\nModern.js 在执行 dev, start 和 serve 命令时，会以 8080\n为默认端口启动，并会在端口被占用时自动递增端口号。你可以通过该配置来修改 Server 启动的端口号：\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n  },\n});\n\n\n\n与 dev.port 的区别\n\n大多数情况下，我们推荐使用 server.port 而不是 dev.port 来设置端口号，他们之间的区别如下：\n\n * dev.port 仅在开发环境下生效，server.port 在开发环境和生产环境下均能生效。\n * 在开发环境下，dev.port 的优先级高于 server.port。\n\n当你同时设置 dev.port 和 server.port 时，dev.port 会在开发环境下生效，server.port\n会在生产环境下生效。比如以下例子，在开发环境下监听的端口号为 3001，在生产环境下监听的端口号为 3002。\n\nexport default defineConfig({\n  dev: {\n    port: 3001,\n  },\n  server: {\n    port: 3002,\n  },\n});\n","frontmatter":{"sidebar_label":"port"}},{"id":461,"title":"server.publicRoutes","routePath":"/configure/app/server/public-routes","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： Object\n * 默认值： 根据文件约定自动生成的服务端路由规则：应用的每个文件生成一条路由规则。\n\n该配置选项只作用于服务端路由，可以自定义 config/public/ 下资源的访问路由。\n\n对象的 key 为当前应用的相对文件路径（不使用 ./）, 值可以是 string。\n\nexport default defineConfig({\n  server: {\n    publicRoutes: {\n      // 设置一个长路由\n      'index.json': '/user-config/card-info/extra/help.json',\n\n      // 设置一个不带后缀的路由\n      'robot.txt': '/app/authentication',\n    },\n  },\n});\n","frontmatter":{"sidebar_label":"publicRoutes"}},{"id":462,"title":"server.routes","routePath":"/configure/app/server/routes","lang":"zh","toc":[{"id":"自定义访问路由","text":"自定义访问路由","depth":2},{"id":"自定义响应头","text":"自定义响应头","depth":2}],"domain":"","content":"\n\n * 类型： Object\n * 默认值： 根据文件约定自动生成的服务端路由规则：应用的每个入口生成一条路由规则，入口名称等于路由名称。\n\n该配置选项只作用于服务端路由，可以自定义应用入口的服务访问配置。\n\n\n自定义访问路由\n\n对象的 key 为当前应用的入口名, 值可以是 string | Array<string>。\n\n当值类型为 string 时，当前值即表示访问该入口的路由名称。\n\nexport default defineConfig({\n  server: {\n    routes: {\n      // 默认路由为 /entryName1，自定义后为 /p/test1\n      entryName1: '/p/test1'\n      // 支持动态服务端路由配置\n      entryName2: '/detail/:id'\n    }\n  }\n});\n\n\n也可以通过 Array<string> 为入口设置多个访问路由:\n\nexport default defineConfig({\n  server: {\n    routes: {\n      'page-a': [`/a`, '/b'],\n    },\n  },\n});\n\n\n此时，通过 /a、/b 两个路由都可以访问到 page-a 入口。\n\n执行 dev 命令后，可以在 dist/route.json 中查看入口 page-a 存在两条路由记录:\n\n{\n  \"routes\": [\n    {\n      \"urlPath\": \"/a\",\n      \"entryName\": \"page-a\",\n      \"entryPath\": \"html/page-a/index.html\",\n      \"isSPA\": true,\n      \"isSSR\": false\n    },\n    {\n      \"urlPath\": \"/b\",\n      \"entryName\": \"page-a\",\n      \"entryPath\": \"html/page-a/index.html\",\n      \"isSPA\": true,\n      \"isSSR\": false\n    }\n  ]\n}\n\n\n\n自定义响应头\n\n可以通过配置入口的 resHeaders 设置响应头：\n\nexport default defineConfig({\n  server: {\n    routes: {\n      'page-a': {\n        route: ['/a', '/b'],\n        resHeaders: {\n          'x-modern-test': '1',\n        },\n      },\n    },\n  },\n});\n\n\nNOTE\n\n这一配置在生产环境与开发环境都生效，可以根据 NODE_ENV 区分环境设置不同的响应头。但如果你只需要在开发环境设置响应头，推荐使用\ntools.devServer.headers。","frontmatter":{"sidebar_label":"routes"}},{"id":463,"title":"server.ssrByEntries","routePath":"/configure/app/server/ssr-by-entries","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： Object\n * 默认值： undefined\n\n按入口设置 ssr 选项，选项内的属性同 ssr，指定值会和 ssr 属性内容做替换合并操作，例如：\n\nINFO\n\n「 入口名 」默认为目录名，少数情况下通过 source.entries 自定义入口时，入口名为 source.entries 对象的 key。\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n    ssrByEntries: {\n      // page-a 不启用 ssr\n      'page-a': false,\n    },\n  },\n});\n\n\n如上配置，项目整体启用了 ssr, 但是针对入口 page-a 关闭了 ssr 渲染能力。","frontmatter":{"sidebar_label":"ssrByEntries"}},{"id":464,"title":"server.ssr","routePath":"/configure/app/server/ssr","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： boolean\n * 默认值： false\n\nSSR 开关以及相关设置。\n\n当值类型为 boolean 时，表示是否开启 SSR 部署模式，默认 false 不开启。\n\nexport default defineConfig({\n  server: {\n    ssr: true,\n  },\n});\n","frontmatter":{"sidebar_label":"ssr"}},{"id":465,"title":"source.alias","routePath":"/configure/app/source/alias","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":4},{"id":"function-类型","text":"Function 类型","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.alias。\n\n * 类型： Record<string, string | string[]> | Function\n * 默认值： undefined\n\n设置文件引用的别名，对应 webpack 的 resolve.alias 配置。\n\nTIP\n\n对于 TypeScript 项目，只需要在 tsconfig.json 中配置 compilerOptions.paths 即可，Builder 会自动识别\ntsconfig.json 里的别名，因此不需要额外配置 alias字段。\n\nObject 类型\n\nalias 的值可以定义为 Object 类型，其中的相对路径会自动被 Builder 转换为绝对路径。\n\nexport default {\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n};\n\n\n以上配置完成后，如果在代码中引用 @common/Foo.tsx, 则会映射到 <root>/src/common/Foo.tsx 路径上。\n\nFunction 类型\n\nalias 的值定义为函数时，可以接受预设的 alias 对象，并对其进行修改。\n\nexport default {\n  source: {\n    alias: alias => {\n      alias['@common'] = './src/common';\n    },\n  },\n};\n\n\n也可以在函数中返回一个新对象作为最终结果，新对象会覆盖预设的 alias 对象。\n\nexport default {\n  source: {\n    alias: alias => {\n      return {\n        '@common': './src/common',\n      };\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"alias"}},{"id":466,"title":"source.compileJsDataURI","routePath":"/configure/app/source/compile-js-data-uri","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.compileJsDataURI。\n\n * 类型： boolean\n * 默认值： true\n\n对于使用 Data URI 引入的 JavaScript 代码，是否采用 babel 进行编译。\n\n比如以下代码：\n\n\n\nimport 'data:text/javascript;charset=utf-8;base64,Y29uc29sZS5sb2coJ2lubGluZSAxJyk7';\n\n\n\n示例\n\n添加以下配置来关闭：\n\nexport default {\n  source: {\n    compileJsDataURI: false,\n  },\n};\n","frontmatter":{"sidebar_label":"compileJsDataURI"}},{"id":467,"title":"source.configDir","routePath":"/configure/app/source/config-dir","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： string\n * 默认值： ./config\n\nModern.js 支持在 ./config 文件夹下放置一些文件自定义 HTML 模板、图标、静态资源等，具体可参考文件约定。\n\n通过该选项可以自定义配置文件的目录。\n\n例如，将资源文件目录调整为 resources 目录：\n\n\n\nexport default defineConfig({\n  source: {\n    configDir: './resources',\n  },\n});\n","frontmatter":{"title":"source.configDir","sidebar_label":"configDir"}},{"id":468,"title":"source.define","routePath":"/configure/app/source/define","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.define。\n\n * 类型： Record<string, unknown>\n * 默认值： {}\n\n构建时将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n传入的配置对象的键名是需要替换变量的名称，或者是用 . 连接的多个标识符，配置项的值则根据类型进行不同的处理：\n\n * 字符串会被当作代码片段。\n * 包括函数在内的其他类型会被转换成字符串。\n * 嵌套对象的父子键名之间会用 . 连接作为需要替换的变量名。\n * 以 typeof 开头的键名会用来替换 typeof 调用。\n\n更多细节参考 https://webpack.js.org/plugins/define-plugin/。\n\n\n示例\n\nexport default {\n  source: {\n    define: {\n      PRODUCTION: JSON.stringify(true),\n      VERSION: JSON.stringify('5fa3b9'),\n      BROWSER_SUPPORTS_HTML5: true,\n      TWO: '1 + 1',\n      'typeof window': JSON.stringify('object'),\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n      'import.meta': { test: undefined },\n    },\n  },\n};\n\n\n表达式会被替换为对应的代码段：\n\nconst foo = TWO;\n\n// ⬇️ Turn into being...\nconst foo = 1 + 1;\n","frontmatter":{"sidebar_label":"define"}},{"id":469,"title":"source.designSystem","routePath":"/configure/app/source/design-system","lang":"zh","toc":[{"id":"结构","text":"结构","depth":3},{"id":"screens","text":"Screens","depth":4},{"id":"colors","text":"Colors","depth":4},{"id":"spacing","text":"Spacing","depth":4},{"id":"core-plugins","text":"Core plugins","depth":4},{"id":"自定义默认配置","text":"自定义默认配置","depth":3},{"id":"覆盖默认配置","text":"覆盖默认配置","depth":4},{"id":"扩展默认配置","text":"扩展默认配置","depth":4},{"id":"引用其他值","text":"引用其他值","depth":4},{"id":"禁用整个核心插件","text":"禁用整个核心插件","depth":4},{"id":"添加自己的-key","text":"添加自己的 key","depth":4},{"id":"配置引用","text":"配置引用","depth":3},{"id":"额外的配置","text":"额外的配置","depth":3},{"id":"sourcedesignsystemsupportstyledcomponents","text":"source.designSystem.supportStyledComponents","depth":4}],"domain":"","content":"\n\n * 类型： Object\n * **默认值：**见下方配置详情。\n\n注意\n\n需要先通过 pnpm run new 启用 Tailwind CSS 功能。\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n  colors: {\n    transparent: 'transparent',\n    current: 'currentColor',\n\n    black: '#000',\n    white: '#fff',\n\n    gray: {\n      100: '#f7fafc',\n      200: '#edf2f7',\n      300: '#e2e8f0',\n      400: '#cbd5e0',\n      500: '#a0aec0',\n      600: '#718096',\n      700: '#4a5568',\n      800: '#2d3748',\n      900: '#1a202c',\n    },\n    red: {\n      100: '#fff5f5',\n      200: '#fed7d7',\n      300: '#feb2b2',\n      400: '#fc8181',\n      500: '#f56565',\n      600: '#e53e3e',\n      700: '#c53030',\n      800: '#9b2c2c',\n      900: '#742a2a',\n    },\n    orange: {\n      100: '#fffaf0',\n      200: '#feebc8',\n      300: '#fbd38d',\n      400: '#f6ad55',\n      500: '#ed8936',\n      600: '#dd6b20',\n      700: '#c05621',\n      800: '#9c4221',\n      900: '#7b341e',\n    },\n    yellow: {\n      100: '#fffff0',\n      200: '#fefcbf',\n      300: '#faf089',\n      400: '#f6e05e',\n      500: '#ecc94b',\n      600: '#d69e2e',\n      700: '#b7791f',\n      800: '#975a16',\n      900: '#744210',\n    },\n    green: {\n      100: '#f0fff4',\n      200: '#c6f6d5',\n      300: '#9ae6b4',\n      400: '#68d391',\n      500: '#48bb78',\n      600: '#38a169',\n      700: '#2f855a',\n      800: '#276749',\n      900: '#22543d',\n    },\n    teal: {\n      100: '#e6fffa',\n      200: '#b2f5ea',\n      300: '#81e6d9',\n      400: '#4fd1c5',\n      500: '#38b2ac',\n      600: '#319795',\n      700: '#2c7a7b',\n      800: '#285e61',\n      900: '#234e52',\n    },\n    blue: {\n      100: '#ebf8ff',\n      200: '#bee3f8',\n      300: '#90cdf4',\n      400: '#63b3ed',\n      500: '#4299e1',\n      600: '#3182ce',\n      700: '#2b6cb0',\n      800: '#2c5282',\n      900: '#2a4365',\n    },\n    indigo: {\n      100: '#ebf4ff',\n      200: '#c3dafe',\n      300: '#a3bffa',\n      400: '#7f9cf5',\n      500: '#667eea',\n      600: '#5a67d8',\n      700: '#4c51bf',\n      800: '#434190',\n      900: '#3c366b',\n    },\n    purple: {\n      100: '#faf5ff',\n      200: '#e9d8fd',\n      300: '#d6bcfa',\n      400: '#b794f4',\n      500: '#9f7aea',\n      600: '#805ad5',\n      700: '#6b46c1',\n      800: '#553c9a',\n      900: '#44337a',\n    },\n    pink: {\n      100: '#fff5f7',\n      200: '#fed7e2',\n      300: '#fbb6ce',\n      400: '#f687b3',\n      500: '#ed64a6',\n      600: '#d53f8c',\n      700: '#b83280',\n      800: '#97266d',\n      900: '#702459',\n    },\n  },\n  spacing: {\n    px: '1px',\n    0: '0',\n    1: '0.25rem',\n    2: '0.5rem',\n    3: '0.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    8: '2rem',\n    10: '2.5rem',\n    12: '3rem',\n    16: '4rem',\n    20: '5rem',\n    24: '6rem',\n    32: '8rem',\n    40: '10rem',\n    48: '12rem',\n    56: '14rem',\n    64: '16rem',\n  },\n  backgroundColor: theme => theme('colors'),\n  backgroundOpacity: theme => theme('opacity'),\n  backgroundPosition: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  backgroundSize: {\n    auto: 'auto',\n    cover: 'cover',\n    contain: 'contain',\n  },\n  borderColor: theme => ({\n    ...theme('colors'),\n    default: theme('colors.gray.300', 'currentColor'),\n  }),\n  borderOpacity: theme => theme('opacity'),\n  borderRadius: {\n    none: '0',\n    sm: '0.125rem',\n    default: '0.25rem',\n    md: '0.375rem',\n    lg: '0.5rem',\n    full: '9999px',\n  },\n  borderWidth: {\n    default: '1px',\n    0: '0',\n    2: '2px',\n    4: '4px',\n    8: '8px',\n  },\n  boxShadow: {\n    xs: '0 0 0 1px rgba(0, 0, 0, 0.05)',\n    sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',\n    default: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',\n    md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',\n    lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',\n    xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',\n    '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',\n    inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',\n    outline: '0 0 0 3px rgba(66, 153, 225, 0.5)',\n    none: 'none',\n  },\n  container: {},\n  cursor: {\n    auto: 'auto',\n    default: 'default',\n    pointer: 'pointer',\n    wait: 'wait',\n    text: 'text',\n    move: 'move',\n    'not-allowed': 'not-allowed',\n  },\n  divideColor: theme => theme('borderColor'),\n  divideOpacity: theme => theme('borderOpacity'),\n  divideWidth: theme => theme('borderWidth'),\n  fill: {\n    current: 'currentColor',\n  },\n  flex: {\n    1: '1 1 0%',\n    auto: '1 1 auto',\n    initial: '0 1 auto',\n    none: 'none',\n  },\n  flexGrow: {\n    0: '0',\n    default: '1',\n  },\n  flexShrink: {\n    0: '0',\n    default: '1',\n  },\n  fontFamily: {\n    sans: [\n      'system-ui',\n      '-apple-system',\n      'BlinkMacSystemFont',\n      '\"Segoe UI\"',\n      'Roboto',\n      '\"Helvetica Neue\"',\n      'Arial',\n      '\"Noto Sans\"',\n      'sans-serif',\n      '\"Apple Color Emoji\"',\n      '\"Segoe UI Emoji\"',\n      '\"Segoe UI Symbol\"',\n      '\"Noto Color Emoji\"',\n    ],\n    serif: ['Georgia', 'Cambria', '\"Times New Roman\"', 'Times', 'serif'],\n    mono: [\n      'Menlo',\n      'Monaco',\n      'Consolas',\n      '\"Liberation Mono\"',\n      '\"Courier New\"',\n      'monospace',\n    ],\n  },\n  fontSize: {\n    xs: '0.75rem',\n    sm: '0.875rem',\n    base: '1rem',\n    lg: '1.125rem',\n    xl: '1.25rem',\n    '2xl': '1.5rem',\n    '3xl': '1.875rem',\n    '4xl': '2.25rem',\n    '5xl': '3rem',\n    '6xl': '4rem',\n  },\n  fontWeight: {\n    hairline: '100',\n    thin: '200',\n    light: '300',\n    normal: '400',\n    medium: '500',\n    semibold: '600',\n    bold: '700',\n    extrabold: '800',\n    black: '900',\n  },\n  height: theme => ({\n    auto: 'auto',\n    ...theme('spacing'),\n    full: '100%',\n    screen: '100vh',\n  }),\n  inset: {\n    0: '0',\n    auto: 'auto',\n  },\n  letterSpacing: {\n    tighter: '-0.05em',\n    tight: '-0.025em',\n    normal: '0',\n    wide: '0.025em',\n    wider: '0.05em',\n    widest: '0.1em',\n  },\n  lineHeight: {\n    none: '1',\n    tight: '1.25',\n    snug: '1.375',\n    normal: '1.5',\n    relaxed: '1.625',\n    loose: '2',\n    3: '.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    7: '1.75rem',\n    8: '2rem',\n    9: '2.25rem',\n    10: '2.5rem',\n  },\n  listStyleType: {\n    none: 'none',\n    disc: 'disc',\n    decimal: 'decimal',\n  },\n  margin: (theme, { negative }) => ({\n    auto: 'auto',\n    ...theme('spacing'),\n    ...negative(theme('spacing')),\n  }),\n  maxHeight: {\n    full: '100%',\n    screen: '100vh',\n  },\n  maxWidth: (theme, { breakpoints }) => ({\n    none: 'none',\n    xs: '20rem',\n    sm: '24rem',\n    md: '28rem',\n    lg: '32rem',\n    xl: '36rem',\n    '2xl': '42rem',\n    '3xl': '48rem',\n    '4xl': '56rem',\n    '5xl': '64rem',\n    '6xl': '72rem',\n    full: '100%',\n    ...breakpoints(theme('screens')),\n  }),\n  minHeight: {\n    0: '0',\n    full: '100%',\n    screen: '100vh',\n  },\n  minWidth: {\n    0: '0',\n    full: '100%',\n  },\n  objectPosition: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  opacity: {\n    0: '0',\n    25: '0.25',\n    50: '0.5',\n    75: '0.75',\n    100: '1',\n  },\n  order: {\n    first: '-9999',\n    last: '9999',\n    none: '0',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n    8: '8',\n    9: '9',\n    10: '10',\n    11: '11',\n    12: '12',\n  },\n  padding: theme => theme('spacing'),\n  placeholderColor: theme => theme('colors'),\n  placeholderOpacity: theme => theme('opacity'),\n  space: (theme, { negative }) => ({\n    ...theme('spacing'),\n    ...negative(theme('spacing')),\n  }),\n  stroke: {\n    current: 'currentColor',\n  },\n  strokeWidth: {\n    0: '0',\n    1: '1',\n    2: '2',\n  },\n  textColor: theme => theme('colors'),\n  textOpacity: theme => theme('opacity'),\n  width: theme => ({\n    auto: 'auto',\n    ...theme('spacing'),\n    '1/2': '50%',\n    '1/3': '33.333333%',\n    '2/3': '66.666667%',\n    '1/4': '25%',\n    '2/4': '50%',\n    '3/4': '75%',\n    '1/5': '20%',\n    '2/5': '40%',\n    '3/5': '60%',\n    '4/5': '80%',\n    '1/6': '16.666667%',\n    '2/6': '33.333333%',\n    '3/6': '50%',\n    '4/6': '66.666667%',\n    '5/6': '83.333333%',\n    '1/12': '8.333333%',\n    '2/12': '16.666667%',\n    '3/12': '25%',\n    '4/12': '33.333333%',\n    '5/12': '41.666667%',\n    '6/12': '50%',\n    '7/12': '58.333333%',\n    '8/12': '66.666667%',\n    '9/12': '75%',\n    '10/12': '83.333333%',\n    '11/12': '91.666667%',\n    full: '100%',\n    screen: '100vw',\n  }),\n  zIndex: {\n    auto: 'auto',\n    0: '0',\n    10: '10',\n    20: '20',\n    30: '30',\n    40: '40',\n    50: '50',\n  },\n  gap: theme => theme('spacing'),\n  gridTemplateColumns: {\n    none: 'none',\n    1: 'repeat(1, minmax(0, 1fr))',\n    2: 'repeat(2, minmax(0, 1fr))',\n    3: 'repeat(3, minmax(0, 1fr))',\n    4: 'repeat(4, minmax(0, 1fr))',\n    5: 'repeat(5, minmax(0, 1fr))',\n    6: 'repeat(6, minmax(0, 1fr))',\n    7: 'repeat(7, minmax(0, 1fr))',\n    8: 'repeat(8, minmax(0, 1fr))',\n    9: 'repeat(9, minmax(0, 1fr))',\n    10: 'repeat(10, minmax(0, 1fr))',\n    11: 'repeat(11, minmax(0, 1fr))',\n    12: 'repeat(12, minmax(0, 1fr))',\n  },\n  gridColumn: {\n    auto: 'auto',\n    'span-1': 'span 1 / span 1',\n    'span-2': 'span 2 / span 2',\n    'span-3': 'span 3 / span 3',\n    'span-4': 'span 4 / span 4',\n    'span-5': 'span 5 / span 5',\n    'span-6': 'span 6 / span 6',\n    'span-7': 'span 7 / span 7',\n    'span-8': 'span 8 / span 8',\n    'span-9': 'span 9 / span 9',\n    'span-10': 'span 10 / span 10',\n    'span-11': 'span 11 / span 11',\n    'span-12': 'span 12 / span 12',\n  },\n  gridColumnStart: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n    8: '8',\n    9: '9',\n    10: '10',\n    11: '11',\n    12: '12',\n    13: '13',\n  },\n  gridColumnEnd: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n    8: '8',\n    9: '9',\n    10: '10',\n    11: '11',\n    12: '12',\n    13: '13',\n  },\n  gridTemplateRows: {\n    none: 'none',\n    1: 'repeat(1, minmax(0, 1fr))',\n    2: 'repeat(2, minmax(0, 1fr))',\n    3: 'repeat(3, minmax(0, 1fr))',\n    4: 'repeat(4, minmax(0, 1fr))',\n    5: 'repeat(5, minmax(0, 1fr))',\n    6: 'repeat(6, minmax(0, 1fr))',\n  },\n  gridRow: {\n    auto: 'auto',\n    'span-1': 'span 1 / span 1',\n    'span-2': 'span 2 / span 2',\n    'span-3': 'span 3 / span 3',\n    'span-4': 'span 4 / span 4',\n    'span-5': 'span 5 / span 5',\n    'span-6': 'span 6 / span 6',\n  },\n  gridRowStart: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n  },\n  gridRowEnd: {\n    auto: 'auto',\n    1: '1',\n    2: '2',\n    3: '3',\n    4: '4',\n    5: '5',\n    6: '6',\n    7: '7',\n  },\n  transformOrigin: {\n    center: 'center',\n    top: 'top',\n    'top-right': 'top right',\n    right: 'right',\n    'bottom-right': 'bottom right',\n    bottom: 'bottom',\n    'bottom-left': 'bottom left',\n    left: 'left',\n    'top-left': 'top left',\n  },\n  scale: {\n    0: '0',\n    50: '.5',\n    75: '.75',\n    90: '.9',\n    95: '.95',\n    100: '1',\n    105: '1.05',\n    110: '1.1',\n    125: '1.25',\n    150: '1.5',\n  },\n  rotate: {\n    '-180': '-180deg',\n    '-90': '-90deg',\n    '-45': '-45deg',\n    0: '0',\n    45: '45deg',\n    90: '90deg',\n    180: '180deg',\n  },\n  translate: (theme, { negative }) => ({\n    ...theme('spacing'),\n    ...negative(theme('spacing')),\n    '-full': '-100%',\n    '-1/2': '-50%',\n    '1/2': '50%',\n    full: '100%',\n  }),\n  skew: {\n    '-12': '-12deg',\n    '-6': '-6deg',\n    '-3': '-3deg',\n    0: '0',\n    3: '3deg',\n    6: '6deg',\n    12: '12deg',\n  },\n  transitionProperty: {\n    none: 'none',\n    all: 'all',\n    default:\n      'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform',\n    colors: 'background-color, border-color, color, fill, stroke',\n    opacity: 'opacity',\n    shadow: 'box-shadow',\n    transform: 'transform',\n  },\n  transitionTimingFunction: {\n    linear: 'linear',\n    in: 'cubic-bezier(0.4, 0, 1, 1)',\n    out: 'cubic-bezier(0, 0, 0.2, 1)',\n    'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',\n  },\n  transitionDuration: {\n    75: '75ms',\n    100: '100ms',\n    150: '150ms',\n    200: '200ms',\n    300: '300ms',\n    500: '500ms',\n    700: '700ms',\n    1000: '1000ms',\n  },\n  transitionDelay: {\n    75: '75ms',\n    100: '100ms',\n    150: '150ms',\n    200: '200ms',\n    300: '300ms',\n    500: '500ms',\n    700: '700ms',\n    1000: '1000ms',\n  },\n};\n\n\n提示\n\n更多关于：TailwindCSS 配置。\n\ndesignSystem 用于定义项目的调色板、排版比例（Typographic Scales 或者 Type\nScale）、字体列表、断点、边框圆角值等等。因为 Modern.js 借用了 Tailwind Theme 的设计方式，并且内部也集成了 Tailwind\nCSS，所以 designSystem 使用方式与 Tailwind CSS Theme 相同。\n\n\n结构\n\ndesignSystem 对象包含 screens、colors 和 spacing 的属性，以及每个可自定义核心插件。\n\nScreens\n\n使用 screens 可以自定义项目中的响应断点：\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n};\n\n\n其中 screens 对象里的属性名是屏幕名称（用作 Tailwind CSS 生成的自适应实用程序变体的前缀，例如\nmd:text-center），值是该断点应在其开始的 min-width。\n\n默认断点受常见设备分辨率的启发：\n\nconst designSystem = {\n  screens: {\n    sm: '640px',\n    // => @media (min-width: 640px) { ... }\n\n    md: '768px',\n    // => @media (min-width: 768px) { ... }\n\n    lg: '1024px',\n    // => @media (min-width: 1024px) { ... }\n\n    xl: '1280px',\n    // => @media (min-width: 1280px) { ... }\n  },\n};\n\n\n你可以在你的项目中使用任意你喜欢的名称作为断点的属性：\n\nconst designSystem = {\n  screens: {\n    tablet: '640px',\n    // => @media (min-width: 640px) { ... }\n\n    laptop: '1024px',\n    // => @media (min-width: 1024px) { ... }\n\n    desktop: '1280px',\n    // => @media (min-width: 1280px) { ... }\n  },\n};\n\n\n这些屏幕名称反映在 utilities 中，因此 text-center 现在是这样的：\n\n.text-center {\n  text-align: center;\n}\n\n@media (min-width: 640px) {\n  .tablet\\:text-center {\n    text-align: center;\n  }\n}\n\n@media (min-width: 1024px) {\n  .laptop\\:text-center {\n    text-align: center;\n  }\n}\n\n@media (min-width: 1280px) {\n  .desktop\\:text-center {\n    text-align: center;\n  }\n}\n\n\nMax-width 断点\n\n如果要使用 max-width 断点而不是 min-width，可以将屏幕指定为具有 max 属性的对象：\n\nconst designSystem = {\n  screens: {\n    xl: { max: '1279px' },\n    // => @media (max-width: 1279px) { ... }\n\n    lg: { max: '1023px' },\n    // => @media (max-width: 1023px) { ... }\n\n    md: { max: '767px' },\n    // => @media (max-width: 767px) { ... }\n\n    sm: { max: '639px' },\n    // => @media (max-width: 639px) { ... }\n  },\n};\n\n\n如有必要，以创建带有 min-width 和 max-width 定义的断点，例如：\n\nconst designSystem = {\n  screens: {\n    sm: { min: '640px', max: '767px' },\n    md: { min: '768px', max: '1023px' },\n    lg: { min: '1024px', max: '1279px' },\n    xl: { min: '1280px' },\n  },\n};\n\n\n多个范围的断点\n\n有时，将单个断点定义应用于多个范围会很有用。\n\n例如，假设您有一个 sidebar，并且希望断点基于内容区域宽度而不是整个视口。您可以模拟这种情况，当 sidebar\n可见并缩小内容区域时，断点的样式使用较小的断点样式：\n\nconst designSystem = {\n  screens: {\n    sm: '500px',\n    md: [\n      // Sidebar appears at 768px, so revert to `sm:` styles between 768px\n      // and 868px, after which the main content area is wide enough again to\n      // apply the `md:` styles.\n      { min: '668px', max: '767px' },\n      { min: '868px' },\n    ],\n    lg: '1100px',\n    xl: '1400px',\n  },\n};\n\n\n自定义媒体查询\n\n如果需要为断点提供完全自定义的媒体查询，则可以使用带有 raw 属性的对象：\n\nconst designSystem = {\n  extend: {\n    screens: {\n      portrait: { raw: '(orientation: portrait)' },\n      // => @media (orientation: portrait) { ... }\n    },\n  },\n};\n\n\nPrint 样式\n\n如果需要为打印应用不同的样式，则 raw 选项可能特别有用。\n\n需要做的就是在 designSystem.extend.screens 下添加一个 print：\n\nconst designSystem = {\n  extend: {\n    screens: {\n      print: { raw: 'print' },\n      // => @media print { ... }\n    },\n  },\n};\n\n\n然后，可以使用诸如 print:text-black 之类的类来指定仅当某人尝试打印页面时才应用的样式：\n\n<div class=\"text-gray-700 print:text-black\">\n  {/* ...  */}\n</div>\n\n\nDark Mode\n\nraw 选项可以用于实现 “暗模式” 屏幕：\n\nconst designSystem = {\n  extend: {\n    screens: {\n      dark: { raw: '(prefers-color-scheme: dark)' },\n      // => @media (prefers-color-scheme: dark) { ... }\n    },\n  },\n};\n\n\n然后，您可以使用 dark: 前缀在暗模式下为元素设置不同的样式：\n\n<div class=\"text-gray-700 dark:text-gray-200\">\n  {/* ...  */}\n</div>\n\n\n请注意，由于这些 screen variants 是在 Tailwind CSS 中实现的，因此无法使用这种方法将断点与暗模式结合使用 ，例如\nmd:dark:text-gray-300 将不起作用。\n\nColors\n\ncolors 属性可让您自定义项目的全局调色板。\n\nconst designSystem = {\n  colors: {\n    transparent: 'transparent',\n    black: '#000',\n    white: '#fff',\n    gray: {\n      100: '#f7fafc',\n      // ...\n      900: '#1a202c',\n    },\n\n    // ...\n  },\n};\n\n\n默认情况下，这些颜色由 backgroundColor，textColor 和 borderColor 核心插件继承。\n\n想了解更多，可以查看：Customizing Colors。\n\nSpacing\n\n使用 space 属性，可以自定义项目的全局间距和缩放比例：\n\nconst designSystem = {\n  spacing: {\n    px: '1px',\n    0: '0',\n    1: '0.25rem',\n    2: '0.5rem',\n    3: '0.75rem',\n    4: '1rem',\n    5: '1.25rem',\n    6: '1.5rem',\n    8: '2rem',\n    10: '2.5rem',\n    12: '3rem',\n    16: '4rem',\n    20: '5rem',\n    24: '6rem',\n    32: '8rem',\n    40: '10rem',\n    48: '12rem',\n    56: '14rem',\n    64: '16rem',\n  },\n};\n\n\n默认情况下，这些值由 padding，margin，negativeMargin，width 和 height 核心插件继承。\n\n想要了解更多，看 Customizing Spacing。\n\nCore plugins\n\n主题部分的其余部分用于配置每个核心插件可用的值。\n\n例如，borderRadius 属性可让您自定义将生成的圆角的 utilities：\n\nconst designSystem = {\n  borderRadius: {\n    none: '0',\n    sm: '.125rem',\n    default: '.25rem',\n    lg: '.5rem',\n    full: '9999px',\n  },\n};\n\n\n**属性名确定所生成类的后缀，值确定实际 CSS 声明的值。**上面的示例 borderRadius 配置将生成以下 CSS 类：\n\n.rounded-none {\n  border-radius: 0;\n}\n.rounded-sm {\n  border-radius: 0.125rem;\n}\n.rounded {\n  border-radius: 0.25rem;\n}\n.rounded-lg {\n  border-radius: 0.5rem;\n}\n.rounded-full {\n  border-radius: 9999px;\n}\n\n\n会注意到，在主题配置中使用 default 属性创建了不带后缀的 rounded 类。这是许多（尽管不是全部）核心插件支持的 Tailwind CSS\n中的通用约定。\n\n要了解有关自定义特定核心插件的更多信息，请访问该插件的文档。\n\n\n自定义默认配置\n\n开箱即用，您的项目将自动从默认主题配置继承值。如果想自定义默认主题，则根据目标有几种不同的选择。\n\n覆盖默认配置\n\n要覆盖默认配置中的选项，请在 designSystem 中添加要覆盖的属性：\n\nconst designSystem = {\n  // Replaces all of the default `opacity` values\n  opacity: {\n    0: '0',\n    20: '0.2',\n    40: '0.4',\n    60: '0.6',\n    80: '0.8',\n    100: '1',\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n这将完全替换默认属性配置，因此在上面的示例中，不会生成默认的 opacity utilities。\n\n您未提供的任何属性都将从默认主题继承，因此在上面的示例中，将保留颜色，间距，边框圆角，背景位置等内容的默认主题配置。\n\n扩展默认配置\n\n如果您想保留主题选项的默认值，但又要添加新值，请在 designSystem.extend 属性下添加扩展的内容。\n\n例如，如果您想添加一个额外的断点但保留现有的断点，则可以扩展 screens 属性：\n\nconst designSystem = {\n  extend: {\n    // Adds a new breakpoint in addition to the default breakpoints\n    screens: {\n      '2xl': '1440px',\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n您当然可以覆盖默认主题的某些部分，并在同一配置中扩展默认主题的其他部分：\n\nconst designSystem = {\n  opacity: {\n    0: '0',\n    20: '0.2',\n    40: '0.4',\n    60: '0.6',\n    80: '0.8',\n    100: '1',\n  },\n  extend: {\n    screens: {\n      '2xl': '1440px',\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n引用其他值\n\n如果需要在配置中引用另一个值，可以通过提供闭包函数而不是静态值来实现。函数将收到 theme() 函数作为参数，您可以使用该函数使用点表示法在配置中查找其他值。\n\n例如，您可以在 fill 配置上通过引用 theme('colors') 为调色板中的每种颜色生成 fill utilities。\n\nconst designSystem = {\n  colors: {\n    // ...\n  },\n  fill: theme => theme('colors'),\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\ntheme()函数尝试从已经完全合并的配置对象中找到您要查找的值，因此它可以引用您自己的自定义设置以及默认主题值。它也可以递归工作，因此只要链末尾有一个静态值，\n它就可以解析您要查找的值。\n\n引用默认配置\n\n如果出于任何原因想要引用默认配置中的值，则可以从 tailwindcss/defaultTheme\n导入它。一个有用的示例是，如果要将添加默认配置提供的字体中某一个字体：\n\nconst defaultTheme = require('tailwindcss/defaultTheme');\n\nconst designSystem = {\n  extend: {\n    fontFamily: {\n      sans: ['Lato', ...defaultTheme.fontFamily.sans],\n    },\n  },\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n});\n\n\n禁用整个核心插件\n\n如果您不想为某个核心插件生成任何类，则最好在 corePlugins 配置中将该插件设置为 false，而不是在配置中为该属性提供一个空对象：\n\n// Don't assign an empty object in your theme configuration\n\nconst designSystem = {\n  opacity: {},\n};\n\n// Do disable the plugin in your corePlugins configuration\nconst designSyttem = {\n  corePlugins: {\n    opacity: false,\n  },\n};\n\n\n最终结果是相同的，但是由于许多核心插件未公开任何配置，因此无论如何只能使用 corePlugins 禁用它们，最好保持一致。\n\n添加自己的 key\n\n在很多情况下，将自己的属性添加到配置对象可能会很有用。\n\n其中一个示例是添加新属性为多个核心插件之间复用。例如，您可以提取一个 positions对象，backgroundPosition 和\nobjectPosition 插件都可以引用该对象：\n\nconst designSystem = {\n  positions: {\n    bottom: 'bottom',\n    center: 'center',\n    left: 'left',\n    'left-bottom': 'left bottom',\n    'left-top': 'left top',\n    right: 'right',\n    'right-bottom': 'right bottom',\n    'right-top': 'right top',\n    top: 'top',\n  },\n  backgroundPosition: theme => theme('positions'),\n  objectPosition: theme => theme('positions'),\n};\n\n\n另一个示例是在自定义插件中添加新的属性以进行引用。例如，如果您为项目编写了渐变插件，则可以向该插件引用的主题对象添加渐变属性：\n\nconst designSystem = {\n  gradients: theme => ({\n    'blue-green': [theme('colors.blue.500'), theme('colors.green.500')],\n    'purple-blue': [theme('colors.purple.500'), theme('colors.blue.500')],\n    // ...\n  }),\n};\n\nexport default defineConfig({\n  source: {\n    designSystem,\n  },\n  tools: {\n    tailwind: {\n      plugins: [require('./plugins/gradients')],\n    },\n  },\n});\n\n\n\n配置引用\n\n除了 screens，colors 和 spacing 外，配置对象中的所有属性都映射到 Tailwind CSS\n的核心插件上。由于许多插件负责仅接受静态值集（例如，例如float）的 CSS 属性，因此请注意，并非每个插件在主题对象中都有对应的属性。\n\n所有这些属性也可以在 designSystem.extend 属性下使用，以扩展默认主题。\n\n关于所有属性的作用，可以查看此 链接。\n\n\n额外的配置\n\n除了与 Tailwind CSS Theme 相同的配置以外，还有 Modern.js 提供的额外的配置。\n\nsource.designSystem.supportStyledComponents\n\n该配置类型为 boolean，默认为 false。\n\n当该配置值为 true 时，运行时在应用外层提供 styled-components ThemeProvider 组件，并且将通过 designSystem\n生成的 Theme Token 对象注入。","frontmatter":{"title":"source.designSystem","sidebar_label":"designSystem"}},{"id":470,"title":"source.disableDefaultEntries","routePath":"/configure/app/source/disable-default-entries","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： boolean\n * 默认值： false\n\n关闭根据项目目录结构自动识别应用构建入口的功能，默认情况下，Modern.js 会根据项目目录结构得到对应构建入口。\n\nINFO\n\n默认情况下，Modern.js 会根据项目目录结构得到对应入口信息。具体可参考入口。 配置关闭改机制后，需要使用 source.entries 配置自定义入口。\n\n警告\n\n推荐按照 Modern.js 提供的目录规范组织代码可以更好使用框架的功能，避免一些冗余的配置。\n\n设置如下，即可关闭默认的行为：\n\nexport default defineConfig({\n  source: {\n    disableDefaultEntries: true,\n  },\n});\n","frontmatter":{"title":"source.disableDefaultEntries","sidebar_label":"disableDefaultEntries"}},{"id":471,"title":"source.disableEntryDirs","routePath":"/configure/app/source/disable-entry-dirs","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： string[]\n * 默认值： []\n\n默认会根据 src 目录识别应用入口，可通过该选项禁止某些目录被识别为应用入口。\n\n例如，当配置与目录结构如下时：\n\nexport default defineConfig({\n  source: {\n    disableEntryDirs: './src/one',\n  },\n});\n\n\n└── src/\n    ├── one/\n    |    └── App.tsx\n    ├── two/\n    |    └── routes/\n    └── env.d.ts\n\n\n在未设置该配置项时，Modern.js 会根据项目目录产出两个 entry:\n\n * one\n * two\n\n当设置该配置项后，src/one 不会作为 entry 目录被识别。\n\n常见的用法是，将 src/common、src/components 目录配置到该选项中，避免这些目录被识别为应用入口。","frontmatter":{"title":"source.disableEntryDirs","sidebar_label":"disableEntryDirs"}},{"id":472,"title":"source.enableAsyncEntry","routePath":"/configure/app/source/enable-async-entry","lang":"zh","toc":[{"id":"背景知识","text":"背景知识","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n * 类型： boolean\n * 默认值： false\n\n该选项用于 webpack 模块联邦 (Module Federation）场景。\n\n开启此选项后，Modern.js 会通过 Dynamic Import 来包裹自动生成的入口文件（asynchronous\nboundary），使页面代码可以消费模块联邦生成的远程模块。\n\n\n背景知识\n\n如果不了解 webpack 模块联邦，请先阅读 Module Federation 官方文档：\n\n * 中文文档\n * 英文文档\n\n\n示例\n\n首先，在配置文件中开启此选项：\n\nexport default defineConfig({\n  source: {\n    enableAsyncEntry: true,\n  },\n});\n\n\n然后执行 dev 或 build 命令，可以看到 Modern.js 自动生成的文件变为以下结构：\n\nnode_modules\n  └─ .modern-js\n     └─ main\n        ├─ bootstrap.js  # 真正的入口代码\n        ├─ index.js      # 异步入口文件（asynchronous boundary）\n        └─ index.html\n\n\n其中 index.js 的内容如下：\n\nimport('./bootstrap.js');\n\n\n此时，就可以在当前页面中消费任意的远程模块了。\n\nINFO\n\nModern.js 未对 webpack 的 ModuleFederationPlugin 进行封装，请通过 tools.webpackChain 自行配置\nModuleFederationPlugin。","frontmatter":{"title":"source.enableAsyncEntry","sidebar_label":"enableAsyncEntry"}},{"id":473,"title":"source.entriesDir","routePath":"/configure/app/source/entries-dir","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： string\n * 默认值： ./src\n\n默认会根据 src 目录识别应用入口，可通过该选项自定义应用入口的识别目录。\n\n例如，当配置与目录结构如下时：\n\nexport default defineConfig({\n  source: {\n    entriesDir: './src/pages',\n  },\n});\n\n\n.\n└── src\n    └── pages\n        ├── a\n        │   └── App.jsx\n        └── b\n            └── App.jsx\n\n\nModern.js 会根据 ./src/pages 目录结构生成构建入口 a 和入口 b，结果如下：\n\n {\n   a: './src/pages/a/App.jsx',\n   b: './src/pages/b/App.jsx'\n }\n","frontmatter":{"title":"source.entriesDir","sidebar_label":"entriesDir"}},{"id":474,"title":"source.entries","routePath":"/configure/app/source/entries","lang":"zh","toc":[{"id":"string-类型","text":"String 类型","depth":2},{"id":"object-类型","text":"Object 类型","depth":2},{"id":"自定义入口和默认入口合并","text":"自定义入口和默认入口合并","depth":2}],"domain":"","content":"\n\n * 类型： Object = { [ entryName: string ]: string | Object }\n * 默认值： 根据当前项目目录结构动态结算出的默认入口对象。\n\n对于大部分场景，Modern.js 根据目录结构自动生成的入口能满足大部分业务需求。具体可参考入口。\n\n如需自定义构建入口时，可以通过该选项指定。\n\n\nString 类型\n\n当值为 string 类型时，为入口的文件路径:\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      // 指定一个名称为 entry_customize 的新入口\n      entry_customize: './src/home/test/index.js',\n    },\n  },\n});\n\n\n默认情况下，配置的入口等价于 App.[jt]sx，即指定的入口文件只需要导出应用的根组件。\n\n例如以下目录结构：\n\n.\n├── src\n│   └── entry\n│       ├── chat.tsx\n│       └── home.tsx\n└── package.json\n\n\n结合上面默认入口机制的内容，Modern.js 在分析上述目录结构时，不会得到任何默认入口。\n\n在不想改变目录结构的情况下（如项目迁移），可以通过 source.entries 自定义入口：\n\nexport default defineConfig({\n  source: {\n    entries: {\n      home: './src/entry/home.tsx',\n      chat: './src/entry/chat.tsx',\n    },\n  },\n});\n\n\n\nObject 类型\n\n当值为 Object 时，可配置如下属性：\n\n * entry：string，入口文件路径。\n * disableMount：boolean = false，关闭 Modern.js 生成入口代码的行为。\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      entry_customize: {\n        // 入口文件路径\n        entry: './src/home/test/App.jsx',\n      },\n      // 启用约定式路由\n      entry_spa: {\n        // 约定式路由的入口路径必须设置为目录\n        entry: './src/about',\n      },\n    },\n  },\n});\n\n\n默认情况下，配置的入口等价于 App.[jt]sx，如果希望该入口等价于构建模式下的入口，可以将属性 disableMount 设置为 true。\n\n\n自定义入口和默认入口合并\n\n在指定 source.entries 后，Modern.js 会将用户自定义的入口与分析目录结构得到的默认入口合并。合并规则为：\n\n比较自定义入口设置的入口路径和默认入口路径，当入口路径一致时，自定义入口会覆盖默认入口。\n\n例如以下目录结构:\n\n.\n├── src\n│   ├── chat\n│   │   └── App.jsx\n│   └── home\n│       └── index.js\n└── package.json\n\n\nModern.js 分析 src/ 目录，得到默认入口 chat 和 home。当用户在 modern.config.js 文件中配置如下时：\n\n\n\nexport default defineConfig({\n  source: {\n    entries: {\n      index: './src/home/index.js',\n    },\n  },\n};\n\n\n可以看到自定义入口 index 的路径和默认入口 home 的路径一致，在合并的过程中，index 会覆盖掉 home，最终入口如下：\n\n * chat -> ./src/chat/App.jsx\n * index -> ./src/home/index.js","frontmatter":{"title":"source.entries","sidebar_label":"entries"}},{"id":475,"title":"source.exclude","routePath":"/configure/app/source/exclude","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.exclude。\n\n * 类型： Array<string | RegExp>\n * 默认值： []\n\n指定不需要编译的 JavaScript/TypeScript 文件。用法与 webpack 中的 Rule.exclude\n一致，支持传入字符串或正则表达式来匹配模块的路径。\n\n比如:\n\n\n\nexport default {\n  source: {\n    exclude: [path.resolve(__dirname, 'src/module-a'), /src\\/module-b/],\n  },\n};\n","frontmatter":{"sidebar_label":"exclude"}},{"id":476,"title":"source.globalVars","routePath":"/configure/app/source/global-vars","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.globalVars。\n\n * 类型： Record<string, JSONValue>\n * 默认值：\n\n// Builder 会自动添加环境变量 `process.env.NODE_ENV` 作为默认值，因此你不需要手动添加它。\nconst defaultGlobalVars = {\n  'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n};\n\n\n构建时将类似 process.env.FOO 的全局变量表达式替换为指定的值，比如：\n\nconsole.log(process.env.NODE_ENV);\n\n// ⬇️ Turn into being...\nconsole.log('development');\n\n\n使用解构赋值时，构建器无法判断变量 NODE_ENV 是否与要替换的表达式 process.env.NODE_ENV 存在关联，所以这样的使用方式是无效的：\n\nconst { NODE_ENV } = process.env;\nconsole.log(NODE_ENV);\n// ❌ Won't get a string.\n\n\nsource.globalVars 是 source.define 的一个语法糖，唯一的区别是 source.globalVars 会自动将传入的值进行\nJSON 序列化处理，这使得设置全局变量的值更容易。注意 globalVars 的每个值都需要是可以被 JSON 序列化的值。\n\nexport default {\n  source: {\n    globalVars: {\n      'process.env.BUILD_VERSION': '0.0.1',\n      'import.meta.foo': { bar: 42 },\n      'import.meta.baz': false,\n    },\n    define: {\n      'process.env.BUILD_VERSION': JSON.stringify('0.0.1'),\n      'import.meta': {\n        foo: JSON.stringify({ bar: 42 }),\n        baz: JSON.stringify(false),\n      },\n    },\n  },\n};\n\n\n\n示例\n\nexport default {\n  source: {\n    globalVars: {\n      ENABLE_VCONSOLE: true,\n      APP_CONTEXT: { answer: 42 },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"globalVars"}},{"id":477,"title":"source.include","routePath":"/configure/app/source/include","lang":"zh","toc":[{"id":"编译-npm-包","text":"编译 npm 包","depth":3},{"id":"编译-npm-包的子依赖","text":"编译 npm 包的子依赖","depth":3},{"id":"编译-monorepo-中的其他库","text":"编译 Monorepo 中的其他库","depth":3},{"id":"编译-commonjs-模块","text":"编译 CommonJS 模块","depth":3},{"id":"匹配-symlink","text":"匹配 Symlink","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.include。\n\n * 类型： Array<string | RegExp>\n * 默认值： []\n\n出于编译性能的考虑，默认情况下，Builder 不会编译 node_modules 下的 JavaScript/TypeScript\n文件，也不会编译当前工程目录外部的 JavaScript/TypeScript 文件。\n\n通过 source.include 配置项，可以指定需要 Builder 额外进行编译的目录或模块。source.include 的用法与 webpack 中的\nRule.include 一致，支持传入字符串或正则表达式来匹配模块的路径。\n\n比如:\n\n\n\nexport default {\n  source: {\n    include: [path.resolve(__dirname, '../other-dir')],\n  },\n};\n\n\n\n编译 npm 包\n\n比较典型的使用场景是编译 node_modules 下的 npm 包，因为某些第三方依赖存在 ES6+\n的语法，这可能导致在低版本浏览器上无法运行，你可以通过该选项指定需要编译的依赖，从而解决此类问题。\n\n以 query-string 为例，你可以做如下的配置：\n\n\n\nexport default {\n  source: {\n    include: [\n      // 方法一:\n      // 先通过 require.resolve 来获取模块的路径\n      // 再通过 path.dirname 来指向对应的目录\n      path.dirname(require.resolve('query-string')),\n      // 方法二:\n      // 通过正则表达式进行匹配\n      // 所有包含 `/query-string/` 的路径都会被匹配到\n      /\\/query-string\\//,\n    ],\n  },\n};\n\n\n\n编译 npm 包的子依赖\n\n当你通过 source.include 编译一个 npm 包时，Builder 默认只会编译匹配到的模块，不会编译对应模块的子依赖。\n\n以 query-string 为例，它依赖的 decode-uri-component 包中同样存在 ES6+ 代码，因此需要将\ndecode-uri-component 也加入到 source.include 中：\n\n\n\nexport default {\n  source: {\n    include: [/\\/query-string\\//, /\\/decode-uri-component\\//],\n  },\n};\n\n\n\n编译 Monorepo 中的其他库\n\n在 Monorepo 中进行开发时，如果需要引用 Monorepo 中其他库的源代码，也可以直接在 source.include 进行配置:\n\n\n\nexport default {\n  source: {\n    include: [\n      // 方法一:\n      // 编译 Monorepo 的 package 目录下的所有文件\n      path.resolve(__dirname, '../../packages'),\n\n      // 方法二:\n      // 编译 Monorepo 的 package 目录里某个包的源代码\n      // 这种写法匹配的范围更加精准，对整体编译性能的影响更小\n      path.resolve(__dirname, '../../packages/xxx/src'),\n    ],\n  },\n};\n\n\n\n编译 CommonJS 模块\n\nBabel 默认无法编译 CommonJS 模块，如果你编译了一个 CommonJS 模块，可能会出现 exports is not defined\n的运行时报错信息。\n\n当你需要使用 source.include 来编译 CommonJS 模块时，可以将 Babel 的 sourceType 配置设置为 unambiguous：\n\nexport default {\n  tools: {\n    babel(config) {\n      config.sourceType = 'unambiguous';\n    },\n  },\n};\n\n\n将 sourceType 设置为 unambiguous 可能会产生一些其他影响，请参考 Babel 官方文档。\n\n\n匹配 Symlink\n\n如果你匹配的模块是通过 symlink 链接到当前项目中的，那么需要匹配这个模块的真实路径，而不是 symlink 后的路径。\n\n比如，你将 Monorepo 中的 packages/foo 路径 symlink 到当前项目的 node_modules/foo 路径下，则需要去匹配\npackages/foo 路径，而不是 node_modules/foo 路径。\n\n该行为可以通过 webpack 的 resolve.symlinks 配置项来进行控制。","frontmatter":{"sidebar_label":"include"}},{"id":478,"title":"source.moduleScopes","routePath":"/configure/app/source/module-scopes","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3},{"id":"array-类型","text":"Array 类型","depth":4},{"id":"function-类型","text":"Function 类型","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.moduleScopes。\n\n * 类型： Array<string | Regexp> | Function\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n限制源代码的引用路径。配置该选项后，所有源文件只能从约定的目录下引用代码，从其他目录引用代码会产生对应的报错提示。\n\n\n示例\n\n首先我们配置 moduleScopes 仅包含 src 目录：\n\nexport default {\n  source: {\n    moduleScopes: ['./src'],\n  },\n};\n\n\n然后在 src/App.tsx 中导入 src 目录外部的 utils/a 模块:\n\n\n\n在编译时，会提示引用路径错误:\n\n\n\n通过该选项配置 utils 目录，再进行编译，则不会出现错误提示。\n\nexport default {\n  source: {\n    moduleScopes: ['./src', './utils'],\n  },\n};\n\n\nArray 类型\n\n当 moduleScopes 的值为 Array 类型时，可以直接设置若干个代码路径，比如添加以下配置：\n\nexport default {\n  source: {\n    moduleScopes: ['./src', './shared', './utils'],\n  },\n};\n\n\nFunction 类型\n\nmoduleScopes 也支持通过函数的形式来进行修改，避免覆盖默认值：\n\nexport default {\n  source: {\n    moduleScopes: scopes => {\n      scopes.push('./shared');\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"moduleScopes"}},{"id":479,"title":"source.preEntry","routePath":"/configure/app/source/pre-entry","lang":"zh","toc":[{"id":"添加单个脚本","text":"添加单个脚本","depth":4},{"id":"添加全局样式","text":"添加全局样式","depth":4},{"id":"添加多个脚本","text":"添加多个脚本","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.preEntry。\n\n * 类型： string | string[]\n * 默认值： undefined\n\n在每个页面的入口文件前添加一段代码，这段代码会早于页面的代码执行，因此可以用于执行一些全局的代码逻辑，比如注入 polyfill、设置全局样式等。\n\n添加单个脚本\n\n首先创建一个 src/polyfill.ts 文件：\n\nconsole.log('I am a polyfill');\n\n\n然后将 src/polyfill.ts 配置到 source.preEntry 上：\n\nexport default {\n  source: {\n    preEntry: './src/polyfill.ts',\n  },\n};\n\n\n重新运行编译并访问任意页面，可以看到 src/polyfill.ts 中的代码已经执行，并在 console 中输出了对应的内容。\n\n添加全局样式\n\n你也可以通过 source.preEntry 来配置全局样式，这段 CSS 代码会早于页面代码加载，比如引入一个 normalize.css 文件：\n\nexport default {\n  source: {\n    preEntry: './src/normalize.css',\n  },\n};\n\n\n添加多个脚本\n\n你可以将 preEntry 设置为数组来添加多个脚本，它们会按数组顺序执行：\n\nexport default {\n  source: {\n    preEntry: ['./src/polyfill-a.ts', './src/polyfill-b.ts'],\n  },\n};\n","frontmatter":{"sidebar_label":"preEntry"}},{"id":480,"title":"source.resolveExtensionPrefix","routePath":"/configure/app/source/resolve-extension-prefix","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3},{"id":"根据产物类型设置","text":"根据产物类型设置","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.resolveExtensionPrefix。\n\n * 类型： string | Record<BuilderTarget, string>\n * 默认值： undefined\n\n用于为 resolve.extensions 添加统一的前缀。\n\n如果多个文件拥有相同的名称，但具有不同的文件后缀，Builder 会根据 extensions\n数组的顺序进行识别，解析数组中第一个被识别的文件，并跳过其余文件。\n\n\n示例\n\n下面是配置 .web 前缀的例子。\n\nexport default {\n  source: {\n    resolveExtensionPrefix: '.web',\n  },\n};\n\n\n配置完成后，extensions 数组会发生以下变化：\n\n// 配置前\nconst extensions = ['.js', '.ts', ...];\n\n// 配置后\nconst extensions = ['.web.js', '.js', '.web.ts' , '.ts', ...];\n\n\n在代码中 import './foo' 时，会优先识别 foo.web.js 文件，再识别 foo.js 文件。\n\n根据产物类型设置\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 extension 前缀。此时，你需要把 resolveExtensionPrefix\n设置为一个对象，对象的 key 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 extension 前缀：\n\nexport default {\n  output: {\n    source: {\n      resolveExtensionPrefix: {\n        web: '.web',\n        node: '.node',\n      },\n    },\n  },\n};\n\n\n在代码中 import './foo' 时，对于 node 产物，会优先识别 foo.node.js 文件，而对于 web 产物，则会优先识别\nfoo.web.js 文件。","frontmatter":{"sidebar_label":"resolveExtensionPrefix"}},{"id":481,"title":"source.resolveMainFields","routePath":"/configure/app/source/resolve-main-fields","lang":"zh","toc":[{"id":"示例","text":"示例","depth":3},{"id":"根据产物类型设置","text":"根据产物类型设置","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 source.resolveMainFields。\n\n * 类型：\n\ntype Fields = (string | string[])[];\n\ntype ResolveMainFields = Fields | Record<BuilderTarget, Fields>;\n\n\n * 默认值： undefined\n\n该配置项将决定你使用 package.json 哪个字段导入 npm 模块。对应 webpack 的 resolve.mainFields 配置。\n\n\n示例\n\nexport default {\n  source: {\n    resolveMainFields: ['main', 'browser', 'exports'],\n  },\n};\n\n\n根据产物类型设置\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 mainFields。此时，你需要把 resolveMainFields 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 mainFields：\n\nexport default {\n  output: {\n    source: {\n      resolveMainFields: {\n        web: ['main', 'browser', 'exports'],\n        node: ['main', 'node', 'exports'],\n      },\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"resolveMainFields"}},{"id":482,"title":"testing.transformer","routePath":"/configure/app/testing/transformer","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： 'babel-jest' | 'ts-jest'\n * 默认值： babel-jest\n\n配置执行测试的时候对于源码的编译工具： babel-jest 或 ts-jest。默认使用 babel-jest。\n\n补充信息\n\nbabel-jest 也可以编译 TS 文件，但不会类型报错，如果你需要跑测试的时候对 TS 类型进行校验，那么请使用 ts-jest。","frontmatter":{"title":"testing.transformer","sidebar_label":"transformer","sidebar_position":1}},{"id":483,"title":"tools.autoprefixer","routePath":"/configure/app/tools/autoprefixer","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.autoprefixer。\n\n * 类型： Object | Function\n * 默认值：\n\n{\n  flexbox: 'no-2009',\n  // browserslist 取决于项目中的 browserslist 配置\n  // 以及 `output.overrideBrowserslist`(优先级更高) 配置\n  overrideBrowserslist: browserslist,\n}\n\n\n通过 tools.autoprefixer 可以修改 autoprefixer 的配置。\n\n\nObject 类型\n\n当 tools.autoprefixer 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    autoprefixer: {\n      flexbox: 'no-2009',\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.autoprefixer 为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。比如：\n\nexport default {\n  tools: {\n    autoprefixer(config) {\n      // 修改 flexbox 的配置\n      config.flexbox = 'no-2009';\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"autoprefixer"}},{"id":484,"title":"tools.babel","routePath":"/configure/app/tools/babel","lang":"zh","toc":[{"id":"function-类型","text":"Function 类型","depth":3},{"id":"object-类型","text":"Object 类型","depth":3},{"id":"工具函数","text":"工具函数","depth":3},{"id":"addplugins","text":"addPlugins","depth":4},{"id":"addpresets","text":"addPresets","depth":4},{"id":"removeplugins","text":"removePlugins","depth":4},{"id":"removepresets","text":"removePresets","depth":4},{"id":"addincludes","text":"addIncludes","depth":4},{"id":"addexcludes","text":"addExcludes","depth":4},{"id":"modifypresetenvoptions","text":"modifyPresetEnvOptions","depth":4},{"id":"modifypresetreactoptions","text":"modifyPresetReactOptions","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.babel。\n\n * 类型： Object | Function\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n通过 tools.babel 可以修改 babel-loader 的配置项。\n\n\nFunction 类型\n\n当 tools.babel 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    babel(config) {\n      // 添加一个插件，比如配置某个组件库的按需引入\n      // 目前内置了 antd 的按需引入规则\n      config.plugins.push([\n        'babel-plugin-import',\n        {\n          libraryName: 'xxx-components',\n          libraryDirectory: 'es',\n          style: true,\n        },\n      ]);\n    },\n  },\n};\n\n\n\nObject 类型\n\n当 tools.babel 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。注意 Object.assign\n是浅拷贝，会完全覆盖内置的 presets 或 plugins 数组，请谨慎使用。\n\nexport default {\n  tools: {\n    babel: {\n      plugins: [\n        [\n          'babel-plugin-import',\n          {\n            libraryName: 'xxx-components',\n            libraryDirectory: 'es',\n            style: true,\n          },\n        ],\n      ],\n    },\n  },\n};\n\n\n\n工具函数\n\ntools.babel 为 Function 类型时，第二个参数可用的工具函数如下:\n\naddPlugins\n\n * 类型： (plugins: BabelPlugin[]) => void\n\n添加若干个 Babel 插件。\n\nexport default {\n  tools: {\n    babel(config, { addPlugins }) {\n      addPlugins([\n        [\n          'babel-plugin-import',\n          {\n            libraryName: 'xxx-components',\n            libraryDirectory: 'es',\n            style: true,\n          },\n        ],\n      ]);\n    },\n  },\n};\n\n\naddPresets\n\n * 类型： (presets: BabelPlugin[]) => void\n\n添加若干个 Babel 预设配置 (大多数情况下不需要增加预设)。\n\nexport default {\n  tools: {\n    babel(config, { addPresets }) {\n      addPresets(['@babel/preset-env']);\n    },\n  },\n};\n\n\nremovePlugins\n\n * 类型： (plugins: string | string[]) => void\n\n移除 Babel 插件，传入需要移除的插件名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\nexport default {\n  tools: {\n    babel(config, { removePlugins }) {\n      removePlugins('babel-plugin-import');\n    },\n  },\n};\n\n\nremovePresets\n\n * 类型： (presets: string | string[]) => void\n\n移除 Babel 预设配置，传入需要移除的预设名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\nexport default {\n  tools: {\n    babel(config, { removePresets }) {\n      removePresets('@babel/preset-env');\n    },\n  },\n};\n\n\naddIncludes\n\n * 类型： (includes: string | RegExp | (string | RegExp)[]) => void\n\n默认情况下 Babel 只会编译 src 目录下的业务代码，使用 addIncludes 你可以指定 Babel 编译 node_modules\n下的一些文件。比如编译 query-string 依赖：\n\nexport default {\n  tools: {\n    babel(config, { addIncludes }) {\n      addIncludes(/\\/query-string\\//);\n    },\n  },\n};\n\n\nTIP\n\naddIncludes 函数的用法与 source.include 配置项基本一致，请查看 source.include 文档\n来查看更详细的用法说明。也可以直接使用 source.include 来代替 addIncludes函数。\n\naddExcludes\n\n * 类型： (excludes: string | RegExp | (string | RegExp)[]) => void\n\naddExcludes 和 addIncludes 的用处相反，指定 Babel 编译时排除某些文件。\n\n比如不编译 src/example 目录下的文件:\n\nexport default {\n  tools: {\n    babel(config, { addExcludes }) {\n      addExcludes('src/example');\n    },\n  },\n};\n\n\nTIP\n\naddExcludes 函数的用法与 source.exclude 配置项基本一致，请查看 source.exclude 文档\n来查看更详细的用法说明。也可以直接使用 source.exclude 来代替 addExcludes函数。\n\nmodifyPresetEnvOptions\n\n * 类型： (options: PresetEnvOptions) => void\n\n修改 @babel/preset-env 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\nexport default {\n  tools: {\n    babel(config, { modifyPresetEnvOptions }) {\n      modifyPresetEnvOptions({\n        targets: {\n          browsers: ['last 2 versions'],\n        },\n      });\n    },\n  },\n};\n\n\nmodifyPresetReactOptions\n\n * 类型： (options: PresetReactOptions) => void\n\n修改 @babel/preset-react 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\nexport default {\n  tools: {\n    babel(config, { modifyPresetReactOptions }) {\n      modifyPresetReactOptions({\n        pragma: 'React.createElement',\n      });\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"babel"}},{"id":485,"title":"tools.cssExtract","routePath":"/configure/app/tools/css-extract","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.cssExtract。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  // Loader 配置\n  loaderOptions: {},\n  // Plugin 配置\n  pluginOptions: {\n    // cssPath 默认为 static/css, cssFilename 默认为 [name].[contenthash:8].css\n    filename: `${cssPath}/${cssFilename}`,\n    chunkFilename: `${cssPath}/async/${cssFilename}`,\n    ignoreOrder: true,\n  },\n};\n\n\n * 打包工具： 仅支持 webpack\n\n通过 tools.cssExtract 可以更改 mini-css-extract-plugin 的配置。\n\n\nObject 类型\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    cssExtract: {\n      pluginOptions: {\n        filename: 'static/css/[name].[contenthash:8].css',\n      },\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\nexport default {\n  tools: {\n    cssExtract: config => {\n      config.pluginOptions.filename = 'static/css/[name].[contenthash:8].css';\n      return config;\n    },\n  },\n};\n\n\n更多配置细节可参考 mini-css-extract-plugin。","frontmatter":{"sidebar_label":"cssExtract"}},{"id":486,"title":"tools.cssLoader","routePath":"/configure/app/tools/css-loader","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.cssLoader。\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.cssLoader 可以修改 css-loader 的配置项。默认配置如下:\n\n{\n  importLoaders: 1,\n  modules: {\n    auto: true,\n    exportLocalsConvention: 'camelCase',\n    localIdentName: config.output.cssModuleLocalIdentName,\n    // isServer 表示 node (SSR) 构建\n    // isWebWorker 表示 web worker 构建\n    exportOnlyLocals: isServer || isWebWorker,\n  },\n  // 默认在开发环境下启用 CSS 的 Source Map\n  sourceMap: isDev,\n}\n\n\n * 打包工具： 仅支持 webpack\n\n\nObject 类型\n\n当此值为 Object 类型时，会与默认配置进行深层合并 (deep merge)。比如：\n\nexport default {\n  tools: {\n    cssLoader: {\n      modules: {\n        exportOnlyLocals: true,\n      },\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\nexport default {\n  tools: {\n    cssLoader: config => {\n      config.modules.exportOnlyLocals = true;\n      return config;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"cssLoader"}},{"id":487,"title":"tools.devServer","routePath":"/configure/app/tools/dev-server","lang":"zh","toc":[{"id":"选项","text":"选项","depth":3},{"id":"after","text":"after","depth":4},{"id":"before","text":"before","depth":4},{"id":"client","text":"client","depth":4},{"id":"devmiddleware","text":"devMiddleware","depth":4},{"id":"headers","text":"headers","depth":4},{"id":"historyapifallback","text":"historyApiFallback","depth":4},{"id":"hot","text":"hot","depth":4},{"id":"https","text":"https","depth":4},{"id":"livereload","text":"liveReload","depth":4},{"id":"setupmiddlewares","text":"setupMiddlewares","depth":4},{"id":"proxy","text":"proxy","depth":4},{"id":"watch","text":"watch","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.devServer。\n\n * 类型： Object\n * 默认值： {}\n\n通过 tools.devServer 可以修改开发环境服务器的配置。\n\n\n选项\n\nafter\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件后执行。\n\nexport default {\n  tools: {\n    devServer: {\n      after: [\n        async (req, res, next) => {\n          console.log('after dev middleware');\n          next();\n        },\n      ],\n    },\n  },\n};\n\n\nbefore\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件前执行。\n\nexport default {\n  tools: {\n    devServer: {\n      before: [\n        async (req, res, next) => {\n          console.log('before dev middleware');\n          next();\n        },\n      ],\n    },\n  },\n};\n\n\nclient\n\n * 类型：\n\n{\n    /** 指定协议名称 */\n    protocol?: string;\n    /** 事件流路径 */\n    path?: string;\n    /** 指定监听请求的端口号 */\n    port?: string;\n    /** 指定要使用的 host */\n    host?: string;\n}\n\n\n * 默认值：\n\n{\n    path: '/webpack-hmr',\n    port: '8080',\n    host: networkAddress || 'localhost',\n}\n\n\n配置 hmr 客户端相关功能。\n\ndevMiddleware\n\n * 类型：\n\n{\n  writeToDisk: boolean | ((filename: string) => boolean);\n}\n\n\n * 默认值：\n\n{\n  writeToDisk: (file: string) => !file.includes('.hot-update.'),\n}\n\n\ndevMiddleware 配置项。当前配置是 webpack-dev-middleware 配置项的子集.\n\nheaders\n\n * 类型： Record<string, string>\n * 默认值： undefined\n\n设置自定义响应头。\n\nexport default {\n  tools: {\n    devServer: {\n      headers: {\n        'X-Custom-Foo': 'bar',\n      },\n    },\n  },\n};\n\n\nhistoryApiFallback\n\n * 类型： boolean | ConnectHistoryApiFallbackOptions\n * 默认值： false\n\n在需要对一些 404 响应或其他请求提供替代页面的场景，可通过 devServer.historyApiFallback 进行设置：\n\nexport default {\n  tools: {\n    devServer: {\n      historyApiFallback: true,\n    },\n  },\n};\n\n\n更多选项和详细信息可参考 connect-history-api-fallback 文档。\n\nhot\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\nhttps\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n默认情况下，DevServer 会启用 HTTP 服务器。通过设置 devServer.https 为 true 将开启对 HTTPS 的支持，同时会禁用\nHTTP 服务器。\n\n你也可以手动传入 HTTPS 服务器所需要的证书和对应的私钥：\n\nexport default {\n  tools: {\n    devServer: {\n      https: {\n        key: fs.readFileSync('certificates/private.pem'),\n        cert: fs.readFileSync('certificates/public.pem'),\n      },\n    },\n  },\n};\n\n\nliveReload\n\n * 类型： boolean\n * 默认值： true\n\n默认情况下，当监听到文件变化时，DevServer 将会刷新页面（为使 liveReload 能够生效，devServer.hot 配置项应当禁用）。通过设置\ndevServer.liveReload 为 false 可以关闭该行为。\n\nsetupMiddlewares\n\n * 类型：\n\nArray<\n  (\n    middlewares: {\n      unshift: (...handlers: RequestHandler[]) => void;\n      push: (...handlers: RequestHandler[]) => void;\n    },\n    server: {\n      sockWrite: (\n        type: string,\n        data?: string | boolean | Record<string, any>,\n      ) => void;\n    },\n  ) => void\n>;\n\n\n * 默认值： undefined\n\n提供执行自定义函数和应用自定义中间件的能力。\n\n几种不同中间件之间的执行顺序是: devServer.before => unshift => 内置中间件 => push =>\ndevServer.after。\n\nexport default {\n  tools: {\n    devServer: {\n      setupMiddlewares: [\n        (middlewares, server) => {\n          middlewares.unshift((req, res, next) => {\n            next();\n          });\n\n          middlewares.push((req, res, next) => {\n            next();\n          });\n        },\n      ],\n    },\n  },\n};\n\n\n一些特殊场景需求可能需要使用服务器 API：\n\n * sockWrite。允许向 hmr 客户端传递一些消息，hmr 客户端将根据接收到的消息类型进行不同的处理。如果你发送一个\n   \"content-changed \" 的消息，页面将会重新加载。\n\nexport default {\n  tools: {\n    devServer: {\n      setupMiddlewares: [\n        (middlewares, server) => {\n          // 添加自定义 watcher 并在文件更新时触发页面刷新\n          watcher.on('change', changed => {\n            server.sockWrite('content-changed');\n          });\n        },\n      ],\n    },\n  },\n};\n\n\nproxy\n\n * 类型： Record<string, string> | Record<string, ProxyDetail>\n * 默认值： undefined\n\n代理请求到指定的服务上。\n\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': 'http://localhost:3000',\n      },\n    },\n  },\n};\n\n\n此时，/api/users 请求将会代理到 http://localhost:3000/api/users。\n\n如果你不想传递 /api，可以通过 pathRewrite 重写请求路径：\n\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': {\n          target: 'http://localhost:3000',\n          pathRewrite: { '^/api': '' },\n        },\n      },\n    },\n  },\n};\n\n\nDevServer Proxy 基于 http-proxy-middleware 实现。你可以使用 http-proxy-middleware\n的所有配置项，具体可以查看文档。\n\nDevServer Proxy 完整类型定义为：\n\n\n\ntype ProxyDetail = HttpProxyOptions & {\n  bypass?: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    proxyOptions: ProxyOptions,\n  ) => string | undefined | null | false;\n  context?: string | string[];\n};\n\ntype ProxyOptions =\n  | Record<string, string>\n  | Record<string, ProxyDetail>\n  | ProxyDetail[]\n  | ProxyDetail;\n\n\n除了 http-proxy-middleware 的选项外，还支持 bypass 和 context 两个配置项：\n\n * bypass：根据函数的返回值绕过代理。\n   * 返回 null 或 undefined 会继续用代理处理请求。\n   * 返回 false 会返回 404 错误。\n   * 返回一个具体的服务路径，将会使用此路径替代原请求路径。\n * context：如果你想代理多个特定的路径到同一个目标，你可以使用 context 配置项。\n\n// 自定义 bypass 方法\nexport default {\n  tools: {\n    devServer: {\n      proxy: {\n        '/api': {\n          target: 'http://localhost:3000',\n          bypass: function (req, res, proxyOptions) {\n            if (req.headers.accept.indexOf('html') !== -1) {\n              console.log('Skipping proxy for browser request.');\n              return '/index.html';\n            }\n          },\n        },\n      },\n    },\n  },\n};\n\n\n// 代理多个路径到同一个目标\nexport default {\n  tools: {\n    devServer: {\n      proxy: [\n        {\n          context: ['/auth', '/api'],\n          target: 'http://localhost:3000',\n        },\n      ],\n    },\n  },\n};\n\n\nwatch\n\n * 类型： boolean\n * 默认值： true\n\n是否监听 mock/、server/、api/ 等目录的文件变化。","frontmatter":{"sidebar_label":"devServer"}},{"id":488,"title":"tools.esbuild","routePath":"/configure/app/tools/esbuild","lang":"zh","toc":[{"id":"介绍","text":"介绍","depth":2},{"id":"配置项","text":"配置项","depth":2}],"domain":"","content":"\n\n * 类型： Object\n * 默认值： undefined\n\n\n介绍\n\nesbuild 介绍\n\nesbuild 是一款基于 Golang 开发的前端构建工具，具有打包、编译和压缩 JavaScript 代码的功能，相比传统的打包编译工具，esbuild\n在性能上有显著提升。在代码压缩方面，相比 webpack 内置的 terser 压缩器，esbuild 在性能上有数十倍的提升。\n\nModern.js 提供了 esbuild 插件，让你能使用 esbuild 代替 babel-loader、ts-loader 和 terser\n等库进行代码编译和压缩。在大型工程中开启后，可以大幅度减少代码编译和压缩所需的时间，同时有效避免 OOM (heap out of memory) 问题。\n\n\n配置项\n\n你可以通过 tools.esbuild 配置项来设置 esbuild 编译行为。\n\n\n\nexport default defineConfig({\n  tools: {\n    esbuild: {\n      loader: {\n        target: 'chrome61',\n      },\n      minimize: {\n        target: 'chrome61',\n      },\n    },\n  },\n});\n\n\n完整配置项请参考 Modern.js Builder - esbuild 插件配置。","frontmatter":{"title":"tools.esbuild","sidebar_label":"esbuild"}},{"id":489,"title":"tools.htmlPlugin","routePath":"/configure/app/tools/html-plugin","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3},{"id":"boolean-类型","text":"Boolean 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.htmlPlugin。\n\n * 类型： false | Object | Function\n * 默认值：\n\nconst defaultHtmlPluginOptions = {\n  inject, // 对应 html.inject 配置项\n  favicon, // 对应 html.favicon 配置项\n  filename, // 基于 output.distPath 和 entryName 生成\n  template, // 默认为内置的 HTML 模板路径\n  templateParameters, // 对应 html.templateParameters 配置项\n  chunks: [entryName],\n  minify: {\n    removeComments: false,\n    useShortDoctype: true,\n    keepClosingSlash: true,\n    collapseWhitespace: true,\n    removeRedundantAttributes: true,\n    removeScriptTypeAttributes: true,\n    removeStyleLinkTypeAttributes: true,\n  },\n};\n\n\n通过 tools.htmlPlugin 可以修改 html-webpack-plugin 的配置项。\n\n\nObject 类型\n\n当 tools.htmlPlugin 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\nexport default {\n  tools: {\n    htmlPlugin: {\n      scriptLoading: 'blocking',\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.htmlPlugin 为 Function 类型时：\n\n * 第一个参数是默认配置的对象，可以直接修改该对象。\n * 第二个参数是也是一个对象，包含了 entry 的名称和 entry 的值。\n * 函数可以 return 一个新的对象作为最终的配置。\n\nexport default {\n  tools: {\n    htmlPlugin(config, { entryName, entryValue }) {\n      if (entryName === 'main') {\n        config.scriptLoading = 'blocking';\n      }\n    },\n  },\n};\n\n\n\nBoolean 类型\n\n将 tools.htmlPlugin 配置为 false，可以禁用默认的 html-webpack-plugin 插件。\n\nexport default {\n  tools: {\n    htmlPlugin: false,\n  },\n};\n","frontmatter":{"sidebar_label":"htmlPlugin"}},{"id":490,"title":"tools.inspector","routePath":"/configure/app/tools/inspector","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.inspector。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n你可以通过 tools.inspector 开启或者配置 webpack 调试工具 webpack inspector。\n\n当配置不为 undefined 时，则表示开启了 webpack-inspector，此时 tools.inspector 的类型可以为 Object 或者\nFunction。\n\n\nObject 类型\n\n当 tools.inspector 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    inspector: {\n      // 默认端口为 3333\n      port: 3334,\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.inspector 为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。比如：\n\nexport default {\n  tools: {\n    inspector(config) {\n      // 修改端口号\n      config.port = 3333;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"inspector"}},{"id":491,"title":"tools.jest","routePath":"/configure/app/tools/jest","lang":"zh","toc":[],"domain":"","content":"\n\n * 类型： Object | Function\n * 默认值： {}\n\n注意\n\n需要先通过 pnpm run new 启用 单元测试 功能。\n\n对应 Jest 的配置，当为 Object 类型时，可以配置 Jest 所支持的所有底层配置 。\n\nexport default defineConfig({\n  tools: {\n    jest: {\n      testTimeout: 10000,\n    },\n  },\n});\n\n\n值为 Function 类型时，默认配置作为第一个参数传入，需要返回新的 Jest 配置对象。\n\nexport default defineConfig({\n  tools: {\n    jest: options => {\n      return {\n        ...options,\n        testTimeout: 10000,\n      };\n    },\n  },\n});\n","frontmatter":{"title":"tools.jest","sidebar_label":"jest"}},{"id":492,"title":"tools.less","routePath":"/configure/app/tools/less","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3},{"id":"工具函数","text":"工具函数","depth":3},{"id":"addexcludes","text":"addExcludes","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.less。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  lessOptions: {\n    javascriptEnabled: true,\n  },\n  // 默认在开发环境下启用 CSS 的 Source Map\n  sourceMap: isDev,\n};\n\n\n你可以通过 tools.less 修改 less-loader 的配置。\n\n\nObject 类型\n\n当 tools.less 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，lessOptions 会通过\ndeepMerge 进行深层合并。\n\nexport default {\n  tools: {\n    less: {\n      lessOptions: {\n        javascriptEnabled: false,\n      },\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.less 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    less(config) {\n      // 修改 lessOptions 配置\n      config.lessOptions = {\n        javascriptEnabled: false,\n      };\n    },\n  },\n};\n\n\n\n工具函数\n\naddExcludes\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 less-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 less 文件的路径。例如：\n\nexport default {\n  tools: {\n    less(config, { addExcludes }) {\n      addExcludes(/node_modules/);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"less"}},{"id":493,"title":"tools.minifyCss","routePath":"/configure/app/tools/minify-css","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.minifyCss。\n\n * 类型： Object | Function | undefined\n * 默认值：\n\nconst defaultOptions = {\n  minimizerOptions: {\n    preset: [\n      'default',\n      {\n        mergeLonghand: false,\n      },\n    ],\n  },\n};\n\n\n * 打包工具： 仅支持 webpack\n\n在生产环境构建时，Builder 会通过 css-minimizer-webpack-plugin 对 CSS 代码进行压缩优化。可以通过\ntools.minifyCss 修改 css-minimizer-webpack-plugin 的配置。\n\n\nObject 类型\n\n当 tools.minifyCss 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如下面修改 cssnano 的 preset 配置：\n\nexport default {\n  tools: {\n    minifyCss: {\n      minimizerOptions: {\n        preset: require.resolve('cssnano-preset-simple'),\n      },\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.minifyCss 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\nexport default {\n   tools: {\n    minifyCss: options => {\n      options.minimizerOptions = {\n        preset: require.resolve('cssnano-preset-simple'),\n      },\n    }\n  }\n};\n","frontmatter":{"sidebar_label":"minifyCss"}},{"id":494,"title":"tools.postcss","routePath":"/configure/app/tools/postcss","lang":"zh","toc":[{"id":"function-类型","text":"Function 类型","depth":3},{"id":"object-类型","text":"Object 类型","depth":3},{"id":"工具函数","text":"工具函数","depth":3},{"id":"addplugins","text":"addPlugins","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.postcss。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  postcssOptions: {\n    plugins: [\n      require('postcss-flexbugs-fixes'),\n      require('postcss-custom-properties'),\n      require('postcss-initial'),\n      require('postcss-page-break'),\n      require('postcss-font-variant'),\n      require('postcss-media-minmax'),\n      require('postcss-nesting'),\n      require('autoprefixer')({\n        flexbox: 'no-2009',\n      }),\n    ],\n    // 默认在开发环境下启用 CSS 的 Source Map\n    sourceMap: isDev,\n  },\n};\n\n\nBuilder 默认集成 PostCSS，你可以通过 tools.postcss 对 postcss-loader 进行配置。\n\n\nFunction 类型\n\n值为 Function 类型时，内部默认配置作为第一参数传入，可以直接修改配置对象不做返回，也可以返回一个对象作为最终结果；第二个参数为修改\npostcss-loader 配置的工具函数集合。\n\n例如，需要在原有插件的基础上新增一个 PostCSS 插件，在 postcssOptions.plugins 数组中 push 一个新的插件即可：\n\nexport default {\n  tools: {\n    postcss: opts => {\n      opts.postcssOptions.plugins.push(require('postcss-px-to-viewport'));\n    },\n  },\n};\n\n\n需要给 PostCSS 插件传递参数时，可以通过函数参数的形式进行传入：\n\nexport default {\n  tools: {\n    postcss: opts => {\n      const viewportPlugin = require('postcss-px-to-viewport')({\n        viewportWidth: 375,\n      });\n      opts.postcssOptions.plugins.push(viewportPlugin);\n    },\n  },\n};\n\n\ntools.postcss 可以返回一个配置对象，并完全替换默认配置：\n\nexport default {\n  tools: {\n    postcss: () => {\n      return {\n        postcssOptions: {\n          plugins: [require('postcss-px-to-viewport')],\n        },\n      };\n    },\n  },\n};\n\n\n\nObject 类型\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。注意 Object.assign 是浅拷贝，会完全覆盖内置的 plugins\n数组，请谨慎使用。\n\nexport default {\n  tools: {\n    postcss: {\n      // 由于使用 `Object.assign` 合并，因此默认的 postcssOptions 会被覆盖。\n      postcssOptions: {\n        plugins: [require('postcss-px-to-viewport')],\n      },\n    },\n  },\n};\n\n\n\n工具函数\n\naddPlugins\n\n * 类型： (plugins: PostCSSPlugin | PostCSSPlugin[]) => void\n\n用于添加额外的 PostCSS 插件，你可以传入单个 PostCSS 插件，也可以传入 PostCSS 插件数组。\n\nexport default {\n  tools: {\n    postcss: (config, { addPlugins }) => {\n      // 添加一个插件\n      addPlugins(require('postcss-preset-env'));\n      // 批量添加插件\n      addPlugins([require('postcss-preset-env'), require('postcss-import')]);\n    },\n  },\n};\n\n\nTIP\n\nBuilder 中使用的 PostCSS 版本为 v8，当你引入社区中的 PostCSS 插件时，请注意版本是否适配，部分旧版本插件可能无法在 PostCSS\nv8 下运行。","frontmatter":{"sidebar_label":"postcss"}},{"id":495,"title":"tools.pug","routePath":"/configure/app/tools/pug","lang":"zh","toc":[{"id":"boolean-类型","text":"Boolean 类型","depth":3},{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.pug。\n\n * 类型： true | Object | Function | undefined\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n配置 Pug 模板引擎。\n\n\nBoolean 类型\n\nBuilder 默认不启用 Pug 模板引擎，你可以将 tools.pug 设置为 true 来启用它。\n\nexport default {\n  tools: {\n    pug: true,\n  },\n};\n\n\n启用后，你可以在 html.template 中指定使用 index.pug 作为模板文件。\n\n\nObject 类型\n\n当 tools.terser 的值为 Object 类型时，可以配置 Pug 模板引擎的选项：\n\nexport default {\n  tools: {\n    pug: {\n      doctype: 'xml',\n    },\n  },\n};\n\n\n详细参数请查看 Pug API Reference。\n\n\nFunction 类型\n\n当 tools.pug 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\nexport default {\n  tools: {\n    pug(config) {\n      config.doctype = 'xml';\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"pug"}},{"id":496,"title":"tools.rspack","routePath":"/configure/app/tools/rspack","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3},{"id":"工具集合","text":"工具集合","depth":3},{"id":"env","text":"env","depth":4},{"id":"isprod","text":"isProd","depth":4},{"id":"target","text":"target","depth":4},{"id":"isserver","text":"isServer","depth":4},{"id":"iswebworker","text":"isWebWorker","depth":4},{"id":"addrules","text":"addRules","depth":3},{"id":"prependplugins","text":"prependPlugins","depth":3},{"id":"appendplugins","text":"appendPlugins","depth":3},{"id":"removeplugin","text":"removePlugin","depth":3},{"id":"mergeconfig","text":"mergeConfig","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.rspack。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 Rspack\n\ntools.rspack 选项用于配置原生的 Rspack。\n\n\nObject 类型\n\n你可以配置为一个对象，这个对象将会和原始的 Rspack 配置通过 webpack-merge 进行合并。比如：\n\nexport default {\n  tools: {\n    rspack: {\n      resolve: {\n        alias: {\n          '@util': 'src/util',\n        },\n      },\n    },\n  },\n};\n\n\n\nFunction 类型\n\n你也可以配置为一个函数，这个函数接收一个参数，即原始的 Rspack 配置，你可以对这个配置进行修改，然后返回一个新的配置。比如：\n\nexport default {\n  tools: {\n    rspack: config => {\n      config.resolve.alias['@util'] = 'src/util';\n      return config;\n    },\n  },\n};\n\n\n这个函数的第二个参数是一个对象，包含了一些工具集合的信息。详情如下：\n\n\n工具集合\n\nenv\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    rspack: (config, { env }) => {\n      if (env === 'development') {\n        config.devtool = 'cheap-module-eval-source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\nisProd\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    rspack: (config, { isProd }) => {\n      if (isProd) {\n        config.devtool = 'source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\ntarget\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    rspack: (config, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisServer\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    rspack: (config, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisWebWorker\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    rspack: (config, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\n\naddRules\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 Rspack rules。\n\n示例：\n\nexport default {\n  tools: {\n    rspack: (config, { addRules }) => {\n      // 添加单条规则\n      addRules({\n        test: /\\.foo/,\n        loader: require.resolve('foo-loader'),\n      });\n\n      // 以数组形式添加多条规则\n      addRules([\n        {\n          test: /\\.foo/,\n          loader: require.resolve('foo-loader'),\n        },\n        {\n          test: /\\.bar/,\n          loader: require.resolve('bar-loader'),\n        },\n      ]);\n    },\n  },\n};\n\n\n\nprependPlugins\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\nexport default {\n  tools: {\n    rspack: (config, { prependPlugins }) => {\n      // 添加单个插件\n      prependPlugins(\n        new PluginA(),\n      );\n\n      // 以数组形式添加多个插件\n      prependPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nappendPlugins\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\nexport default {\n  tools: {\n    rspack: (config, { appendPlugins }) => {\n      // 添加单个插件\n      appendPlugins([\n        new PluginA(),\n      ]);\n\n      // 以数组形式添加多个插件\n      appendPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nremovePlugin\n\n * 类型： (name: string) => void\n\n删除内部的 Rspack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 webpack-bundle-analyzer：\n\nexport default {\n  tools: {\n    rspack: (config, { removePlugin }) => {\n      removePlugin('BundleAnalyzerPlugin');\n    },\n  },\n};\n\n\n\nmergeConfig\n\n * 类型： (...configs: RspackConfig[]) => RspackConfig\n\n用于合并多份 Rspack 配置，等价于 webpack-merge。\n\nexport default {\n  tools: {\n    rspack: (config, { mergeConfig }) => {\n      return mergeConfig(config, {\n        devtool: 'eval',\n      });\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"rspack"}},{"id":497,"title":"tools.sass","routePath":"/configure/app/tools/sass","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3},{"id":"工具函数","text":"工具函数","depth":3},{"id":"addexcludes","text":"addExcludes","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.sass。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  // 默认在开发环境下启用 CSS 的 Source Map\n  sourceMap: isDev,\n};\n\n\n你可以通过 tools.sass 修改 sass-loader 的配置。\n\n\nObject 类型\n\n当 tools.sass 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，sassOptions 会通过\ndeepMerge 进行深层合并。\n\nexport default {\n  tools: {\n    sass: {\n      sourceMap: true,\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.sass 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    sass(config) {\n      // 修改 sourceMap 配置\n      config.additionalData = async (content, loaderContext) => {\n        // ...\n      };\n    },\n  },\n};\n\n\n\n工具函数\n\naddExcludes\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 sass-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 sass 文件的路径。例如：\n\nexport default {\n  tools: {\n    sass(config, { addExcludes }) {\n      addExcludes(/node_modules/);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"sass"}},{"id":498,"title":"tools.styleLoader","routePath":"/configure/app/tools/style-loader","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.styleLoader。\n\n * 类型： Object | Function\n * 默认值： {}\n * 打包工具： 仅支持 webpack\n\n通过 tools.styleLoader 可以设置 style-loader 的配置项。\n\n值得注意的是，Builder 默认不会开启 style-loader，你可以通过 output.disableCssExtract 配置项来开启它。\n\n\nObject 类型\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\nexport default {\n  tools: {\n    styleLoader: {\n      insert: 'head',\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\nexport default {\n  tools: {\n    styleLoader: config => {\n      config.insert = 'head';\n      return config;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"styleLoader"}},{"id":499,"title":"tools.styledComponents","routePath":"/configure/app/tools/styled-components","lang":"zh","toc":[],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.styledComponents。\n\n * 类型： Object | Function\n * 默认值\n\n{\n  displayName: true,\n  // 在 SSR 构建中 isSSR 为 true\n  ssr: isSSR,\n  // 在生产环境构建时启用 `pure` 来优化包体积\n  pure: isProd,\n  transpileTemplateLiterals: true,\n}\n\n\n * 打包工具： 仅支持 webpack\n\n对应 babel-plugin-styled-components 的配置。 值为 Object 类型时，利用 Object.assign\n函数与默认配置合并。比如:\n\nexport default {\n  tools: {\n    styledComponents: {\n      pure: false,\n    },\n  },\n};\n\n\n值为 Function 类型时，第一个参数为默认配置，第二个参数提供了一些可以直接调用的工具函数：\n\nexport default {\n  tools: {\n    styledComponents(config) {\n      // 修改 pure 配置\n      config.pure = false;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"styledComponents"}},{"id":500,"title":"tools.swc","routePath":"/configure/app/tools/swc","lang":"zh","toc":[{"id":"介绍","text":"介绍","depth":2},{"id":"安装","text":"安装","depth":2},{"id":"配置项","text":"配置项","depth":2}],"domain":"","content":"\n\n * 类型： Object\n * 默认值： undefined\n\n\n介绍\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且比 Babel 性能高出 10 倍不止。\n\nModern.js 提供了开箱即用的 SWC 插件，可以为你的 Web 应用提供语法降级、Polyfill 以及压缩，并且移植了一些额外常见的 Babel\n插件。\n\n\n安装\n\n使用前需要安装 @modern-js/plugin-swc 插件。\n\npnpm add @modern-js/plugin-swc -D\n\n\n安装完成后，只需在 modern.config.ts 文件中注册 SWC 插件，即可启用 SWC 编译和压缩能力。\n\n\n\n\nexport default defineConfig({\n  plugins: [appTools(), swcPlugin()],\n});\n\n\n\n配置项\n\n你可以通过 tools.swc 配置项来设置 SWC 编译行为。\n\n\n\nexport default defineConfig({\n  tools: {\n    swc: {\n      jsMinify: {\n        compress: {},\n        mangle: true,\n      },\n    },\n  },\n});\n\n\n完整配置项请参考 Modern.js Builder - SWC 插件配置。","frontmatter":{"title":"tools.swc","sidebar_label":"swc"}},{"id":501,"title":"tools.tailwindcss","routePath":"/configure/app/tools/tailwindcss","lang":"zh","toc":[{"id":"限制","text":"限制","depth":3}],"domain":"","content":"\n\n * 类型： Object | Function\n * 默认值：\n\nconst tailwind = {\n  content: [\n    './config/html/**/*.html',\n    './config/html/**/*.ejs',\n    './config/html/**/*.hbs',\n    './src/**/*.js',\n    './src/**/*.jsx',\n    './src/**/*.ts',\n    './src/**/*.tsx',\n    './storybook/**/*',\n  ],\n  // 使用 source.designSystem 配置作为 Tailwind CSS Theme 配置\n  theme: source.designSystem,\n};\n\n\n对应 TailwindCSS 的配置。\n\n当值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n当值为 Function 类型时，函数返回的对象与默认配置通过 Object.assign 合并。\n\n\n限制\n\n注意，该配置中不允许使用 theme 配置项，否则会构建失败。在 Modern.js 中，请使用 source.designSystem 作为 Tailwind\nCSS Theme 配置。\n\n其他的使用方式和 Tailwind CSS 一致: 快速传送门。","frontmatter":{"sidebar_label":"tailwindcss"}},{"id":502,"title":"tools.terser","routePath":"/configure/app/tools/terser","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.terser。\n\n * 类型： Object | Function | undefined\n * 默认值：\n\nconst defaultTerserOptions = {\n  terserOptions: {\n    mangle: {\n      safari10: true,\n    },\n  },\n};\n\n\n * 打包工具： 仅支持 webpack\n\n在生产环境构建时，Builder 会通过 terser-webpack-plugin 对 JavaScript 代码进行压缩优化。可以通过\ntools.terser 修改 terser-webpack-plugin 的配置。\n\n\nObject 类型\n\n当 tools.terser 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如通过 exclude 排除部分文件的压缩：\n\nexport default {\n  tools: {\n    terser: {\n      exclude: /\\/excludes/,\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当 tools.terser 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\nexport default {\n  tools: {\n    terser: opts => {\n      opts.exclude = /\\/excludes/;\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"terser"}},{"id":503,"title":"tools.tsChecker","routePath":"/configure/app/tools/ts-checker","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.tsChecker。\n\n * 类型： Object | Function\n * 默认值：\n\nconst defaultOptions = {\n  typescript: {\n    // avoid OOM issue\n    memoryLimit: 8192,\n    // use tsconfig of user project\n    configFile: tsconfigPath,\n    // use typescript of user project\n    typescriptPath: require.resolve('typescript'),\n  },\n  issue: {\n    exclude: [\n      { file: '**/*.(spec|test).ts' },\n      { file: '**/node_modules/**/*' },\n    ],\n  },\n  logger: {\n    log() {\n      // do nothing\n      // we only want to display error messages\n    },\n    error(message: string) {\n      console.error(message.replace(/ERROR/g, 'Type Error'));\n    },\n  },\n},\n\n\n * 打包工具： 仅支持 webpack\n\n默认情况下，Builder 会开启 fork-ts-checker-webpack-plugin 进行类型检查。你可以通过\noutput.disableTsChecker 配置项来关闭类型检查。\n\n\nObject 类型\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n\nFunction 类型\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。","frontmatter":{"sidebar_label":"tsChecker"}},{"id":504,"title":"tools.tsLoader","routePath":"/configure/app/tools/ts-loader","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3},{"id":"工具函数","text":"工具函数","depth":3},{"id":"addincludes","text":"addIncludes","depth":4},{"id":"addexcludes","text":"addExcludes","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.tsLoader。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n项目中默认不开启 ts-loader，当 tools.tsLoader 不为 undefined 则表示开启 ts-loader，同时禁用\nbabel-loader 对 TypeScript 的编译。\n\n\nObject 类型\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n默认配置如下:\n\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"ESNext\"\n  },\n  \"transpileOnly\": true,\n  \"allowTsInNodeModules\": true\n}\n\n\n你可以通过 tools.tsLoader 配置项来覆盖默认配置:\n\nexport default {\n  tools: {\n    tsLoader: {\n      allowTsInNodeModules: false,\n    },\n  },\n};\n\n\n\nFunction 类型\n\n当此值为 Function 类型时，默认配置作为第一参数传入，可以直接修改配置对象，也可以返回一个对象作为最终配置；第二个参数为修改 ts-loader\n配置工具函数集合：\n\nexport default {\n  tools: {\n    tsLoader: opts => {\n      opts.allowTsInNodeModules = false;\n    },\n  },\n};\n\n\n\n工具函数\n\ntools.tsLoader 的值为 Function 类型时，第二个参数可用的工具函数如下：\n\naddIncludes\n\n类型: (includes: string | RegExp | Array<string | RegExp>) => void\n\n默认情况下只会编译 src 目录下的业务代码，使用 addIncludes 可以指定 ts-loader 编译 node_modules 下的一些文件。比如:\n\nexport default {\n  tools: {\n    tsLoader: (config, { addIncludes }) => {\n      addIncludes([/node_modules\\/react/]);\n    },\n  },\n};\n\n\naddExcludes\n\n类型: (excludes: string | RegExp | Array<string | RegExp>) => void\n\n和 addIncludes 相反，指定 ts-loader 编译时排除某些文件。\n\n例如不编译 src/example 目录下的文件：\n\nexport default {\n  tools: {\n    tsLoader: (config, { addExcludes }) => {\n      addExcludes([/src\\/example\\//]);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"tsLoader"}},{"id":505,"title":"tools.webpackChain","routePath":"/configure/app/tools/webpack-chain","lang":"zh","toc":[{"id":"工具集合","text":"工具集合","depth":3},{"id":"env","text":"env","depth":4},{"id":"isprod","text":"isProd","depth":4},{"id":"target","text":"target","depth":4},{"id":"isserver","text":"isServer","depth":4},{"id":"iswebworker","text":"isWebWorker","depth":4},{"id":"webpack","text":"webpack","depth":4},{"id":"htmlwebpackplugin","text":"HtmlWebpackPlugin","depth":3},{"id":"chain_id","text":"CHAIN_ID","depth":4},{"id":"chain_idone_of","text":"CHAIN_ID.ONE_OF","depth":3},{"id":"chain_iduse","text":"CHAIN_ID.USE","depth":3},{"id":"chain_idplugin","text":"CHAIN_ID.PLUGIN","depth":3},{"id":"chain_idminimizer","text":"CHAIN_ID.MINIMIZER","depth":3},{"id":"常用-webpackchain-使用示例","text":"常用 WebpackChain 使用示例","depth":3},{"id":"新增修改删除-loader","text":"新增/修改/删除 loader","depth":4},{"id":"新增修改删除-plugin","text":"新增/修改/删除 plugin","depth":4}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.webpackChain。\n\n * 类型： Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n你可以通过 tools.webpackChain 来修改默认的 webpack 配置，值为 Function 类型，接收两个参数：\n\n * 第一个参数为 webpack-chain 对象实例，你可以通过这个实例来修改默认的 webpack 配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n相比于 tools.webpack，webpack-chain 不仅支持链式调用，而且能够基于别名来定位到内置的 Rule 或\nPlugin，从而实现精准的配置修改。我们推荐使用 tools.webpackChain 来代替 tools.webpack。\n\n> tools.webpackChain 的执行时机早于 tools.webpack，因此会被 tools.webpack 中的修改所覆盖。\n\n\n工具集合\n\nenv\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { env }) => {\n      if (env === 'development') {\n        chain.devtool('cheap-module-eval-source-map');\n      }\n    },\n  },\n};\n\n\nisProd\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isProd }) => {\n      if (isProd) {\n        chain.devtool('source-map');\n      }\n    },\n  },\n};\n\n\ntarget\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n    },\n  },\n};\n\n\nisServer\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n    },\n  },\n};\n\n\nisWebWorker\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n    },\n  },\n};\n\n\nwebpack\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\nexport default {\n  tools: {\n    webpackChain: (chain, { webpack }) => {\n      chain.plugin('my-progress').use(webpack.ProgressPlugin);\n    },\n  },\n};\n\n\n\nHtmlWebpackPlugin\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { HtmlWebpackPlugin }) => {\n      console.log(HtmlWebpackPlugin);\n    },\n  },\n};\n\n\nCHAIN_ID\n\nBuilder 中预先定义了一些常用的 Chain ID，你可以通过这些 ID 来定位到内置的 Rule 或 Plugin。\n\nCHAIN_ID.RULE\n\n| ID | 描述 | | ------------ | ------------------ | | RULE.MJS | 处理 mjs 的规则 | |\nRULE.JS | 处理 js 的规则 | | RULE.TS | 处理 ts 的规则 | | RULE.CSS | 处理 css 的规则 | |\nRULE.LESS | 处理 less 的规则 | | RULE.SASS | 处理 sass 的规则 | | RULE.PUG | 处理 pug 的规则 |\n| RULE.TOML | 处理 toml 的规则 | | RULE.YAML | 处理 yaml 的规则 | | RULE.FONT | 处理字体的规则 |\n| RULE.IMAGE | 处理图片的规则 | | RULE.MEDIA | 处理媒体资源的规则 |\n\n\nCHAIN_ID.ONE_OF\n\n通过 ONE_OF.XXX 可以匹配到规则数组中的某一类规则。\n\n| ID | 描述 | | ------------------- |\n--------------------------------------------------- | | ONE_OF.SVG | 处理 SVG\n的规则，在 data URI 和单独文件之间自动选择 | | ONE_OF.SVG_URL | 处理 SVG 的规则，输出为单独文件 | |\nONE_OF.SVG_INLINE | 处理 SVG 的规则，作为 data URI 内联到 bundle 中 | | ONE_OF.SVG_ASSETS |\n处理 SVG 的规则，在 data URI 和单独文件之间自动选择 |\n\n\nCHAIN_ID.USE\n\n通过 USE.XXX 可以匹配到对应的 loader。\n\n| ID | 描述 | | ---------------------- | ------------------------------------- | |\nUSE.TS | 对应 ts-loader | | USE.CSS | 对应 css-loader | | USE.LESS | 对应 less-loader\n| | USE.SASS | 对应 sass-loader | | USE.PUG | 对应 pug-loader | | USE.TOML | 对应\ntoml-loader | | USE.YAML | 对应 yaml-loader | | USE.FILE | 对应 file-loader | |\nUSE.URL | 对应 url-loader | | USE.SVGR | 对应 @svgr/webpack | | USE.BABEL | 对应\nbabel-loader | | USE.STYLE | 对应 style-loader | | USE.POSTCSS | 对应 postcss-loader\n| | USE.MARKDOWN | 对应 markdown-loader | | USE.CSS_MODULES_TS | 对应\ncss-modules-typescript-loader | | USE.MINI_CSS_EXTRACT | 对应\nmini-css-extract-plugin.loader |\n\n\nCHAIN_ID.PLUGIN\n\n通过 PLUGIN.XXX 可以匹配到对应的 plugin。\n\n| ID | 描述 | | ------------------------------ |\n--------------------------------------------------------------------------------\n-- | | PLUGIN.HMR | 对应 HotModuleReplacementPlugin | | PLUGIN.COPY | 对应\nCopyWebpackPlugin | | PLUGIN.HTML | 对应 HtmlWebpackPlugin，使用时需要拼接 entry\n名称：${PLUGIN.HTML}-${entryName} | | PLUGIN.DEFINE | 对应 DefinePlugin | |\nPLUGIN.IGNORE | 对应 IgnorePlugin | | PLUGIN.BANNER | 对应 BannerPlugin | |\nPLUGIN.PROGRESS | 对应 Webpackbar | | PLUGIN.APP_ICON | 对应 AppIconPlugin | |\nPLUGIN.LOADABLE | 对应 LoadableWebpackPlugin | | PLUGIN.MANIFEST | 对应\nWebpackManifestPlugin | | PLUGIN.TS_CHECKER | 对应 ForkTsCheckerWebpackPlugin | |\nPLUGIN.INLINE_HTML | 对应 InlineChunkHtmlPlugin | | PLUGIN.BUNDLE_ANALYZER | 对应\nWebpackBundleAnalyzer | | PLUGIN.BOTTOM_TEMPLATE | 对应 BottomTemplatePlugin | |\nPLUGIN.MINI_CSS_EXTRACT | 对应 MiniCssExtractPlugin | | PLUGIN.REACT_FAST_REFRESH\n| 对应 ReactFastRefreshPlugin | | PLUGIN.NODE_POLYFILL_PROVIDE | 对应处理 node\npolyfill 的 ProvidePlugin | | PLUGIN.INSPECTOR | 对应\n@modern-js/inspector-webpack-plugin | | PLUGIN.SUBRESOURCE_INTEGRITY | 对应\nwebpack-subresource-integrity | | PLUGIN.ASSETS_RETRY | 对应 Builder 中的 webpack\n静态资源重试插件 WebpackAssetsRetryPlugin | | PLUGIN.AUTO_SET_ROOT_SIZE | 对应 Builder\n中的自动设置根字体大小插件 AutoSetRootSizePlugin |\n\n\nCHAIN_ID.MINIMIZER\n\n通过 MINIMIZER.XXX 可以匹配到对应的压缩工具。\n\n| ID | 描述 | | ------------------- | -------------------------------- | |\nMINIMIZER.JS | 对应 TerserWebpackPlugin | | MINIMIZER.CSS | 对应\nCssMinimizerWebpackPlugin | | MINIMIZER.ESBUILD | 对应 ESBuildPlugin | |\nMINIMIZER.SWC | 对应 SwcWebpackPlugin |\n\n\n常用 WebpackChain 使用示例\n\n以下是一些常见的配置示例，完整的 webpack-chain API 请见 webpack-chain 文档。\n\n新增/修改/删除 loader\n\nexport default {\n  tools: {\n    webpackChain: (chain, { CHAIN_ID }) => {\n      // 新增 loader\n      chain.module\n        .rule('md')\n        .test(/\\.md$/)\n        .use('md-loader')\n        .loader('md-loader');\n\n      // 修改 loader\n      chain.module\n        .rule(CHAIN_ID.RULE.JS)\n        .use(CHAIN_ID.USE.BABEL)\n        .tap(options => {\n          options.plugins.push('babel-plugin-xxx');\n          return options;\n        });\n\n      // 删除 loader\n      chain.module.rule(CHAIN_ID.RULE.JS).uses.delete(CHAIN_ID.USE.BABEL);\n    },\n  },\n};\n\n\n新增/修改/删除 plugin\n\nexport default {\n  tools: {\n    webpackChain: (chain, { webpack, CHAIN_ID }) => {\n      // 新增插件\n      chain.plugin('custom-define').use(webpack.DefinePlugin, [\n        {\n          'process.env': {\n            NODE_ENV: JSON.stringify(process.env.NODE_ENV),\n          },\n        },\n      ]);\n\n      // 修改插件\n      chain.plugin(CHAIN_ID.PLUGIN.HMR).tap(options => {\n        options[0].fullBuildTimeout = 200;\n        return options;\n      });\n\n      // 删除插件\n      chain.plugins.delete(CHAIN_ID.PLUGIN.HMR);\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"webpackChain"}},{"id":506,"title":"tools.webpack","routePath":"/configure/app/tools/webpack","lang":"zh","toc":[{"id":"object-类型","text":"Object 类型","depth":3},{"id":"function-类型","text":"Function 类型","depth":3},{"id":"工具集合","text":"工具集合","depth":3},{"id":"env","text":"env","depth":4},{"id":"isprod","text":"isProd","depth":4},{"id":"target","text":"target","depth":4},{"id":"isserver","text":"isServer","depth":4},{"id":"iswebworker","text":"isWebWorker","depth":4},{"id":"webpack","text":"webpack","depth":4},{"id":"htmlwebpackplugin","text":"HtmlWebpackPlugin","depth":3},{"id":"addrules","text":"addRules","depth":3},{"id":"prependplugins","text":"prependPlugins","depth":3},{"id":"appendplugins","text":"appendPlugins","depth":3},{"id":"removeplugin","text":"removePlugin","depth":3},{"id":"mergeconfig","text":"mergeConfig","depth":3}],"domain":"","content":"\n\nTIP\n\n该配置由 Modern.js Builder 提供，更多信息可参考 tools.webpack。\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\ntools.webpack 选项用于配置原生的 webpack。\n\n> tools.webpackChain 同样可以修改 webpack 配置，并且功能更加强大，建议优先使用 tools.webpackChain。\n\n\nObject 类型\n\n你可以配置为一个对象，这个对象将会和原始的 webpack 配置通过 webpack-merge 进行合并。比如：\n\nexport default {\n  tools: {\n    webpack: {\n      resolve: {\n        alias: {\n          '@util': 'src/util',\n        },\n      },\n    },\n  },\n};\n\n\n\nFunction 类型\n\n你也可以配置为一个函数，这个函数接收一个参数，即原始的 webpack 配置，你可以对这个配置进行修改，然后返回一个新的配置。比如：\n\nexport default {\n  tools: {\n    webpack: config => {\n      config.resolve.alias['@util'] = 'src/util';\n      return config;\n    },\n  },\n};\n\n\n这个函数的第二个参数是一个对象，包含了一些工具集合的信息。详情如下：\n\n\n工具集合\n\nenv\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { env }) => {\n      if (env === 'development') {\n        config.devtool = 'cheap-module-eval-source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\nisProd\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { isProd }) => {\n      if (isProd) {\n        config.devtool = 'source-map';\n      }\n      return config;\n    },\n  },\n};\n\n\ntarget\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { target }) => {\n      if (target === 'node') {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisServer\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\nexport default {\n  tools: {\n    webpack: (config, { isServer }) => {\n      if (isServer) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nisWebWorker\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\nexport default {\n  tools: {\n    webpack: (config, { isWebWorker }) => {\n      if (isWebWorker) {\n        // ...\n      }\n      return config;\n    },\n  },\n};\n\n\nwebpack\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\nexport default {\n  tools: {\n    webpack: (config, { webpack }) => {\n      config.plugins.push(new webpack.ProgressPlugin());\n      return config;\n    },\n  },\n};\n\n\n\nHtmlWebpackPlugin\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\nexport default {\n  tools: {\n    webpackChain: (chain, { HtmlWebpackPlugin }) => {\n      console.log(HtmlWebpackPlugin);\n    },\n  },\n};\n\n\n\naddRules\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 webpack rules。\n\n示例：\n\nexport default {\n  tools: {\n    webpack: (config, { addRules }) => {\n      // 添加单条规则\n      addRules({\n        test: /\\.foo/,\n        loader: require.resolve('foo-loader'),\n      });\n\n      // 以数组形式添加多条规则\n      addRules([\n        {\n          test: /\\.foo/,\n          loader: require.resolve('foo-loader'),\n        },\n        {\n          test: /\\.bar/,\n          loader: require.resolve('bar-loader'),\n        },\n      ]);\n    },\n  },\n};\n\n\n\nprependPlugins\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\nexport default {\n  tools: {\n    webpack: (config, { prependPlugins, webpack }) => {\n      // 添加单个插件\n      prependPlugins(\n        new webpack.BannerPlugin({\n          banner: 'hello world!',\n        }),\n      );\n\n      // 以数组形式添加多个插件\n      prependPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nappendPlugins\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\nexport default {\n  tools: {\n    webpack: (config, { appendPlugins, webpack }) => {\n      // 添加单个插件\n      appendPlugins([\n        new webpack.BannerPlugin({\n          banner: 'hello world!',\n        }),\n      ]);\n\n      // 以数组形式添加多个插件\n      appendPlugins([new PluginA(), new PluginB()]);\n    },\n  },\n};\n\n\n\nremovePlugin\n\n * 类型： (name: string) => void\n\n删除内部的 webpack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 fork-ts-checker-webpack-plugin：\n\nexport default {\n  tools: {\n    webpack: (config, { removePlugin }) => {\n      removePlugin('ForkTsCheckerWebpackPlugin');\n    },\n  },\n};\n\n\n\nmergeConfig\n\n * 类型： (...configs: WebpackConfig[]) => WebpackConfig\n\n用于合并多份 webpack 配置，等价于 webpack-merge。\n\nexport default {\n  tools: {\n    webpack: (config, { mergeConfig }) => {\n      return mergeConfig(config, {\n        devtool: 'eval',\n      });\n    },\n  },\n};\n","frontmatter":{"sidebar_label":"webpack"}},{"id":507,"title":"配置使用","routePath":"/configure/app/usage","lang":"zh","toc":[{"id":"在配置文件中配置","text":"在配置文件中配置","depth":2},{"id":"modernconfigjs","text":"modern.config.js","depth":3},{"id":"modernconfigts推荐","text":"modern.config.ts（推荐）","depth":3},{"id":"导出配置函数","text":"导出配置函数","depth":3},{"id":"导出异步函数","text":"导出异步函数","depth":3},{"id":"指定配置文件","text":"指定配置文件","depth":3},{"id":"在-packagejson-中配置不推荐","text":"在 package.json 中配置（不推荐）","depth":2},{"id":"注意事项","text":"注意事项","depth":3},{"id":"本地调试配置","text":"本地调试配置","depth":2},{"id":"示例","text":"示例","depth":3},{"id":"注意事项-1","text":"注意事项","depth":3}],"domain":"","content":"\n\nModern.js 中有两种配置，一个是编译时配置，一个是服务端运行时配置。\n\n编译时配置可以在两个位置进行配置：\n\n * 根路径下的 modern.config.(ts|js|mjs) 文件\n * package.json 文件\n\nINFO\n\nModern.js 不支持同时在 package.json 中和 modern.config.ts 中配置同一个配置项，推荐优先在\nmodern.config.ts 中进行配置。如果 Modern.js 检测到重复配置导致的冲突，将会抛出警告。\n\n服务端运行时配置可以在根路径下的 modern.server-runtime.config.(ts|js|mjs) 中自定义配置选项。\n\n\n在配置文件中配置\n\nModern.js 的配置文件定义在项目的根目录下，支持 .js, .ts 和 .mjs 格式：\n\n * modern.config.js\n * modern.config.ts\n * modern.config.mjs\n\n\nmodern.config.js\n\nmodern.config.js 中可以使用 JavaScript 语法，因此比 package.json 更加灵活。\n\n比如，你可以在 modern.config.js 中定义函数类型的配置选项：\n\nexport default {\n  source: {\n    alias: opts => {\n      opts['@common'] = './src/common';\n    },\n  },\n};\n\n\n你也可以通过 process.env.NODE_ENV 进行动态设置：\n\nexport default {\n  server: {\n    ssr: process.env.NODE_ENV === 'development',\n  },\n};\n\n\n\nmodern.config.ts（推荐）\n\n我们推荐使用 .ts 格式的配置文件，它提供了友好的 TypeScript 类型提示，从而帮助你避免配置中的错误。\n\n从 @modern-js/app-tools 中导入 defineConfig 工具函数, 它会帮助你进行配置的类型推导和类型补全：\n\n\n\nexport default defineConfig({\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n});\n\n\n\n导出配置函数\n\nModern.js 支持在配置文件中导出一个函数，你可以在函数中动态计算配置，并返回给 Modern.js。\n\n\n\nexport default defineConfig(({ env, command }) => ({\n  source: {\n    alias: {\n      '@foo': env === 'development' ? './src/foo.dev.ts' : './src/foo.prod.ts',\n    },\n  },\n}));\n\n\n该函数接受以下入参：\n\n * env：对应 process.env.NODE_ENV 的值。\n   * 当运行 modern dev 或 modern start 时，env 的值为 development。\n   * 当运行 modern build 或 modern serve 时，env 的值为 production。\n   * 当运行 modern test 时，env 的值为 test。\n * command: 对应当前运行的命令，如 dev、start、build、serve。\n\n\n导出异步函数\n\nModern.js 也支持在配置文件中导出一个异步函数，你可以在函数中进行一些异步操作：\n\n\n\nexport default defineConfig(async ({ env, command }) => {\n  const result = await someAsyncFunction();\n\n  return {\n    html: {\n      title: result,\n    },\n  };\n});\n\n\n\n指定配置文件\n\nModern.js 命令行支持通过 --config 选项来指定配置文件的名称。\n\n例如，你需要在执行 build 命令时使用 modern.prod.config.ts 文件，可以在 package.json 中添加如下配置：\n\n{\n  \"scripts\": {\n    \"dev\": \"modern modern\",\n    \"build\": \"modern build --config modern.prod.config.ts\"\n  }\n}\n\n\n你也可以将 --config 选项缩写为 -c：\n\n$ modern build -c modern.prod.config.js\n\n\n\n在 package.json 中配置（不推荐）\n\n除了配置文件外，也可以在 package.json 中的 modernConfig 字段下设置配置选项，如：\n\n{\n  \"modernConfig\": {\n    \"source\": {\n      \"alias\": {\n        \"@common\": \"./src/common\"\n      }\n    }\n  }\n}\n\n\n由于 JSON 文件格式的限制，package.json 中只能定义数字、字符串、布尔值、数组等简单类型的值，当我们需要设置函数类型的值时，建议在\nModern.js 配置文件中进行设置。\n\n\n注意事项\n\n * 不建议同时使用 package.json 和 modern.config.js 进行配置。如果同时使用了两者并出现配置冲突，Modern.js\n   会在命令行进行提示。\n * @modern-js/runtime 导出了同名的 defineConfig API，请注意区分。\n\n\n本地调试配置\n\n为了便于本地调试配置，Modern.js 支持在项目根目录下创建 modern.config.local.(ts|js|mjs) 文件，用于覆盖\nmodern.config.(ts|js|mjs) 中的配置选项。\n\n\n示例\n\n比如，项目的 modern.config.ts 中配置了端口号为 3000:\n\n\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n  },\n});\n\n\n如果你在本地调试时需要将端口号修改为 3001，但是又不希望修改当前项目的 modern.config.ts 文件，那么可以创建一个\nmodern.config.local.ts 文件，并添加以下配置：\n\n\n\nexport default defineConfig({\n  server: {\n    port: 3001,\n  },\n});\n\n\nmodern.config.local.ts 文件中的配置会与 modern.config.ts 中的配置进行深层合并，并覆盖 modern.config.ts\n中的配置选项，因此 server.port 会被覆盖为 3001。\n\n\n注意事项\n\n在使用 modern.config.local.ts 时，请注意以下事项：\n\n * modern.config.local.ts 文件仅会在执行 modern dev 或 modern start 命令时被加载，当执行 modern\n   build 时不会被加载。\n * modern.config.local.ts 文件的优先级不仅高于 modern.config.ts，也高于 package.json 中的\n   modernConfig 字段。\n * 由于 modern.config.local.ts 仅在本地调试时使用，因此不建议将其提交到代码仓库中，请确保项目的 .gitignore 文件中包含\n   modern.config.local.ts 等文件。\n\nmodern.config.local.ts\nmodern.config.local.js\nmodern.config.local.mjs\n","frontmatter":{"sidebar_position":0}},{"id":508,"title":"使用 BFF 代理","routePath":"/guides/advanced-features/bff/bff-proxy","lang":"zh","toc":[],"domain":"","content":"\n\n通过配置 BFF 代理，无需手动写码，即可对 API 请求进行转发。\n\nCAUTION\n\n使用 BFF 代理需确保请求能进入 BFF handler。（例如请求路径必须包含 bff prefix）\n\n在 modern.server-runtime.config.js 文件中编写以下 BFF 代理配置，会将发送到\nhttp://localhost:8080/api/v1/topics 的请求代理到 https://cnodejs.org/api/v1/topics。\n\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api/v1/topics': 'https://cnodejs.org',\n    },\n  },\n};\n\n\nNOTE\n\n详细 API 请查看 BFF 代理。更多 Modern.js 代理的能力可查看调试代理。","frontmatter":{"sidebar_position":5,"title":"使用 BFF 代理"}},{"id":509,"title":"运行时框架","routePath":"/guides/advanced-features/bff/frameworks","lang":"zh","toc":[{"id":"函数写法","text":"函数写法","depth":2},{"id":"框架写法","text":"框架写法","depth":2},{"id":"express","text":"Express","depth":3},{"id":"koa","text":"Koa","depth":3}],"domain":"","content":"\n\nModern.js 的 BFF 支持不同的运行时框架，当前 Modern.js 的 BFF 支持两种运行时框架 Express.js 和 Koa.js。\n\n\n函数写法\n\n在函数写法下，各类运行时框架仅中间件写法存在差异，其他实现基本相同。这里以 Express 为例，介绍如何在 api/_app.ts\n中，手写一个中间件，添加权限校验：\n\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(async (req: Request, res: Response, next: NextFunction) => {\n    if (req.url !== '/api/login') {\n      const sid = req?.cookies?.sid;\n      if (!sid) {\n        res.status(400);\n        res.json({ code: -1, message: 'need login' });\n      } else {\n        next();\n      }\n    } else {\n      next();\n    }\n  });\n});\n\n\n然后添加一个普通的 BFF 函数 /api/hello.ts：\n\nexport default async () => {\n  return 'Hello Modern.js';\n};\n\n\n最后在前端 src/App.tsx 添加接口的访问代码，直接使用一体化的方式调用：\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    async function fetchMyApi() {\n      const { message } = await hello();\n      setText(message);\n    }\n\n    fetchMyApi();\n  }, []);\n\n  return <p>{text}</p>;\n};\n\n\n然后 pnpm run dev 启动项目，访问 http://localhost:8080/ 会发现 /api/hello 的请求被拦截了：\n\n\n\n最后再修改前端代码 src/App.tsx，在访问 /api/hello 前先调用登录接口：\n\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    async function fetchAfterLogin() {\n      const { code } = await login();\n      if (code === 0) {\n        const { message } = await hello();\n        setText(message);\n      }\n    }\n    fetchAfterLogin();\n  }, []);\n\n  return <p>{text}</p>;\n};\n\n\n刷新页面，可以看到 /api/hello 访问成功：\n\n\n\n以上代码模拟了在 /api/_app.ts 中添加中间件的方式，实现了简易的登录功能。同样，可以在这个钩子文件中实现其他功能来扩展 BFF Server。\n\n\n框架写法\n\n框架写法下，Modern.js 不会收集 api/_app.ts 中的中间件，运行流程由插件自行控制。\n\n\nExpress\n\nExpress 的框架写法支持可在 api/app.[tj]s 定义 API Server\n的启动逻辑，执行应用的初始化工作，添加全局中间件，声明路由，甚至扩展原有框架等。\n\nBFF 函数定义的路由会在 app.ts 文件定义的路由之后注册，所以在这里你也可以拦截 BFF 函数定义的路由，进行预处理或是提前响应。\n\n\n\nconst app = express();\n\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n\napp.use(async (req, res, next) => {\n  console.info(`access url: ${req.url}`);\n  next();\n});\n\nexport default app;\n\n\n\nKoa\n\nKoa 框架写法与 Express 类似，支持在 app.[tj]s 定义 API Server\n的启动逻辑，执行应用的初始化工作，添加全局中间件，声明路由，扩展原有框架等。\n\nBFF 函数定义的路由会在 app.ts 文件定义的路由之后注册，所以在这里你也可以拦截 BFF 函数定义的路由，进行预处理或是提前响应。\n\n注意\n\n在框架写法下，当没有 app.ts 的时候，Modern.js 默认会添加 koa-body；当有 app.ts 时，如果开发者希望使用带有 Body 的\nBFF 函数，需要确保 koa-body 中间件已经添加。\n\n\n\nconst app = new Koa();\n\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n\napp.use(async (ctx, next) => {\n  console.info(`access url: ${ctx.url}`);\n  await next();\n});\n\nexport default app;\n","frontmatter":{"sidebar_position":3,"title":"运行时框架"}},{"id":510,"title":"基础用法","routePath":"/guides/advanced-features/bff/function","lang":"zh","toc":[{"id":"启用-bff","text":"启用 BFF","depth":2},{"id":"bff-函数","text":"BFF 函数","depth":2},{"id":"函数路由","text":"函数路由","depth":2},{"id":"默认路由","text":"默认路由","depth":3},{"id":"多层路由","text":"多层路由","depth":3},{"id":"动态路由","text":"动态路由","depth":3},{"id":"白名单","text":"白名单","depth":3},{"id":"restful-api","text":"RESTful API","depth":2},{"id":"函数具名导出","text":"函数具名导出","depth":3},{"id":"函数参数规则","text":"函数参数规则","depth":3},{"id":"dynamic-path","text":"Dynamic Path","depth":4},{"id":"requestoption","text":"RequestOption","depth":4}],"domain":"","content":"\n\n通过 Modern.js 开发的应用，可以在 api/\n目录下定义接口函数，前端可以调用这些接口函数，即可发起请求，无需写前后端胶水层代码，同时保证前后端类型安全。\n\n\n启用 BFF\n\n 1. 执行 pnpm new，选择启用 BFF\n 2. 根据选择的运行时框架，将下面的代码添加到 modern.config.[tj]s 中：\n\n\n\n\nexport default defineConfig({\n  plugins: [expressPlugin(), bffPlugin()],\n});\n\n\n\n\n\nexport default defineConfig({\n  plugins: [koaPlugin(), bffPlugin()],\n});\n\n\n\nBFF 函数\n\n允许通过一体化调用的函数，称为 BFF 函数。这里写一个最简单的 BFF 函数，创建 api/hello.ts 文件：\n\nCAUTION\n\n如果是框架模式（有 api/lambda 目录），需要创建 api/lambda/hello.ts\n\nexport const get = async () => 'Hello Modern.js';\n\n\n接着在 src/App.tsx 中直接引入函数并调用：\n\n\n\n\nexport default () => {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    hello().then(setText);\n  }, []);\n  return <div>{text}</div>;\n};\n\n\nINFO\n\nModern.js 生成器已经在 tsconfig.json 中配置 @api 别名，因此可以直接通过别名的方式引入函数。\n\n在 src/App.tsx 中引入的函数，会自动转换成接口调用，不需要再去通过 fetch 去调用接口。\n\n执行 pnpm run dev 打开 http://localhost:8080/ 可以看到页面已经展示了 BFF 函数返回的内容，在 Network\n中可以看到页面向 http://localhost:8080/api/hello 发送了请求：\n\n\n\n\n函数路由\n\nModern.js 中，BFF 函数对应的路由系统是基于文件系统实现的，也是一种约定式路由。\n\n函数写法下 api/ 下的所有文件中的每个 BFF 函数都会映射为一个接口。框架写法下 api/lambda 下的所有文件中的每个 BFF\n函数都会映射为一个接口。\n\nNOTE\n\n函数写法和框架写法会在下一节详细介绍。\n\n所有 BFF 函数生成的路由都带有统一的前缀，默认值为 /api。可以通过 bff.prefix 设置公共路由的前缀。\n\n下面介绍几种路由的约定。\n\n\n默认路由\n\n以 index.[jt]s 命名的文件会被映射到上一层目录。\n\n * api/index.ts -> {prefix}/\n * api/user/index.ts -> {prefix}/user\n\n\n多层路由\n\n支持解析嵌套的文件，如果创建嵌套文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/hello.ts -> {prefix}/hello\n * api/user/list.ts -> {prefix}/user/list\n\n\n动态路由\n\n同样的，创建命名带有 [xxx] 的文件夹或者文件，支持动态的命名路由参数。动态路由的函数参数规则可以看 dynamac-path\n\n * api/user/[username]/info.ts -> {prefix}/user/:username/info\n * api/user/username/[action].ts -> {prefix}/user/username/:action\n\n\n白名单\n\n默认 api/ 目录下所有文件都会当作 BFF 函数文件去解析，但以下文件不会被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\nRESTful API\n\nModern.js 的 BFF 函数需要遵循 RESTful API 标准来定义, 遵循 HTTP Method 规范，并且不允许自由定义参数。\n\nINFO\n\n假设函数允许自由定义参数，产出的路由必然由私有协议进行调用（原因是无法区分请求参数与请求体），而无法实现任意的 RESTful API。\n\n如果服务仅用于应用本身不存在问题，但它不标准的接口定义无法融入更大的体系。 在多个系统共同工作的情况下（例如 BFF\n低码搭建），会导致其他系统也需要遵循私有协议。\n\n\n函数具名导出\n\nModern.js BFF 函数的导出名决定了函数对应接口的 Method，如 get，post 等。\n\n例如，按照以下例子，可导出一个 GET 接口。\n\nexport const get = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n按照以下例子，则可导出一个 POST 接口\n\nexport const post = async () => {\n  return {\n    name: 'Modern.js',\n    desc: '现代 web 工程方案',\n  };\n};\n\n\n * 对应 HTTP Method，Modern.js 也支持了 9\n   种定义，即：GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTION、HEAD，即可以用这些 Method\n   作为函数导出的名字。\n\n * 名字是大小不敏感的，如果是 GET，写成 get、Get、GEt、GET，都可以准确识别。而默认导出，即 export default xxx\n   则会被映射为 Get。\n\n * 可以在一个文件中定义多个不同 Method 的函数，但如果定义多个相同 Method 的函数，则只有第一个会生效。\n\nINFO\n\n需要注意的是，定义的函数都应该是异步的，与函数调用时类型有关，后面会提到。\n\n\n函数参数规则\n\n如上所述，为了满足 RESTful API 的设计标准，因此 Modern.js 中 BFF 函数需要遵循一定的入参规则。\n\n函数参数分为两块，分别是请求路径中的动态部分和请求选项 RequestOption。\n\nDynamic Path\n\n动态路由会作为函数第一部分的入参，每个入参对应一段动态路由。例如以下示例，uid 会作为前两个参数传递到函数中：\n\nexport default async (level: number, id: number) => {\n  const userData = await queryUser(level, uid);\n  return userData;\n};\n\n\n在调用时直接传入动态参数：\n\n\n\n\nexport default () => {\n  const [name, setName] = useState('');\n\n  useEffect(() => {\n    getUser(6, 001).then(userData => setName(userData.name));\n  }, []);\n\n  return <div>{name}</div>;\n};\n\n\nRequestOption\n\nDynamic Path 之后的参数是包含 querystring、request body 的对象 RequestOption，这个字段用来定义 data 和\nquery 的类型。\n\n在不存在动态路由的普通函数中，可以从第一个入参中获取传入的 data 和 query，例如：\n\n\n\nexport async function post({\n  query,\n  data,\n}: RequestOption<Record<string, string>, Record<string, string>>) {\n  // do somethings\n}\n\n\n这里你也可以使用自定义类型：\n\n\n\ntype IQuery = {\n  // some types\n};\ntype IData = {\n  // some types\n};\n\nexport async function post({ query, data }: { query: IQuery; data: IData }) {\n  // do somethings\n}\n\n\n当函数文件使用动态路由规则时，动态路由会在 RequestOption 对象参数前。\n\nexport async function post(\n  sku: string,\n  id: string,\n  {\n    data,\n    query,\n  }: RequestOption<Record<string, string>, Record<string, string>>,\n) {\n  // do somethings\n}\n\n\n调用时也按照函数定义，传入对应的参数即可：\n\n\n\nexport default () => {\n  const addSku = () => {\n    post('0001' /* sku */, '1234' /* id */, {\n      query: {\n        /* ... */\n      },\n      data: {\n        /* ... */\n      },\n    });\n  };\n\n  return <div onClick={addSku}>添加 SKU</div>;\n};\n\n\n之前提到，定义的函数都应该是异步的，是因为在前端调用时会自动转换成 HTTP 接口调用，所以为了保持类型定义与实际调用体验统一，需要在定义 BFF\n函数时将它设置为异步。","frontmatter":{"sidebar_position":1,"title":"基础用法"}},{"id":511,"title":"BFF","routePath":"/guides/advanced-features/bff/","lang":"zh","toc":[],"domain":"","content":"\n\n在前后端分离概念出现后一段时间发展中，前端部分能够做的事越来越多，前端需要一些面向 UI 的数据接口，因此业界引入了 BFF（Backends for\nFrontends）这一概念。\n\n它主要为了解决的问题包括：\n\n * 根据自身业务需求，对更底层 API 的聚合、映射、裁剪、代理。\n * 对一些特定场景的数据进行缓存，提高性能，进而提升用户体验。\n * 根据已有接口快速开发新产品。\n * 与第三方系统对接，例如登陆鉴权。\n\nModern.js 官方支持了 BFF，并提供了一体化 BFF 方案来进一步强化 BFF 能力，主要包括以下能力：\n\n * 快速开发调试上线，在同一项目中运行、构建、部署 BFF 代码。\n * 极简的纯函数调用，在前端直接 import BFF 函数，调用时能自动转换成 HTTP 请求。\n * 无私有协议，遵循 RESTful API 规范，所有 BFF 接口都是标准化的。\n * 完善的 TypeScript 支持。\n * 满足用户使用偏好，支持多框架扩展写法。","frontmatter":{"title":"BFF"}},{"id":512,"title":"函数写法 & 框架写法","routePath":"/guides/advanced-features/bff/type","lang":"zh","toc":[{"id":"函数写法","text":"函数写法","depth":2},{"id":"框架写法","text":"框架写法","depth":2}],"domain":"","content":"\n\n运行时框架支持也是 BFF 中重要的一环。Modern.js 支持通过插件扩展 BFF\n的运行时框架，并提供了一系列内置插件，开发者可以直接使用对应框架的约定和生态。\n\n插件中兼容了这些框架大部分的规范，每一种框架都需要提供两类扩展写法 BFF 函数的方式，分别是函数写法和框架写法。\n\nNOTE\n\n当前 api/ 目录结构是否为框架写法由对应的插件决定，Modern.js 并不关心。\n\n\n函数写法\n\n当插件认为当前为函数写法时，必须支持在 api/_app.ts 中编写中间件，用来扩展 BFF 函数。\n\nModern.js 会收集 api/_app.ts 中的中间件，并传递给插件，由插件将中间件注入运行时，例如：\n\n\n\nexport default hook(({ addMiddleware }) => {\n  addMiddleware(myMiddleware);\n});\n\n\nNOTE\n\n不同插件的中间件的写法不一定相同，详情可见运行时框架。\n\n\n框架写法\n\n框架写法是一种使用框架结构来扩展 BFF 函数的方式。和函数写法相比，框架写法虽然能够利用更多框架的结构，在复杂场景下让整个 BFF Server\n更加清晰，但也相的更加复杂，需要关心更多框架层面的内容。\n\n框架写法中，所有的 BFF 函数都需要写在 api/lambda/ 目录下，并且无法使用钩子文件 _app.[tj]s。\n\n多数情况下，函数写法就能覆盖大多数 BFF 函数的定制需求。只有当你的项目服务端逻辑比较复杂，代码需要分层，或者需要使用更多框架的元素时，才需要使用框架写法。\n\nNOTE\n\n不同插件框架写法的目录结构不一定相同，详情可见运行时框架。","frontmatter":{"sidebar_position":2,"title":"函数写法 & 框架写法"}},{"id":513,"title":"代码分割","routePath":"/guides/advanced-features/code-split","lang":"zh","toc":[{"id":"import","text":"import","depth":2},{"id":"reactlazy","text":"React.lazy","depth":2},{"id":"loadable","text":"loadable","depth":2}],"domain":"","content":"\n\n代码分割是优化前端资源加载的一种常用手段，本文将介绍 Modern.js 支持的三种代码分割方式：\n\nINFO\n\n使用 Modern.js 约定式路由时，默认会根据路由组件做代码分割，包裹 Suspense 组件，无需自行进行代码分割。\n\n * import\n * React.lazy\n * loadable\n\n\nimport\n\n使用动态 import() 语法，import 接收的 JS 模块将作为一个新的打包入口被打包到单独的 JS 文件中。例如：\n\nimport('./math').then(math => {\n  console.log(math.add(16, 26));\n});\n\n\n./math 路径对应的 JS 模块会被打包到单独的 JS 文件中。\n\n\nReact.lazy\n\nReact 官方提供的组件代码分割的方式。\n\nCAUTION\n\nReact 17 及以下版本不支持 SSR，建议 React17 的 SSR 应用使用 loadable。\n\n\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <section>\n          <OtherComponent />\n          <AnotherComponent />\n        </section>\n      </Suspense>\n    </div>\n  );\n}\n\n\nReact.lazy 更多用法请见 React lazy。\n\n\nloadable\n\n使用 loadable API，示例如下：\n\n\n\nconst OtherComponent = loadable(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return <OtherComponent />;\n}\n\n\nloadable 更多用法请见 loadable API。\n\nINFO\n\nloadable 开箱即用的支持 SSR，但不支持和 Suspense 一起使用，如果是 CSR 项目可以使用 loadable.lazy","frontmatter":{"title":"代码分割","sidebar_position":6}},{"id":514,"title":"客户端兼容性","routePath":"/guides/advanced-features/compatibility","lang":"zh","toc":[{"id":"browserslist-配置","text":"Browserslist 配置","depth":2},{"id":"polyfill","text":"Polyfill","depth":2},{"id":"编译时-polyfill","text":"编译时 Polyfill","depth":3},{"id":"运行时按需-polyfill","text":"运行时按需 Polyfill","depth":3}],"domain":"","content":"\n\n\nBrowserslist 配置\n\nModern.js 支持在项目根目录 package.json 文件中的 browserslist 字段（或单独的 .browserslistrc\n文件）指定项目覆盖的目标浏览器范围。该值会被 @babel/preset-env 和 autoprefixer 用来确定需要转换的 JavaScript\n语法特性和需要添加的 CSS 浏览器前缀。\n\nModern.js 中默认值如下:\n\n['> 0.01%', 'not dead', 'not op_mini all'];\n\n\n可以在这里了解如何自定义浏览器范围。\n\n查看 Modern.js Builder 文档了解更多 Browserslist 相关内容。\n\nNOTE\n\nModern.js 支持配置 output.overrideBrowserslist 覆盖默认 browserslist 值。\n\n\nPolyfill\n\n\n编译时 Polyfill\n\nModern.js 在编译时默认通过 core-js 引入对应的 Polyfill 代码。\n\n默认情况下会根据项目 Browserslist 的设置情况引入所需的 Polyfill 代码， 这样基本不用再担心项目源码和第三方依赖的 Polyfill\n问题了，但是因为包含了一些没有用到的 Polyfill 代码，所以最终的包大小可能会有所增加。\n\nINFO\n\n对于明确第三方依赖不需要 Polyfill 的场景，可以设置 output.polyfill 为 usage, 这样 Babel\n编译时只会根据代码中使用到的语法引入 Polyfill 代码。\n\n\n运行时按需 Polyfill\n\nModern.js 中还提供了基于浏览器 UA 信息的运行时按需 Polyfill 方案，相比于 Babel 优势如下：\n\n * 不会插入到代码中，只根据访问页面的设备，按需下发 Polyfill 代码 ，减少整体代码体积。\n * 相同浏览器会公用一份 Polyfill 代码。因此，随着项目越来越多，基于 UA 的 Polyfill 代码下发速度会越来越快，综合速度超过常规方案。\n\n可以通过微生成器开启该功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「基于 UA 的 Polyfill」功能\n\n\n执行命令后，在 modern.config.ts 中注册 Polyfill 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., polyfillPlugin()],\n});\n\n\n配置 output.polyfill 为 ua 并且执行 pnpm run build && pnpm run serve 启动服务器后，访问页面可以看到\nHTML 产物中包含如下脚本:\n\n<script src=\"/__polyfill__\" crossorigin></script>\n\n\n在 Chrome 51 下访问页面可以看到 http://localhost:8080/__polyfill__ 返回内容如下:\n\n\n\n注意\n\n该功能只有在使用 Modern.js 内置的 Web Server 时才会生效。","frontmatter":{"title":"客户端兼容性","sidebar_position":5}},{"id":515,"title":"ESLint 规则集","routePath":"/guides/advanced-features/eslint","lang":"zh","toc":[{"id":"q-如何处理-lint","text":"Q: 如何处理 Lint","depth":2},{"id":"实时自动修复","text":"实时自动修复","depth":3},{"id":"批量自动修复","text":"批量自动修复","depth":3},{"id":"人工修复","text":"人工修复","depth":3},{"id":"声明例外情况","text":"声明例外情况","depth":3},{"id":"q-如何自定义-eslint-规则","text":"Q: 如何自定义 ESLint 规则","depth":2},{"id":"仓库根目录下-packagejson-里的-eslintconfig-字段","text":"仓库根目录下 package.json 里的 \"eslintConfig\" 字段","depth":3},{"id":"srceslintrcjs-文件","text":"src/.eslintrc.js 文件","depth":3},{"id":"packagejson-里的-eslintignore-字段","text":"package.json 里的 eslintIgnore 字段","depth":3},{"id":"q-如何升级-eslint-插件的版本","text":"Q: 如何升级 ESLint 插件的版本","depth":2},{"id":"q-webstorm-有时候会报-eslint-错误","text":"Q: WebStorm 有时候会报 ESLint 错误","depth":2}],"domain":"","content":"\n\n{/* 参考 实战教程 - 确认编程环境 确保本地 IDE 环境正常。 */}\n\nModern.js ESLint 规则集是全量的 ESLint 规则集合，包含 @modern-js （对于 Node.js 项目的 Lint 规则）和\n@modern-js-app（对于前端项目的 Lint 规则）。\n\n下面以具体问题介绍更多 ESLint 用法。\n\n\nQ: 如何处理 Lint\n\n\n实时自动修复\n\n多数问题会被 ESLint 规则的自动修复功能或 Prettier 的代码格式化功能（已被集成到 ESLint\n里）自动解决，开发者不需要关心问题的细节和解决方式。\n\nINFO\n\n主要在 IDE 保存文件的环节执行这种自动修复，少数漏网之鱼会在提交代码环节被自动修复。\n\n\n批量自动修复\n\n在少数情况下，比如旧项目迁移的时候，可以执行以下命令，批量修复和检查所有文件：\n\npnpm run lint:error\n\n\n\n人工修复\n\n对于无法自动修复的问题，可以在 IDE 里点击问题提示框里的规则链接，打开这条规则的文档，查看问题的解释和解决方案。\n\n\n声明例外情况\n\n目前阶段，有些规则并不能做到足够智能，多数情况下会有很大收益，在少数情况下也许不适用。但如果为了这些少数情况就把整个规则关掉或改掉，得不偿失。\n\n这种情况下可以用 eslint-disable 注释，对符合少数情况的代码块做标注，声明这里是一个例外，应该忽略。比如：\n\n/* eslint-disable filenames/match-exported */\n...\n/* eslint-enable filenames/match-exported */\n\n\nINFO\n\n在 VS Code 编辑器里输入 eslint，会自动出现关于 \"eslint-disable\" 的提示框，选择提示选项生成对应注释对。\n\n【Modern.js ESLint 规则集】要求 eslint-disable\n必须成对使用，必须明确表达要影响的范围，以及在这个范围内明确表达要禁用什么规则，目的是让例外有明确的、最小化的范围，避免 eslint-disable\n被滥用，导致不属于例外的代码也被禁用了规则。\n\n\nQ: 如何自定义 ESLint 规则\n\n\n仓库根目录下 package.json 里的 \"eslintConfig\" 字段\n\n这个地方是整个仓库的默认 ESLint 配置，是针对纯 Node.js 代码（只能在 Node.js 里运行）设计的。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置。该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n \"eslintConfig\": {\n    \"extends\": [\n      \"@modern-js\"\n    ],\n    \"rules\": {\n      \"filenames/match-exported\": \"off\"\n    }\n  },\n\n\n\n\nsrc/.eslintrc.js 文件\n\nModern.js 的应用工程、模块工程，源代码目录里都会默认有这个配置文件，是针对 Universal JS 代码设计的。\n\nINFO\n\nUniversal JS 代码是既能浏览器端也能在服务器端运行的代码。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置，该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n// eslint-disable-next-line import/no-commonjs\nmodule.exports = {\n  root: true,\n  extends: ['@modern-js-app'],\n  parserOptions: {\n    tsconfigRootDir: __dirname,\n    project: ['../tsconfig.json'],\n  },\n  rules: {\n    'filenames/match-exported': 'off',\n  },\n};\n\n\n如果有需要，还可以继续在不同的子目录里增加 .eslintrc.js 文件，针对这个子目录里的代码做特殊配置：\n\nmodule.exports = {\n  rules: {\n    'filenames/match-exported': 'off',\n  },\n};\n\n\n提示\n\n注意：没有必要使用 extends 字段，会自动继承父目录的配置。\n\n\npackage.json 里的 eslintIgnore 字段\n\n把包含 .js、.jsx、.ts、.tsx 文件、但不需要做代码检查和自动修复的目录，添加到 eslintIgnore 里，可以优化 ESLint\n检查的速度，比如：\n\n \"eslintIgnore\": [\n    \"node_modules\",\n    \"dist\",\n    \"output\"\n  ],\n\n\n\nQ: 如何升级 ESLint 插件的版本\n\n只要不是 Major 版本的变化（不符合 Semver 规则的 ^ 符号），就可以直接在业务项目的 package.json 里指定这个依赖，删除 Lock\n文件（或尝试手动删除 Lock 文件中这个包名的内容），执行 pnpm install 重新安装依赖并且生成新的 Lock 文件。\n\n做完这些操作之后，在业务项目的 ./node_modules 目录里，这个插件应该只存在一份，并且升级到了你指定的版本。\n\n提示\n\n * Major 版本就是主版本号。更多信息，请阅读【Semantic Versioning】。\n * 所有被 Modern.js 封装的上游项目（比如 ESLint、ESLint 插件、React Router 等），也都可以这样升级。\n * Modern.js 也会在每次发版中尽量及时的升级这些上游依赖。\n * Major 版本的升级需要由 Modern.js 来发版。\n\n\nQ: WebStorm 有时候会报 ESLint 错误\n\n由于 WebStorm 认为 ESLint 执行目录是根据 .eslintrc 文件来决定的。因此 src/.eslintrc 文件位置的放置会导致\ntsconfig.json 文件指定的位置（项目根目录下）在 src/ 目录下找不到。\n\n此时需要手动配置一下：\n\n--parser-options=project:../tsconfig.json\n\n\n","frontmatter":{"title":"ESLint 规则集","sidebar_position":8}},{"id":516,"title":"配置底层工具","routePath":"/guides/advanced-features/low-level","lang":"zh","toc":[{"id":"使用方式","text":"使用方式","depth":2},{"id":"底层配置明细","text":"底层配置明细","depth":2}],"domain":"","content":"\n\n\n使用方式\n\nModern.js 内部默认集成了 Babel、TypeScript、Webpack、PostCSS、Tailwind CSS\n等工具。通常情况下，默认配置能够满足大多业务开发需求。当有特殊需求时，可以通过底层配置来实现。\n\n以配置 Webpack 为例，只需要在 modern.config.ts 中添加 tools.webpack 即可：\n\nexport default defineConfig({\n  tools: {\n    webpack: config => {},\n  },\n});\n\n\ntools 命名空间下的配置都可以设置为 Object 或者 Function。\n\n值为 Object 时，会与内部默认配置进行合并，具体合并策略参考对应的配置选项文档（见下表）。\n\n值为 Function 时，第一个参数为内部的默认配置对象，可以直接修改这个对象不做返回，也可以返回一个新的对象或者合并后的对象作为最终结果。\n\n\n底层配置明细\n\n目前提供的底层配置如下表：\n\n| 底层工具 | 配置 | | ----------------- |\n--------------------------------------------------------------------- | |\nDevServer | tools.devServer | | Babel | tools.babel | | styled-components |\ntools.styledComponents | | PostCSS | tools.postcss | | Less | tools.less | |\nSass | tools.sass | | webpack | tools.webpack | | Minify CSS | tools.minifyCss |\n| terser | tools.terser | | Tailwind CSS | tools.tailwind | | Autoprefixer |\ntools.autoprefixer |","frontmatter":{"title":"配置底层工具","sidebar_position":11}},{"id":517,"title":"静态站点生成（SSG）","routePath":"/guides/advanced-features/ssg","lang":"zh","toc":[{"id":"在约定式路由中使用","text":"在约定式路由中使用","depth":3},{"id":"在自控式路由中使用","text":"在自控式路由中使用","depth":3}],"domain":"","content":"\n\nSSG（Static Site Generation）是一种基于数据与模板，在构建时渲染完整静态网页的技术解决方案。\n\n我们首先需要执行 pnpm run new 启用 SSG 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「SSG」功能\n\n\n执行命令后，在 modern.config.ts 中注册 SSG 插件：\n\n\n\nexport default defineConfig({\n  output: {\n    ssg: true,\n  },\n  plugins: [..., ssgPlugin()],\n});\n\n\nSSG 在约定式路由和自控式路由下的使用方式不同。\n\n\n在约定式路由中使用\n\n约定式路由中， Modern.js 根据入口下的文件结构生成路由，因此框架能够收集完整的路由信息。\n\n例如，以下是一个使用约定式路由的项目目录结构：\n\n.\n├── src\n│   └── routes\n│       ├── layout.tsx\n│       ├── page.tsx\n│       └── user\n│           ├── layout.tsx\n│           ├── page.tsx\n│           └── profile\n│               └── page.tsx\n\n\n上述文件目录将会生成以下三条路由：\n\n * /\n * /user\n * /user/profile\n\nNOTE\n\n如果还不了解约定式路由的规则，可以先查看路由。\n\n在 src/routes/page.tsx 中添加组件代码：\n\nexport default () => {\n  return <div>Index Page</div>;\n};\n\n\nSSG 也是在 Node.js 环境渲染页面，因此我们可以在开发阶段开启 SSR，提前在暴露代码问题，验证 SSG 渲染效果：\n\nexport default defineConfig({\n  server: {\n    ssr: process.env.NODE_ENV === 'development',\n  }\n}\n\n\n在项目根路径下执行 pnpm run dev 命令，查看 dist/ 目录，此时只生成一个 HTML 文件 main/index.html。\n\n在项目根路径下执行 pnpm run build 命令，构建完成后，查看 dist/ 目录，此时生成\nmain/index.html、main/user/index.html 和 main/user/profile/index.html 三个 HTML\n文件，内容分别对应上述三条路由。\n\n约定式路由中的每一条路由，都会生成一个单独的 HTML 文件。查看 main/index.html，可以发现包含 Index Page 的文本内容，这正是\nSSG 的效果。\n\n执行 pnpm run serve 启动项目后，访问页面，在浏览器我们工具的 Network 窗口，查看请求返回的文档，文档包含组件渲染后的完整页面内容。\n\n\n在自控式路由中使用\n\n自控式路由是通过组件代码自定义路由，需要应用运行起来才能获取准确的路由信息。因此，无法开箱即用的使用 SSG 功能。此时需要用户提前告知 Modern.js\n框架，哪些路由需要开启 SSG 功能。\n\n例如有以下代码，包含多条路由，设置 output.ssg 为 true 时，默认只会渲染入口路由即 /：\n\n\n\n\n\n\nconst Router = typeof window === 'undefined' ? StaticRouter : BrowserRouter;\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const pathname = context?.request?.pathname;\n  return (\n    <Router location={pathname}>\n      <Routes>\n        <Route index element={<div>index</div>} />\n        <Route path=\"about\" element={<div>about</div>} />\n      </Routes>\n    </Router>\n  );\n};\n\n\n如果我们希望同时开启 /about 的 SSG 功能，可以配置 output.ssg，告知 Modern.js 开启指定路由的 SSG 功能。\n\nexport default defineConfig({\n  output: {\n    ssg: {\n      routes: ['/', '/about'],\n    },\n  },\n});\n\n\n执行 pnpm run build 与 pnpm run serve 后，访问 http://localhost:8080/about，在 Preview\n视图中可以看到页面已经完成渲染。\n\n查看构建产物文件，可以看到 dist/ 目录中，新增了一个 main/about/index.html 文件。\n\nINFO\n\n以上仅介绍了单入口的情况，更多相关内容可以查看 API 文档。","frontmatter":{"title":"静态站点生成（SSG）","sidebar_position":4}},{"id":518,"title":"服务端渲染（SSR）","routePath":"/guides/advanced-features/ssr","lang":"zh","toc":[{"id":"ssr-时的数据获取","text":"SSR 时的数据获取","depth":2},{"id":"保持渲染一致","text":"保持渲染一致","depth":2},{"id":"关注内存泄漏","text":"关注内存泄漏","depth":2},{"id":"收敛服务端数据","text":"收敛服务端数据","depth":2},{"id":"serverless-pre-render","text":"Serverless Pre-render","depth":2},{"id":"treeshaking","text":"Treeshaking","depth":2},{"id":"环境变量区分","text":"环境变量区分","depth":3},{"id":"文件后缀区分","text":"文件后缀区分","depth":3},{"id":"独立文件","text":"独立文件","depth":3},{"id":"接口请求","text":"接口请求","depth":2},{"id":"流式渲染","text":"流式渲染","depth":2}],"domain":"","content":"\n\n在 Modern.js 中，SSR 也是开箱即用的。开发者无需为 SSR 编写复杂的服务端逻辑，也无需关心 SSR\n的运维，或是创建单独的服务。Modern.js 拥有完备的 SSR 降级策略，保证页面能够安全运行。\n\n启用 SSR 非常简单，只需要设置 server.ssr 为 true 即可：\n\n{\n  \"server\": {\n    \"ssr\": true\n  }\n}\n\n\n\nSSR 时的数据获取\n\nModern.js 中提供了 Data Loader，方便开发者在 SSR、CSR 下同构的获取数据。每个路由模块，如 layout.tsx 和\npage.tsx 都可以定义自己的 Data Loader：\n\nexport const loader = () => {\n  return {\n    message: 'Hello World',\n  };\n};\n\n\n在组件中可以通过 Hooks API 的方式获取 loader 函数返回的数据：\n\nexport default () => {\n  const data = useLoaderData();\n  return <div>{data.message}</div>;\n};\n\n\nModern.js 打破传统的 SSR 开发模式，提供了用户无感的 SSR 开发体验。并且提供了优雅的降级处理，一旦 SSR\n请求失败，会自动降级在浏览器端重新发起请求。\n\n不过，开发者仍然需要关注数据的兜底处理，例如 null 值或不符合预期的数据返回。避免在 SSR 时产生 React 渲染错误或是返回凌乱的渲染结果。\n\n补充信息\n\n使用 Data Loader 时，数据获取发生在渲染前，Modern.js 也仍然支持在组件渲染时获取数据。更多相关内容可以查看数据获取。\n\n\n保持渲染一致\n\n有些业务中，通常需要根据当前的运行容器环境特征做不同的 UI 展示，例如 UA 信息。如果处理不够仔细，此时很有可能出现不符合预期的渲染结果。\n\n这里通过一个例子，演示当 SSR 与 CSR 渲染不一致时出现的问题，在组件中添加以下代码：\n\n{\n  typeof window !== 'undefined' ? <div>browser content</div> : null;\n}\n\n\n启动应用后，访问页面，会发现浏览器控制台抛出警告信息：\n\nWarning: Expected server HTML to contain a matching <div> in <div>.\n\n\n这是 React 在客户端执行 hydrate 逻辑时，发现渲染结果与 SSR 渲染结果不一致造成的。虽然页面表现正常，但在复杂应用中，很有可能因此出现 DOM\n层级混乱、样式混乱等问题。\n\nINFO\n\n关于 hydrate (注水)逻辑请参考这里。\n\n应用需要保持 SSR 与 CSR 渲染结果的一致性，如果存在不一致的情况，说明这部分内容无需在 SSR 中进行渲染。Modern.js 为这类在 SSR\n中不需要渲染的内容提供 <NoSSR> 工具组件：\n\n\n\n在不需要进行 SSR 的元素外部，用 NoSSR 组件包裹：\n\n<NoSSR>\n  <div>client content</div>\n</NoSSR>\n\n\n修改代码后，刷新页发现之前的 Waring 消失。打开浏览器开发者工具的 Network 窗口，查看返回的 HTML 文档是不包含 NoSSR\n组件包裹的内容的。\n\n补充信息\n\nuseRuntimeContext 可以获取完整的请求信息，可以利用它保证 SSR 与 CSR 的渲染结果一致。\n\n\n关注内存泄漏\n\n警告\n\n在 SSR 场景下，开发者需要特别关注内存泄露问题，即使是微小的内存泄露，在大量的访问后也会对服务造成影响。\n\nSSR\n时，浏览器的每次请求，都会触发服务端重新执行一次组件渲染逻辑。所以，需要避免在全局定义任何可能不断增长的数据结构，或在全局进行事件订阅，或创建不会被销毁的流。\n\n例如以下代码，使用 redux-observable 时，习惯了 CSR 的开发者通常会在组件中这样编码：\n\n/* 代码仅作为示例，不可运行 */\n\n\nconst epicMiddleware = createEpicMiddleware();\nconst rootEpic = combineEpics();\n\nexport default function Test() {\n  epicMiddleware.run(rootEpic);\n  return <div>Hello Modern.js</div>;\n}\n\n\n在组件外层创建 Middleware 实例 epicMiddleware，并在组件内部调用 epicMiddleware.run。\n\n在浏览器端，这段代码不会造成任何问题，但是在 SSR 时，Middleware 实例会一直无法被销毁。每次渲染组件，调用\nepicMiddleware.run(rootEpic) 时，都会在内部添加新的事件绑定，导致整个对象不断变大，最终对应用性能造成影响。\n\nCSR 中这类问题不易被发觉，因此从 CSR 切换到 SSR 时，如果不确定应用是否存在这类隐患，可以对应用进行压测。\n\n\n收敛服务端数据\n\n为了保持 SSR 阶段请求的数据，可以在浏览器端直接使用，Modern.js 会将渲染过程中收集的数据与状态注入到 HTML 内。但是，CSR\n应用常常存在接口数据量大、组件状态未收敛的情况，这时如果直接使用 SSR，渲染得到的 HTML 体积可能会存在过大的问题。此时，SSR\n不仅无法为应用带来用户体验上的提升，反而可能起到相反的作用。\n\n因此，使用 SSR 时，开发者需要为应用做合理的瘦身：\n\n 1. 关注首屏，SSR 中可以只请求首屏需要的数据，并在浏览器端渲染剩余的部分。\n 2. 将与渲染无关的数据，从接口返回数据中剔除。\n\n\nServerless Pre-render\n\nModern.js 提供 Serverless Pre-rendering (SPR) 这一特性来提升 SSR 性能。\n\nSPR 利用预渲染与缓存技术，为 SSR 页面提供静态 Web 的响应性能。它让 SSR 应用拥有静态 Web\n页面的响应速度与稳定性，同时还能保持数据的动态更新。\n\n在 Modern.js 中使用 SPR 非常简单，只需要在组件中新增 PreRender 组件，该组件所在的页面就会自动开启 SPR。\n\n这里模拟一个使用 useLoaderData API 的组件，Data Loader 中的请求需要消耗 2s 时间。\n\n\n\nexport const loader = async () => {\n  await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(null);\n    }, 2000);\n  });\n\n  return {\n    message: 'Hello Modern.js',\n  };\n};\n\nexport default () => {\n  const data = useLoaderData();\n  return <div>{data?.message}</div>;\n};\n\n\n执行 dev 命令后，打开页面，可以明显的察觉到页面需要等到 2s 后才返回。\n\n接下来使用 PreRender 组件来进行优化，该组件可以直接从 @modern-js/runtime/ssr 中导出：\n\n\n\n在路由组件内使用 PreRender 组件，并设置参数 interval，用于表示该次渲染结果的过期时间为 5s：\n\n<PreRender interval={5} />\n\n\n修改后，执行 pnpm run build && pnpm run serve 启动应用，并打开页面。\n\n首次打开时，和之前的渲染并没有什么不同，同样存在 2s 延迟。点击刷新，页面瞬间打开，但此时，页面数据并没有因为刷新发生变化，这是因为缓存还没有过期。\n\n等待 5s，重新刷新页面，页面的数据仍然没有变化。再一次刷新页面数据发生变化，但是页面仍然几乎是瞬间响应的。 这是因为在之前的请求时，SPR\n已经在后台异步获取了新的渲染结果，本次请求到的页面是已经缓存在服务器中的版本。\n\n可以想象，当 interval 设置为 1 时，用户可以在感知到实时数据的同时，拥有静态页面的响应体验。\n\n补充信息\n\nPreRender 的详细使用可以参考这里。\n\n\nTreeshaking\n\n开启 SSR 时，Modern.js 会用相同的入口，构建出 SSR Bundle 和 CSR Bundle 两份产物。因此，在 SSR Bundle 中存在\nWeb API，或是在 CSR Bundle 中存在 Node API 时，都可能导致运行出错。\n\n在组件中引入 Web API，通常情况下是要做一些全局监听，或是获取浏览器相关的数据，例如：\n\ndocument.addEventListener('load', () => {\n  console.log('document load');\n});\nconst App = () => {\n  return <div>Hello World</div>;\n};\nexport default App;\n\n\n在组件文件中引入 Node API，通常情况下是因为使用了 Data Loader，例如：\n\n\nexport const loader = () => {\n  const file = fse.readFileSync('./myfile');\n  return {\n    ...\n  };\n};\n\n\n\n环境变量区分\n\n对于第一种情况，我们可以直接使用 Modern.js 内置的环境变量 MODERN_TARGET 进行判断，在构建时删除无用代码：\n\nif (process.env.MODERN_TARGET === 'browser') {\n  document.addEventListener('load', () => {\n    console.log('document load');\n  });\n}\n\n\nNOTE\n\n更多内容可以查看环境变量。\n\n\n文件后缀区分\n\n但例如第二种情况，Treeshaking 的方式并不能保证代码被完全分离。Modern.js 也支持通过 .node. 后缀的文件来区分 SSR Bundle\n和 CSR Bundle 产物的打包文件。\n\n例如在代码中引入了 fs-extra，这时候直接引用到组件中，会造成 CSR 加载报错。可以创建同名的 .ts 和 .node.ts 文件做一层代理：\n\nexport const readFileSync: any = () => {};\n\n\nexport { readFileSync } from 'fs-extra';\n\n\n在文件中直接引入 ./compat，此时 SSR 环境下会优先使用 .node.ts 后缀的文件，CSR 环境下会使用 .ts 后缀的文件。\n\n\n\nexport const loader = () => {\n  const file = readFileSync('./myfile');\n  return {\n    ...\n  };\n};\n\n\n\n独立文件\n\n上述两种方式，都会为开发者带来一些心智负担。Modern.js 基于嵌套路由开发设计了更简单的方案来分离 CSR 和 SSR 的代码。\n\n\n接口请求\n\n在 SSR 中发起接口请求时，开发者有时自己封装了同构的请求工具。部分接口需要传递用户 Cookie，开发者可以通过 useRuntimeContext API\n获取到请求头来实现。\n\n需要注意的是，此时获取到的是 HTML\n请求的请求头，不一定适用于接口请求，因此千万不能透传所有请求头。并且，一些后端接口，或是通用网关，会根据请求头中的信息做校验，全量透传容易出现各种难以排查的问题\n，推荐按需透传。\n\n如果实在需要透传所有请求头，请务必过滤 host 字段。\n\n\n流式渲染\n\nModern.js 支持了 React 18 的流式渲染，可以通过如下配置修改默认的渲染模式：\n\n{\n  \"server\": {\n    \"ssr\": {\n      \"mode\": \"stream\"\n    }\n  }\n}\n\n\nNOTE\n\n目前 Modern.js 内置的数据获取方式还未支持流式渲染，如迫切需要开发者可以按照 React Stream SSR 的 Demo 自建。","frontmatter":{"title":"服务端渲染（SSR）","sidebar_position":3}},{"id":519,"title":"测试","routePath":"/guides/advanced-features/testing","lang":"zh","toc":[{"id":"测试文件","text":"测试文件","depth":2},{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"transform","text":"transform","depth":2}],"domain":"","content":"\n\nModern.js 默认继承了 Jest 的测试能力。\n\n我们首先需要执行 pnpm run new 启用「单元测试 / 集成测试」功能：\n\n? 请选择你想要的操作： 启用可选功能\n? 启用可选功能： 启用「单元测试 / 集成测试」功能\n\n\n执行上述命令后，package.json 中将会自动生成 \"test\": \"modern test\" 命令。\n\n在 modern.config.ts 中注册 Test 插件：\n\n\n\nexport default defineConfig({\n  ...,\n  plugins: [..., testPlugin()],\n});\n\n\n\n测试文件\n\nModern.js 默认识别的测试文件路径为：<rootDir>/src/**/*.test.[jt]s?(x) 和\n<rootDir>/tests/**/*.test.[jt]s?(x)。\n\n如果你需要自定义 test 目录，可通过 tools.jest 进行配置。\n\n\n使用姿势\n\nModern.js test 支持使用 testing-library 相关包 API，可直接通过 @modern-js/runtime/testing\n进行导入:\n\n\n\n其他 Modern.js 支持的 testing API 可参考这里。\n\n\ntransform\n\nModern.js 测试默认使用 babel-jest 进行源码编译，如果你需要使用 ts-jest，可以通过 testing.transform 进行配置。","frontmatter":{"sidebar_position":10}},{"id":520,"title":"自定义 Web Server","routePath":"/guides/advanced-features/web-server","lang":"zh","toc":[{"id":"创建自定义-web-server","text":"创建自定义 Web Server","depth":2},{"id":"使用-api-扩展-web-server","text":"使用 API 扩展 Web Server","depth":2},{"id":"hook","text":"Hook","depth":3},{"id":"middleware","text":"Middleware","depth":3},{"id":"完全自定义的-web-server","text":"完全自定义的 Web Server","depth":2}],"domain":"","content":"\n\nModern.js\n作为以客户端为中心的开发框架，对服务端的定制能力较弱。而在有些开发场景下，需要定制特殊的服务端逻辑，例如用户鉴权、请求预处理、添加页面渲染骨架等。\n\n因此 Modern.js 提供了一种功能，让项目可以在给定的范围内扩展 Modern.js 内置的 Web Server，来实现相应的需求。\n\n\n创建自定义 Web Server\n\n在项目根目录执行 pnpm run new 命令，按照如下选择，开启「自定义 Web Serve」功能：\n\n? 请选择你想要的操作 创建工程元素\n? 创建工程元素 新建「自定义 Web Server」源码目录\n\n\n执行命令后，在 modern.config.ts 中注册 Server 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., serverPlugin()],\n});\n\n\n项目目录下会新建 server/index.ts 文件，自定义逻辑在这个文件中编写。\n\n\n使用 API 扩展 Web Server\n\nModern.js 提供了 Hook 与 Middleware 两类 API 来扩展 Web Server。\n\n\nHook\n\nHook 可以控制 Web Server 对请求处理的内置逻辑，非 BFF 请求会经过 Hook 的处理。\n\nHook 不可以使用运行时框架拓展。\n\n详细 API 可以查看 Hook。\n\n\nMiddleware\n\nMiddleware 可以为 Web Server 添加前置中间件，只有 SSR 请求会经过 Middleware 的处理。\n\nMiddleware 可以使用运行时框架拓展。\n\n详细 API 可以查看 Hook。\n\n\n完全自定义的 Web Server\n\nNOTE\n\n敬请期待","frontmatter":{"title":"自定义 Web Server","sidebar_position":2}},{"id":521,"title":"别名","routePath":"/guides/basic-features/alias","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 允许在 JS 和 CSS 中使用别名导入自定义目录下的模块，并内置了以下别名:\n\n{\n  '@': '<appDirectory>/src',\n  '@shared': '<appDirectory>/shared',\n}\n\n\nINFO\n\n在开启可选功能时，生成器也会动态的添加内置别名，例如启用 BFF 时默认会添加 @api 别名。\n\n例如从 src/App.tsx 文件中导入 src/common 目录下的模块：\n\n.\n├── common\n│   ├── styles\n│   │   └── base.css\n│   └── utils\n│       └── index.ts\n├── App.tsx\n\n\nsrc/App.tsx 中写法如下：\n\n\nimport '@/src/common/styles/base.css';\n\n\nModern.js 也提供了自定义别名的方式，以添加 @common 别名为例，对于 TypeScript 项目，只需要在项目根目录 tsconfig.json\n下配置 compilerOptions.paths 如下：\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"@/common/*\": [\"./src/common/*\"]\n    }\n  }\n}\n\n\nJavaScript 项目可以在 modern.config.js 中配置 source.alias：\n\nexport default defineConfig({\n  source: {\n    alias: {\n      '@common': './src/common',\n    },\n  },\n});\n\n\n对于别名配置的具体用法，请参考 source.alias 文档。","frontmatter":{"title":"别名","sidebar_position":8}},{"id":522,"title":"数据获取","routePath":"/guides/basic-features/data-fetch","lang":"zh","toc":[{"id":"data-loader推荐","text":"Data Loader(推荐)","depth":2},{"id":"基础示例","text":"基础示例","depth":3},{"id":"loader-函数","text":"loader 函数","depth":3},{"id":"params","text":"Params","depth":4},{"id":"request","text":"request","depth":4},{"id":"返回值","text":"返回值","depth":4},{"id":"请求-api","text":"请求 API","depth":3},{"id":"错误处理","text":"错误处理","depth":3},{"id":"获取上层组件的数据","text":"获取上层组件的数据","depth":3},{"id":"wiploading-ui","text":"(WIP)Loading UI","depth":3},{"id":"错误用法","text":"错误用法","depth":3},{"id":"useloader旧版","text":"useLoader（旧版）","depth":2}],"domain":"","content":"\n\nModern.js 中提供了开箱即用的数据获取能力，开发者可以通过这些 API，在 CSR 和 SSR 环境同构的进行开发。\n\n需要注意的是，这些 API 并不帮助应用发起请求，而是帮助开发者更好地管理数据，提升项目的性能。\n\n\nData Loader(推荐)\n\nModern.js 推荐使用约定式路由做路由的管理，通过 Modern.js 的约定式（嵌套）路由，每个路由组件(layout.ts 或\npage.ts)可以有一个同名的 loader 文件，该 loader 文件需要导出一个函数，函数会在组件渲染之前执行，为路由组件提供数据。\n\nINFO\n\nModern.js v1 支持通过 useLoader 获取数据，这已经不是我们推荐的用法，除迁移过程外，不推荐两者混用。\n\n\n基础示例\n\n路由组件如 layout.ts 或 page.ts，可以定义同名的 loader 文件，loader\n文件中导出一个函数，该函数提供组件所需的数据，然后在路由组件中通过 useLoaderData 函数获取数据，如下面示例：\n\n.\n└── routes\n    ├── layout.tsx\n    └── user\n        ├── layout.tsx\n        ├── layout.loader.ts\n        ├── page.tsx\n        └── page.loader.ts\n\n\n在文件中定义以下代码：\n\n\n\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return <div>{profileData}</div>;\n}\n\n\nexport type ProfileData = {\n  /*  some types */\n};\n\nexport default async (): Promise<ProfileData> => {\n  const res = await fetch('https://api/user/profile');\n  return await res.json();\n};\n\n\nCAUTION\n\n这里路由组件和 loader 文件共享类型，要使用 import type 语法。\n\n在 CSR 环境下，loader 函数会在客户端执行，loader 函数内可以使用浏览器的 API（但通常不需要，也不推荐）。\n\n在 SSR 环境下，不管是首屏，还是在客户端的导航，loader 函数只会在服务端执行，这里可以调用任意的 Node.js\nAPI，同时这里使用的任何依赖和代码都不会包含在客户端的 bundle 中。\n\nINFO\n\n在以后的版本中，Modern.js 可能会支持在 CSR 环境下，loader 函数也在服务端运行，以提高性能和安全性，所以这里建议尽可能地保证 loader\n的纯粹，只做数据获取的场景。\n\n当在客户端导航时，基于 Modern.js 的约定式路由，所有的 loader 函数会并行执行（请求），即当访问 /user/profile 时，/user 和\n/user/profile 下的 loader 函数都会并行执行（请求），以提高客户端的性能。\n\n\nloader 函数\n\nloader 函数有两个入参：\n\nParams\n\n当路由文件通过 [] 时，会作为动态路由，动态路由片段会作为参数传入 loader 函数：\n\n// routes/user/[id]/page.loader.ts\n\n\nexport default async ({ params }: LoaderArgs) => {\n  const { id } = params;\n  const res = await fetch(`https://api/user/${id}`);\n  return res.json();\n};\n\n\n当访问 /user/123 时，loader 函数的参数为 { params: { id: '123' } }。\n\nrequest\n\nrequest 是一个 Fetch Request 实例。\n\n一个常见的使用场景是通过 request 获取查询参数：\n\n// routes/user/[id]/page.loader.ts\n\n\nexport default async ({ request }: LoaderArgs) => {\n  const url = new URL(request.url);\n  const userId = url.searchParams.get('id');\n  return queryUser(userId);\n};\n\n\n返回值\n\nloader 函数的返回值可以是任何可序列化的内容，也可以是一个 Fetch Response 实例：\n\nconst loader = async (): Promise<ProfileData> => {\n  return {\n    message: 'hello world',\n  };\n};\nexport default loader;\n\n\n默认情况下，loader 返回的响应 Content-type 是 application/json，status 为 200，你可以通过自定义\nResponse 来设置：\n\nconst loader = async (): Promise<ProfileData> => {\n  const data = { message: 'hello world' };\n  return new Response(JSON.stringify(data), {\n    status: 200,\n    headers: {\n      'Content-Type': 'application/json; utf-8',\n    },\n  });\n};\n\n\n\n请求 API\n\nModern.js 对 fetch API 做了 polyfill, 用于发起请求，该 API 与浏览器的 fetch API 一致，但是在服务端也能使用该\nAPI 发起请求，这意味着不管是 CSR 还是 SSR，都可以使用统一的 fetch API 进行数据获取：\n\nasync function loader() {\n  const res = await fetch('https://api/user/profile');\n}\n\n\n\n错误处理\n\n在 loader 函数中，可以通过 throw error 或者 throw response 的方式处理错误，当 loader\n函数中有错误被抛出时，Modern.js 会停止执行当前 loader 中的代码，并将前端 UI 切换到定义的 ErrorBoundary 组件：\n\n// routes/user/profile/page.loader.ts\nexport default async function loader() {\n  const res = await fetch('https://api/user/profile');\n  if (!res.ok) {\n    throw res;\n  }\n  return res.json();\n}\n\n// routes/user/profile/error.tsx\n\nconst ErrorBoundary = () => {\n  const error = useRouteError() as Response;\n  return (\n    <div>\n      <h1>{error.status}</h1>\n      <h2>{error.statusText}</h2>\n    </div>\n  );\n};\n\nexport default ErrorBoundary;\n\n\n\n获取上层组件的数据\n\n很多场景下，子组件需要获取到祖先组件 loader 中的数据，你可以通过 useRouteLoaderData 方便地获取到祖先组件的数据：\n\n// routes/user/profile/page.tsx\n\n\nexport default function UserLayout() {\n  // 获取 routes/user/layout.loader.ts 中 loader 返回的数据\n  const data = useRouteLoaderData('user/layout');\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <h2>{data.age}</h2>\n    </div>\n  );\n}\n\n\nuserRouteLoaderData 接受一个参数 routeId，在使用约定式路由时，Modern.js 会为你自动生成routeId，routeId\n的值是对应组件相对于 src/routes 的路径，如上面的例子中，子组件想要获取 routes/user/layout.tsx 中 loader\n返回的数据，routeId 的值就是 user/layout。\n\n在多 entry（MPA） 场景下，routeId 的值需要加上对应 entry 的 name，entry name 非指定情况下一般是 entry\n目录名，如以下目录结构：\n\n.\n└── src\n    ├── entry1\n    │     └── routes\n    │           └── layout.tsx\n    └── entry2\n          └── routes\n                └── layout.tsx\n\n\n如果想获取 entry1/routes/layout.tsx 中 loader 返回的数据，routeId 的值就是 entry1_layout。\n\n\n(WIP)Loading UI\n\nINFO\n\n此功能目前是实验性质，后续 API 可能有调整。 目前仅支持 CSR，敬请期待 Streaming SSR。\n\n在 user/layout.tsx 中添加以下代码：\n\nimport {\n  Await,\n  defer,\n  useLoaderData,\n  Outlet\n} from '@modern-js/runtime/router';\n\nexport const loader = () => {\n  return defer({\n    // fetchUserInfo 是一个异步函数，返回用户信息\n    userInfo: fetchUserInfo(),\n  })\n}\n\nexport default function UserLayout() {\n  const { userInfo } = useLoaderData() as {userInfo: Promise<UserInfo>};\n  return (\n    <div>\n      <React.Suspense\n        fallback={<p>Loading...</p>}\n      >\n        <Await resolve={userInfo} children={userInfo => (\n          <div>\n            <span>{userInfo.name}</span>\n            <span>{userInfo.age}</span>\n            <Outlet>\n          </div>\n        )}>\n        </Await>\n      </React.Suspense>\n    </div>\n  );\n}\n\n\nINFO\n\nAwait 组件的具体用法请查看 Await\n\ndefer 的具体用法请查看 defer\n\n{/* TODO 缓存相关 */}\n\n\n错误用法\n\n 1. loader 中只能返回可序列化的数据，在 SSR 环境下，loader 函数的返回值会被序列化为 JSON\n    字符串，然后在客户端被反序列化为对象。因此，loader 函数中不能返回不可序列化的数据（如函数）。\n\nWARNING\n\n目前 CSR 下没有这个限制，但我们强烈推荐你遵循该限制，且未来我们可能在 CSR 下也加上该限制。\n\n// This won't work!\nexport default () => {\n  return {\n    user: {},\n    method: () => {},\n  };\n};\n\n\n 2. Modern.js 会帮你调用 loader 函数，你不应该自己调用 loader 函数：\n\n// This won't work!\nexport default async () => {\n  const res = fetch('https://api/user/profile');\n  return res.json();\n};\n\n\nexport default function RouteComp() {\n  const data = loader();\n}\n\n\n 3. 不能从路由组件中引入 loader 文件，也不能从 loader 文件引入路由组件中的变量，如果需要共享类型的话，应该使用 import type\n\n// Not allowed\n// routes/layout.tsx\n\n // should use \"import type\" instead\n\nexport const fetch = wrapFetch(fetch);\n\nexport default function UserPage() {\n  const profileData = useLoaderData() as ProfileData;\n  return <div>{profileData}</div>;\n}\n\n// routes/layout.loader.ts\n // should not be imported from the routing component\nexport type ProfileData = {\n  /*  some types */\n};\n\nexport default async (): Promise<ProfileData> => {\n  const res = await fetch('https://api/user/profile');\n  return await res.json();\n};\n\n\n 4. 在服务端运行时，loader 函数会被打包为一个统一的 bundle，所以我们不推荐服务端的代码使用 __filename 和 __dirname。\n\n\nuseLoader（旧版）\n\nuseLoader 是 Modern.js 老版本中的 API。该 API 是一个 React Hook，专门提供给 SSR\n应用使用，让开发者能同构的在组件中获取数据。\n\nTIP\n\nCSR 的项目没有必要使用 useLoader 获取数据。\n\n以下是一个最简单的例子：\n\n\n\nexport default () => {\n  const { data } = useLoader(async () => {\n    console.log('fetch in useLoader');\n\n    // 这里没有发送真实的请求，只是返回了一个写死的数据。\n    // 真实项目中，应该返回从远端获取的数据。\n    return {\n      name: 'Modern.js',\n    };\n  });\n\n  return <div>Hello, {data?.name}</div>;\n};\n\n\n上述代码启动后，访问页面。可以看到在终端输出了日志，而在浏览器终端却没有打印日志。\n\n这是因为 Modern.js 在服务端渲染时，在会收集 useLoader 返回的数据，并将数据注入到响应的 HTML 中。如果 SSR 渲染成功，在 HTML\n中可以看到如下代码片段：\n\n<script>\n  window._SSR_DATA = {};\n</script>\n\n\n在这全局变量中，记录了每一份数据，而在浏览器端渲染的过程中，会优先使用这份数据。如果数据不存在，则会重新执行 useLoader 函数。\n\nNOTE\n\n在构建阶段，Modern.js 会自动为每个 useLoader 生成一个 Loader ID，并注入到 SSR 和 CSR 的 JS Bundle\n中，用来关联 Loader 和数据。\n\n相比于 Next.js 中的 getServerSideProps，在渲染前预先获取数据。使用 useLoader，可以在组件中获取局部 UI\n所需要的数据，而不用将数据层层传递。同样，也不会因为不同路由需要不同数据请求，而在最外层的数据获取函数中添加冗余的逻辑。当然 useLoader\n也存在一些问题，例如服务端代码 Treeshaking 困难，服务端需要多一次预渲染等。\n\nModern.js 在新版本中，设计了全新的 Loader 方案。新方案解决了这些问题，并能够配合嵌套路由，对页面性能做优化。\n\nNOTE\n\n详细 API 可以查看 useLoader。","frontmatter":{"title":"数据获取","sidebar_position":3}},{"id":523,"title":"环境变量","routePath":"/guides/basic-features/env-vars","lang":"zh","toc":[{"id":"内置的环境变量","text":"内置的环境变量","depth":2},{"id":"node_env","text":"NODE_ENV","depth":3},{"id":"modern_env","text":"MODERN_ENV","depth":3},{"id":"modern_target","text":"MODERN_TARGET","depth":3},{"id":"自定义环境变量","text":"自定义环境变量","depth":2},{"id":"通过-shell-指定","text":"通过 shell 指定","depth":3},{"id":"通过-env-文件指定","text":"通过 .env 文件指定","depth":3},{"id":"使用环境变量","text":"使用环境变量","depth":2},{"id":"约定命名","text":"约定命名","depth":3},{"id":"任意命名","text":"任意命名","depth":3},{"id":"使用全局替换","text":"使用全局替换","depth":2}],"domain":"","content":"\n\nModern.js 提供了对环境变量的支持，包含内置的环境变量和自定义的环境变量。\n\n\n内置的环境变量\n\n\nNODE_ENV\n\n表示当前的执行环境，是只读的的环境变量，其值在不同的执行命令下具有不同的值：\n\n * production：执行 modern build、modern serve 命令时的默认值。\n * test：执行 modern test 命令时的默认值。\n * development：执行 modern dev 命令时的默认值，同时也是其他所有情况下的默认值。\n\n\nMODERN_ENV\n\n手动设置当前的执行环境。除了上述 NODE_ENV 对应的值之外，这里支持自定义环境名称，例如 staging、boe 等。\n\nTIP\n\nMODERN_ENV 的优先级高于 NODE_ENV。\n\n\nMODERN_TARGET\n\n使用 @modern-js/runtime 时会自动注入，用于区分 SSR 与 CSR 环境。开发者可以自行在代码中判断，构建时会默认移除 dead code。\n\nfunction App() {\n  if (process.env.MODERN_TARGET === 'browser') {\n    console.log(window.innerHeight);\n  }\n}\n\n\n开发环境打包后，可以看到 SSR 产物和 CSR 产物如下：\n\nfunction App() {\n  if (false) {\n  }\n}\n\n\nfunction App() {\n  if (true) {\n    console.log(window.innerHeight);\n  }\n}\n\n\nNOTE\n\n在生产环境，会将 dead code 移除，例如上述 if 语句。\n\n这种方式可以针对不同客户端提供不同的产物，保证代码体积最小化。也能方便处理不同环境下，代码中的一些副作用，\n\n\n自定义环境变量\n\n环境变量支持通过 shell 和 .env 文件两种方式指定。\n\n\n通过 shell 指定\n\n在命令前添加自定义环境变量：\n\nREACT_APP_FOO=123 BAR=456 pnpm run dev\n\n\n\n通过 .env 文件指定\n\n在项目根目录创建 .env 文件，并添加自定义环境变量，这些环境变量会默认添加到启动项目的 Node.js 进程中，例如：\n\nREACT_APP_FOO=123\nBAR=456\n\n\n.env 文件遵循以下规则加载规则：\n\n * .env：默认加载。\n * .env.{ MODERN_ENV | NODE_ENV }：针对具体环境设置环境变量，会覆盖 .env 中的设置。\n\n当需要根据环境使用不同的配置时，可以把环境变量定义到对应环境名称的 .env 文件中，并在启动项目时手动设置执行环境。例如使用以下命令启动项目时，将会加载\n.env 和 .env.staging:\n\nMODERN_ENV=staging pnpm run dev\n\n\n\n使用环境变量\n\n\n约定命名\n\n在前端代码中可以直接使用 NODE_ENV 环境变量。另外，以 MODERN_ 开头的自定义环境变量，也可以在代码中直接使用。\n\n例如:\n\nif (process.env.NODE_ENV === 'development') {\n  // do something\n}\n\n\n执行 pnpm run dev 命令之后可以看到如下构建产物：\n\nif (true) {\n  // do something\n}\n\n\n同样在自定义的 HTML 模板中，也可以直接使用这类环境变量。如 config/html/head.html:\n\n<meta name=\"test\" content=\"<process.env.NODE_ENV>\">\n\n\n\n任意命名\n\n如果需要在代码中使用任意名称的环境变量，可以在 source.globalVars 配置指定, 例如：\n\nexport default defineConfig({\n  source: {\n    globalVars: {\n      'process.env.VERSION': process.env.VERSION,\n    }.\n  },\n});\n\n\n此时，在代码中的 process.env.VERSION，将会被替换为环境变量中 VERSION 的值。\n\nNOTE\n\nsource.globalVars 也支持将其他表达式或字符串替换为指定的值，不仅限于环境变量。\n\n\n使用全局替换\n\n除了环境变量，Modern.js 也支持将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n例如将代码中的 TWO 转换为 1 + 1 的表达式：\n\nexport default {\n  source: {\n    define: {\n      TWO: '1 + 1',\n    },\n  },\n};\n\n\nconst foo = TWO;\n\n// ⬇️ Turn into being...\nconst foo = 1 + 1;\n\n\n在大多数情况下，source.globalVars 已经能满足替换变量的需求。但 source.globalVars 传入的值都会默认被 JSON\n序列化，因此无法做出像上面例子中 1 + 1 的替换，此时就需要使用 source.define。","frontmatter":{"title":"环境变量","sidebar_position":7}},{"id":524,"title":"HTML 模板","routePath":"/guides/basic-features/html","lang":"zh","toc":[{"id":"jsx-语法","text":"JSX 语法","depth":2},{"id":"html-组件","text":"HTML 组件","depth":3},{"id":"模板参数","text":"模板参数","depth":3},{"id":"示例","text":"示例","depth":3},{"id":"html-语法","text":"Html 语法","depth":2},{"id":"自定义-html-片段","text":"自定义 HTML 片段","depth":3},{"id":"完全自定义-html-模板","text":"完全自定义 HTML 模板","depth":3},{"id":"模板参数-1","text":"模板参数","depth":3},{"id":"按入口设置","text":"按入口设置","depth":3}],"domain":"","content":"\n\nModern.js 提供了 JSX 语法和 HTML(EJS) 语法两种方式用于自定义 HTML 模板。\n\n\nJSX 语法\n\nModern.js 约定，在 src/ 目录下，或在入口目录下，可以创建 Document.[jt]sx 并默认导出组件。该组件的渲染结果可以作为入口的\nHTML 模板。\n\n例如以下目录结构：\n\n.\n└── src\n    ├── Document.tsx\n    ├── entry-a\n    │   ├── Document.tsx\n    │   └── routes\n    ├── entry-b\n    │    └── routes\n    └── modern-app-env.d.ts\n\n\nentry-a 会优先使用当前入口下的 Docoument.[jt]sx 文件。如果当前入口没有 Document.[jt]sx 文件，例如\nentry-b，则会查找根目录下的 Document.[jt]sx 文件。\n\n如果还没有，则会兜底到传统模板的逻辑。\n\n\nHTML 组件\n\nModern.js 提供了一些列渲染页面的组件，用来帮助开发者生成模板，可以从 @modern-js/runtime/document 中导出这些组件：\n\n\n\n这些组件分别渲染：\n\n * Html：提供原生 HTML Element 的能力，并能默认渲染开发者未添加的必须的组件。<Head> 和 <Body>\n   是必须要存在的，其它组件可以按需选择合适的组件进行组装。\n\n * Body：提供原生 Body Element 的能力，内部需要包含 <Root> 组件，也支持其它元素同时作为子元素，例如添加页脚。\n\n * Root：渲染的根节点 <div id='root'></div>。默认根节点的 id = 'root'。可以设置 props.rootId 来更改 id\n   属性。可以添加子组件，也会被渲染到 HTML 模板中，当 React 渲染完成后会被覆盖，一般用来实现全局 Loading。\n\n * Head：提供原生 Head Element 的能力，并会自动填充 <meta>，以及 <Scripts> 组件。\n\n * Scripts：构建产生的 script 内容，可用于调整构建产物的位置，默认放在 <Head> 组件中。\n\n\n模板参数\n\n因为是 JSX 形式，Document.[jt]sx 里，可以比较自由的在组件内使用各种变量去赋值给各种自定义组件。\n\nModern.js 也提供了 DocumentContext 来提供一些配置、环境参数，方便直接获取。主要以下参数：\n\n * processEnv：提供构建时的 process.env\n * config：Modern.js 项目的配置。目前只暴露出 output 相关的配置\n * entryName：当前的入口名\n * templateParams：HTML 模板的参数（为了兼容传统模板，不推荐使用）\n\n\n示例\n\n\nimport {\n  Html,\n  Root,\n  Head,\n  Body,\n  Scripts,\n  DocumentContext,\n} from '@modern-js/runtime/document';\n\nexport default function Document(): React.ReactElement {\n  // DocumentContext 提供一些构建时的参数\n  const {\n    config: { output: htmlConfig },\n    entryName,\n    templateParams,\n  } = useContext(DocumentContext);\n\n  return (\n    <Html>\n      <Head>\n        <link href=\"https://modernjs.dev\">Modern.js</link>\n      </Head>\n      <Body>\n        <Root rootId=\"root\">\n          <h1 style={{ color: 'red' }}>以下为构建时传过来的参数：</h1>\n          <h2> entryName：{entryName}</h2>\n          <h2> title：{htmlConfig.title}</h2>\n          <h2> rootId: {templateParams.mountId}</h2>\n        </Root>\n        <h1>bottom</h1>\n      </Body>\n    </Html>\n  );\n}\n\n\n以上 JSX 组件，将会生成以下 HTML 模板：\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, shrink-to-fit=no, viewport-fit=cover, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"\n    />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <meta name=\"renderer\" content=\"webkit\" />\n    <meta name=\"layoutmode\" content=\"standard\" />\n    <meta name=\"imagemode\" content=\"force\" />\n    <meta name=\"wap-font-scale\" content=\"no\" />\n    <meta name=\"format-detection\" content=\"telephone=no\" />\n    <script>\n      ...\n    </script>\n    <script defer src=\"/static/js/lib-react.js\"></script>\n    <script defer src=\"/static/js/lib-polyfill.js\"></script>\n    <script defer src=\"/static/js/lib-router.js\"></script>\n    <script\n      defer\n      src=\"/static/js/vendors-node_modules_pnpm_loadable_component_5_15_2_react_18_2_0_node_modules_loadable_compon-3fb0cf.js\"\n    ></script>\n    <script\n      defer\n      src=\"/static/js/packages_runtime_plugin-router-legacy_dist_js_treeshaking_runtime_index_js-packages_runtime_p-28f4c9.js\"\n    ></script>\n    <script defer src=\"/static/js/sub.js\"></script>\n    <link href=\"https://www.baidu.com\" />\n  </head>\n\n  <body>\n    <div id=\"root\">\n      {/* <?- html ?> */}\n      <h1 style=\"color:red\">以下为构建时传过来的参数：</h1>\n      <h2>entryName：sub</h2>\n      <h2>title：</h2>\n      <h2>rootId: root</h2>\n    </div>\n    <h1>bottom</h1>\n    {/* <?- chunksMap.js ?> */}\n    {/* <?- SSRDataScript ?> */}\n  </body>\n</html>\n\n\n\nHtml 语法\n\nModern.js 也支持 HTML 语法。默认情况下，Modern.js 的应用工程中会内置一份 HTML 模板，用于生成 HTML 代码。\n\n基于 HTML 语法的模板，Modern.js 提供了 自定义 HTML 片段和完全自定义 HTML 模板两种方式来自定义模板。\n\n\n自定义 HTML 片段\n\n在应用根目录下，创建 config/html/ 目录，该目录下支持创建四种 HTML 片段。\n\n * top.html\n * head.html\n * body.html\n * bottom.html\n\n这些片段将按位置注入到默认的 HTML 模板中。\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <%= meta %>\n    <title><%= title %></title>\n    <%= topTemplate %>\n\n    <script>\n      window.__assetPrefix__ = '<%= assetPrefix %>';\n    </script>\n    <%= headTemplate %>\n    {/* webpack inject css  */}\n  </head>\n  <body>\n    <noscript>\n      We're sorry but react app doesn't work properly without JavaScript\n      enabled. Please enable it to continue.\n    </noscript>\n    <div id=\"<%= mountId %>\"></div>\n    <%= bodyTemplate %>\n    {/* webpack inject js  */}\n    {/* <?- bottomTemplate ?> */}\n  </body>\n</html>\n\n\n代码片段支持使用 Lodash template 语法。\n\n例如在 body.html 里插入一个外链脚本：\n\n<script src=\"//example.com/assets/a.js\"></script>\n\n\nINFO\n\n自定义 HTML 片段的实现方式是将片段与框架内置的模板进行合并，由于框架的默认模板中已经存在 <title>，因此自定义 HTML 模板中的 title\n标签无法生效，请通过 html.title 来修改页面标题。\n\n\n完全自定义 HTML 模板\n\n某些情况下，HTML 片段无法满足自定义需求，Modern.js 提供了完全自定义方式。\n\n注意\n\n通常不建议直接覆盖默认的 HTML 模板，可能会失去一部分功能选项。即使需要替换，建议以内置模板为基础，按需修改。\n\n在 config/html/ 目录下，创建 index.html 文件,该文件将替代默认的 HTML 模板。\n\nINFO\n\n内部默认 HTML 模板可以在 node_modules/.modern-js/${entryName}/index.html 中查看。\n\n\n模板参数\n\n模板中使用的参数可以通过 html.templateParameters 配置项来定义。\n\n\n按入口设置\n\nconfig/html/ 目录中的 HTML 片段对应用中的所有入口都生效。如果希望按入口自定义 HTML 片段，可以在 config/html/\n目录下新建一个以入口名命名的目录，然后在这个目录中自定义 HTML 片段。\n\n例如，如下设置的 HTML 片段仅对入口 entry1 生效：\n\n.\n├── config/\n│   └── html/\n│       └── entry1\n│           ├── head.html\n│           └── body.html\n└── src/\n    ├── entry1/\n    │   └── routes\n    └── entry2/\n        └── routes\n","frontmatter":{"title":"HTML 模板","sidebar_position":9}},{"id":525,"title":"数据模拟","routePath":"/guides/basic-features/mock","lang":"zh","toc":[{"id":"mock-文件","text":"Mock 文件","depth":2},{"id":"编写-mock-文件","text":"编写 Mock 文件","depth":2},{"id":"返回随机数据","text":"返回随机数据","depth":2},{"id":"延迟返回","text":"延迟返回","depth":2},{"id":"按需使用-mock-服务","text":"按需使用 Mock 服务","depth":2}],"domain":"","content":"\n\nModern.js 提供了快速生成 Mock 数据的功能，能够让前端独立自主开发，不被后端接口阻塞。\n\n\nMock 文件\n\n约定当 config/mock 目录下存在 index.[jt]s 时，会自动开启 Mock 功能，如下：\n\n.\n├── config\n│   └── mock\n│       └── index.ts\n├── src\n│   └── App.tsx\n└── modern.config.ts\n\n\n\n编写 Mock 文件\n\nconfig/mock/index.ts 文件只需要导出一个包含所有 Mock API 的对象，对象的属性由请求配置 method 和 url\n组成，对应的属性值可以为 Object、Array、Function：\n\nmodule.exports = {\n  /* 属性为具体的 method 和 请求 url，值为 object 或 array 作为请求的结果 */\n  'GET /api/getInfo': { data: [1, 2, 3, 4] },\n\n  /* method 默认为 GET */\n  '/api/getExample': { id: 1 },\n\n  /* 可以使用自定义函数根据请求动态返回数据，返回值参考 express middleware */\n  'POST /api/addInfo': (req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.end('200');\n  },\n};\n\n\n代码中访问 http://localhost:8080/api/getInfo 时，接口会返回 JSON 格式数据：{ \"data\": [1, 2, 3, 4]\n}。\n\n\n返回随机数据\n\n可以在 config/mock/index.js 中自主引入 Mock.js 等库生成随机数据，例如：\n\nconst Mock = require('mockjs');\n\nmodule.exports = {\n  '/api/getInfo': Mock.mock({\n    'data|1-10': [{ name: '@cname' }],\n  }) /* => {data: [{name: \"董霞\"}, {name: \"魏敏\"},  {name: \"石磊\"}} */,\n};\n\n\n更多随机数据生成库\n\n * Chancejs\n * Mock\n\n\n延迟返回\n\n * 可以使用浏览器「 弱网模拟 」的功能实现。\n * 可以通过 setTimeout 为单个接口设置延迟，例如：\n\nmodule.exports = {\n  'api/getInfo': (req, res) => {\n    setTimeout(() => {\n      res.end('delay 2000ms');\n    }, 2000);\n  },\n};\n\n\n\n按需使用 Mock 服务\n\nconfig/mock/index.ts 下还可以到处 config 对象，更精细的控制 Mock 服务。\n\ntype MockConfig = {\n  enable: ((req: IncomingMessage, res: ServerResponse) => boolean) | boolean;\n};\n\nexport const config = {\n  enable: false\n}\n\n\n目前仅支持 enable 配置，开发者可以通过该配置控制是否执行 Mock。\n\nNOTE\n\n修改 config后无需重启服务，即刻生效。","frontmatter":{"title":"数据模拟","sidebar_position":6}},{"id":526,"title":"代理","routePath":"/guides/basic-features/proxy","lang":"zh","toc":[{"id":"本地代理","text":"本地代理","depth":2},{"id":"全局代理","text":"全局代理","depth":2},{"id":"设置代理规则","text":"设置代理规则","depth":3},{"id":"代理服务器-ui-界面","text":"代理服务器 UI 界面","depth":3},{"id":"bff-代理","text":"BFF 代理","depth":2}],"domain":"","content":"\n\n\n本地代理\n\nModern.js 在 tools.devServer 中提供了配置开发环境代理的方式。例如，将本地开发接口，代理到线上某个地址：\n\n\n\nexport default defineConfig({\n  tools: {\n    devServer: {\n      proxy: {\n        '/go/api': {\n          target: 'http://www.example.com/',\n          changeOrigin: true,\n        },\n      },\n    },\n  },\n});\n\n\n请求 http://localhost:8080/go/api 时，会从 http://www.example.com/ 返回响应内容。\n\n补充信息\n\n配置格式可参考：http-proxy-middleware。\n\n\n全局代理\n\nModern.js 提供了开箱即用的全局代理插件 @modern-js/plugin-proxy，该插件底层基于 whistle，可用来查看、修改\nHTTP/HTTPS 的请求和响应，也可作为 HTTP 代理服务器使用。\n\n\n设置代理规则\n\n引入代理插件并填写规则后，执行 pnpm run dev，Modern.js 会在开发服务器启动之后，自动启用代理服务器。\n\n具体代理规则，可通过 dev.proxy 选项或 config/proxy.js 文件进行设置。\n\n\n代理服务器 UI 界面\n\n安装代理插件并配置代理规则后， 执行 pnpm run dev 命令：\n\n  App running at:\n\n  Local:    http://localhost:8080/\n  Network:  http://192.168.0.1:8080/\n\nℹ  info      Starting the proxy server.....\n✔  success   Proxy Server start on localhost:8899\n\n\n在控制台中可以看到代理服务器成功启动。\n\n访问 http://localhost:8899，显示下图所示的 UI 界面后，即可通过界面设置规则。\n\n\n\n\nBFF 代理\n\n通过配置 bff.proxy 可以代理 BFF API 请求到指定的服务上，上述两种代理不同，它同样可以用在生产环境：\n\nexport default defineConfig({\n  bff: {\n    proxy: {\n      '/api/v1': 'https://cnodejs.org',\n    },\n  },\n});\n\n\n例如代码中使用一体化 BFF 调用时，最终请求 http://localhost:8080/api/v1/topics 会自动代理到\nhttps://cnodejs.org/api/v1/topics：\n\n\n\ngetTopics();\n","frontmatter":{"title":"代理","sidebar_position":5}},{"id":527,"title":"路由","routePath":"/guides/basic-features/routes","lang":"zh","toc":[{"id":"约定式路由","text":"约定式路由","depth":2},{"id":"路由文件约定","text":"路由文件约定","depth":3},{"id":"layout","text":"Layout","depth":4},{"id":"page","text":"Page","depth":4},{"id":"动态路由","text":"动态路由","depth":3},{"id":"通配路由","text":"通配路由","depth":3},{"id":"无路径布局","text":"无路径布局","depth":3},{"id":"无布局路径","text":"无布局路径","depth":3},{"id":"wiploading","text":"(WIP)Loading","depth":3},{"id":"错误处理","text":"错误处理","depth":3},{"id":"运行时配置","text":"运行时配置","depth":3},{"id":"渲染前的钩子","text":"渲染前的钩子","depth":3},{"id":"自控式路由","text":"自控式路由","depth":2},{"id":"其他路由方案","text":"其他路由方案","depth":2}],"domain":"","content":"\n\nModern.js 的路由基于 React Router\n6，并提供了多种类型的路由模式。根据不同入口类型，将路由分为三种模式，分别是约定式路由，自控式路由和其他路由方案。\n\nNOTE\n\n本小节提到的路由，都是客户端路由，即 SPA 路由。\n\n\n约定式路由\n\n以 routes/ 为约定的入口，Modern.js 会自动基于文件系统，生成对应的路由结构。\n\nModern.js 支持了业界流行的约定式路由模式：嵌套路由，使用嵌套路由时，页面的路由 与 UI 结构是相呼应的，我们将会详细介绍这种路由模式。\n\n/user/johnny/profile                  /user/johnny/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------>  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n\n\n\n路由文件约定\n\n在routes/ 目录下，目录名会作为路由 url 的映射，Modern.js 有两个文件约定 layout.[jt]sx 和\npage.[jt]sx（后面简写为 .tsx）。这两个文件决定了应用的布局层次，其中 layout.tsx 中作为布局组件，page.tsx\n作为内容组件，是整条路由的叶子节点（一条路由有且仅有一个叶子节点，且必须以叶子节点结尾）。\n\n例如以下目录结构：\n\n.\n└── routes\n    ├── page.tsx\n    └── user\n        └── page.tsx\n\n\n会产出下面两条路由：\n\n * /\n * /user\n\n当添加 layout.tsx 后， 假设有以下目录\n\nINFO\n\n这里 routes/layout.tsx 会作为 / 路由下所有组件的布局组件使用， routes/user/layout.tsx 会作为 /user\n路由下所有路由组件的布局组件使用。\n\n.\n└── routes\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n当路由为 / 时，会有以下 UI 布局：\n\n<Layout>\n  <Page />\n</Layout>\n\n\n同样，routes/user/layout.tsx 会作为 /user 路由下所有组件的布局组件使用。当路由为 /user 时， 会有以下 UI 布局：\n\n<Layout>\n  <UserLayout>\n    <UserPage>\n  <UserLayout>\n</Layout>\n\n\nLayout\n\n<Layout> 组件是指 routes/ 目录下所有 layout.tsx 文件，它们表示对应路由片段的布局，使用 <Outlet> 表示子组件。\n\n\n\nexport default () => {\n  return (\n    <>\n      <Outlet></Outlet>\n    </>\n  );\n};\n\n\nNOTE\n\n<Outlet> 是 React Router 6 中新的 API，详情可以查看 Outlet.\n\n为了方便介绍 <Layout> 与 <Outlet> 的关系，以下面的文件目录举例：\n\n.\n└── routes\n    ├── blog\n    │   └── page.tsx\n    ├── layout.tsx\n    ├── page.tsx\n    └── user\n        ├── layout.tsx\n        └── page.tsx\n\n\n 1. 当路由为 / 时，routes/layout.tsx 中的 <Outlet> 代表的是 routes/page.tsx 中导出的组件，生成以下 UI\n    结构：\n\n<Layout>\n  <Page />\n</Layout>\n\n\n 2. 当路由为 /blog 时，routes/layout.tsx 中的 <Outlet> 代表的是 routes/blog/page.tsx\n    中导出的组件，生成以下 UI 结构：\n\n<Layout>\n  <BlogPage />\n</Layout>\n\n\n 3. 当路由为 /user 时，routes/layout.tsx 中的 <Outlet> 代表的是 routes/user/layout.tsx\n    中导出的组件。routes/user/layout.tsx 中的 <Outlet> 代表的是 routes/user/page.tsx\n    中导出的组件。生成以下 UI 结构：\n\n<Layout>\n  <UserLayout>\n    <UserPage>\n  <UserLayout>\n</Layout>\n\n\n总结而言，如果子路由的文件目录下存在 layout.tsx，上一级 layout.tsx 中的 <Outlet> 即为子路由文件目录下的 layout.tsx\n，否则为子路由文件目录下的 page.tsx。\n\nPage\n\n所有的路由，理论上都应该由 <Page> 组件结束。在 page.tsx 文件内，如果开发者引入 <Outlet> 组件，不会有任何效果。\n\n\n动态路由\n\n通过 [] 命名的文件目录，生成的路由会作为动态路由。例如以下文件目录：\n\n└── routes\n    ├── [id]\n    │   └── page.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\nroutes/[id]/page.tsx 文件会转为 /:id 路由。除了可以确切匹配的 /blog 路由，其他所有 /xxx 都会匹配到该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在 loader 中，params 会作为 loader 的入参，通过 params.xxx 可以获取。\n\n\n通配路由\n\n如果在 routes 目录下创建 $.tsx 文件，该文件会作为通配路由组件，当没有匹配的路由时，会渲染该路由组件。\n\nNOTE\n\n$.tsx 可以认为是一种特殊的 page 路由组件，当前目录下有 layout 组件时，$.tsx，会作为 layout的子组件渲染。\n\n例如以下目录结构：\n\n└── routes\n    ├── $.tsx\n    ├── blog\n    │   └── page.tsx\n    └── page.tsx\n\n\n当访问任何匹配不到的路径时，都会渲染 routes/$.tsx 组件，同样，$.tsx 中可以使用 useParams 捕获 url 的剩余部分。\n\n\n// 当 path 是 `/aaa/bbb` 时\nconst params = useParams();\nparams['*']  // => 'aaa/bbb'\n\n\n$.tsx 可以加入到 routes 目录下的任意目录中，一个常见的使用示例是添加 routes/$.tsx 文件去定制任意层级的 404 页面。\n\n\n无路径布局\n\n当目录名以 __ 开头时，对应的目录名不会转换为实际的路由路径，例如以下文件目录：\n\n.\n└── routes\n    ├── __auth\n    │   ├── layout.tsx\n    │   ├── login\n    │   │   └── page.tsx\n    │   └── signup\n    │       └── page.tsx\n    ├── layout.tsx\n    └── page.tsx\n\n\nModern.js 会生成 /login 和 /sign 两条路由，__auth/layout.tsx 组件会作为 login/page.tsx 和\nsignup/page.tsx 的布局组件，但__auth 不会作为路由路径片段。\n\n当需要为某些类型的路由，做独立的布局，或是想要将路由做归类时，这一功能非常有用。\n\n\n无布局路径\n\n有些情况下，项目需要较为复杂的路由，但这些路由又不存在独立的 UI 布局，如果像普通文件目录那边创建路由会导致目录层级较深。\n\n因此 Modern.js 支持了通过 . 来分割路由片段，代替文件目录。例如，当需要 /user/profile/2022/edit 时，可以直接创建如下文件：\n\n└── routes\n    ├── user.profile.[id].edit\n    │      └── page.tsx\n    ├── layout.tsx\n    └── page.tsx\n\n\n访问路由时，将得到如下 UI 布局：\n\n<RootLayout>\n  <UserProfileEdit /> // routes/user.profile.[id].edit/page.tsx\n</RootLayout>\n\n\n\n(WIP)Loading\n\nroutes/ 下每一层目录中，开发者可以创建 loading.tsx 文件，默认导出一个 <Loading> 组件。\n\n当路由目录下存在该组件和 layout 组件时，这一级子路由下所有的路由切换时，都会以该 <Loading> 组件作为 JS Chunk 加载时的\nFallback UI。例如以下文件目录：\n\n.\n└── routes\n    ├── blog\n    │   ├── [id]\n    │   │   └── page.tsx\n    │   └── page.tsx\n    ├── layout.tsx\n    ├── loading.tsx\n    └── page.tsx\n\n\n当定义 loading.tsx 时，就相当于以下布局：\n\n<Layout>\n  <Suspense fallback={<Loading/>}>\n    <Page><Page>\n  </Suspense>\n</Layout>\n\n\n<Layout>\n  <Suspense fallback={<Loading />}>\n    <BlogPage />\n  </Suspense>\n</Layout>\n\n\n<Layout>\n  <Suspense fallback={<Loading />}>\n    <BlogIdPage />\n  </Suspense>\n</Layout>\n\n\nINFO\n\n当目录的 layout 组件不存在时，该目录下的 loading 组件也不会生效。 Modern.js 建议必须有根 layout 和根 loading。\n\n当路由从 / 跳转到 /blog 时，如果 blog/page 组件的 JS Chunk 还未加载，则会先展示 loading.tsx 中导出的组件 UI。\n\n同理，当路由从 / 或者 /blog 跳转到 /blog/123 时，如果 blog/[id]/page 组件的 JS Chunk 还未加载，也会先展示\nloading.tsx 中导出的组件 UI。\n\n\n错误处理\n\nroutes/ 下每一层目录中，开发者同样可以定义一个 error.tsx 文件，默认导出一个 <ErrorBoundary> 组件。\n\n当有路由目录下存在该组件时，组件渲染出错会被 ErrorBoundary 组件捕获。当目录未定义 layout.tsx 文件时，<ErrorBoundary>\n组件不会生效。\n\n<ErrorBoundary> 可以返回出错时的 UI 视图，当前层级未声明 <ErrorBoundary>\n组件时，错误会向上冒泡到更上层的组件，直到被捕获或抛出错误。同时，当组件出错时，只会影响捕获到该错误的路由组件及子组件，其他组件的状态和视图不受影响，可以继续交\n互。\n\n{/* Todo API 路由 */}\n\n在 <ErrorBoundary> 组件内，可以使用 useRouteError 获取的错误的具体信息：\n\n\nconst ErrorBoundary = () => {\n  const error = useRouteError();\n  return (\n    <div>\n      <h1>{error.status}</h1>\n      <h2>{error.message}</h2>\n    </div>\n  );\n};\nexport default ErrorBoundary;\n\n\n\n运行时配置\n\n在每个根 Layout 组件中(routes/layout.ts)，可以动态地定义应用运行时配置：\n\n// 定义运行时配置\n\n\nexport const config = (): AppConfig => {\n  return {\n    router: {\n      supportHtml5History: false\n    }\n  }\n};\n\n\n\n渲染前的钩子\n\n在有些场景下，需要在应用渲染前做一些操作，可以在 routes/layout.tsx 中定义 init 钩子，init\n在客户端和服务端均会执行，基本使用示例如下：\n\n\n\nexport const init = (context: RuntimeContext) => {\n  // do something\n};\n\n\n通过 init 钩子可以挂载一些全局的数据，在应用的其他地方可以访问 runtimeContext 变量：\n\nNOTE\n\n该功能在应用需要页面前置的数据、自定义数据注入或是框架迁移（如 Next.js）时会非常有用。\n\nimport {\n  RuntimeContext,\n} from '@modern-js/runtime';\n\nexport const init = (context: RuntimeContext) => {\n  return {\n    message: 'Hello World',\n  }\n}\n\n\n\n\nexport default () => {\n  const { context } = useRuntimeContext();\n  const { message } = context.getInitData();\n\n  return <div>{message}</div>;\n}\n\n\n配合 SSR 功能时，浏览器端可以获取到 SSR 时 init 返回的数据，开发者可以自行判断是否要在浏览器端重新获取数据来覆盖 SSR 数据，例如：\n\n\n\nexport const init = (context: RuntimeContext) => {\n  if (process.env.MODERN_TARGET === 'node') {\n    return {\n      message: 'Hello World By Server',\n    }\n  } else {\n    const { context } = runtimeContext;\n    const data = context.getInitData();\n    // 如果没有获取到期望的数据\n    if (!data.message) {\n      return {\n        message: 'Hello World By Client'\n      }\n    }\n  }\n}\n\n\n\n自控式路由\n\n以 src/App.tsx 为约定的入口，Modern.js 不会多路由做额外的操作，开发者可以自行使用 React Router 6 的 API\n进行开发，例如：\n\n\n\nexport default () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route index element={<div>index</div>} />\n        <Route path=\"about\" element={<div>about</div>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\n\nNOTE\n\nModern.js 默认对约定式路由做了一系列资源加载及渲染上的优化，并且提供了开箱即用的 SSR\n能力，而这些能力，在使用自控路由时，都需要开发者自行封装，推荐开发者使用约定式路由。\n\n\n其他路由方案\n\n默认情况下，Modern.js 会开启内置的路由方案，即 React Router。\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n  },\n});\n\n\nModern.js 从 @modern-js/runtime/router 命名空间暴露了 React Router 的 API 供开发者使用，保证开发者和\nModern.js 中使用同一份代码。另外，这种情况下，React Router 的代码会被打包到 JS\n产物中。如果项目已经有自己的路由方案，或者不需要使用客户端路由，可以关闭这个功能。\n\nexport default defineConfig({\n  runtime: {\n    router: false,\n  },\n});\n","frontmatter":{"title":"路由","sidebar_position":1}},{"id":528,"title":"构建引擎","routePath":"/guides/concept/builder","lang":"zh","toc":[{"id":"构建架构","text":"构建架构","depth":2},{"id":"构建文档","text":"构建文档","depth":2},{"id":"构建配置","text":"构建配置","depth":2},{"id":"构建能力","text":"构建能力","depth":2}],"domain":"","content":"\n\nModern.js 的构建能力由 Modern.js Builder 提供。\n\nModern.js Builder 是 Modern.js 体系的核心组件之一，它是一个面向 Web 开发场景的构建引擎，可以脱离 Modern.js\n被独立使用。Modern.js Builder 同时支持 webpack 和 Rspack 等多种打包工具，默认情况下使用最成熟的 webpack 进行打包。\n\n\n构建架构\n\n从构建的角度看，Modern.js 分为三层架构，从上到下依次是：\n\n * 上层研发框架：Modern.js。\n * 通用构建引擎：Modern.js Builder。\n * 底层打包工具：webpack 和 Rspack。\n\n<img\nsrc=\"https://lf3-static.bytednsdoc.com/obj/eden-cn/zq-uylkvT/ljhwZthlaukjlkulzlp\n/builder-layers-1117.png\" style={{ maxWidth: '540px' }} />\n\n\n构建文档\n\n由于 Modern.js Builder 是一个可独立使用的模块，我们为它提供了单独的文档，文档地址为：modernjs.dev/builder。\n\n在该文档中，你可以了解到 Modern.js Builder\n的详细介绍，同时也可以找到各个构建能力的完整使用指南。当你遇到构建方面的需求或问题时，建议你优先阅读 Modern.js Builder 文档来解决。\n\n\n构建配置\n\nModern.js 的配置继承自 Modern.js Builder，因此你可以在 Modern.js 中使用 Modern.js Builder\n提供的所有构建配置。\n\n以 Modern.js Builder 的 html.title 配置项为例，你可以直接在 modern.config.ts\n文件中使用该配置项，它会被自动传递给 Modern.js Builder。\n\nexport default defineConfig({\n  html: {\n    title: 'example',\n  },\n});\n\n\n关于构建配置的详细说明，请参考 「Modern.js Builder - Builder 配置」。\n\n\n构建能力\n\nModern.js Builder 提供了丰富的构建能力，包括 JavaScript 编译、CSS 编译、静态资源处理、代码热更新、代码压缩、TS\n类型检查等几十种能力。\n\n我们推荐你阅读 「Modern.js Builder - 功能导航」 来了解 Modern.js Builder 提供的所有构建能力。","frontmatter":{"sidebar_position":2}},{"id":529,"title":"入口","routePath":"/guides/concept/entries","lang":"zh","toc":[{"id":"单入口与多入口","text":"单入口与多入口","depth":2},{"id":"入口类型","text":"入口类型","depth":2},{"id":"框架模式入口","text":"框架模式入口","depth":3},{"id":"约定式路由","text":"约定式路由","depth":4},{"id":"自定义路由","text":"自定义路由","depth":4},{"id":"自定义-app","text":"自定义 App","depth":4},{"id":"构建模式入口","text":"构建模式入口","depth":3},{"id":"使用配置文件定义入口","text":"使用配置文件定义入口","depth":2},{"id":"禁用默认入口扫描","text":"禁用默认入口扫描","depth":2}],"domain":"","content":"\n\n入口是 Modern.js 默认的文件约定，项目的每一个入口是一张独立的页面，对应一条服务端路由。\n\n很多配置，如 HTML 模板、Meta 信息、是否开启 SSR、SSG、服务端路由规则都是以入口为维度划分的。\n\n\n单入口与多入口\n\nModern.js 初始化的项目是单入口的，项目结构如下：\n\n.\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── package.json\n├── modern.config.ts\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\nModern.js 可以很方便的将单入口切换成多入口。可以在项目下执行 pnpm run new，通过生成器创建入口：\n\n? 请选择你想要的操作 创建工程元素\n? 创建工程元素 新建「应用入口」\n? 请填写入口名称 new-entry\n\n\n执行后，src/ 目录将会变成如下结构：\n\n.\n├── modern-app-env.d.ts\n├── myapp\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n└── new-entry\n    └── routes\n        ├── index.css\n        ├── layout.tsx\n        └── page.tsx\n\n\n原本的代码被移动到了和 package.json 中 name 同名的目录下，并创建了新的目录。\n\n执行 pnpm run dev 后，可以看到新增一条 /new-entry 的路由，并且被迁移的代码路由并未发生变化。\n\nNOTE\n\nModern.js 会将和 package.json 中 name 字段同名的入口作为主入口，默认路由为 /，其他入口默认路由为 /{entryName}。\n\n\n入口类型\n\n不同的入口类型具有不同的编译和运行时行为。在 Modern.js\n创建项目时，开发者可以手动选择创建框架模式或是构建模式的项目。完成创建后，可以看到不同模式的项目样板文件是不同的。\n\n默认情况下，Modern.js 启动项目前会对 src/ 下的文件进行扫描，识别入口，并生成对应的服务端路由。\n\nTIP\n\n可以通过 source.entriesDir 更改入口目录为其他目录。\n\n并非 src/ 下所有的一级目录都会成为项目入口, 入口所在目录必须满足以下四个条件之一：\n\n 1. 具有 routes/ 目录\n 2. 具有 App.[jt]sx? 文件\n 3. 具有 index.[jt]sx? 文件\n 4. 具有 pages/ 目录（兼容 Modern.js 1.0）\n\n当 src/ 目录满足入口特征时，Modern.js 会认为当前项目为单入口应用。\n\nTIP\n\n单入口默认的入口名为 main。\n\n当项目不是单入口应用时，Modern.js 会进一步查看 src/ 下的一级目录。\n\n\n框架模式入口\n\n框架模式指需要使用 Modern.js 框架能力，例如 Router、SSR、一体化调用等。这类入口约定下，开发者定义的入口并不是真正的 Webpack\n编译入口。Modern.js 在启动时会生成一个封装过的入口，可以在 node_modules/.modern/{entryName}/index.js\n找到真正的入口。\n\n约定式路由\n\n如果入口中存在 routes/ 目录，Modern.js 会在启动时扫描 routes/\n下的文件，基于文件约定，自动生成客户端路由（react-router）。\n\n详细内容可以参考路由。\n\n自定义路由\n\n如果入口中存在 App.[jt]sx? 文件，开发者可以在这个文件中自由的设置客户端路由，或者不设置客户端路由。\n\n详细内容可以参考路由。\n\n自定义 App\n\n如果入口中存在 index.[jt]sx 文件，并且当文件默认导出函数时，Modern.js 还是会根据 runtime 的设置情况生成 createApp\n包裹后的代码。在渲染过程中，将 createApp 包裹后的组件作为参数传递给 index 文件导出的函数，这样开发者可以自定义将组件挂载到 DOM\n节点上，或在挂载前添加自定义行为。例如：\n\n\n\n\nexport default (App: React.ComponentType) => {\n  // do something before bootstrap...\n  bootstrap(App, 'root', undefined, ReactDOM);\n};\n\n\nWARNING\n\n由于 bootstrap 函数需要兼容 React17 和 React18 的用法，调用 bootstrap 函数时需要手动传入 ReactDOM 参数。\n\nModern.js 生成的文件内容如下：\n\n\n\n\n\n\n\nconst IS_BROWSER = typeof window !== 'undefined' && window.name !== 'nodejs';\nconst MOUNT_ID = 'root';\n\nlet AppWrapper = null;\n\nfunction render() {\n  AppWrapper = createApp({\n    // runtime 的插件参数...\n  })(App);\n  if (IS_BROWSER) {\n    customBootstrap(AppWrapper);\n  }\n  return AppWrapper;\n}\n\nAppWrapper = render();\n\nexport default AppWrapper;\n\n\n\n构建模式入口\n\n构建模式是指不使用任何 Modern.js 运行时的能力，完全由开发者自己定义项目 Webpack 的入口。\n\n如果入口中存在 index.[jt]sx ，并且没有默认导出函数时，这时候该文件就是真正的 Webpack 入口文件。这里和 Create React App\n类似，需要自己将组件挂载到 DOM 节点、添加热更新代码等。例如:\n\n\n\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\nModern.js 不推荐使用这种方式，这种方式丧失了框架的一些能力，如 modern.config.js 文件中的 runtime\n配置将不会再生效。但是在项目从其他框架迁移到 Modern.js，例如 CRA，或是自己手动搭建的 webpack 时，这种方式会非常有用。\n\n\n使用配置文件定义入口\n\n有些时候，已有的项目并不是按照 Modern.js 的目录结构来搭建的。如果强行要按照这种结构来工作，会有比较大的迁移成本。\n\n在 Modern.js 中，除了使用文件约定生成入口外，还可以在 modern.config.[jt]s 中手动配置入口。\n\nexport default defineConfig({\n  source: {\n    entries: {\n      // 指定一个名称为 entry_customize 的新入口\n      entry_customize: './src/home/test/index.js',\n    },\n  },\n});\n\n\nTIP\n\n详情可以查看 source.entries。\n\n\n禁用默认入口扫描\n\n另外，项目的部分结构可能恰巧命中了 Modern.js 的约定，但实际上这部分并不是真实的入口。\n\nModern.js 提供了配置，来禁用默认的入口扫描。与配置的入口结合使用，大部分项目可以在不修改目录结构的情况下，快速的进行迁移。\n\nexport default defineConfig({\n  source: {\n    disableDefaultEntries: true,\n  },\n});\n\n\nTIP\n\n详情可以查看 source.disableDefaultEntries。","frontmatter":{"sidebar_position":1}},{"id":530,"title":"CSS-in-JS","routePath":"/guides/css/css-in-js","lang":"zh","toc":[],"domain":"","content":"\n\nCSS-in-JS 是一种可以将 CSS 样式写在 JS 文件里的技术。Modern.js 集成了社区常用的 CSS-in-JS 实现库\nstyled-components，它使用 JavaScript 的新特性 Tagged template 编写组件的 CSS 样式。可以直接从\n@modern-js/runtime/styled 引入 styled-components 的 API 进行使用。\n\n当需要编写一个内部字体为红色的 div 组件时，可以如下实现：\n\n\n\nconst RedDiv = styled.div`\n  color: red;\n`;\n\n\n当需要根据组件的 props 动态设置组件样式时，例如 props 的属性 primary 为 true 时，按钮的颜色为白色，其他情况为红色，实现代码如下：\n\n\n\nconst Button = styled.button`\n  color: ${props => (props.primary ? 'white' : 'red')};\n  font-size: 1em;\n`;\n\n\n关于 styled-components 的更多用法，请参考【styled-components 官网】。\n\n补充信息\n\nModern.js 内部使用了 Babel 插件 babel-plugin-styled-components，可以通过\ntools.styledComponents 对插件进行配置。\n\n提示\n\n如果需要使用 styled-jsx、Emotion 等其他 CSS-in-JS 库，需要先安装对应库的依赖。具体使用方式请参考对应库的官网。","frontmatter":{"sidebar_position":1}},{"id":531,"title":"CSS Modules","routePath":"/guides/css/css-modules","lang":"zh","toc":[{"id":"文件后缀形式-css-modules","text":"文件后缀形式 CSS Modules","depth":2},{"id":"全面启用-css-modules","text":"全面启用 CSS Modules","depth":2}],"domain":"","content":"\n\nModern.js 为 CSS Modules 提供了开箱即用的支持。\n\n\n文件后缀形式 CSS Modules\n\n默认情况下，以 .module.(css|scss|sass|less) 结尾的文件会作为 CSS Modules 文件处理，例如：\n\n.redColor {\n  color: red;\n}\n\n\n\n\nexport default function Button() {\n  return (\n    <button type=\"button\" className={styles.redColor}>\n      red button\n    </button>\n  );\n}\n\n\n最终将被编译为\n\n<button type=\"button\" className=\"button_redColor__1-RBg\">\n  red button\n</button>\n\n\n\n全面启用 CSS Modules\n\n如果想去掉文件名中 .module 后缀，可以设置 output.disableCssModuleExtension。\n\n设置后，除了 node_modules/ 目录下的样式文件和文件名称格式为 [name].global.(css|scss|sass|less)\n之外的所有样式文件，都会作为 CSS Modules 处理。\n\n如果此时需要全局样式，可以通过创建文件名称格式为 [name].global.(css|less|scss|sass) 的样式文件来解决， 例如:\n\n.bg-blue {\n  background-color: blue;\n}\n\n\n.redColor {\n  color: red;\n}\n\n\nimport './app.global.css';\n\n\nexport default function Button() {\n  return (\n    <button type=\"button\" className={`${styles.redColor} bg-blue`}>\n      button\n    </button>\n  );\n}\n\n\n最终将被编译为:\n\n<button type=\"button\" className=\"button__redColor--JsFYl bg-blue\">\n  button\n</button>\n\n\n最终效果如下：\n\n\n\n提示\n\n使用 babel-plugin-react-css-modules 时需要注意，该插件的配置选项 generateScopedName 需要和\noutput.cssModuleLocalIdentName 保持一致。","frontmatter":{"sidebar_position":5}},{"id":532,"title":"Less 和 Sass","routePath":"/guides/css/less-sass","lang":"zh","toc":[{"id":"自定义配置","text":"自定义配置","depth":2}],"domain":"","content":"\n\nLess 和 Sass 是常用的两种 CSS 预处理器，Modern.js 内置了 Less 和 Sass 编译能力的支持。\n\n\n自定义配置\n\n * 如果需要自定义 less-loader 的配置，请参考 tools.less 配置项。\n * 如果需要自定义 sass-loader 的配置，请参考 tools.less 配置项。\n\n提示\n\n经过 Less 和 Sass 预编译后的 CSS 文件，仍然会经过 Modern.js 内置的 PostCSS\n的转换，具备良好的浏览器兼容性。相关内容请参考【PostCSS】。","frontmatter":{"sidebar_position":4}},{"id":533,"title":"PostCSS","routePath":"/guides/css/postcss","lang":"zh","toc":[],"domain":"","content":"\n\nPostCSS 是一个用 JavaScript 工具和插件转换 CSS 代码的工具。Modern.js 内置 PostCSS，并集成 Autoprefixer\n等常用的 PostCSS 插件，能够满足大多数项目的样式开发需求。\n\n默认情况下，Modern.js 会对 CSS 进行以下编译和转换：\n\n 1. Autoprefixer 根据需要支持的浏览器范围，会自动为 CSS 规则添加需要的浏览器厂商前缀。Modern.js 默认支持的浏览器范围为：['>\n    0.01%', 'not dead', 'not op_mini all']。\n\n注意\n\n * 【支持的浏览器范围为：> 0.01%】是指浏览器市场份额大于 0.01%。\n * not dead 是指不包含官方不再支持的浏览器和过去 24 个月没有更新的浏览器。\n * not op_mini all 是指不包含 Opera Mini。\n\n补充信息\n\n如果需要修改默认浏览器支持范围，可以在项目的 package.json 文件中配置 browserslist，设置规则参考 Browserslist\n的使用，下面是一个示例： json title=\"package.json\" { \"browserslist\": [ \"last 1 version\", \">\n1%\", \"IE 10\" ] }\n\n 2. 提供 CSS custom properties 支持，可以在 CSS 中定义和使用自定义变量，如：\n\n:root {\n  --main-bg-color: pink;\n}\n\nbody {\n  background-color: var(--main-bg-color);\n}\n\n\n 3. 提供 CSS Nesting 支持，可以在 CSS 中使用嵌套写法，如：\n\ntable.colortable td {\n  text-align: center;\n}\ntable.colortable td.c {\n  text-transform: uppercase;\n}\n\n\n也可以改写成 CSS 嵌套写法：\n\ntable.colortable {\n  & td {\n    text-align: center;\n    &.c {\n      text-transform: uppercase;\n    }\n  }\n}\n\n\n 4. 修复已知的 Flexbugs 。\n 5. 对以下 CSS 特性提供兼容：\n    * initial 属性值\n    * break- 属性\n    * font-variant\n    * Media Query Ranges\n\n当需要修改 PostCSS 配置时，可以通过底层配置 tools.postcss 来实现，下面是一个示例：\n\nexport default defineConfig({\n  tools: {\n    postcss: {\n      plugins: ['autoprefixer', ('postcss-flexbugs-fixes': {})],\n    },\n  },\n});\n","frontmatter":{"sidebar_position":3}},{"id":534,"title":"Tailwind CSS","routePath":"/guides/css/tailwindcss","lang":"zh","toc":[{"id":"tailwind-css-版本","text":"Tailwind CSS 版本","depth":2},{"id":"浏览器兼容性","text":"浏览器兼容性","depth":3},{"id":"theme-配置","text":"Theme 配置","depth":2}],"domain":"","content":"\n\nTailwind CSS 是一个以 Utility Class 为基础的 CSS 框架和设计系统，可以快速地为组件添加常用样式，同时支持主题样式的灵活扩展。在\nModern.js 中使用 Tailwind CSS，只需要在项目根目录下执行 pnpm run new 并开启。\n\n按照如下进行选择：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用 Tailwind CSS 支持\n\n\n在 modern.config.ts 中注册 Tailwind 插件:\n\n\n\nexport default defineConfig({\n  plugins: [..., tailwindcssPlugin()],\n});\n\n\n使用时在入口的根组件(如 src/App.jsx)添加如下代码：\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\n然后即可在各个组件中使用 Tailwind CSS 提供的 Utility Class 了：\n\nconst App = () => (\n  <div className=\"h-12 w-48\">\n    <p className=\"text-xl font-medium text-black\">hello world</p>\n  </div>\n);\n\n\n补充信息\n\n根据需求不同，你可以选择性的导入 Tailwind CSS 提供的 CSS 文件。由于使用 @tailwind 与直接导入 CSS 文件的作用等价，因此关于\nTailwind CSS 提供的 CSS 文件的用途，可以参考 @tailwind 的使用 文档中注释里的内容。\n\n\nTailwind CSS 版本\n\nModern.js 同时支持 Tailwind CSS v2 和 v3 版本，框架会识别项目 package.json 中的 tailwindcss\n依赖版本，并启用相应的配置。默认情况下，我们会为你安装 Tailwind CSS v3 版本。\n\n如果你的项目仍在使用 Tailwind CSS v2，我们推荐你升级到 v3 以支持 JIT 等能力。关于 Tailwind CSS v2 与 v3\n版本之间的差异，请参考以下文章：\n\n * Tailwind CSS v3.0\n * Upgrade Guide\n\n\n浏览器兼容性\n\nTailwind CSS v2 和 v3 均不支持 IE 11 浏览器，相关背景请参考：\n\n * Tailwind CSS v3 - Browser Support。\n * Tailwind CSS v2 - Browser Support\n\n如果你在 IE 11 浏览器上使用 Tailwind CSS，可能会出现部分样式不可用的现象，请谨慎使用。\n\n\nTheme 配置\n\n当需要自定义 Tailwind CSS 的 theme 配置的时候，可以在配置 source.designSystem 中修改，例如，颜色主题中增加一个\nprimary：\n\nexport default defineConfig({\n  source: {\n    designSystem: {\n      extend: {\n        colors: {\n          primary: '#5c6ac4',\n        },\n      },\n    },\n  },\n});\n\n\n当需要对 Tailwind CSS 做 theme 以外的其他特殊配置时，可以在 tools.tailwindcss 中配置，例如设置 variants：\n\nexport default defineConfig({\n  tools: {\n    tailwindcss: {\n      variants: {\n        extend: {\n          backgroundColor: ['active'],\n        },\n      },\n    },\n  },\n});\n\n\n> 当你为项目配置 Tailwind CSS 的时候，source.designSystem 和 tools.tailwindcss\n> 这两个配置的组合等价于单独配置了一个 tailwindcss.config.js 文件。其中 source.designSystem 等效于\n> Tailwind CSS 的 theme 配置。","frontmatter":{"sidebar_position":2}},{"id":535,"title":"介绍","routePath":"/guides/get-started/introduction","lang":"zh","toc":[{"id":"为什么使用-modernjs","text":"为什么使用 Modern.js","depth":2},{"id":"下一步","text":"下一步","depth":2}],"domain":"","content":"\n\nModern.js 是基于 React 的渐进式现代 Web 开发框架。\n\n框架内置多种开箱即用的开发工具，拥有极致的构建性能，支持零配置的渲染范式切换，一体化的 API\n调用。并从三种工程方案出发（应用工程方案、模块工程方案，Monorepo 工程方案），支持全链路的前端研发。\n\nModern.js 是字节跳动的底层前端研发框架，已经直接或间接的服务上千个应用，包括中后台、PC Web、H5\n等多种应用场景。框架覆盖完整的生命周期，拥有完善的插件体系，提供高度定制能力。支持通过生成器插件自定义业务线专属的工程方案，定制各种功能扩展和业务需求，帮助开发\n者更快速的搭建应用。\n\n\n为什么使用 Modern.js\n\nModern.js 能为开发者提供极致的开发体验（Development Experience），让应用拥有更好的用户体验（User Experience）。\n\n在开发 React 应用过程中，开发者通常需要去为某些功能去设计实现方案，或是使用其他的库、框架来解决这些问题。Modern.js 支持 React\n应用所需要的所有配置和工具，并内置额外的功能和优化。开发者可以使用 React 构建应用的 UI，然后逐步采用 Modern.js\n的功能来解决常见的应用需求，如路由、数据获取、状态管理等。\n\n它主要包含以下特点：\n\n * 🪜 渐进式：使用最精简的模板创建项目，通过生成器逐步开启插件功能，定制解决方案。\n * 🏠 一体化：开发与生产环境 Web Server 唯一，CSR 和 SSR 同构开发，函数即接口的 API 服务调用。\n * 📦 开箱即用：默认 TS 支持，内置构建、ESLint、调试工具，全功能可测试。\n * 🌏 周边生态：自研状态管理、微前端、模块打包、Monorepo 方案等周边需求。\n * 🕸 多种路由模式：包含自控路由、基于文件约定的路由（嵌套路由）等。\n * 🚀 独立构建核心：支持多种打包工具，深度优化构建产物。\n\n\n下一步\n\n如果你希望了解如何使用 Modern.js，可以尝试 创建第一个应用，或是阅读 快速上手。","frontmatter":{"title":"介绍","sidebar_position":1}},{"id":536,"title":"快速上手","routePath":"/guides/get-started/quick-start","lang":"zh","toc":[{"id":"环境准备","text":"环境准备","depth":2},{"id":"nodejs","text":"Node.js","depth":3},{"id":"pnpm","text":"pnpm","depth":3},{"id":"安装","text":"安装","depth":2},{"id":"初始化项目","text":"初始化项目","depth":2},{"id":"启动项目","text":"启动项目","depth":2},{"id":"使用配置","text":"使用配置","depth":2},{"id":"构建项目","text":"构建项目","depth":2},{"id":"本地验证","text":"本地验证","depth":2},{"id":"部署","text":"部署","depth":2}],"domain":"","content":"\n\n\n环境准备\n\n\nNode.js\n\n需要 Node.js LTS，并确保 Node 版本大于等于 v16.18.1。\n\nModern.js 推荐在开发环境里先安装 nvm，在 shell 里集成自动切换 node 版本的脚本。\n\n然后只要仓库根目录下有内容为 lts/gallium 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的 Node.js 版本。\n\n\npnpm\n\n推荐使用 pnpm 来管理依赖：\n\nnpm install -g pnpm\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n安装\n\nModern.js 提供了 @modern-js/create 生成器来创建项目，不要全局安装，使用 npx 按需运行。\n\n可以使用已有的空目录来创建项目：\n\nmkdir myapp && cd myapp\nnpx @modern-js/create\n\n\n也可以直接用新目录创建项目：\n\nnpx @modern-js/create myapp\n\n\n\n初始化项目\n\nModern.js 生成器会提供一个可交互的问答界面，根据结果初始化项目，按照默认的选择进行初始化：\n\n? 请选择你想创建的工程类型 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n在生成项目后，Modern.js 会自动安装依赖、创建 git 仓库。\n\n[INFO] 依赖自动安装成功\n[INFO] git 仓库初始化成功\n[INFO] 创建成功！\n可在新项目的目录下运行以下命令：\npnpm run dev          # 按开发环境的要求，运行和调试项目\npnpm run build        # 按生产环境的要求，构建项目\npnpm run serve        # 按生产环境的要求，运行项目\npnpm run lint         # 检查和修复所有代码\npnpm run new          # 继续创建更多项目要素，比如应用入口\n\n\nNOTE\n\nModern.js 生成器除了在项目初始化时工作外，也能在后续研发中生成项目各种粒度的模块，并非一用即抛开。\n\n现在，项目结构如下：\n\n.\n├── node_modules\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── modern.config.ts\n├── package.json\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\n\n启动项目\n\n在项目中执行 pnpm run dev 即可启动项目：\n\n$ pnpm run dev\n\n> modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n Client ✔ done in 76.10ms\n\n\n在浏览器中打开 http://localhost:8000/，可以看到页面内容。\n\n\n使用配置\n\n通过生成器创建的 Modern.js 项目中，存在 modern.config.ts 文件。\n\n可以通过配置文件来开启功能，或覆盖 Modern.js 的默认行为。例如添加如下配置，开启 SSR：\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools()],\n});\n\n\n重新执行 pnpm run dev，在浏览器 Network 菜单中，可以发现项目已经在服务端完成了页面渲染。\n\n\n构建项目\n\n在项目中执行 pnpm run build 即可构建项目生产环境产物：\n\n$ pnpm run build\n\n> modern build\n\ninfo    Create a production build...\n\ninfo    File sizes after production build:\n\n  File                                      Size         Gzipped\n  dist/static/js/lib-corejs.ffeb7fb8.js     214.96 kB    67.23 kB\n  dist/static/js/lib-react.09721b5c.js      152.61 kB    49.02 kB\n  dist/static/js/218.102e2f39.js            85.45 kB     28.5 kB\n  dist/static/js/lib-babel.a7bba875.js      11.93 kB     3.95 kB\n  dist/html/main/index.html                 5.84 kB      2.57 kB\n  dist/static/js/main.3568a38e.js           3.57 kB      1.44 kB\n  dist/static/css/async/304.c3c481a5.css    2.62 kB      874 B\n  dist/asset-manifest.json                  1.48 kB      349 B\n  dist/static/js/async/304.c45706bc.js      1.4 kB       575 B\n  dist/static/js/async/509.fcb06e14.js      283 B        230 B\n\n Client ✔ done in 3.57s\n\n\n构建产物默认生成到 dist/，目录结构如下：\n\n.\n├── asset-manifest.json\n├── html\n│   └── main\n├── loader-routes\n│   └── main\n├── modern.config.json\n├── route.json\n└── static\n    ├── css\n    └── js\n\n\n\n本地验证\n\n在项目中执行 pnpm run serve 即可在本地验证构建产物是否正常运行：\n\n$ pnpm run serve\n\n> modern serve\n\nStarting the modern server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n\n在浏览器中打开 http://localhost:8000/，内容应该和 pnpm run dev 时一致。\n\n\n部署\n\n本地验证完成后，可以将 dist/ 下的产物整理成服务器需要的结构，进行部署。","frontmatter":{"title":"快速上手","sidebar_position":2}},{"id":537,"title":"升级","routePath":"/guides/get-started/upgrade","lang":"zh","toc":[{"id":"通过命令行升级","text":"通过命令行升级","depth":2},{"id":"指定版本升级","text":"指定版本升级","depth":2},{"id":"锁定子依赖","text":"锁定子依赖","depth":2},{"id":"pnpm","text":"pnpm","depth":3},{"id":"yarn","text":"Yarn","depth":3},{"id":"npm","text":"Npm","depth":3}],"domain":"","content":"\n\n\n通过命令行升级\n\nModern.js 提供了 upgrade 命令支持项目升级到最新的 Modern.js 版本。\n\n在项目中执行 pnpm run upgrade：\n\n$ pnpm run upgrade\n\n> modern upgrade\n\n[INFO] [项目类型]: 应用\n[INFO] [Modern.js 最新版本]: 2.0.0\n[INFO] 已更新 Modern.js 依赖至最新版本!\n\n\n可以看到项目 package.json 中的依赖已经更改到最新。\n\n\n指定版本升级\n\nModern.js 所有的官方包目前都使用统一版本号进行发布。\n\n根据官网 Release Note，开发者也可以手动将项目升级到想要的版本。\n\nTIP\n\n当升级时，需要对 Modern.js 官方提供的所有包做统一升级，而不是升级单个依赖。\n\n\n锁定子依赖\n\n当项目某个子依赖出现问题，而 Modern.js 无法立即更新时，可以使用包管理器锁定子依赖版本。\n\n\npnpm\n\n对于使用 pnpm 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 pnpm install：\n\n{\n  \"pnpm\": {\n    \"overrides\": {\n      \"package-name\": \"^1.0.0\"\n    }\n  }\n}\n\n\n\nYarn\n\n对于使用 Yarn 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 yarn install：\n\n{\n  \"resolutions\": {\n    \"package-name\": \"^1.0.0\"\n  }\n}\n\n\n\nNpm\n\n对于使用 Npm 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 npm install：\n\n{\n  \"overrides\": {\n    \"package-name\": \"^1.0.0\"\n  }\n}\n\n\nINFO\n\n对于 Monorepo 仓库，只能在项目根目录的 package.json 中锁定依赖版本，并且会影响 Monorepo 中的所有 package。","frontmatter":{"title":"升级","sidebar_position":3}},{"id":538,"title":"添加一个 changeset","routePath":"/guides/topic-detail/changesets/add","lang":"zh","toc":[{"id":"信息","text":"信息","depth":2},{"id":"步骤","text":"步骤","depth":2},{"id":"模块工程方案","text":"模块工程方案","depth":3},{"id":"在根目录执行以下命令","text":"在根目录执行以下命令：","depth":4},{"id":"选择本次变更需要升级的版本号类型点击回车","text":"选择本次变更需要升级的版本号类型，点击回车：","depth":4},{"id":"填入-changelog-信息并点击两次回车","text":"填入 Changelog 信息，并点击两次回车：","depth":4},{"id":"monorepo-工程方案","text":"Monorepo 工程方案","depth":3},{"id":"在根目录执行以下命令-1","text":"在根目录执行以下命令：","depth":4},{"id":"选择本次需要升级的包列表","text":"选择本次需要升级的包列表：","depth":4},{"id":"分别选择不同版本类型对应的包changeset-会询问-major-和-minor-类型如果存在包未选择这两种类型将会默认使用-patch-类型","text":"分别选择不同版本类型对应的包，changeset 会询问 major 和 minor 类型，如果存在包未选择这两种类型，将会默认使用 patch 类型：","depth":4},{"id":"填入-changelog-信息并点击两次回车-1","text":"填入 Changelog 信息，并点击两次回车：","depth":4},{"id":"参数","text":"参数","depth":2},{"id":"注意事项","text":"注意事项","depth":2}],"domain":"","content":"\n\n当我们开发完成一个功能时，需要添加一个 changeset 用于声明当前功能，用于后续版本发布。\n\n\n信息\n\n一个 changeset 包含的内容包括：\n\n * 本次变更涉及哪些包的变更。\n\n * 本次变更需要升级的版本号类型，类型符合 semver 规范。\n\n * 本次变更的 Changelog 信息。\n\n\n步骤\n\nINFO\n\n以下示例命令都以 pnpm 作为包管理工具进行，如果需要使用其他包管理工具，请按需求进行替换。\n\n\n模块工程方案\n\n在根目录执行以下命令：\n\npnpm run change\n\n\n选择本次变更需要升级的版本号类型，点击回车：\n\n\n\n填入 Changelog 信息，并点击两次回车：\n\n\n\n执行完成后，将在项目的 .changeset 目录创建对应的 changeset 文件，文件内容如下：\n\n---\n'module-changeset': patch\n---\n\nfeat: test module solution changeset\n\n\n该文件中包含了 changeset 的所有信息。\n\n\nMonorepo 工程方案\n\n我们假设 monorepo 中存在三个模块包，分别为 module-1，module-2，module-3。\n\n在根目录执行以下命令：\n\npnpm run change\n\n\n选择本次需要升级的包列表：\n\nChangesets 会根据当前代码变更(git diff Head...baseBranch)，将 Monorepo 中的 package\n分为两类，changed packages 和 unchanged packages，方便用户进行选择。\n\n使用空格键选择对应的包或者分类即可，选择完成后点击回车：\n\n\n\n分别选择不同版本类型对应的包，changeset 会询问 major 和 minor 类型，如果存在包未选择这两种类型，将会默认使用 patch 类型：\n\n\n\n填入 Changelog 信息，并点击两次回车：\n\n\n\n执行完成后，将在项目的 .changeset 目录创建对应的 changeset 文件，文件内容如下：\n\n---\n'module-2': minor\n'module-3': patch\n---\n\nfeat: test-changeset\n\n\n该文件中包含了 changeset 的所有信息，不同的包也会根据选择的版本类型进行标记。\n\n\n参数\n\nchange 命令支持以下参数：\n\n * --empty 添加一个空的 changeset。\n\npnpm run change -- --empty\n\n\n执行完成后，将在项目的 .changeset 目录创建空的 changeset 文件，文件内容如下：\n\n---\n---\n\n\n * --open 使用该参数时，在填写 Changelog 步骤会打开系统默认编辑器进行填写。\n\n\n注意事项\n\n * 不是所有的变更都需要 changeset\n\n如果当前变更是修改仓库的一些基础设施，比如 CI、测试等，就不需要添加 changeset 或者可以添加一个空的 changeset。\n\n * 一个 pull reuqest 可以提交多个 changeset\n\n当一个 pull request 存在多个功能开发或者问题修复时，可以多次执行 pnpm run change 添加多个 changeset\n文件，每个文件选择对应功能的包和添加变更信息即可。\n\n * 创建 changeset 时，需要选择该功能相关的所有包\n\n在 Monorepo 中创建 changeset 时，需要选中和该功能相关的所有变更包，避免出现发版时部分包未发布的情况。","frontmatter":{"sidebar_position":2}},{"id":539,"title":"自定义 Changelog 生成","routePath":"/guides/topic-detail/changesets/changelog","lang":"zh","toc":[{"id":"自定义-changlog-内容","text":"自定义 Changlog 内容","depth":2},{"id":"getreleaseline","text":"getReleaseLine","depth":3},{"id":"params","text":"Params","depth":4},{"id":"返回值","text":"返回值","depth":4},{"id":"默认实现","text":"默认实现","depth":4},{"id":"getdependencyreleaseline","text":"getDependencyReleaseLine","depth":3},{"id":"params-1","text":"Params","depth":4},{"id":"返回值-1","text":"返回值","depth":4},{"id":"默认实现-1","text":"默认实现","depth":4},{"id":"配置","text":"配置","depth":2},{"id":"配置相对路径","text":"配置相对路径","depth":3},{"id":"使用模块工程方案","text":"使用模块工程方案","depth":3},{"id":"使用-npx-modern-jscreate-创建模块工程方案","text":"使用 npx @modern-js/create 创建模块工程方案。","depth":4},{"id":"实现自定义内容","text":"实现自定义内容。","depth":4},{"id":"将模块发布到-npm","text":"将模块发布到 NPM。","depth":4},{"id":"在目标仓库根目录安装对应模块例如-custom-changelog","text":"在目标仓库根目录安装对应模块，例如 custom-changelog。","depth":4},{"id":"配置-changeset-的-changelog-配置为包名称","text":"配置 changeset 的 changelog 配置为包名称。","depth":4},{"id":"使用-monorepo-工程方案","text":"使用 Monorepo 工程方案","depth":3},{"id":"执行-pnpm-run-new-创建模块子项目","text":"执行 pnpm run new 创建模块子项目。","depth":4},{"id":"实现自定义内容-1","text":"实现自定义内容。","depth":4},{"id":"在-monorepo-根目录添加子项目模块依赖例如-custom-changelog","text":"在 Monorepo 根目录添加子项目模块依赖，例如 custom-changelog。","depth":4},{"id":"配置-changeset-的-changelog-配置为包名称-1","text":"配置 changeset 的 changelog 配置为包名称。","depth":4}],"domain":"","content":"\n\nChangesets 默认会使用 @changesets/cli/changelog 生成 Changelog 信息，如果默认的 Changelog\n信息不能满足需求，可以自定义 Changelog 的生成。\n\n\n自定义 Changlog 内容\n\nChangelog 信息主要包含以下两种信息：\n\n * changeset 中写入的 Changelog 信息。\n\n * 本次版本升级关联包的版本变更信息。\n\n自定义逻辑主要实现两个函数，getReleaseLine 和 getDependencyReleaseLine，分别用来定义上述这两种信息。\n\n\ngetReleaseLine\n\nParams\n\n * changeset\n\nexport type VersionType = 'major' | 'minor' | 'patch' | 'none';\n\nexport type Release = { name: string; type: VersionType };\n\nexport type Changeset = {\n  id: string; // changeset 的文件名称\n  commit?: string; // changeset 提交时的 commit id 信息\n  summary: string; // changeset 内容信息\n  releases: Array<Release>; // 当前计算出的 changeset 升级包名称及类型信息\n};\n\n\n * type\n\n当前包对应的升级版本类型，类型为上述 VersionType。\n\n返回值\n\nChangelog 内容。\n\n默认实现\n\n@changesets/cli/changelog 默认处理逻辑为将 summary 信息按照换行符 \\n 分割，第一样前面增加 -\n作为列表开头，其他内容作为第一行内容的补充整理在列表下方。\n\nasync function getReleaseLine(changeset, type) {\n  const [firstLine, ...futureLines] = changeset.summary\n    .split('\\n')\n    .map(l => l.trimRight());\n\n  let returnVal = `- ${\n    changeset.commit ? `${changeset.commit}: ` : ''\n  }${firstLine}`;\n\n  if (futureLines.length > 0) {\n    returnVal += `\\n${futureLines.map(l => `  ${l}`).join('\\n')}`;\n  }\n\n  return returnVal;\n}\n\n\n\ngetDependencyReleaseLine\n\nParams\n\n * changesets\n\n当前关联的所有 changeset 信息，类型为 getReleaseLine changeset 类型数组。\n\n * dependenciesUpdated\n\ntype ModCompWithPackage = {\n  name: string; // 依赖模块名称\n  type: VersionType; // 依赖模块的升级类型\n  oldVersion: string; // 依赖模块当前版本号\n  newVersion: string; // 依赖模块新版本号\n  changesets: string[]; // 关联的 changeset id 列表\n  packageJson: PackageJSON; // 依赖模块完整的 package.json 内容\n  dir: string; // 依赖模块的路径(绝对路径)\n};\n\ntype DependenciesUpdated = ModCompWithPackage[];\n\n\n返回值\n\nChangelog 内容。\n\n默认实现\n\n@changesets/cli/changelog 默认会使用 changesets 信息展示对应的 Updated dependencies + commit\nid，以列表形式展示。然后根据 dependenciesUpdated 信息展示对应的依赖包包名和新版本号，作为列表的子列表项。\n\nasync function getDependencyReleaseLine(changesets, dependenciesUpdated) {\n  console.log('getDependencyReleaseLine', changesets, dependenciesUpdated);\n  if (dependenciesUpdated.length === 0) return '';\n\n  const changesetLinks = changesets.map(\n    changeset =>\n      `- Updated dependencies${\n        changeset.commit ? ` [${changeset.commit}]` : ''\n      }`,\n  );\n\n  const updatedDepenenciesList = dependenciesUpdated.map(\n    dependency => `  - ${dependency.name}@${dependency.newVersion}`,\n  );\n\n  return [...changesetLinks, ...updatedDepenenciesList].join('\\n');\n}\n\n\n展示效果为：\n\n- Updated dependencies [f0438ab]\n- Updated dependencies [f0438ab]\n  - module-3@2.0.0\n  - module-1@0.2.0\n\n\n\n配置\n\nChangesets 配置文件中 changelog 字段，该字段用于标记 Changelog 信息的获取途径。\n\n该配置可以为字符串，直接声明获取 Changelog 信息模块的模块名称或者路径。\n\n该配置还支持配置数组，数组中第一个元素为获取 Changelog 信息模块的模块名称或者路径，第二个元素为传入对应函数的参数值，会作为\ngetReleaseLine 和 getDependencyReleaseLine 函数的第三个参数传入。\n\n\n配置相对路径\n\nchangelog 配置如果为相对路径为 .changesets 目录下的相对路径。\n\n例如创建 .changeset/my-changelog-config.js 文件，定义如下内容：\n\nasync function getReleaseLine(changeset, type) {}\n\nasync function getDependencyReleaseLine(changesets, dependenciesUpdated) {}\n\nmodule.exports = {\n  getReleaseLine,\n  getDependencyReleaseLine,\n};\n\n\nchanglog 配置为 ./my-changelog-config.js 即可:\n\n{\n  \"changelog\": \"./my-changelog-config.js\",\n   ...\n}\n\n\n\n使用模块工程方案\n\n自定义 Changelog 还可以使用模块工程方案进行管理，提供通用方案。\n\n使用 npx @modern-js/create 创建模块工程方案。\n\n? 请选择你想创建的工程类型 模块\n? 请填写项目名称 custom-changelog\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n实现自定义内容。\n\nexport async function getReleaseLine() {}\n\nexport async function getDependencyReleaseLine() {}\n\n\n将模块发布到 NPM。\n\n在目标仓库根目录安装对应模块，例如 custom-changelog。\n\n配置 changeset 的 changelog 配置为包名称。\n\n{\n  \"changelog\": \"custom-changelog\",\n   ...\n}\n\n\n\n使用 Monorepo 工程方案\n\n如果你当前仓库为 Monorepo 工程方案，可以直接使用模块子项目进行管理。\n\n执行 pnpm run new 创建模块子项目。\n\n? 请选择你想创建的工程类型 模块\n? 请填写子项目名称 custom-changelog\n? 请填写子项目目录名称 custom-changelog\n? 请选择开发语言 TS\n\n\n实现自定义内容。\n\nexport async function getReleaseLine() {}\n\nexport async function getDependencyReleaseLine() {}\n\n\n在 Monorepo 根目录添加子项目模块依赖，例如 custom-changelog。\n\n{\n  \"devDependencies\": {\n    \"custom-changelog\": \"workspace: *\",\n    ...\n  }\n}\n\n\n配置 changeset 的 changelog 配置为包名称。\n\n{\n  \"changelog\": \"custom-changelog\",\n   ...\n}\n\n\n该模块发布到 NPM 后，依然可以和模块类型一样供其他仓库使用。","frontmatter":{"sidebar_position":6}},{"id":540,"title":"自定义提交 commit 信息","routePath":"/guides/topic-detail/changesets/commit","lang":"zh","toc":[{"id":"自定义-commit-信息内容","text":"自定义 commit 信息内容","depth":2},{"id":"getaddmessage","text":"getAddMessage","depth":3},{"id":"params","text":"Params","depth":4},{"id":"返回值","text":"返回值","depth":4},{"id":"默认实现","text":"默认实现","depth":4},{"id":"getversionmessage","text":"getVersionMessage","depth":3},{"id":"params-1","text":"Params","depth":4},{"id":"返回值-1","text":"返回值","depth":4},{"id":"默认实现-1","text":"默认实现","depth":4},{"id":"配置","text":"配置","depth":2},{"id":"配置相对路径","text":"配置相对路径","depth":3},{"id":"使用模块工程方案","text":"使用模块工程方案","depth":3},{"id":"使用-npx-modern-jscreate-创建模块工程方案","text":"使用 npx @modern-js/create 创建模块工程方案。","depth":4},{"id":"实现自定义内容","text":"实现自定义内容。","depth":4},{"id":"将模块发布到-npm","text":"将模块发布到 NPM。","depth":4},{"id":"在目标仓库根目录安装对应模块例如-custom-commit","text":"在目标仓库根目录安装对应模块，例如 custom-commit。","depth":4},{"id":"配置-changeset-的-commit-配置为包名称","text":"配置 changeset 的 commit 配置为包名称。","depth":4},{"id":"使用-monorepo-工程方案","text":"使用 Monorepo 工程方案","depth":3},{"id":"执行-pnpm-run-new-创建模块子项目","text":"执行 pnpm run new 创建模块子项目。","depth":4},{"id":"实现自定义内容-1","text":"实现自定义内容。","depth":4},{"id":"在-monorepo-根目录添加子项目模块依赖例如-custom-commit","text":"在 Monorepo 根目录添加子项目模块依赖，例如 custom-commit。","depth":4},{"id":"配置-changeset-的-commit-配置为包名称-1","text":"配置 changeset 的 commit 配置为包名称。","depth":4}],"domain":"","content":"\n\nChangesets 支持配置 commit 为 true 时，在执行 change 和 bump 命令时自动提交当前变更。\n\n默认的 commit 信息由 @changesets/cli/commit 提供，默认信息格式为：\n\n\n\n当默认的 commit 信息不能满足需求时，支持自定义 commit 信息。\n\n\n自定义 commit 信息内容\n\ncommit 信息分为两种：\n\n * 执行 change 命令时自动生成的 commit 信息。\n * 执行 bump 命令时自动生成的 commit 信息。\n\n自定义逻辑主要实现两个函数，getAddMessage 和 getVersionMessage，分别用来定义上述这两种信息。\n\n\ngetAddMessage\n\nParams\n\n * changeset\n\n当前创建的 chagneset 信息\n\ntype Release = {\n  name: string;\n  type: VersionType;\n};\n\ntype Changeset = {\n  summary: string;\n  releases: Array<Release>;\n};\n\n\n * options\n\n配置 commit 时的配置信息。\n\n> commit 配置为数组时，第二个参数支持传入默认的配置信息，会对应的使用该参数传递。\n\n返回值\n\ncommit 信息内容。\n\n默认实现\n\n@changesets/cli/commit 默认处理逻辑为以 docs(changeset): 开头，commit 信息为 changeset 的\nsummary，并根据传入的 skipCI 参数配置添加 [skip ci] 信息。\n\ntype SkipCI = boolean | 'add' | 'version';\n\nconst getAddMessage = async (\n  changeset: Changeset,\n  options: { skipCI?: SkipCI } | null,\n) => {\n  const skipCI = options?.skipCI === 'add' || options?.skipCI === true;\n  return outdent`docs(changeset): ${changeset.summary}${\n    skipCI ? `\\n\\n[skip ci]\\n` : ''\n  }`;\n};\n\n\n> outdent 目的是删除模板字符串开头的空格内容，使 commit 信息更符合规范。\n\n\ngetVersionMessage\n\nParams\n\n * releasePlan\n\ntype VersionType = 'major' | 'minor' | 'patch' | 'none';\n\ntype Release = {\n  name: string;\n  type: VersionType;\n};\n\ntype Changeset = {\n  id: string;\n  summary: string;\n  releases: Array<Release>;\n};\n\ntype ComprehensiveRelease = {\n  name: string;\n  type: VersionType;\n  oldVersion: string;\n  newVersion: string;\n  changesets: string[];\n};\n\ntype PreState = {\n  mode: 'pre' | 'exit'; // pre 模式当前状态\n  tag: string; // pre 的类型\n  initialVersions: {\n    [pkgName: string]: string; // 版本升级前包名及版本号信息，Map 格式\n  };\n  changesets: string[]; // 本次升级的 changeset id 列表\n};\n\ntype ReleasePlan = {\n  changesets: Changeset[]; // 本次升级的 changeset 列表\n  releases: ComprehensiveRelease[]; // 当前升级的包信息，包含包名称、当前版本、升级后版本、升级类型等\n  preState: PreState | undefined; // 当前如果为 pre 发布，提供相关状态信息\n};\n\n\n * options\n\n配置 commit 时的配置信息。\n\n> commit 配置为数组时，第二个参数支持传入默认的配置信息，会对应的使用该参数传递。\n\n返回值\n\ncommit 信息内容。\n\n默认实现\n\n@changesets/cli/commit 默认处理逻辑为：先展示当前需要 release 的包数量，再展示 release 包的名称及新版本号，并根据传入的\nskipCI 参数配置添加 [skip ci] 信息。\n\nconst getVersionMessage = async (\n  releasePlan: ReleasePlan,\n  options: { skipCI?: SkipCI } | null,\n) => {\n  const skipCI = options?.skipCI === 'version' || options?.skipCI === true;\n  const publishableReleases = releasePlan.releases.filter(\n    release => release.type !== 'none',\n  );\n  const numPackagesReleased = publishableReleases.length;\n\n  const releasesLines = publishableReleases\n    .map(release => `  ${release.name}@${release.newVersion}`)\n    .join('\\n');\n\n  return outdent`\n    RELEASING: Releasing ${numPackagesReleased} package(s)\n\n    Releases:\n    ${releasesLines}\n    ${skipCI ? `\\n[skip ci]\\n` : ''}\n`;\n};\n\n\n\n配置\n\nChangesets 配置文件中 commit 字段，该字段用于标记是否需要在 change 和 bump 命令是提交 commit 信息及 commit\n信息的获取途径。\n\n该配置可以为 boolean，为 true 时使用默认 @changesets/cli/commit 格式化 commit 信息。\n\n该配置可以为字符串，直接声明获取 commit 信息模块的模块名称或者路径。\n\n该配置还支持配置数组，数组中第一个元素为获取 commit 信息模块的模块名称或者路径，第二个元素为传入对应函数的参数值，会作为 getAddMessage 和\ngetVersionMessage 函数的第二个参数传入。\n\n\n配置相对路径\n\ncommit 配置如果为相对路径为 .changesets 目录下的相对路径。\n\n例如创建 .changeset/my-commit-config.js 文件，定义如下内容：\n\nasync function getAddMessage(changeset, options) {}\n\nasync function getVersionMessage(releasePlan, options) {}\n\nmodule.exports = {\n  getAddMessage,\n  getVersionMessage,\n};\n\n\ncommit 配置为 ./my-commit-config.js 即可:\n\n{\n  \"changelog\": \"./my-commit-config.js\",\n   ...\n}\n\n\n\n使用模块工程方案\n\n自定义 commit 还可以使用模块工程方案进行管理，提供通用方案。\n\n自定义 Changelog 还可以使用模块工程方案进行管理，提供通用方案。\n\n使用 npx @modern-js/create 创建模块工程方案。\n\n? 请选择你想创建的工程类型 模块\n? 请填写项目名称 custom-commit\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n实现自定义内容。\n\nexport async function getAddMessage() {}\n\nexport async function getVersionMessage() {}\n\n\n将模块发布到 NPM。\n\n在目标仓库根目录安装对应模块，例如 custom-commit。\n\n配置 changeset 的 commit 配置为包名称。\n\n{\n  \"changelog\": \"custom-commit\",\n   ...\n}\n\n\n\n使用 Monorepo 工程方案\n\n如果你当前仓库为 Monorepo 工程方案，可以直接使用模块子项目进行管理。\n\n执行 pnpm run new 创建模块子项目。\n\n? 请选择你想创建的工程类型 模块\n? 请填写子项目名称 custom-commit\n? 请填写子项目目录名称 custom-commit\n? 请选择开发语言 TS\n\n\n实现自定义内容。\n\nexport async function getAddMessage() {}\n\nexport async function getVersionMessage() {}\n\n\n在 Monorepo 根目录添加子项目模块依赖，例如 custom-commit。\n\n{\n  \"devDependencies\": {\n    \"custom-commit\": \"workspace: *\",\n    ...\n  }\n}\n\n\n配置 changeset 的 commit 配置为包名称。\n\n{\n  \"commit\": \"custom-commit\",\n   ...\n}\n\n\n该模块发布到 NPM 后，依然可以和模块类型一样供其他仓库使用。","frontmatter":{"sidebar_position":7}},{"id":541,"title":"Changesets 配置文件","routePath":"/guides/topic-detail/changesets/config","lang":"zh","toc":[{"id":"配置介绍","text":"配置介绍","depth":2},{"id":"commit","text":"commit","depth":3},{"id":"access","text":"access","depth":3},{"id":"basebranch","text":"baseBranch","depth":3},{"id":"ignore","text":"ignore","depth":3},{"id":"fixed","text":"fixed","depth":3},{"id":"linked","text":"linked","depth":3},{"id":"updateinternaldependencies","text":"updateInternalDependencies","depth":3},{"id":"changelog","text":"changelog","depth":3},{"id":"___experimentalunsafeoptions_will_change_in_patch","text":"___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH","depth":3},{"id":"onlyupdatepeerdependentswhenoutofrange","text":"onlyUpdatePeerDependentsWhenOutOfRange","depth":4},{"id":"updateinternaldependents","text":"updateInternalDependents","depth":4},{"id":"usecalculatedversionforsnapshots","text":"useCalculatedVersionForSnapshots","depth":4}],"domain":"","content":"\n\n我们前面了解到，初始化 Modern.js 仓库时，会默认初始化 Changesets 的配置文件，即 .changeset/config.json\n文件，下面我们将详细了解一下该文件中支持哪些配置。\n\n\n配置介绍\n\n\ncommit\n\n类型： boolean\n\n默认值： false\n\n当配置该字段为 true 时，在执行 change 和 bump 命令时，将自动执行提交代码操作。\n\n默认的 commit 信息格式如下：\n\n\n\n该 commit 信息支持自定义，我们将在自定义提交 commit 信息章节进行详细介绍。\n\n\naccess\n\n类型：restricted | public\n\n默认值：restricted\n\n用于配置当前包的发布形式，如果配置为 restricted，将作为私有包发布，如果为 public，则发布公共范围包。\n\n对于仓库中存在部分包需要配置 access，可以在 package.json 中配置 publishConfig，例如：\n\n{\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org/\",\n    \"access\": \"public\"\n  }\n}\n\n\n对于不需要发布的包，可以在 package.json 中设置 private 为 true，阻止其进行发布。\n\n\nbaseBranch\n\n类型： string\n\n默认值： main\n\n仓库主分支。该配置用于计算当前分支的变更包并进行分类。\n\n\nignore\n\n类型：string[]\n\n默认值：[]\n\n用于声明执行 bump 命令时忽略的包，和 bump 命令的 --ignore 参数用法一致，注意两者不能同时使用。\n\n\nfixed\n\n类型： string[][]\n\n默认值：[]\n\n用于 monorepo 中对包进行分组，相同分组中的包版本号将进行绑定，每次执行 bump 命令时，同一分组中的包只要有一个升级版本号，其他会一起升级。\n支持使用正则匹配包名称。\n\n\nlinked\n\n类型： string[][]\n\n默认值：[]\n\n和 fixed 类似，也是对 monorepo 中对包进行分组，但是每次执行 bump 命令时，只有和 changeset\n声明的变更相关的包才会升级版本号，同一分组的变更包的版本号将保持一致。 支持使用正则匹配包名称。\n\n\nupdateInternalDependencies\n\n类型：patch | minor\n\n默认值：patch\n\n用于声明更新内部依赖的版本号规则。\n\n当执行 bump 命令升级版本号时，默认会自动更新仓库中使用该包的依赖声明。配置该字段为 minor 后，如果升级版本号为 patch\n类型，将不会自动更新引用依赖声明。\n\n例如：\n\npkg-a @ version 1.0.0\npkg-b @ version 1.0.0\n  depends on pkg-a at range `^1.0.0\n\n\n默认情况下，升级 pkg-a 至 1.0.1 时，会更新 pkg-b 中的 pkg-a 的依赖版本为 ^1.0.1。\n\n当配置 updateInternalDependencies 为 minor 时，升级 pkg-a 至 1.0.1 时，pkg-b 中的 pkg-a\n的依赖版本将不会更新，只有 pkg-a 升级版本号为 1.1.0 或者 2.0.0 时，才会更新 pkg-b 中的 pkg-a 的依赖。\n\n\nchangelog\n\n类型：boolean | string | [string, unknow]\n\n默认值：@changesets/cli/changelog\n\n生成 Changelog 规则。\n\n配置为 false 时，执行 bump 命令时，在 CHANGELOG.md 文件中只声明版本号，不声明其他 Changelog 信息。\n\n\n\n配置为 @changesets/cli/changelog 将使用官方提供的 Changlog 生成规则，将 changeset 信息转换为 Changlog\n内容。\n\n配置为数组时，第一个参数为自定义 NPM 包或者路径，第二个参数为需要传入的默认参数配置，自定义格式我们将在后续自定义 Changelog 章节讲解。\n\n\n___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH\n\n一些实验性配置。\n\nonlyUpdatePeerDependentsWhenOutOfRange\n\n类型：boolean\n\n默认值：false\n\n针对于 peerDependence 依赖的升级策略配置，默认针对 peerDependence 在 minor 和 major\n版本升级时，当前包会升级大版本。\n\n该配置设置为 true 时，仅当 peerDependence 声明包依赖超出声明范围时才更新版本。\n\nupdateInternalDependents\n\n类型： always | out-of-range\n\n默认值：always\n\n当执行 bump 命令升级版本号时，默认会自动更新仓库中使用该包的依赖声明。当设置该参数为 out-of-range\n时，只有当依赖声明超出范围时才会更新仓库中使用该包的依赖声明。\n\nuseCalculatedVersionForSnapshots\n\n类型：boolean\n\n默认值：false\n\n使用快照发布时，默认会使用 0.0.0-timestamp\n的版本格式，保证用户可以正常使用预发布版本。当你需要忽略上述问题，使用正常的版本号格式时，即当前版本为 1.0.1\n快照版本期望使用1.0.1-timestamp，可配置该参数为 true。","frontmatter":{"sidebar_position":5}},{"id":542,"title":"使用 Github 相关工具","routePath":"/guides/topic-detail/changesets/github","lang":"zh","toc":[{"id":"bot","text":"BOT","depth":2},{"id":"安装","text":"安装","depth":3},{"id":"配置","text":"配置","depth":3},{"id":"使用","text":"使用","depth":3},{"id":"未添加-changeset","text":"未添加 changeset","depth":4},{"id":"已添加-changeset","text":"已添加 changeset","depth":4},{"id":"不需要-changeset","text":"不需要 changeset","depth":4},{"id":"action","text":"Action","depth":2},{"id":"自动创建-release-pull-request","text":"自动创建 Release Pull Request","depth":3},{"id":"使用-1","text":"使用","depth":3},{"id":"自动-release","text":"自动 Release","depth":3},{"id":"使用-2","text":"使用","depth":4}],"domain":"","content":"\n\n\nBOT\n\n在 Github 上，Changesets 提供了机器人用于检测当前 Pull Request 是否存在 changeset，并提供了 UI 界面添加和修改\nchangeset。\n\n\n安装\n\n点击进入链接，右上角选择安装，确认即可安装成功。\n\n\n\n\n配置\n\n安装成功后，即可进入配置页面，根据需求选择应用仓库即可。\n\n\n\n\n使用\n\n配置完成后，该机器人将会自动 check 每个 Pull Request 是否添加了 changeset，并通过回复的方式给到提示信息。\n\n未添加 changeset\n\n\n\n可在仓库执行 pnpm run change 添加 changeset，也可直接点击下方第二个链接填写 changeset。\n\n已添加 changeset\n\n\n\n可点击下方链接修改和添加新的 changeset。\n\n不需要 changeset\n\n可直接忽略未添加时的提示信息，它不会造成 Pull Request 不能合并的问题。\n\n\nAction\n\n\n自动创建 Release Pull Request\n\nModern.js 提供了自动创建发版 Pull Request 的 Github Action，提供基于选择的分支自动执行 bump 操作，更新 lock\n文件及创建 Pull Request 操作。\n\n\n使用\n\n在仓库中创建 .github/workflows/release-pull-request.yml 文件，填入以下内容：\n\nname: Release Pull Request\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        description: 'Release Version(v1.0.0)'\n        required: true\n\njobs:\n  release:\n    name: Create Release Pull Request\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@master\n        with:\n          # This makes Actions fetch only one branch to release\n          fetch-depth: 100\n\n      - name: Create Release Pull Request\n        uses: modern-js-dev/actions@main\n        with:\n          # this expects you to have a script called release which does a build for your packages and calls changeset publish\n          versionNumber: ${{ github.event.inputs.version }}\n          type: 'pull request'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          REPOSITORY: ${{ github.repository }}\n          REF: ${{ github.ref }}\n\n\n将 Workflow 合并到主分支后，进入 Github 仓库对应的 Action 页面，选择 Release Pull Request：\n\n\n\n选择本次发布的分支并填入版本号，版本号格式推荐 v1.0.0，点击 Run workflow 按钮：\n\n\n\nworkflow 运行完成后将自动创建 Release-${version} 的 Pull Request，自动完成 bump changeset\n相关版本号并更新 lock 文件，Pull Request 的内容为执行 gen-release-note 命令自动生成的 Release Note。\n\n\n\n\n自动 Release\n\nModern.js 提供了自动创建发版 Pull Request 的 Github Action，提供基于选择的分支自动执行 release 操作，将包发布到\nNPM 上。\n\n使用\n\n在仓库中创建 .github/workflows/release.yml 文件，填入以下内容：\n\nname: Release\n\non:\n  workflow_dispatch:\n    inputs:\n      version:\n        type: choice\n        description: 'Release Version(canary, alpha, pre, latest)'\n        required: true\n        default: 'canary'\n        options:\n          - canary\n          - alpha\n          - pre\n          - latest\n      branch:\n        description: 'Release Branch(confirm release branch)'\n        required: true\n        default: 'main'\n\njobs:\n  release:\n    name: Release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@master\n        with:\n          # This makes Actions fetch only one branch to release\n          fetch-depth: 1\n\n      - name: Release\n        uses: modern-js-dev/actions@main\n        with:\n          # this expects you to have a script called release which does a build for your packages and calls changeset publish\n          version: ${{ github.event.inputs.version }}\n          branch: ${{ github.event.inputs.branch }}\n          type: 'release'\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n          REPOSITORY: ${{ github.repository }}\n          REF: ${{ github.ref }}\n\n\n配置仓库的 NPM_TOKEN:\n\n\n\n将 Workflow 合并到主分支后，进入 Github 仓库对应的 Action 页面，选择 Release：\n\n\n\n选择分支名称和发布版本类型，点击 Run workflow 按钮：\n\n\n\nWorkflow 将自动完成仓库 build 和发布到 NPM 流程。","frontmatter":{"sidebar_position":9}},{"id":543,"title":"认识 Changesets","routePath":"/guides/topic-detail/changesets/introduce","lang":"zh","toc":[{"id":"特点","text":"特点","depth":2},{"id":"初始化","text":"初始化","depth":2},{"id":"命令","text":"命令","depth":2}],"domain":"","content":"\n\nModern.js 默认集成了 Changesets 用于模块和 Monorepo 工程方案项目中的包版本管理。\n\n\n特点\n\nChangesets 具有以下几个特点：\n\n * 在开发时，需要开发者提供本次变更涉及的包名称、升级版本类型(pathch、minor、major)及变更信息，即 changeset。\n\n * 在发布版本时，会根据 changeset 自动升级对应包的版本号，并在对应的包中生成 Changelog 信息。\n\n * 在 Monorepo 场景中，changeset 会自动生成仓库依赖图，升级时只会升级变更包及相关依赖包的版本号。\n\n\n初始化\n\nModern.js 默认创建的模块和 Monorepo 工程方案项目已经初始化完成 Changesets，在项目根目录会自动创建 .changeset 目录，及\n.changeset/config.json 的配置文件。\n\n并且，Modern.js 在其对应的工程方案工具 @modern-js/module-tools 和 @modern-js/monorepo-tools 提供了\nChangesets 相应的命令，无需再手动安装 Changesets 相关依赖。\n\nChangesets 默认配置如下：\n\n{\n  \"$schema\": \"https://unpkg.com/@changesets/config@2.0.0/schema.json\",\n  \"changelog\": \"@changesets/cli/changelog\",\n  \"commit\": false,\n  \"linked\": [],\n  \"access\": \"restricted\",\n  \"baseBranch\": \"main\",\n  \"updateInternalDependencies\": \"patch\",\n  \"ignore\": []\n}\n\n\n配置文件提供了生成 Changesets 的一些基本配置，字段详细介绍请参考后续章节： Changesets 配置文件。\n\n\n命令\n\n * change 创建一个 changeset，执行完成该命令后会自动在 .changeset 目录生成一个 changeset 文件。\n\n * bump 根据当前 changeset 升级对应包版本号。\n\n * pre 标记进入和退出 pre release 模式，在 pre release 模式下执行 bump 命令，将会生成\n   x.x.x-${pre-tag}.x 的版本号格式。\n\n * release 发布包到 NPM。\n\n * status 查看当前 changeset 状态。\n\n * gen-release-note 根据当前的 chagneset 状态生成 Release Note 信息。\n\n具体命令支持的参数可以查看后续对应章节介绍。","frontmatter":{"sidebar_position":1}},{"id":544,"title":"自定义 Release Note 格式","routePath":"/guides/topic-detail/changesets/release-note","lang":"zh","toc":[{"id":"信息","text":"信息","depth":2},{"id":"自定义-release-note-所需信息","text":"自定义 Release Note 所需信息","depth":3},{"id":"getreleaseinfo","text":"getReleaseInfo","depth":4},{"id":"使用获取的信息生成-release-note","text":"使用获取的信息生成 Release Note","depth":3},{"id":"getreleasenoteline","text":"getReleaseNoteLine","depth":4},{"id":"使用自定义模块","text":"使用自定义模块","depth":2},{"id":"配置相对路径","text":"配置相对路径","depth":3},{"id":"使用模块工程方案","text":"使用模块工程方案","depth":3},{"id":"使用-monorepo-工程方案","text":"使用 Monorepo 工程方案","depth":3}],"domain":"","content":"\n\nModern.js 提供了 modern gen-release-note 命令，支持通过当前存在的 changeset 和 git commit 信息自动生成\nRelease Note 信息，在发布命令执行之前，可以通过执行该命令生成本次发布的 Release Note。\n\n默认生成的 Release Note 格式为：\n\n[[#1220](https://github.com/modern-js-dev/modern.js/pull/1220)] feat: support bff operators -- Ming\n\n\n根据 commit 信息获取 changeset 的 Pull Request ID，并生成 Github 的链接，内容为 changeset 的\nchangelog 信息和作者信息。\n\n当默认生成 Release Note 逻辑不能满足需求时，支持自定义 Release Note 格式。\n\n\n信息\n\n\n自定义 Release Note 所需信息\n\n生成 Release Note 信息需要先收集一些信息，比如 commit ID、Pull Request ID、commit message 等等。\n\n该逻辑可通过 getReleaseInfo 函数实现。\n\ngetReleaseInfo\n\nParams\n\n * commit\n\n类型： string;\n\n当前 changeset 对应的 commit message 信息。\n\n执行 git log --pretty=format:%h--%s--%an .changeset/${changeset.id}.md 的结果。\n\n * commitObj\n\n初步解析 commit 获取基本信息。\n\ninterface Commit {\n  id: string; // commit id\n  type: 'feature' | 'fix'; // commit 类型，默认通过开头字符串如果为 fix，类型为 fix，其他为 feature\n  repository?: string; // 参数传入的 repo 信息或者 package.json 中定义的 repository 信息\n  pullRequestId?: string;\n  author?: string;\n  message: string; // commit message\n  summary: string; // changeset summary\n  [key: string]: string | undefined;\n}\n\n\n返回值\n\ncommitObj， 补充后完整的 commit 对象。\n\n默认实现\n\nModern.js 的默认实现为：根据 commit 信息拆分出 Pull Request ID 和作者，加入到 commitObj 中。\n\nfunction getReleaseInfo(commit: string, commitObj: Commit) {\n  const commitRegex = /(.*)\\(#(\\d*)\\)/;\n\n  const [, message, author] = commit.split('--');\n\n  commitObj.author = author;\n\n  if ((message || commitObj.summary).match(commitRegex)) {\n    const [, messageShort, pullRequestId] = (\n      message || commitObj.summary\n    ).match(commitRegex)!;\n    commitObj.pullRequestId = pullRequestId;\n    commitObj.message = messageShort.trim();\n  }\n\n  return commitObj;\n}\n\n\n\n使用获取的信息生成 Release Note\n\n根据 getReleaseInfo 中获取的 commit 对象信息，生成对应的 Release Note。\n\n该逻辑可通过 getReleaseNoteLine 函数实现。\n\ngetReleaseNoteLine\n\nParams\n\n * commit\n\n类型和上述 commitObj 类型一致。\n\n返回值\n\n生成的 Release Note。\n\n默认实现\n\nModern.js 的默认实现为：\n\nfunction formatSummary(summary: string, pullRequestId?: string) {\n  const [firstLine, ...futureLines] = summary\n    .split('\\n')\n    .map(l => l.trimRight());\n\n  let returnVal = firstLine;\n\n  if (futureLines.length > 0) {\n    if (pullRequestId) {\n      returnVal = `\\n\\n  ${returnVal}`;\n    } else {\n      returnVal = `\\n  ${returnVal}`;\n    }\n    returnVal += `\\n\\n  ${futureLines\n      .filter(l => Boolean(l))\n      .map(l => l)\n      .join('\\n\\n')}`;\n  }\n  return returnVal;\n}\n\nexport async function getReleaseNoteLine(\n  commit: Commit,\n  customReleaseNoteFunction?: CustomReleaseNoteFunction,\n) {\n  if (customReleaseNoteFunction?.getReleaseNoteLine) {\n    return customReleaseNoteFunction.getReleaseNoteLine(commit);\n  }\n\n  const { repository, pullRequestId, summary } = commit;\n  if (pullRequestId && repository) {\n    return `- [#${pullRequestId}](https://github.com/${repository}/pull/${pullRequestId}) ${formatSummary(\n      summary,\n      pullRequestId,\n    )}\\n`;\n  }\n  if (pullRequestId) {\n    return `#${pullRequestId} ${formatSummary(summary, pullRequestId)}\\n`;\n  }\n  return `${formatSummary(summary, pullRequestId)}\\n`;\n}\n\n\n\n使用自定义模块\n\ngen-release-note 命令支持 --custom 参数，该参数可传入自定义 release note 模块的模块名称或者路径。\n\n\n配置相对路径\n\ncustom 参数值如果为相对路径为项目跟目录。\n\n例如创建 scripts/my-release-note-config.js 文件，定义如下内容：\n\nfunction getReleaseInfo(commit, commitObj) {\n  return commitObj;\n}\n\nfunction getReleaseNoteLine(commit) {}\n\nmodule.exports = {\n  getReleaseInfo,\n  getReleaseNoteLine,\n};\n\n\n执行下面命令：\n\npnpm run gen-release-note -- --custom ./scripts/my-release-note-config.js\n\n\n也可以把命令参数直接定义到 package.json 中：\n\n{\n    \"scripts\": {\n        ...\n        \"gen-release-note\": \"modern gen-release-note --custom ./scripts/my-release-note-config.js\"\n    },\n    ...\n}\n\n\n直接执行命令 pnpm run gen-release-note 即可。\n\n\n使用模块工程方案\n\ncustom 参数值还可以使用模块工程方案进行管理，提供通用方案。\n\n 1. 使用 npx @modern-js/create 创建模块工程方案。\n\n? 请选择你想创建的工程类型 模块\n? 请填写项目名称 custom-release-note\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n 2. 实现自定义内容。\n\nexport function getReleaseInfo() {}\n\nexport function getReleaseNoteLine() {}\n\n\n 3. 将模块发布到 NPM。\n 4. 在目标仓库根目录安装对应模块，例如 custom-release-note。\n 5. 执行 gen-release-note 命令添加 custom 参数\n\npnpm run gen-release-note -- --custom custom-release-note\n\n\n\n使用 Monorepo 工程方案\n\n如果你当前仓库为 Monorepo 工程方案，可以直接使用模块子项目进行管理。\n\n 1. 执行 pnpm run new 创建模块子项目\n\n? 请选择你想创建的工程类型 模块\n? 请填写子项目名称 custom-release-note\n? 请填写子项目目录名称 custom-release-note\n? 请选择开发语言 TS\n\n\n 2. 实现自定义内容。\n\nexport function getReleaseInfo() {}\n\nexport function getReleaseNoteLine() {}\n\n\n 3. 在 Monorepo 根目录添加子项目模块依赖，例如 custom-release-note。\n\n{\n  \"devDependencies\": {\n    \"custom-release-note\": \"workspace: *\",\n    ...\n}\n\n\n 4. 执行 gen-release-note 命令添加 --custom 参数\n\npnpm run gen-release-note -- --custom custom-release-note\n\n\n该模块发布到 NPM 后，依然可以和模块类型一样供其他仓库使用。","frontmatter":{"sidebar_position":8}},{"id":545,"title":"发布预发布版本","routePath":"/guides/topic-detail/changesets/release-pre","lang":"zh","toc":[{"id":"步骤","text":"步骤","depth":2},{"id":"执行以下命令升级预发布版本版本号","text":"执行以下命令升级预发布版本版本号：","depth":4},{"id":"检查相关变更并提交","text":"检查相关变更并提交","depth":4},{"id":"执行以下命令发布预发布版本","text":"执行以下命令发布预发布版本：","depth":4},{"id":"注意事项","text":"注意事项","depth":2},{"id":"退出预发布模式","text":"退出预发布模式","depth":3}],"domain":"","content":"\n\n在发布正式版本之前，我们也需要发布预发布版本供内部测试和用户使用，Changesets 也支持发布预发布版本。\n\n\n步骤\n\nINFO\n\n以下示例命令都以 pnpm 作为包管理工具进行，如果需要使用其他包管理工具，请按需求进行替换。\n\n执行以下命令升级预发布版本版本号：\n\npnpm run bump -- --canary --preid <preid>\n\n\npreid 为预发布版本标记，例如 alpha、beta 等，默认值为 next。\n\n使用 --canary 参数后，bump 命令由以下三个步骤完成：\n\n * changeset pre enter <preid> 进入预发布模式\n\n * changeset version 升级版本号\n\n * changeset pre exit 退出预发布模式\n\n检查相关变更并提交\n\n检查相关版本号变更是否正确，并提交变更。\n\n建议预发布操作不在主分支上进行，不合入主分支，当预发布验证完成后，直接基于主分支发布正式版本。\n\n执行以下命令发布预发布版本：\n\npnpm run release -- --tag <tag>\n\n\n发布预发布版本一定要使用 --tag 参数，参数值最好和 preid 值相同，方便用户使用。\n\n\n注意事项\n\n\n退出预发布模式\n\n在进入预发布模式后，Changesets 会自动在 .changeset 目录创建 pre.json\n文件用于记录当时进入预发布模式的一些状态信息，当出现状态信息和当前仓库状态不一致时，可直接删除该文件退出预发布模式。","frontmatter":{"sidebar_position":4}},{"id":546,"title":"发布正式版本","routePath":"/guides/topic-detail/changesets/release","lang":"zh","toc":[{"id":"步骤","text":"步骤","depth":2},{"id":"模块工程方案","text":"模块工程方案","depth":3},{"id":"在根目录执行以下命令","text":"在根目录执行以下命令：","depth":4},{"id":"确认并提交当前变更","text":"确认并提交当前变更：","depth":4},{"id":"在根目录执行以下命令发布包至-npm","text":"在根目录执行以下命令发布包至 NPM：","depth":4},{"id":"push-对应的-tag-信息至远程仓库","text":"push 对应的 tag 信息至远程仓库：","depth":4},{"id":"monorepo-工程方案","text":"Monorepo 工程方案","depth":3},{"id":"在根目录执行以下命令-1","text":"在根目录执行以下命令：","depth":4},{"id":"确认并提交当前变更-1","text":"确认并提交当前变更：","depth":4},{"id":"在根目录执行以下命令发布包至-npm-1","text":"在根目录执行以下命令发布包至 NPM：","depth":4},{"id":"push-对应的-tag-信息至远程仓库-1","text":"push 对应的 tag 信息至远程仓库：","depth":4},{"id":"参数","text":"参数","depth":2},{"id":"bump-命令参数","text":"bump 命令参数","depth":3},{"id":"release-命令参数","text":"release 命令参数","depth":3},{"id":"升级版本策略","text":"升级版本策略","depth":2},{"id":"dependencies-或者-devdependencies-依赖","text":"dependencies 或者 devDependencies 依赖","depth":3},{"id":"patch-版本依赖只升级自身","text":"patch 版本依赖只升级自身","depth":4},{"id":"major--minor-版本自身升级-major-或者-minor-版本号依赖包升级-patch-版本号","text":"major / minor 版本自身升级 major 或者 minor 版本号，依赖包升级 patch 版本号","depth":4},{"id":"peerdependencies-依赖","text":"peerDependencies 依赖","depth":3},{"id":"patch-版本依赖自身和依赖包都升级-patch-版本号","text":"patch 版本依赖自身和依赖包都升级 patch 版本号","depth":4},{"id":"major--minor-版本自身升级-major-或者-minor-版本号依赖包升级-major-版本号","text":"major / minor 版本自身升级 major 或者 minor 版本号，依赖包升级 major 版本号","depth":4},{"id":"修改-peerdependencies-的升级策略","text":"修改 peerDependencies 的升级策略","depth":4}],"domain":"","content":"\n\n发版正式版本时，我们需要根据开发过程中生成的 changeset 进行相关包版本号升级，并执行 publish 命令发布到 NPM 上。\n\n\n步骤\n\nINFO\n\n以下示例命令都以 pnpm 作为包管理工具进行，如果需要使用其他包管理工具，请按需求进行替换。\n\n\n模块工程方案\n\n在根目录执行以下命令：\n\npnpm run bump\n\n\n\n\n执行该命令时，changeset 会自动进行以下操作：\n\n * 删除 .changesets 目录下的所有 changeset 文件。\n\n * 根据 changeset 信息升级该包版本号。\n\n * 在根目录的 CHANGELOG.md 文件中写入 Changelog 信息，文件不存在时会自动创建。\n\n确认并提交当前变更：\n\ngit add .\ngit commit -m \"release: bump package\"\n\n\n在根目录执行以下命令发布包至 NPM：\n\npnpm run release\n\n\n\n\npush 对应的 tag 信息至远程仓库：\n\ngit push --follow-tags\n\n\n\nMonorepo 工程方案\n\n在根目录执行以下命令：\n\npnpm run bump\n\n\n\n\n执行该命令时，changeset 会自动进行以下操作：\n\n * 删除 .changesets 目录下的所有 changeset 文件。\n\n * 根据 changeset 信息升级相关包的版本号，除了显示写入 changeset 的包，执行命令时还会将 Monorepo\n   中所有的包进行依赖关系分析，如果需要升级，也会对应的自动升级版本号。\n\n * 在需要升级的包目录的 CHANGELOG.md 文件中写入 Changelog 信息，文件不存在时会自动创建。\n\n确认并提交当前变更：\n\nINFO\n\n需确认自动升级的版本号是否符合预期，如果需要了解版本升级策略，请查看升级版本策略。\n\ngit add .\ngit commit -m \"release: bump package\"\n\n\n在根目录执行以下命令发布包至 NPM：\n\npnpm run release\n\n\n执行该命令时，将会依次判断 Monorepo 中所有的 packages 的版本是否在 NPM 中存在，如果不存在将会执行 publish 命令发布。\n\nWARNING\n\n当 Monorepo 中包之间依赖关系使用 workspace 声明时，注意不要直接在 package 对应的子目录直接执行 npm publish 发布\npackage，使用 relesae 命令在发布时将会自动去除 workspace 声明，确保 NPM 包发布之后可用。\n\npush 对应的 tag 信息至远程仓库：\n\ngit push --follow-tags\n\n\n\n参数\n\n\nbump 命令参数\n\n * --snapshot 生成基于时间戳的版本号。\n\npnpm run bump -- --snapshot canary\n\n\n执行完成后，对应的升级版本号将会变成 0.0.0-canary-20220622092823 的形式，其中 canary 为 snapshot\n配置的标记，如果不配置，将直接生成 0.0.0-20220622092823 的形式。\n\n该参数主要用于发布临时测试版本进行测试，不需要进行代码提交。\n\n * --ignore 发布时手动忽略部分包。\n\n例如本次发布你需要忽略 module-2 包：\n\npnpm run bump -- --ignore module-2\n\n\n命令执行完成后，将会忽略 module-2 包的更新。注意如果存在包依赖 module-2，需要将对应包也加入到 ignore 参数中，否则 bump\n命令将执行失败。\n\n加入多个包的使用姿势为：\n\npnpm run bump -- --ignore module-2 --ignore module-3\n\n\n\nrelease 命令参数\n\n * --otp 使用 npm token 执行 relesae 命令发布对应包\n\npnpm run relese -- --otp <token>\n\n\n * --tag 本地发布使用特定的 tag，默认使用 latest\n\npnpm run release -- --tag <tag>\n\n\n * --ignore-scripts 发布时忽略 npm scripts。\n\n执行 publish 命令时，npm 会自动触发很多命令，比如 prepare、prepublish，使用该参数可以忽略这些命令执行。该参数仅支持在使用\npnpm 的 Monorepo 中使用。\n\npnpm run release -- --ignore-scripts\n\n\n * --no-git-checks 发布时忽略检查当前分支。\n\n执行发布命令时，默认会自动检查当前分支是否为发布分支，是否存在未提交变更等等，使用该参数可以忽略 git 相关检查。\n\npnpm run release -- --no-git-checks\n\n\n\n升级版本策略\n\n\ndependencies 或者 devDependencies 依赖\n\npatch 版本依赖只升级自身\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 dependencies 中存在 module-1。\n\n当前存在的 changeset 为 module-1 的 patch 版本升级。\n\n执行 bump 命令后将只会升级 module-1 的 patch 版本号。\n\nmajor / minor 版本自身升级 major 或者 minor 版本号，依赖包升级 patch 版本号\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 dependencies 中存在module-1。\n\n当前存在的 changeset 为 module-1 的 minor 版本升级。\n\n执行 bump 命令后 module-1 会升级 minor 版本号，module -2 会升级 patch 版本号。\n\n\npeerDependencies 依赖\n\npatch 版本依赖自身和依赖包都升级 patch 版本号\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 peerDependencies 中存在 module-1。\n\n当前存在的 changeset 为 module-1 的 patch 版本升级。\n\n执行 bump 命令后将 module-1 和 module-2 都升级 patch 版本号。\n\nmajor / minor 版本自身升级 major 或者 minor 版本号，依赖包升级 major 版本号\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 peerDependencies 中存在 module-1。\n\n当前存在的 changeset 为 module-1 的 minor 版本升级。\n\n执行 bump 命令后将 module-1 将升级 minor 版本号， module-2 升级 major 版本号。\n\n修改 peerDependencies 的升级策略\n\npeerDependencies 的升级策略支持通过配置 onlyUpdatePeerDependentsWhenOutOfRange\n来修改依赖升级策略，当只有超出声明的版本类型范围时，才对应升级 peerDependencies。\n\n{\n  \"___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH\": {\n    \"onlyUpdatePeerDependentsWhenOutOfRange\": true\n  },\n  ...\n}\n\n\n例如存在如下场景：\n\nMonorepo 中存在两个包，module-1 和 module-2，module-2 的 peerDependencies 中存在 module-1，声明\nmodule-1 的版本号使用 ^。\n\n当前存在的 changeset 为 module-1 的 patch 或者 minor 版本升级。\n\n执行 bump 命令后只升级 module-1 版本号。\n\n需注意，如果包版本号在 0.x.x 的范围时，minor 版本号升级也是超出声明的版本类型范围的。","frontmatter":{"sidebar_position":3}},{"id":547,"title":"扩展插件 Hook","routePath":"/guides/topic-detail/framework-plugin/extend","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2},{"id":"创建-hook","text":"创建 Hook","depth":3},{"id":"使用-hook","text":"使用 Hook","depth":3}],"domain":"","content":"\n\n本小节介绍如何通过动态注册 Hook 模型 的方式来扩展插件 Hook。\n\n\n示例\n\n这里我们用一个简单的例子演示一下。假设我们要添加一些管理控制台输出信息的 Hook。\n\n首先我们初始化一个空的项目文件，并添加基础依赖：\n\n$ npx @modern-js/create modern-js-demo\n\n\n\n创建 Hook\n\n我们先创建一个 Hook 模型：\n\n\n\nconst message = createWaterfall<string[]>();\n\n\n然后注册它：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  registerHook: {\n    message,\n  },\n});\n\n\n添加 Hook 类型：\n\ndeclare module '@modern-js/core' {\n  export interface Hooks {\n    message: typeof message;\n  }\n}\n\n\n\n使用 Hook\n\n创建插件，通过 commands Hook 函数，添加命令处理逻辑：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    return {\n      commands({ program }) {\n        program.command('message').action(async () => {\n          const hookRunners = api.useHookRunners();\n          const messages = hookRunners.message([]);\n          console.log(messages.join('\\n'));\n        });\n      },\n    };\n  },\n});\n\n\n最后 config/plugin/myPlugin.ts 的状态是：\n\n\n\n\nconst message = createWaterfall<string[]>();\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  registerHook: {\n    message,\n  },\n\n  setup(api) {\n    return {\n      commands({ program }) {\n        program.command('message').action(async () => {\n          const hookRunners = api.useHookRunners();\n          const messages = hookRunners.message([]);\n          console.log(messages.join('\\n'));\n        });\n      },\n    };\n  },\n});\n\ndeclare module '@modern-js/core' {\n  export interface Hooks {\n    message: typeof message;\n  }\n}\n\n\n然后在 modern.config.ts 中添加这个插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n这时运行 npx modern message 就会执行相关逻辑，但由于没有收集到任何信息，所以控制台输出为空。\n\n那这里我们添加一个：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'other-plugin',\n\n  setup(api) {\n    return {\n      message(list) {\n        return [...list, '[foo] line 0', '[foo] line 1'];\n      },\n    };\n  },\n});\n\n\n将它添加到配置中：\n\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin(), otherPlugin()],\n});\n\n\n这时运行 npx modern message 就可以在控制台看到信息了：\n\n$ modern message\n[foo] line 0\n[foo] line 1\n\n\n以上面这种方式就可以扩展出拥有各种能力的插件 Hook。","frontmatter":{"title":"扩展插件 Hook","sidebar_position":5}},{"id":548,"title":"Hook 列表","routePath":"/guides/topic-detail/framework-plugin/hook-list","lang":"zh","toc":[{"id":"cli","text":"CLI","depth":2},{"id":"config","text":"config","depth":3},{"id":"validateschema","text":"validateSchema","depth":3},{"id":"prepare","text":"prepare","depth":3},{"id":"afterprepare","text":"afterPrepare","depth":3},{"id":"commands","text":"commands","depth":3},{"id":"beforeexit","text":"beforeExit","depth":3},{"id":"beforedev","text":"beforeDev","depth":3},{"id":"afterdev","text":"afterDev","depth":3},{"id":"beforecreatecompiler","text":"beforeCreateCompiler","depth":3},{"id":"aftercreatecompiler","text":"afterCreateCompiler","depth":3},{"id":"beforeprintinstructions","text":"beforePrintInstructions","depth":3},{"id":"beforebuild","text":"beforeBuild","depth":3},{"id":"afterbuild","text":"afterBuild","depth":3},{"id":"modifyentryimports","text":"modifyEntryImports","depth":3},{"id":"modifyentryexport","text":"modifyEntryExport","depth":3},{"id":"modifyentryruntimeplugins","text":"modifyEntryRuntimePlugins","depth":3},{"id":"modifyentryrenderfunction","text":"modifyEntryRenderFunction","depth":3},{"id":"modifyfilesystemroutes","text":"modifyFileSystemRoutes","depth":3},{"id":"modifyserverroutes","text":"modifyServerRoutes","depth":3},{"id":"modifyasyncentry","text":"modifyAsyncEntry","depth":3},{"id":"htmlpartials","text":"htmlPartials","depth":3},{"id":"server","text":"Server","depth":2},{"id":"create","text":"create","depth":3},{"id":"preparewebserver","text":"prepareWebServer","depth":3},{"id":"prepareapiserver","text":"prepareApiServer","depth":3},{"id":"runtime","text":"Runtime","depth":2},{"id":"init","text":"init","depth":3},{"id":"hoc","text":"hoc","depth":3},{"id":"provide","text":"provide","depth":3},{"id":"client","text":"client","depth":3},{"id":"server-1","text":"server","depth":3}],"domain":"","content":"\n\n在 Modern.js 中暴露了三类插件：CLI、Runtime、Server。下面列举下各类中的 Hook：\n\n\nCLI\n\n\nconfig\n\n * 功能：收集配置\n * 执行阶段：解析完 modern.config.ts 中的配置之后\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      config: () => {\n        return {\n          /** some config */\n        };\n      },\n    };\n  },\n});\n\n\n这里返回的配置信息，会被收集和统一处理合并。\n\n\nvalidateSchema\n\n * 功能：收集各个插件中配置的用来校验用户配置的 JSON Schema\n * 执行阶段：config Hook 运行完之后。\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      validateSchema: () => {\n        return {\n          // target is field\n          target: 'foo',\n          schema: {\n            type: 'string',\n          },\n        };\n      },\n    };\n  },\n});\n\n\n这里返回的 JSON Schema 会用来校验 modern.config.js 中的配置信息。\n\n比如这里返回：\n\n{\n  \"target\": \"foo\",\n  \"schema\": {\n    \"type\": \"string\"\n  }\n}\n\n\n就可以在 modern.config.ts 中这样配置：\n\nexport default defineConfig({\n  foo: 'test',\n});\n\n\n如果是别的类型，校验就不通过会报错，比如这样：\n\nexport default defineConfig({\n  foo: {},\n});\n\n\n就会报错：\n\n$ modern dev\n  1 | {\n> 2 |   \"foo\": {},\n    |   ^^^^^  Property foo is not expected to be here\n\n\n\nprepare\n\n * 功能：运行主流程的前置准备流程\n * 执行阶段：校验完配置之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      prepare: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterPrepare\n\n * 功能：运行前置准备流程的之后的任务\n * 执行阶段：前置准备流程之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterPrepare: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\ncommands\n\n * 功能：为 command 添加新的命令\n * 执行阶段：prepare Hook 运行完之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ program: Command; }, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      commands: ({ program }) => {\n        program.command('foo').action(async () => {\n          // do something\n          console.log('foo');\n        });\n      },\n    };\n  },\n});\n\n\n将上面这个插件添加到 modern.config.ts 中：\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n运行 modern foo 就可以看到控制台输出：\n\n$ modern foo\nfoo\n\n\n\nbeforeExit\n\n * 功能：在退出进程前，重置一些文件状态\n * 执行阶段：进程退出之前\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, void>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeExit: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforeDev\n\n * 功能：运行 dev 主流程的之前的任务\n * 执行阶段：dev 命令运行时，项目开始启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeDev: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterDev\n\n * 功能：运行 dev 主流程的之后的任务\n * 执行阶段：dev 命令运行时，项目启动完成之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterDev: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforeCreateCompiler\n\n * 功能：在中间件函数中可以拿到创建 Webpack Compiler 的 Webpack 配置\n * 执行阶段：创建 Webpack Compiler 之前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ webpackConfigs: Configuration[];}, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeCreateCompiler: ({ webpackConfigs }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterCreateCompiler\n\n * 功能：在中间件函数中可以拿到创建的 Webpack Compiler\n * 执行阶段：创建 Webpack Compiler 之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ compiler: Compiler | MultiCompiler | undefined; },\n   unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterCreateCompiler: ({ compiler }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nbeforePrintInstructions\n\n * 功能：在中间件函数中可以拿到即将打印的日志信息，并对其进行修改\n * 执行阶段：打印日志信息之前执行\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ instructions: string }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforePrintInstructions: ({ instructions }) => {\n        // do something\n        return {\n          instructions: [...instructions, 'some new message'],\n        };\n      },\n    };\n  },\n});\n\n\n\nbeforeBuild\n\n * 功能：运行 build 主流程的之前的任务，可以拿到构建的 Webpack 配置\n * 执行阶段：build 命令运行时，项目构建启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ webpackConfigs: Configuration[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      beforeBuild: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nafterBuild\n\n * 功能：运行 build 主流程的之后的任务\n * 执行阶段：build 命令运行时，项目构建完成之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<void, unknown>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      afterBuild: () => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryImports\n\n * 功能：用于修改、添加生成入口文件中的 import 语句\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ imports: ImportStatement[]; entrypoint: Entrypoint; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryImports({ entrypoint, imports }) {\n        // 添加 ``\n        imports.push({\n          value: 'react',\n          specifiers: [\n            {\n              imported: 'unmountComponentAtNode',\n            },\n          ],\n        });\n\n        return { entrypoint, imports };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryExport\n\n * 功能：用于修改生成入口文件中的 export 语句\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; exportStatement: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryImports({ entrypoint, exportStatement }) {\n        return {\n          entrypoint,\n          exportStatement: [`export const foo = 'test'`, exportStatement].join(\n            '\\n',\n          ),\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryRuntimePlugins\n\n * 功能：用于添加、修改生成入口文件中的 Runtime 插件\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; plugins: RuntimePlugin[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryRuntimePlugins({ entrypoint, plugins }) {\n        const name = 'customPlugin';\n        const options = {\n          /** 可序列化的内容 */\n        };\n\n        return {\n          plugins: [\n            ...plugins,\n            {\n              name,\n              options: JSON.stringify(options),\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyEntryRenderFunction\n\n * 功能：用于修改生成入口文件中 render 函数\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; code: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyEntryRenderFunction({ entrypoint, code }) {\n        const customRender = `/** render function body */`;\n        return {\n          entrypoint,\n          code: customRender,\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyFileSystemRoutes\n\n * 功能：用于修改生成前端页面路由文件中的内容，内容都是需要可序列化的\n * 执行阶段：生成前端路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; routes: Route[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyFileSystemRoutes({ entrypoint, routes }) {\n        return {\n          entrypoint,\n          routes: [\n            ...routes,\n            {\n              path: '/custom_page',\n              component: require.resolve('./Component'),\n              exact: true,\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n这样就为前端新增了一个页面路由。\n\n\nmodifyServerRoutes\n\n * 功能：用于修改生成服务器路由中的内容\n * 执行阶段：生成 Server 路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ routes: ServerRoute[]; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyServerRoutes({ routes }) {\n        return {\n          routes: [\n            ...routes,\n            {\n              urlPath: '/api/foo',\n              isApi: true,\n              entryPath: '',\n              isSPA: false,\n              isSSR: false,\n            },\n          ],\n        };\n      },\n    };\n  },\n});\n\n\n\nmodifyAsyncEntry\n\n * 功能：用于修改包裹入口文件的异步模块，参见 source.enableAsyncEntry\n * 执行阶段：生成入口文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; code: string; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      modifyAsyncEntry({ entrypoint, code }) {\n        const customCode = `console.log('hello');`;\n        return {\n          entrypoint,\n          code: `${customCode}${code}`,\n        };\n      },\n    };\n  },\n});\n\n\n\nhtmlPartials\n\n * 功能：用于定制生成的 HTML 页面模版\n * 执行阶段：prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; partials: HtmlPartials; }>\n * 使用示例：\n\n\n\nexport default (): CliPlugin => ({\n  setup(api) {\n    return {\n      async htmlPartials({ entrypoint, partials }) {\n        partials.head.push('<script>console.log(\"test\")</script>');\n        return {\n          entrypoint,\n          partials,\n        };\n      },\n    };\n  },\n});\n\n\n这样就为 HTML 模版中新增了一个 Script 标签。\n\n\nServer\n\nNOTE\n\n目前 Server 插件还未完全开放，API 不保证稳定，使用需谨慎。\n\n应用工程中的 Server 部分也支持了插件。其中的 Hook 将会提供一些特定阶段调用和特殊功能的 Hook。\n\n\ncreate\n\n * 功能：在中间件函数中会拿到 Server 初始化用到的指标测量工具配置 measureOptions 和日志工具配置\n   loggerOptions，并返回自定义的指标测量工具 measure 和日志工具配置 logger\n * 执行阶段：Server 初始化\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<ServerInitInput, InitExtension>\n * 使用示例：\n\n\n\nexport default (): ServerPlugin => ({\n  setup(api) {\n    return {\n      create: ({ measureOptions, loggerOptions }) => {\n        // do something\n      },\n    };\n  },\n});\n\n\n\nprepareWebServer\n\n * 功能：设置 Web 路由的处理函数，在中间件函数中可以拿到 Web Server 的前置中间件\n * 执行阶段：在请求到达的时候\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<WebServerStartInput, Adapter>\n * 使用示例：\n\n\n\nexport default (): ServerPlugin => ({\n  setup(api) {\n    return {\n      prepareWebServer: ({ middleware }) => {\n        // do something\n\n        return (req, res) => {\n          // do response\n        };\n      },\n    };\n  },\n});\n\n\n\nprepareApiServer\n\n * 功能：设置 API 路由的处理函数，在中间件函数中可以拿到 API Server 的前置中间件\n * 执行阶段：请求到达并且 match bff basename 之后执行\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<APIServerStartInput, Adapter>\n * 使用示例：\n\n\n\nexport default (): ServerPlugin => ({\n  setup(api) {\n    return {\n      prepareApiServer: ({ middleware }) => {\n        // do something\n\n        return (req, res) => {\n          // do response\n        };\n      },\n    };\n  },\n});\n\n\n\nRuntime\n\nNOTE\n\n目前 Runtime 插件还未完全开放，API 不保证稳定，使用需谨慎。\n\nRuntime 插件主要用于开发者修改需要渲染的组件与 Element 和定制服务器端、客户端的渲染过程。\n\n\ninit\n\n * 功能：执行 App.init\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ context: RuntimeContext; }, unknown>\n * 使用示例：\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      init({ context }, next) {\n        // do something\n        return next({ context });\n      },\n    };\n  },\n});\n\n\n\nhoc\n\n * 功能：修改需要渲染的组件\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：Pipeline\n * 类型：Pipeline<{ App: React.ComponentType<any>; }, React.ComponentType<any>>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    const FooContext = createContext('');\n    return {\n      hoc({ App }, next) {\n        return next({\n          App: (props: any) => {\n            return (\n              <FooContext.Provider store={'test'}>\n                <App {...props} />\n              </FooContext.Provider>\n            );\n          },\n        });\n      },\n    };\n  },\n});\n\n\n\nprovide\n\n * 功能：修改需要渲染的 Element\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：Pipeline\n * 类型：Pipeline<{ element: JSX.Element; props: AppProps; context: RuntimeContext\n   }, JSX.Element>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    const FooContext = createContext('');\n\n    return {\n      provide: ({ element }) => <div>{element}</div>,\n    };\n  },\n});\n\n\n\nclient\n\n * 功能：定制客户端渲染流程\n * 执行阶段：在浏览器客户端渲染\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ App: React.ComponentType<any>; context?: RuntimeContext;\n   rootElement: HTMLElement; }, void>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      client: async ({ App, rootElement }) => {\n        ReactDOM.render(\n          React.createElement(App, { context: { foo: 'test' } }),\n          rootElement,\n        );\n      },\n    };\n  },\n});\n\n\n\nserver\n\n * 功能：定制服务器端渲染流程\n * 执行阶段：SSR\n * Hook 模型：AsyncPipeline\n * 类型：AsyncPipeline<{ App: React.ComponentType<any>; context?: RuntimeContext;\n   }, string>\n * 使用示例：\n\n\n\n\nexport default (): Plugin => ({\n  setup(api) {\n    return {\n      server({ App, context }) {\n        return ReactDomServer.renderToString(\n          React.createElement(App, { context: { foo: 'test' } }),\n        );\n      },\n    };\n  },\n});\n","frontmatter":{"title":"Hook 列表","sidebar_position":8}},{"id":549,"title":"Hook 模型","routePath":"/guides/topic-detail/framework-plugin/hook","lang":"zh","toc":[{"id":"基础工作方式","text":"基础工作方式","depth":2},{"id":"不同-hook-模型的区别","text":"不同 Hook 模型的区别","depth":2},{"id":"pipeline","text":"Pipeline","depth":3},{"id":"waterfall","text":"Waterfall","depth":3},{"id":"workflow","text":"Workflow","depth":3},{"id":"hook-模型对比","text":"Hook 模型对比","depth":2}],"domain":"","content":"\n\n首先介绍一下 Modern.js 的基础的插件系统中的一些内容，包括 Hook 模型的工作方式、各个 Hook 模型的运行模式、Manager 的工作模式。\n\n每种 Hook 模型都是独立的，可以独立管理运行函数。\n\n\n基础工作方式\n\n先以 Pipeline 为例，简单介绍一下 Hook 模型的工作方式。先看一个简单的例子：\n\n\n\n// 1. 创建\nconst pipeline = createPipeline<number, number>();\n\n// 2. 添加函数\npipeline.use((count, next) => {\n  return next(count + 1);\n});\npipeline.use((count, next) => {\n  return count * 2;\n});\n\n// 3. 执行\npipeline.run(1); // 4\npipeline.run(5); // 12\n\n\n在这个例子中，创建了一个 Pipeline<number, number> 类型的 Pipeline（L3），这意味着运行它的时候，你需要传入一个\nnumber，然后你会得到一个 number，而这个模型管理的函数的类型是：\n\n(count: number, next: (nextCount: number) => number) => number;\n\n\n这里全是 number，是因为我们创建的是 Pipeline<number, number> ，如果创建的是 Pipeline<number, string>\n则运行它入参是 number，返回值是 string，对应管理的函数的类型会是：\n\n(count: number, next: (nextCount: number) => string) => string;\n\n\n创建好 Pipeline 之后，可以通过 use 添加函数（L5、L8），需要注意的是，添加的顺序就是他们默认的运行顺序，在这些函数中，你可以对 count\n进行处理、返回一个值，如果你调用了 next 函数，则会运行后面的函数，即如果你添加了三个函数： A、B、C，如果你在 A 中调用 next 那么就会运行\nB，同样的，如果你在 B 中调用 next 那么就会运行 C，而在上面的例子中，添加的第一个函数（L5）就运行了\nnext，所以这里就会运行第二个函数（L8），并且运行的返回值就是 第二个函数的返回值，如果在第一个函数中没有调用 next，直接返回，例如：\n\n\n\n// 1. 创建\nconst pipeline = createPipeline<number, number>();\n\n// 2. 添加函数\npipeline.use((count, next) => {\n  return count + 1;\n});\npipeline.use((count, next) => {\n  return count * 2;\n});\n\n// 3. 执行\npipeline.run(1); // 2\npipeline.run(5); // 6\n\n\n则在运行 Pipeline 的时候就不会运行第二个函数，那么 Pipeline 的运行结果则就是第一个函数的返回值。\n\n最后，运行 Pipeline 的方式也显而易见就是调用 pipeline.run 。\n\n\n不同 Hook 模型的区别\n\n上面这部分就是 Pipeline 整体的一个工作模式的描述，其他的 Hook 模型的工作模式基本也是这样，主要的区别点，是函数类型、执行顺序，参数。\n\n\nPipeline\n\n上面的例子就是以 Pipeline 为例描述的，这里就不赘述了，在 Pipeline 这个大类中，提供了两个小类：Sync 和\nAsync，顾名思义，它们的区别就是管理的函数的类型是 Sync 的还是 Async 的。\n\nINFO\n\n当 Pipeline 中没有函数或者所有函数都调用了 next 函数，则就需要在运行的时候提供：\n\npipeline(\n  {},\n  {\n    onLast: () => {\n      // do something\n    },\n  },\n);\n\n\n\nWaterfall\n\n这种模型顾名思义，他的特点就是参数的顺序递交，即前面一个函数的返回值，将会成为下一个函数的入参，我们也用一个例子来看一下：\n\n\n\n// 1. 创建\nconst waterfall = createWaterfall<number>();\n\n// 2. 添加函数\nwaterfall.use(count => {\n  return count + 1;\n});\nwaterfall.use(count => {\n  return count * 2;\n});\n\n// 3. 执行\nwaterfall.run(1); // 4\nwaterfall.run(5); // 12\n\n\n这个例子中，创建了一个类型为 Waterfall<number> ，即这个模型执行的入参和返回值是一样的，这个例子中都是 number，而它管理的函数的类型是：\n\n(count: number) => number;\n\n\n可能简单看这个例子感觉和上面的 Pipeline 功能一样，那需要注意的是，首先这里 Waterfall 管理的函数没有 next\n函数作为第二个参数，所以它无法在函数内部通过调用 next 来先运行之后添加的函数，从而修改运行的顺序，其次这里的运行的入参的类型和返回值的类型必须是一样的（而\nPipeline 可以不一样）。\n\n同样的，在 Waterfall 这个大类中，也提供了 Sync 和 Async 的小类，分别对应 Sync 和 Async 的函数。\n\n\nWorkflow\n\n这种 Hook 模型与上面两种 Hook\n模型的区别是，没有那么强的前后参数返回值递交的概念，在这个模型中，每个函数都是基于同样的入参，相对独立运行的，通过一个例子简单看一下：\n\n\n\n// 1. 创建\nconst workflow = createWorkflow<number, number>();\n\n// 2. 添加函数\nworkflow.use(count => {\n  return count + 1;\n});\nworkflow.use(count => {\n  return count * 2;\n});\n\n// 3. 执行\nworkflow.run(1); // [2, 2]\nworkflow.run(5); // [6, 10]\n\n\n在这个例子中，添加了两个函数，所以运行的结果就是这两个函数运行的结果形成的一个数组。\n\n虽然这种模型中没有那么强的前后参数返回值递交的概念，但依旧有执行顺序的区别，在 Workflow\n这个大类中，提供了三个小类：Sync、Async、Parallel。他们之间的区别就是函数的执行顺序，当然默认的都是按照添加顺序执行，而在 Sync、Async\n则是强制按照添加顺序执行，而 Parallel 则是 Async 模式的一个变体，即它使用的是 Promise.all 来执行所有函数，而 Async 则会\nawait 前面的函数运行结束。\n\n\nHook 模型对比\n\n| | 函数类型 | 执行顺序 | 函数参数来源 | 执行返回值来源 | 倾向处理的任务类型 | 函数 TS 类型 | | ---------------- |\n---------- | ---------------------------------------------------------- |\n--------------------------------------------------------------------------------\n---------- | ------------------------ |\n------------------------------------------------------------------- |\n------------------------------------------------------ | | Pipeline | Sync |\n默认执行第一个添加的函数，可以通过 next 调用之后添加的函数 | 第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数向 next\n函数传递的参数 | 第一个函数的返回值 | 需要修改初始参数需要修改函数执行顺序 | (input: I, next: Next<I, O>) => O | |\nAsyncPipeline | Sync/Async | 默认执行第一个添加的函数，可以通过 next 调用之后添加的函数 |\n第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数向 next 函数传递的参数 | 第一个函数的返回值 |\n需要修改初始参数需要修改函数执行顺序 | (input: I, next: AsyncNext<I, O>) => O ｜ Promise<O> | |\nWaterFall | Sync | 一直顺序执行 | 第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数的返回值 | 最后一个函数的返回值\n| 需要修改初始参数不需要修改函数执行顺序 | (I: I) => I | | AsyncWaterFall | Sync/Async | 一直顺序执行 |\n第一个函数的参数来源是运行的参数，之后的函数的参数来源是，前一个函数的返回值 | 最后一个函数的返回值 | 需要修改初始参数不需要修改函数执行顺序 | (I:\nI) => I ｜ Promise<I> | | Workflow | Sync | 一直顺序执行 | 所有函数的入参都是运行的参数 |\n所有函数返回值形成的数组 | 不需要修改初始参数不需要修改函数执行顺序 | (I: I) => O | | AsyncWorkflow | Sync/Async\n| 一直顺序执行 | 所有函数的入参都是运行的参数 | 所有函数返回值形成的数组 | 不需要修改初始参数不需要修改函数执行顺序 | (I: I) => O ｜\nPromise<O> | | ParallelWorkFlow | Sync/Async | 异步执行 | 所有函数的入参都是运行的参数 |\n所有函数返回值形成的数组 | 不需要修改初始参数不关心执行顺序 | (I: I) => O ｜ Promise<O> |\n\nWorkflow、Waterfall 其实都是 Pipeline 的变体，Pipeline 可以通过特定的写法来实现\nWorkflow、Waterfall，但都较为麻烦，有许多隐形的约定。为了方便使用，提供了这两种变体来满足这种特殊场景。","frontmatter":{"title":"Hook 模型","sidebar_position":2}},{"id":550,"title":"如何编写插件","routePath":"/guides/topic-detail/framework-plugin/implement","lang":"zh","toc":[{"id":"实现插件","text":"实现插件","depth":2},{"id":"插件类型","text":"插件类型","depth":3},{"id":"插件配置项","text":"插件配置项","depth":3},{"id":"插件-api","text":"插件 API","depth":3},{"id":"异步-setup","text":"异步 setup","depth":3},{"id":"添加插件","text":"添加插件","depth":2},{"id":"开发本地插件","text":"开发本地插件","depth":3},{"id":"在-npm-上发布插件","text":"在 npm 上发布插件","depth":3}],"domain":"","content":"\n\n上一小节介绍了 Modern.js 插件的 Hook 模型，这一小节介绍如何编写插件。\n\n\n实现插件\n\nModern.js 插件是一个对象，对象包含以下属性：\n\n * name: 插件的名称，唯一标识符。\n * setup: 插件初始化函数，只会执行一次。setup 函数可以返回一个 Hooks 对象，Modern.js 会在特定的时机执行这些 Hooks。\n\nconst myPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    // 执行一些初始化逻辑\n    const foo = '1';\n\n    // 返回一个 Hooks 对象\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n另外，在插件中，允许配置与其他插件的执行顺序。详情可以参考插件关系。\n\n\n插件类型\n\nModern-js 支持多种工程开发，如应用工程(app-tools), 模块工程(module-tools)等。\n\n为了兼顾不同工程开发的差异和通性，Modern-js 将插件如下图进行组织:\n\n\n\n从图可以看出，Modern-js 将插件大致分为两类:\n\n 1. 通用插件: 插件只会包含一些基础的 Hooks\n\n 2. 工程插件: 不同的工程开发会在通用插件的基础上扩展出自己的 Hooks, Config 等类型。\n\n使用 TypeScript 时，可以引入内置的 CliPlugin 等类型，为插件提供正确的类型推导。\n\n\n\nconst myPlugin: CliPlugin = {\n  name: 'my-plugin',\n\n  setup() {\n    const foo = '1';\n\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n上述代码为通用插件，只包含一些基础的 Hooks。 Modern.js 支持通过泛型对插件的定义进行扩展：\n\n\n\nconst myPlugin: CliPlugin<AppTools> = {\n  name: 'my-plugin',\n\n  setup() {\n    const foo = '1';\n\n    return {\n      afterBuild: () => {\n        // 在构建完成后执行逻辑\n      },\n    };\n  },\n};\n\n\n如果仔细观察 AppTools 这个类型，可以发现 AppTools 由 3 种类型构成.\n\ntype AppTools = {\n  hooks: AppToolsHooks;\n  userConfig: AppToolsUserConfig;\n  normalizedConfig: AppToolsNormalizedConfig;\n};\n\n\n当编写插件时，插件通过泛型扩展在不同的基础上扩展自己的 Hooks 等类型:\n\n// 通用插件上扩展\n\n\n\nconst myPlugin: CliPlugin<{ hooks: MyPluginHook }> = {};\n\n\n// 在 @modern-js/app-tools 基础上扩展\n\n\n\nconst myPlugin: CliPlugin<AppTools & { hooks: MyPluginHook }> = {};\n\n\n详细说明，请参考 扩展 Hook。\n\n\n插件配置项\n\n建议将插件写成函数的形式，使插件能通过函数入参来接收配置项：\n\n\n\ntype MyPluginOptions = {\n  foo: string;\n};\n\nconst myPlugin = (options: MyPluginOptions): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    console.log(options.foo);\n  },\n});\n\n\n\n插件 API\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    // 获取应用原始配置\n    const config = api.useConfigContext();\n    // 获取应用运行上下文\n    const appContext = api.useAppContext();\n    // 获取解析之后的最终配置\n    const resolvedConfig = api.useResolvedConfigContext();\n  },\n});\n\n\n插件 API 的详细说明，请参考 Plugin API。\n\n\n异步 setup\n\nCLI 插件的 setup 可以是一个异步函数，在初始化过程中执行异步逻辑。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  async setup(api) {\n    await doSomething();\n  },\n});\n\n\n\n添加插件\n\n自定义插件的使用方式可以查看：plugins (框架插件)。下面会介绍 Modern.js 中推荐的插件实现方法。\n\n\n开发本地插件\n\n本地插件推荐写在 config/plugin 目录下，并通过 export default 导出：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    // 插件初始化\n  },\n});\n\n\n然后在 modern.config.ts 中注册对应的插件：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n\n在 npm 上发布插件\n\n如果需要将 Modern.js 插件发布到 npm，推荐使用 Modern.js 中的模块工程方案来管理和构建。\n\n首先创建一个空的模块工程方案项目，调整 npm 包名称：\n\n{\n  \"name\": \"my-plugin\"\n  ...\n}\n\n\n然后新建对应的插件文件：\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup() {\n    // 插件初始化\n  },\n});\n\n\n发布之后，安装到需要使用的项目 pnpm add my-plugin，这里以一个应用项目为例，然后在 modern.config.ts 中添加：\n\n\n\n\nexport default defineConfig({\n  plugins: [myPlugin()],\n});\n\n\n如果你发现目前 Modern.js 存在无法满足的场景，欢迎通过编写自定义插件的方式来一起建设 Modern.js 生态。","frontmatter":{"title":"如何编写插件","sidebar_position":3}},{"id":551,"title":"介绍","routePath":"/guides/topic-detail/framework-plugin/introduction","lang":"zh","toc":[{"id":"modernjs-插件系统","text":"Modern.js 插件系统","depth":2},{"id":"插件可以做什么","text":"插件可以做什么","depth":2}],"domain":"","content":"\n\n\nModern.js 插件系统\n\nModern.js 用于扩展项目运行、请求、渲染等不同阶段功能的系统，主要分为三个部分：Hook 模型、管理器，上下文共享机制。\n\nHook 模型用于确定当前 Hook 的执行方式，不同 Hook 模型的函数拥有不同的执行逻辑。管理器用于控制 Hook 的执行与调度。上下文共享机制用于在不同\nHook 间传递信息。\n\n目前 Modern.js 提供几种不同的 Hook 模型：\n\n * Pipeline\n   * Sync\n   * Async\n * Waterfall\n   * Sync\n   * Async\n * Workflow\n   * Sync\n   * Async\n   * Parallel(Async)\n\nNOTE\n\n后续章节详细介绍各个模型的执行方式。\n\n基于 Hook 模型和管理器，Modern.js 暴露了三套插件：CLI、Runtime、Server。\n\n其中 CLI 插件是 Modern.js 中主要的运行流程控制模型，Modern.js 中绝大部分功能都是主要通过这一套模型运行的。Runtime\n插件主要负责处理 React 组件渲染逻辑。Server 插件主要用于对服务端的生命周期以及用户请求的控制。\n\n\n插件可以做什么\n\nModern.js 的所有功能都是通过这套插件实现的，这意味着 Modern.js\n中的所有能力是都对开发者开放的。开发者可以通过编写插件来扩展更多功能，适配复杂场景，包括但不限于：\n\n * 注册命令\n * 修改 Modern.js 配置、配置校验 Schema\n * 修改编译时的 Webpack/Babel/Less/Sass/Tailwind CSS/... 配置\n * 修改运行时需要渲染的 React 组件、Element\n * 修改页面路由\n * 修改服务器路由\n * 自定义控制台输出\n * 自定义动态 HTML 模版\n * 自定义 Node.js 服务器框架\n * 自定义 React 组件客户端/服务器端渲染\n * ...\n\n当 Modern.js 暂时没有覆盖到你所需要的功能或场景时，可以开发一个自定义插件，来实现适配特殊场景的相关功能。","frontmatter":{"title":"介绍","sidebar_position":1}},{"id":552,"title":"生命周期","routePath":"/guides/topic-detail/framework-plugin/lifecycle","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 应用具有完整的生命周期，包括 CLI、Server Side 和 Runtime 三个阶段。\n\n目前 Modern.js 大致的生命周期如下：\n\nNOTE\n\n其中粉色框的矩形代表 Modern.js 提供的插件钩子，淡黄色底色椭圆代表与下一个阶段的连接点。\n\n","frontmatter":{"title":"生命周期","sidebar_position":1}},{"id":553,"title":"插件 API","routePath":"/guides/topic-detail/framework-plugin/plugin-api","lang":"zh","toc":[{"id":"api","text":"API","depth":2},{"id":"useconfigcontext","text":"useConfigContext","depth":3},{"id":"useappcontext","text":"useAppContext","depth":3},{"id":"useresolvedconfigcontext","text":"useResolvedConfigContext","depth":3},{"id":"usehookrunners","text":"useHookRunners","depth":3}],"domain":"","content":"\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  setup(api) {\n    // 获取应用原始配置\n    const config = api.useConfigContext();\n    // 获取应用运行上下文\n    const appContext = api.useAppContext();\n    // 获取解析之后的最终配置\n    const resolvedConfig = api.useResolvedConfigContext();\n  },\n});\n\n\n\nAPI\n\n\nuseConfigContext\n\n用于获取应用原始配置。\n\nconst useConfigContext: () => UserConfig;\n\ninterface UserConfig {\n  source?: SourceConfig;\n  output?: OutputConfig;\n  server?: ServerConfig;\n  dev?: DevConfig;\n  deploy?: DeployConfig;\n  tools?: ToolsConfig;\n  plugins?: PluginConfig;\n  runtime?: RuntimeConfig;\n  runtimeByEntries?: RuntimeByEntriesConfig;\n}\n\n\n具体配置字段的意义请参考【配置】。\n\n\nuseAppContext\n\n用于获取应用运行上下文。\n\nconst useAppContext: () => IAppContext;\n\ninterface IAppContext {\n  appDirectory: string;\n  configFile: string | false;\n  ip?: string;\n  port?: number;\n  distDirectory: string;\n  packageName: string;\n  srcDirectory: string;\n  sharedDirectory: string;\n  nodeModulesDirectory: string;\n  internalDirectory: string;\n  plugins: {\n    cli?: any;\n    server?: any;\n  }[];\n  entrypoints: Entrypoint[];\n  serverRoutes: ServerRoute[];\n  htmlTemplates: HtmlTemplates;\n}\n\n\n\nuseResolvedConfigContext\n\n用于获取解析之后的最终配置。\n\nconst useResolvedConfigContext: () => NormalizedConfig;\n\ninterface NormalizedConfig {\n  source: NormalizedSourceConfig;\n  output: OutputConfig;\n  server: ServerConfig;\n  dev: DevConfig;\n  deploy: DeployConfig;\n  tools: NormalizedToolsConfig;\n  plugins: PluginConfig;\n  runtime: RuntimeConfig;\n  runtimeByEntries?: RuntimeByEntriesConfig;\n  _raw: UserConfig;\n}\n\n\n具体配置字段的意义请参考【配置】。\n\n\nuseHookRunners\n\n用于获取 Hooks 的执行器，并触发特定的 Hook 执行。\n\n\n\nexport default (): CliPlugin => ({\n  name: 'my-plugin',\n\n  async setup(api) {\n    const hookRunners = api.useHookRunners();\n    // 触发 afterBuild Hook\n    await hookRunners.afterBuild();\n  },\n});\n","frontmatter":{"title":"插件 API","sidebar_position":6}},{"id":554,"title":"插件之间的关系","routePath":"/guides/topic-detail/framework-plugin/relationship","lang":"zh","toc":[{"id":"插件排序","text":"插件排序","depth":2},{"id":"前置插件","text":"前置插件","depth":3},{"id":"后置插件","text":"后置插件","depth":3},{"id":"互斥插件","text":"互斥插件","depth":2},{"id":"必需插件","text":"必需插件","depth":2},{"id":"注册插件","text":"注册插件","depth":2}],"domain":"","content":"\n\nModern.js 的插件配置对象提供了一系列的字段，用于控制插件顺序、互斥等能力，可用的字段如下：\n\n * name: string，设置当前插件的名称。\n * pre: string[]，这些插件最终会调整到当前插件前面。\n * post: string[]，这些插件最终会调整到当前插件后面。\n * rivals: string[]，互斥插件，遇到这些插件时会报错。\n * required: string[]，必需插件，插件列表中没有对应的插件时会报错。\n * usePlugin: CliPlugin[]，注册其他插件。\n\n通过以上参数可以实现插件的前置、后置、互斥、必需等逻辑。\n\n\n插件排序\n\nModern.js 的插件通过 pre、post 参数来实现了插件排序的功能。\n\n\n前置插件\n\n默认情况下，插件会按照添加顺序依次执行，通过 pre 字段可以声明前置执行的插件。\n\n比如有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  pre: ['plugin-foo'],\n};\n\n\nbar 插件在 pre 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之前执行。\n\n\n后置插件\n\n同样的，通过 post 字段可以声明后置执行的插件。\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  post: ['plugin-foo'],\n};\n\n\nbar 插件在 post 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之后执行。\n\n\n互斥插件\n\n通过 rivals 字段可以声明插件间的互斥关系。\n\n有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  rivals: ['plugin-foo'],\n};\n\n\nbar 插件在 rivals 字段中配置了 foo 插件，因此同时添加了 foo 插件和 bar 插件就会报错。\n\n\n必需插件\n\n通过 required 字段可以声明插件间的依赖关系。\n\n有下面两个插件：\n\nconst foo = {\n  name: 'plugin-foo',\n};\n\n\nconst bar = {\n  name: 'plugin-bar',\n  required: ['plugin-foo'],\n};\n\n\nbar 插件在 required 字段中配置了 foo 插件，因此使用 bar 插件时，如果未配置 foo 插件就会报错。\n\n\n注册插件\n\n当插件之间存在依赖关系时，我们也可以在一个插件中通过 usePlugin 主动注册另一个插件：\n\nconst foo = () => ({\n  name: 'plugin-foo',\n});\n\nconst bar = () => ({\n  name: 'plugin-bar',\n  usePlugin: [foo()],\n});\n\n\n当使用者配置了 bar 插件时，foo 插件也会自动注册生效，使用者就不需要去额外注册 foo 插件了。","frontmatter":{"title":"插件之间的关系","sidebar_position":4}},{"id":555,"title":"@modern-js/codesmith-api-app","routePath":"/guides/topic-detail/generator/codesmith/api/app","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"checkenvironment","text":"checkEnvironment","depth":3},{"id":"runinstall","text":"runInstall","depth":3},{"id":"rungitandinstall","text":"runGitAndInstall","depth":3},{"id":"forgetemplate","text":"forgeTemplate","depth":3},{"id":"showsuccessinfo","text":"showSuccessInfo","depth":3},{"id":"runsubgenerator","text":"runSubGenerator","depth":3},{"id":"getinputbyschema","text":"getInputBySchema","depth":3},{"id":"getinputbyschemafunc","text":"getInputBySchemaFunc","depth":3}],"domain":"","content":"\n\n微生成器开发过程中常用 API 的组合封装，包含 fs、git、npm 等其他包的 API 封装，在能满足需求时，推荐使用该 npm 包的 API。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const appApi = new AppAPI(context, generator);\n  await appApi.runInstall();\n};\n\n\n * 创建 AppAPI 实例，参数和微生成器函数参数一致，为 context 和 generator，具体介绍请看微生成器项目组成。\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\ncheckEnvironment\n\n检查当前生成器运行环境，检查项为：\n\n 1. node 及 node 版本，默认大于 12.22.12，可传递参数执行 node 版本。\n 2. 可使用 yarn、pnpm 或者 npm。\n\n参数：\n\n * nodeVersion?: string 校验的 node 版本。\n\n\nrunInstall\n\n安装依赖，可传入安装依赖命令，默认根据 config 中的 packageManager 值进行。\n\n参数：\n\n * command?: string 安装依赖命令。\n\n\nrunGitAndInstall\n\n该函数完成以下动作：\n\n 1. 校验当前生成器执行目录是否为一个 git 仓库。\n 2. 如果不是一个 git 仓库，初始化为一个 git 仓库。\n 3. 安装依赖。\n 4. 在非 monorepo 项目(判断条件，config 中 isMonorepoSubProject 不存在或者为 false)中提交初始\n    commit，commit 信息为 feat: init，支持自定义。\n\n参数：\n\n * commitMessage?: string 初始化 commit message 信息。\n * installFunc?: () => Promise<void> 安装依赖函数。\n\n\nforgeTemplate\n\n渲染生成器模板文件。\n\n参数：\n\n * templatePattern: string 模板文件匹配正则，例如： templates/base-templates/**/* 。\n * filter?: (resourceKey: string) => boolean 过滤函数，参数为 templatePattern 匹配的文件路径，返回\n   true 表示渲染该文件，返回 false 表示不渲染该文件。\n * rename?: (resourceKey: string) => string 重命名函数，参数为 templatePattern\n   匹配的文件路径，返回新文件名。默认会替换 resourceKey 开头的 templates 目录和结尾的 .handlebars 后缀。\n * parameters?: Record<string, any> 渲染参数，当模板中存在 handlebars 或者 ejs\n   变量时，使用其传递对应变量值。\n * type?: 'handlebars' | 'ejs' 模板文件类型，默认为 handlebars。\n\n例如:\n\nawait appApi.forgeTemplate(\n  'templates/base-templates/**/*',\n  undefined,\n  resourceKey =>\n    resourceKey\n      .replace('templates/base-templates/', '')\n      .replace('.handlebars', ''),\n);\n\nawait appApi.forgeTemplate(\n  'templates/base-template/**/*',\n  resourceKey => !resourceKey.include('eslintrc.json'),\n  resourceKey =>\n    resourceKey\n      .replace('templates/base-template/', projectPath)\n      .replace('language', language as string)\n      .replace('.handlebars', ''),\n  {\n    name: packageName as string,\n    language,\n    isTs: language === Language.TS,\n    packageManager: getPackageManagerText(packageManager as any),\n  },\n);\n\n\n\nshowSuccessInfo\n\n展示成功信息。\n\n参数：\n\n * successInfo?: string，默认为 Success || 成功。\n\n\nrunSubGenerator\n\n运行子生成器。\n\n参数：\n\n * subGenerator: string 子生成器名称或者路径。\n * relativePwdPath?: string 子生成器运行的相对路径。\n * config?: Record<string, unknown> 子生成器运行的默认 config 配置。\n\n例如：\n\nawait appApi.runSubGenerator(\n  getGeneratorPath('@modern-js/repo-generator', context.config.distTag),\n  undefined,\n  { ...context.config, hasPlugin: false },\n);\n\n\n\ngetInputBySchema\n\n通过 schema 完成用户交互输入。\n\n参数：\n\n * schema: FormilySchema | Question[] 问题列表，支持 Formily schema 和 inquirer 类型。\n * type: 'formily' | 'inquirer' 类型，默认值为 formily。\n * configValue: Record<string, unknown> = {} schema 默认值，传入该值的 schema\n   字段对应的问题将不再和用户交互。\n * validateMap?: Record<string, (input: unknown, data?: Record<string, unknown>)\n   => { success: boolean; error?: string }> schema 中特殊字段的验证函数。\n * initValue?: Record<string, any> schema 中字段的初始化值。\n\nFormily Schema 类型支持方式可参考自定义输入相关类型定义。\n\n\ngetInputBySchemaFunc\n\n通过 schema 完成用户交互输入，schema 参数值为函数，用户处理国际化问题，仅支持 Formily schema。\n\n参数：\n\n * schema: config?: Record<string, any>) => FormilySchema 获取问题列表函数，config\n   参数为当前生成器中的 config 配置信息。\n * configValue: Record<string, unknown> = {} schema 默认值，传入该值的 schema\n   字段对应的问题将不再和用户交互。\n * validateMap?: Record<string, (input: unknown, data?: Record<string, unknown>)\n   => { success: boolean; error?: string }> schema 中特殊字段的验证函数。\n * initValue?: Record<string, any> schema 中字段的初始化值。\n\nFormily Schema 类型支持方式可参考自定义输入相关类型定义。","frontmatter":{"sidebar_position":1}},{"id":556,"title":"@modern-js/codesmith-api-ejs","routePath":"/guides/topic-detail/generator/codesmith/api/ejs","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"rendertemplate","text":"renderTemplate","depth":3},{"id":"rendertemplatedir","text":"renderTemplateDir","depth":3}],"domain":"","content":"\n\n微生成器中使用 ejs 进行文件操作的 API 封装，提供渲染单个模板文件和文件夹的方法。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const ejsAPI = new EjsAPI(generator);\n  await ejsAPI.renderTemplate(\n     material.get('templates/a.js'),\n     target: 'b.js',\n     { data: \"data\" }\n   );\n}\n\n\n * 创建 EjsAPI 实例，参数为微生成器函数参数的 generator，具体介绍请看微生成器项目组成 。\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\nrenderTemplate\n\n渲染单个模板文件。\n\n参数：\n\n * templateResource: FsResource 模板文件资源，通过 context.materials.get(<filename>) 使用。\n * target: string 目标文件路径名称。\n * parameters?: Record<string, string> 渲染参数。\n\n\nrenderTemplateDir\n\n渲染模板文件夹。\n\n参数：\n\n * material: FsMaterial 当前微生成器执行的 material 上下文。\n * findGlob: string 模板文件匹配正则。\n * target: (globMatch: string) => string 目标文件路径生成函数，参数为 resourceKey。\n * options?: RenderTemplateDirOptions glob 查找文件配置，具体函数可查看这里 glob。\n\ntype RenderTemplateDirOptions = {\n  nodir?: boolean;\n  dot?: boolean;\n  ignore?: string | readonly string[];\n};\n","frontmatter":{"sidebar_position":6}},{"id":557,"title":"@modern-js/codesmith-api-fs","routePath":"/guides/topic-detail/generator/codesmith/api/fs","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"renderfile","text":"renderFile","depth":3},{"id":"renderdir","text":"renderDir","depth":3}],"domain":"","content":"\n\n微生成器中文件操作的 API 封装，提供渲染单个模板文件和文件夹的方法。FsAPI 通常用于处理二进制文件或者不能使用 handlebars、ejs\n处理的模板文件。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const handlebarApi = new HandlebarsAPI(generator);\n  await handlebarsAPI.renderFile(\n     material.get('templates/a.js'),\n     target: 'b.js'\n   );\n}\n\n\n * 创建 FsAPI 实例，参数为微生成器函数参数的 generator，具体介绍请看微生成器项目组成 。\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\nrenderFile\n\n渲染单个模板文件。\n\n参数：\n\n * resource: FsResource 模板文件资源，通过 context.materials.get(<filename>) 使用。\n * target: string 目标文件路径名称。\n\n\nrenderDir\n\n渲染模板文件夹。\n\n参数：\n\n * material: FsMaterial 当前微生成器执行的 material 上下文。\n * findGlob: string 模板文件匹配正则。\n * target: (globMatch: string) => string 目标文件路径生成函数，参数为 resourceKey。\n * options?: RenderTemplateDirOptions glob 查找文件配置，具体函数可查看这里 glob。\n\ntype RenderTemplateDirOptions = {\n  nodir?: boolean;\n  dot?: boolean;\n  ignore?: string | readonly string[];\n};\n","frontmatter":{"sidebar_position":3}},{"id":558,"title":"@modern-js/codesmith-api-git","routePath":"/guides/topic-detail/generator/codesmith/api/git","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"isingitrepo","text":"isInGitRepo","depth":3},{"id":"initgitrepo","text":"initGitRepo","depth":3},{"id":"addandcommit","text":"addAndCommit","depth":3}],"domain":"","content":"\n\n微生成器中使用 git 相关操作的 API 封装，提供判断 git 仓库，初始化及提交代码等方法。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const gitApi = new GitAPI(generatorCore, generatorContext);\n  await gitApi.initGitRepo();\n};\n\n\n * 创建 GitAPI 实例，参数和微生成器函数参数一致，为 context 和 generator，具体介绍请看微生成器项目组成\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\nisInGitRepo\n\n当前目录是否为 git 仓库。\n\n参数：\n\n * cwd?: string git 命令的执行目录，默认为微生成器 outputPath。\n\n\ninitGitRepo\n\n初始化为 git 仓库。init 的默认分支名可通过生成器 config 中的 defaultBranch 进行配置。\n\n参数：\n\n * cwd?: string git 命令的执行目录，默认为微生成器 outputPath。\n * force?: boolean 当前目录已经为 git 仓库时使用该参数会强制执行 git init。\n\n\naddAndCommit\n\n执行 git add . 和 git commit 提交当前变更。\n\n参数：\n\n * commitMessage: string commit 信息。\n * cwd?: string git 命令的执行目录，默认为微生成器 outputPath。","frontmatter":{"sidebar_position":4}},{"id":559,"title":"@modern-js/codesmith-api-handlebars","routePath":"/guides/topic-detail/generator/codesmith/api/handlebars","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"rendertemplate","text":"renderTemplate","depth":3},{"id":"rendertemplatedir","text":"renderTemplateDir","depth":3}],"domain":"","content":"\n\n微生成器中使用 handlebars 进行文件操作的 API 封装，提供渲染单个模板文件和文件夹的方法。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const handlebarApi = new HandlebarsAPI(generator);\n  await handlebarsAPI.renderTemplate(\n     material.get('templates/a.js'),\n     target: 'b.js',\n     { data: \"data\" }\n   );\n}\n\n\n * 创建 HandlebarsAPI 实例，参数为微生成器函数参数的 generator，具体介绍请看微生成器项目组成 。\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\nrenderTemplate\n\n渲染单个模板文件。\n\n参数：\n\n * templateResource: FsResource 模板文件资源，通过 context.materials.get(<filename>) 使用。\n * target: string 目标文件路径名称。\n * parameters?: Record<string, string> 渲染参数。\n\n\nrenderTemplateDir\n\n渲染模板文件夹。\n\n参数：\n\n * material: FsMaterial 当前微生成器执行的 material 上下文。\n * findGlob: string 模板文件匹配正则。\n * target: (globMatch: string) => string 目标文件路径生成函数，参数为 resourceKey。\n * options?: RenderTemplateDirOptions glob 查找文件配置，具体函数可查看这里 glob。\n\ntype RenderTemplateDirOptions = {\n  nodir?: boolean;\n  dot?: boolean;\n  ignore?: string | readonly string[];\n};\n","frontmatter":{"sidebar_position":5}},{"id":560,"title":"@modern-js/codesmith-api-json","routePath":"/guides/topic-detail/generator/codesmith/api/json","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"get","text":"get","depth":3},{"id":"extend","text":"extend","depth":3},{"id":"update","text":"update","depth":3}],"domain":"","content":"\n\n微生成器中 JSON API 封装，提供常见的 JSON 文件操作方法。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const jsonAPI = new JsonAPI(generator);\n  await jsonAPI.update(context.materials.default.get('package.json'), {\n    query: {},\n    update: {\n      $set: {\n        'dependencies.@modern-js/plugin-bff': `^2.0.0`,\n      },\n    },\n  });\n};\n\n\n * 创建 JsonAPI 实例，参数为微生成器函数参数的 generator，具体介绍请看微生成器项目组成。\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\nget\n\n获取 JSON 文件内容。\n\n参数：\n\n * resource: FsResource，文件资源，通过 context.materials.default.get(<filename>) 获取。\n\n\nextend\n\n合并对象至 JSON 文件。\n\n参数：\n\n * resource: FsResource 通过 context.materials.default.get(<filename>) 获取。\n * obj: Record<string, any> 需合并对象。\n\n\nupdate\n\n更新对象字段至 JSON 文件。\n\n参数：\n\n * resource: FsResource 通过 context.materials.default.get(<filename>) 获取。\n * operation: { query: Record<string, any>; update: Record<string, any> }\n   更新操作，详细使用姿势查看 declaration-update。","frontmatter":{"sidebar_position":2}},{"id":561,"title":"@modern-js/codesmith-api-npm","routePath":"/guides/topic-detail/generator/codesmith/api/npm","lang":"zh","toc":[{"id":"使用姿势","text":"使用姿势","depth":2},{"id":"api","text":"API","depth":2},{"id":"npminstall","text":"npmInstall","depth":3},{"id":"yarninstall","text":"yarnInstall","depth":3},{"id":"pnpminstall","text":"pnpmInstall","depth":3}],"domain":"","content":"\n\n微生成器中 NPM API 封装，提供常见的 NPM 不同包管理工具安装依赖的方法。\n\n\n使用姿势\n\n\n\nexport default async (context: GeneratorContext, generator: GeneratorCore) => {\n  const npmApi = new NpmAPI(generator);\n  await npmApi.pnpmInstall();\n};\n\n\n * 创建 NpmAPI 实例，参数为微生成器函数参数的 generator，具体介绍请看微生成器项目组成 。\n * 调用其实例上 API 即可。\n\n\nAPI\n\n\nnpmInstall\n\n使用 npm 安装依赖。\n\n参数：\n\n * cwd?: string install 命令的执行目录，默认为微生成器 outputPath。\n\n\nyarnInstall\n\n使用 yarn 安装依赖。\n\n参数：\n\n * cwd?: string install 命令的执行目录，默认为微生成器 outputPath。\n\n\npnpmInstall\n\n使用 pnpm 安装依赖。\n\n参数：\n\n * cwd?: string install 命令的执行目录，默认为微生成器 outputPath。","frontmatter":{"sidebar_position":7}},{"id":562,"title":"开发微生成器项目","routePath":"/guides/topic-detail/generator/codesmith/develop","lang":"zh","toc":[{"id":"创建项目","text":"创建项目","depth":2},{"id":"添加模板文件","text":"添加模板文件","depth":2},{"id":"开发生成器核心逻辑","text":"开发生成器核心逻辑","depth":2},{"id":"测试微生成器","text":"测试微生成器","depth":2},{"id":"运行微生成器","text":"运行微生成器","depth":2}],"domain":"","content":"\n\n\n创建项目\n\nModern.js 提供了创建微生成器项目的微生成器，可以直接通过以下命令创建微生成器项目：\n\n$ mkdir <projectDir>\n$ npx @modern-js/codesmith-cli @modern-js/generator-generator\n\n? 请填写项目名称 <generatorName>\n? 请选择包管理工具 pnpm\n? 请选择开发语言 TS\n\n\n\n添加模板文件\n\n在项目目录的 templates 文件夹，用于存放生成器需要的模板文件，如果没有模板文件，该步骤可跳过。\n\n\n开发生成器核心逻辑\n\n默认生成的的项目中，已经实现直接拷贝 templates 目录文件至目标项目，可直接在 handleTemplateFile 函数中完成生成器的核心逻辑开发。\n\n\n测试微生成器\n\n微生成器开发完成后，需要执行 pnpm run build 对代码进行编译，在开发模式下可以使用 pnpm run build --watch\n\ncodesmith 提供了 cli 工具用于运行和测试微生成器，在目标目录执行使用如下命令执行即可：\n\nnpx @modern-js/codesmith-cli <generatorPath>\n\n\n其中 generatorPath 为上述生成器项目的绝对路径。\n\n\n运行微生成器\n\n生成器发布 npm 包之后，使用如下命令执行：\n\nnpx @modern-js/codesmith-cli <generatorName>\n\n\n其中 generatorName 为生成器包名。\n\nINFO\n\n@modern-js/create 也支持运行微生成器，可以使用 npx @modern-js/create --generator\n<generatorName> 运行自定义的微生成器。","frontmatter":{"sidebar_position":3}},{"id":563,"title":"什么是微生成器","routePath":"/guides/topic-detail/generator/codesmith/introduce","lang":"zh","toc":[{"id":"核心概念","text":"核心概念","depth":2},{"id":"generatorcore","text":"GeneratorCore","depth":3},{"id":"materials","text":"Materials","depth":3}],"domain":"","content":"\n\nModern.js 提供了 @modern-js/create 工具和 new\n命令分别用于初始化创建项目和提供开启一些插件功能的能力，这些工具都是基于微生成器也就是 codesmith 实现的。\n\ncodesmith 致力于提供一套微生成器的运行机制，并维护微生成器执行过程中的上下文信息，从而实现各种基于文件、命令等操作，完成复杂的操作。\n\ncodesmith 还将常用的方法进行了封装，可以直接使用其提供的 API 函数，可以更方便的实现自身的微生成器。\n\n\n核心概念\n\n\nGeneratorCore\n\nGeneratorCore 是 codesmith 运行生成器的核心，维护这生成器执行过程中的上下文及运行方法。\n\nclass GeneratorCore {\n  logger: ILogger; // 日志\n  materialsManager: MaterialsManager; // 资源\n  outputPath: string; // 输出路径\n  output: {\n    // 输出方法\n    fs: (\n      file: string | number,\n      data: any,\n      options?: fs.WriteFileOptions | string,\n    ) => Promise<void>;\n  };\n  _context: GeneratorContext; // 上下文信息\n  addMaterial(key: string, material: FsMaterial): void; // 添加资源\n  runGenerator(\n    generator: string,\n    config?: Record<string, unknown>,\n  ): Promise<void>; // 运行生成器\n  runSubGenerator(\n    subGenerator: string,\n    relativePwdPath?: string,\n    config?: Record<string, any>,\n  ): Promise<void>; // 运行子生成器\n}\n\n\n\nMaterials\n\n微生成器资源信息，目前只包含文件资源(fsMaterials)，通过该字段可以获取到生成器执行过程中的 template 资源，并通过 API 对其进行操作。\n\nclass MaterialsManager {\n  materialMap: {\n    // 资源映射关系\n    [materialUri: string]: FsMaterial;\n  };\n  loadLocalGenerator(generator: string): Promise<FsMaterial>; // 加载本地生成器资源(绝对路径)\n  loadRemoteGenerator(generator: string): Promise<FsMaterial>; // 加载远程生成器资源(npm 包)\n}\n","frontmatter":{"sidebar_position":1}},{"id":564,"title":"使用 JS 代码执行微生成器","routePath":"/guides/topic-detail/generator/codesmith/run-in-js","lang":"zh","toc":[{"id":"安装-codesmith-依赖","text":"安装 codesmith 依赖","depth":2},{"id":"创建-codesmith-实例","text":"创建 codesmith 实例","depth":2},{"id":"调用-forge-方法执行生成器","text":"调用 forge 方法执行生成器","depth":2}],"domain":"","content":"\n\n除了使用 cli 的方式执行微生成器，我们免不了需要在代码中执行微生成器，下面就介绍在 js 代码中如何执行微生成器。\n\n\n安装 codesmith 依赖\n\npnpm add @modern-js/codesmith\n\n\n\n创建 codesmith 实例\n\n\n\nconst smith = new CodeSmith({\n  debug: false, // 是否开启 debug 模式，为 true 时会展示生成器中的 debug 信息\n});\n\n\n\n调用 forge 方法执行生成器\n\ntype RunnerTask = Array<{\n  name: string;\n  config: Record<string, any>;\n}>;\n\nconst task: RunnerTask = [\n  {\n    name: 'generator', // 生成器 npm 包名称\n    config: {}, // 生成器执行的默认配置\n  },\n];\n\nawait smith.forge({\n  tasks: task.map(runner => ({\n    generator: runner.name,\n    config: runner.config,\n  })),\n  pwd: '.', // 生成器执行路径\n});\n","frontmatter":{"sidebar_position":4}},{"id":565,"title":"微生成器的组成","routePath":"/guides/topic-detail/generator/codesmith/structure","lang":"zh","toc":[{"id":"packagejson","text":"package.json","depth":2},{"id":"入口文件","text":"入口文件","depth":2},{"id":"context","text":"context","depth":3},{"id":"generator","text":"generator","depth":3},{"id":"template-文件","text":"Template 文件","depth":2}],"domain":"","content":"\n\n一个微生成器项目为一个模块项目或者一个 Npm 包，包中包含几个基本部分：\n\n\npackage.json\n\nnpm 包描述信息，包含 name、version、main 等字段。\n\n\n入口文件\n\n上述 main 字段对应的 js 文件。文件为默认导出一个生成器函数，函数格式如下：\n\nexport default async (\n  context: GeneratorContext,\n  generator: GeneratorCore,\n) => {};\n\n\n该函数参数为 context 和 generator：\n\n\ncontext\n\ncontext 提供 codesmith 运行时维护的上下文信息。其类型定义为：\n\ninterface GeneratorContext {\n  materials: Record<string, FsMaterial>; // 资源\n  config: Record<string, any>; // 用户 config 配置\n  data?: Record<string, any>; // 用户 data 配置\n  current: { material: FsMaterial } | null; //  当前生成器运行可获取的文件资源\n  [key: string]: any; // 其他补充字段\n}\n\n\nmaterials 是 codesmith 的抽象文件系统，维护这生成器名称和可操作文件的映射关系。\n\nmaterials 中还维护这一个 default 的映射关系，用于维护当前生成器执行目录的资源信息，通过该字段可以对目标项目资源进行操作。\n\n例如当需要修改当前项目的 package.json 中的字段:\n\nconst resource = context.materials.default.get(\n  path.join(appDir, 'package.json'),\n);\n\n\n将获取到的 resource 传递给 codesmith 提供的 JSON API 即可实现 json 操作。\n\nGeneratorContext 的 current 字段上维护这当前运行的生成器文件资源，可以通过 current.material 获取到当前的\nFsMaterial.\n\nFsMaterial 中提供了 get 方法用于获取资源文件并将资源文件传给生成器支持的 API 即可对模板文件进行处理。\n\n例如：\n\nconst resourceMap = await material.find('templates/**/*');\n\n\n通过上述方式可以获取到生成器中符合 templates/**/* 规则的所有模板文件，遍历该对象即可对资源文件进行操作。\n\n\ngenerator\n\ngenerator 提供 codesmith 运行时的函数方法。其类型定义为：\n\ninterface GeneratorCore {\n    logger: Logger; // log 函数，支持 info、warning、debug、error、verbose、stream\n    outputPath: string; // 输出文件路径\n    output: {\n        fs: (file: string | number, data: any, options?: string | fs.WriteFileOptions | undefined) => Promise<void>\n    }; // 写文件方法\n    runSubGenerator: (subGenerator: string, relativePwdPath?: string | undefined, config?: Record<string, any> | undefined): Promise<void> // 运行子生成器\n}\n\n\n其中 outputPath 和 context 中的 materials.default 指向相同的目录，outputPath\n用于直接计算目标路径并操作，materials.default 用于获取资源文件。\n\nrunSubGenerator 提供了在一个微生成器中去运行其他微生成器的方法，该方法将自动更新和维护新的 context 上下文信息。\n\n\nTemplate 文件\n\n生成器模板文件。\n\n推荐在项目根目录创建一个 templates\n目录，用于维护该微生成器的模板文件，微生成器执行过程中只能使用自身的模板文件，对于需要共用的模板文件，建议通过共用子生成器实现。","frontmatter":{"sidebar_position":2}},{"id":566,"title":"Web 应用","routePath":"/guides/topic-detail/generator/config/app","lang":"zh","toc":[{"id":"项目创建","text":"项目创建","depth":2},{"id":"new-命令","text":"New 命令","depth":2},{"id":"actiontype","text":"actionType","depth":3},{"id":"element","text":"element","depth":3},{"id":"name","text":"name","depth":4},{"id":"function","text":"function","depth":3},{"id":"bff-相关参数","text":"BFF 相关参数","depth":4}],"domain":"","content":"\n\n\n项目创建\n\n创建项目时配置，@modern-js/create 使用 --config 参数时使用的配置，也是在生成器插件中修改和添加 input 时使用的配置。\n\n应用项目创建参数都为通用配置。\n\n\nNew 命令\n\n应用项目中 new 命令配置， 可以在执行 new 命令时通过 --config 参数配置，也可在生成器插件中创建元素和启用功能时使用。\n\n\nactionType\n\nNew 命令的操作类型(actionType)，类型支持两种：\n\n * element 创建工程元素\n\n * function 启用功能\n\nINFO\n\n在生成器插件中使用启用功能和创建元素时不需要该参数，生成器插件中自动添加该参数。\n\n\nelement\n\n元素名称(element)，支持两个选项：\n\n * 创建应用入口(entry)\n\n * 新建自定义 Web Serve 源码目录(server)\n\n入口还需要配置具体的配合使用，介绍如下：\n\nname\n\n入口名称(name), 字符串类型。\n\n\nfunction\n\n可选功能名称(function)，支持如下选项:\n\n * Tailwind CSS(tailwindcss)\n\n * BFF(bff)\n\n * SSG(ssg)\n\n * 微前端(micro_frontend)\n\n * 单元测试(test)\n\n * Storybook(mwa_storybook)\n\n * 启用「基于 UA 的 Polyfill」功能(polyfill)\n\n * 启用「全局代理」(proxy)\n\nbff 和还需要配置具体的配合使用，介绍如下：\n\nBFF 相关参数\n\nbffType\n\nBFF 类型(bffType)，支持两个选项：\n\n * 函数模式(function)\n\n * 框架模式(framework)\n\nframework\n\nBFF 运行时框架(framework)，支持两个选项：\n\n * Express(express)\n\n * Koa(koa)","frontmatter":{"sidebar_position":2}},{"id":567,"title":"通用配置","routePath":"/guides/topic-detail/generator/config/common","lang":"zh","toc":[{"id":"solution","text":"solution","depth":3},{"id":"scenes","text":"scenes","depth":3},{"id":"language","text":"language","depth":3},{"id":"packagemanager","text":"packageManager","depth":3},{"id":"其他配置","text":"其他配置","depth":2},{"id":"noneedinstall","text":"noNeedInstall","depth":3},{"id":"noneedgit","text":"noNeedGit","depth":3},{"id":"successinfo","text":"successInfo","depth":3},{"id":"ismonoreposubproject","text":"isMonorepoSubProject","depth":3},{"id":"istest","text":"isTest","depth":3},{"id":"ispublic","text":"isPublic","depth":3}],"domain":"","content":"\n\n\nsolution\n\n工程方案类型(solution)，选项如下：\n\n * 应用(mwa)\n\n * 模块(module)\n\n * Monorepo\n\nINFO\n\nsolution 配置只能在 @modern-js/create 的 --config 参数中使用，不能在生成器插件中通过设置输入默认值的方式使用。\n\n\nscenes\n\n项目场景(scenes)，当使用创建工程方案场景类型的生成器插件时，该值为对应生成器插件的 key 值。\n\nINFO\n\nscenes 配置只能在 @modern-js/create 的 --config 参数中使用，不能在生成器插件中通过设置输入默认值的方式使用。\n\n\nlanguage\n\n开发语言(language)，选项如下：\n\n * TS(ts)\n\n * ES6+(js)\n\n\npackageManager\n\n包管理工具(packageManager)，选项如下：\n\n * pnpm(pnpm)\n\n * Yarn(yarn)\n\nINFO\n\n在生成器插件创建工程方案场景的自定义类型(custom)中，默认只提供了 packageManager 配置。\n\n\n其他配置\n\n\nnoNeedInstall\n\n * 类型： boolean\n * 默认值： false\n\n是否跳过依赖安装。\n\n\nnoNeedGit\n\n * 类型： boolean\n * 默认值： false\n\n是否跳过 git 初始化和提交初始 commit。\n\n\nsuccessInfo\n\n * 类型： string\n * 默认值： 不同工程方案的命令操作提示\n\n自定义创建项目成功的提示信息。\n\n\nisMonorepoSubProject\n\n * 类型： boolean\n * 默认值： false\n\n是否为 Monorepo 子项目。\n\n\nisTest\n\n * 类型： boolean\n * 默认值： false\n\n作用于应用项目，标识是否为测试项目。\n\n * true: 创建到路径 examples/\n * false: 创建到路径 apps/\n\n\nisPublic\n\n * 类型： boolean\n * 默认值： false\n\n作用于模块 (Module) 项目，标识是否需要对外发布。\n\n * true: 创建到路径 packages/\n * false: 创建到路径 features/","frontmatter":{"sidebar_position":1}},{"id":568,"title":"模块","routePath":"/guides/topic-detail/generator/config/module","lang":"zh","toc":[{"id":"项目创建","text":"项目创建","depth":2},{"id":"packagename","text":"packageName","depth":3},{"id":"new-命令","text":"New 命令","depth":2},{"id":"actiontype","text":"actionType","depth":3},{"id":"function","text":"function","depth":3}],"domain":"","content":"\n\n\n项目创建\n\n创建项目时配置，@modern-js/create 使用 --config 参数时使用的配置，也是在生成器插件中修改和添加 input 时使用的配置。\n\n模块项目默认包含通用配置，通用配置可查看通用配置。\n\n\npackageName\n\n包名(packageName)，字符串类型，为输入值。\n\n\nNew 命令\n\n模块项目中 new 命令配置， 可以在执行 new 命令时通过 --config 参数配置，也可在生成器插件中创建元素和启用功能时使用。\n\n\nactionType\n\nNew 命令的操作类型(actionType)，类型支持一种：\n\n * function 启用功能\n\nINFO\n\n在生成器插件中使用启用功能和创建元素时不需要该参数，生成器插件中自动添加该参数。\n\n\nfunction\n\n可选功能名称(function)，支持如下选项:\n\n * Tailwind CSS(tailwindcss)\n\n * Storybook(storybook)\n\n * Runtime API(runtimeApi)\n\n * 测试(test)","frontmatter":{"sidebar_position":3}},{"id":569,"title":"Monorepo","routePath":"/guides/topic-detail/generator/config/monorepo","lang":"zh","toc":[{"id":"创建子项目","text":"创建子项目","depth":2},{"id":"solution","text":"solution","depth":3},{"id":"packagename","text":"packageName","depth":3},{"id":"packagepath","text":"packagePath","depth":3}],"domain":"","content":"\n\nMonorepo 项目默认只需要 PackageManager 配置。\n\n\n创建子项目\n\nMonorepo 项目支持通过使用 new\n命令创建子项目，子项目类型支持应用、测试应用、模块、内部模块，除了应用和模块各自的配置外，这里还需要一些通用的子项目配置。\n\n\nsolution\n\n子项目类型(solution)，不同子项目类型字段为:\n\n * 应用(mwa)\n * 应用（测试）(mwa_test)\n * 模块(module)\n * 模块（内部）(inner_module)\n\n\npackageName\n\n子项目名称(packageName)，字符串类型。\n\n\npackagePath\n\n子项目路径(packagePath)，字符串类型。","frontmatter":{"sidebar_position":4}},{"id":570,"title":"为什么需要生成器插件","routePath":"/guides/topic-detail/generator/plugin/abstract","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 提供了应用、模块和 Monorepo 三种工程方案，并通过使用 @modern-js/create\n工具可以创建三种工程方案的初始项目模板，初始项目模板会提供基本的代码开发环境、简单的示例代码及配置等。\n\nModern.js 提供的初始化模板具有通用性，能满足一些通用的项目开发需求。\n\n当你深度使用 Modern.js 时，必然会发现每次创建的项目都会进行一些针对自身项目的特定的相似改动，比如修改示例代码、增加一些配置、开启某些功能等。\n\n生成器插件可以帮你将这些针对个人或团队特定的改动沉淀下来，在执行 npx @modern-js/create 只需简单的带上 --plugin\n参数即可避免每次创建完项目都需重复性修改项目的工作。\n\n生成器插件是在 Modern.js 提供的初始化模板项目的基础上，提供对模板进行增加、删除、修改的方法，并通过快捷的方式修改\npackage.json、modernConfig 配置和开启功能等操作。\n\n生成器插件提供了两种定制化方式：\n\n 1. 扩展工程方案：直接对默认提供的三大工程方案进行定制化\n\n 2. 创建工程方案场景：基于默认的三大工程方案创建对应的工程方案场景\n\n接下来将会逐步介绍如何使用和开发生成器插件。","frontmatter":{"sidebar_position":1}},{"id":571,"title":"addFile","routePath":"/guides/topic-detail/generator/plugin/api/file/addFile","lang":"zh","toc":[{"id":"type","text":"type","depth":2},{"id":"file","text":"file","depth":2},{"id":"template","text":"template","depth":2},{"id":"templatefile","text":"templateFile","depth":2},{"id":"force","text":"force","depth":2},{"id":"data","text":"data","depth":2}],"domain":"","content":"\n\n添加单个文件。用于添加 templates 目录的单个模板文件或者直接使用模板添加到模板文件。\n\n该方法可用于任何文件类型，对于二进制以外的文件类型，添加文件时会进行 Handlebars 渲染。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport interface AddFileParams {\n  type: FileType;\n  file: string;\n  template?: string;\n  templateFile?: string;\n  force?: boolean;\n  data?: Record<string, string>;\n}\nexport type ForgedAPI = {\n  addFile: (params: AddFileParams) => Promise<void>;\n  ...\n};\n\n\n\ntype\n\n文件类型，具体可查看文件类型。\n\n\nfile\n\n创建的目标文件路径。\n\n\ntemplate\n\n文件模板，配置该字段值可直接用于模板渲染文件。优先级低于 templateFile。\n\n\ntemplateFile\n\n模板文件，用于渲染的模板文件路径，其值为 templates 的相对路径即可。\n\n\nforce\n\n是否强制覆盖，当添加的文件已存在时，默认会冲突报错，设置该值为 true 时，可强制覆盖。\n\n\ndata\n\nHandlebars 渲染数据。","frontmatter":{"sidebar_position":4}},{"id":572,"title":"addHelper","routePath":"/guides/topic-detail/generator/plugin/api/file/addHelper","lang":"zh","toc":[{"id":"name","text":"name","depth":2},{"id":"fn","text":"fn","depth":2}],"domain":"","content":"\n\n针对于文本类型文件，增加 Handlebars 的自定义 Help 函数，具体可查看文档Custom Helpers。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\n  addHelper: (name: string, fn: Handlebars.HelperDelegate) => void;\n  ...\n};\n\n\n\nname\n\nhelp 函数名称。\n\n\nfn\n\nhelp 函数实现。","frontmatter":{"sidebar_position":2}},{"id":573,"title":"addManyFile","routePath":"/guides/topic-detail/generator/plugin/api/file/addManyFile","lang":"zh","toc":[{"id":"type","text":"type","depth":2},{"id":"destination","text":"destination","depth":2},{"id":"templatefiles","text":"templateFiles","depth":2},{"id":"templatebase","text":"templateBase","depth":2},{"id":"filenamefunc","text":"fileNameFunc","depth":2},{"id":"data","text":"data","depth":2}],"domain":"","content":"\n\n批量添加文件。用于添加 templates 目录的多个文件。\n\n该方法可用于任何文件类型，对于二进制以外的文件类型，添加文件时会进行 Handlebars 渲染。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport interface AddManyFilesParams {\n  type: FileType;\n  destination: string;\n  templateFiles: string[] | (() => string[]);\n  templateBase?: string;\n  fileNameFunc?: (name: string) => string;\n  data?: Record<string, string>; // template data\n}\nexport type ForgedAPI = {\n  addManyFiles: (params: AddManyFilesParams) => Promise<void>;\n  ...\n};\n\n\n\ntype\n\n文件类型，具体可查看文件类型。\n\n\ndestination\n\n创建的目标文件夹路径。由于是批量添加文件，这里填写需要写入的文件夹路径即可。\n\n\ntemplateFiles\n\n模板文件列表。 该参数支持函数参数，也支持 globby 正则。\n\n\ntemplateBase\n\n模板基础路径。 模板路径通常为同一个目录下的模板文件，如果渲染结果需要去除掉模板文件前缀目录，可使用该字段。 模板渲染文件内容将等于 templateFiles\n- templateBase\n\n\nfileNameFunc\n\n重命名文件函数，在该函数中将一次传入渲染的文件名称，可在该函数中进行重命名。\n\n\ndata\n\nHandlebars 渲染数据。","frontmatter":{"sidebar_position":5}},{"id":574,"title":"addPartial","routePath":"/guides/topic-detail/generator/plugin/api/file/addPartial","lang":"zh","toc":[{"id":"name","text":"name","depth":2},{"id":"str","text":"str","depth":2}],"domain":"","content":"\n\n针对于文本类型文件，增加 Handlebars 的自定义 Partial 片段，具体可查看文档Partials。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\n  addPartial: (name: string, str: Handlebars.Template) => void;\n  ...\n};\n\n\n\nname\n\npartial 名称。\n\n\nstr\n\npartial 模板字符串。","frontmatter":{"sidebar_position":3}},{"id":575,"title":"介绍","routePath":"/guides/topic-detail/generator/plugin/api/file/introduce","lang":"zh","toc":[{"id":"文件类型","text":"文件类型","depth":2}],"domain":"","content":"\n\n文件操作 API 可在 onForged 生命周期函数中使用，可对当前项目文件进行增、删、改的操作。\n\n文件操作 API 相关路径填写项目相对路径即可，生成器插件会自动添加当前项目路径前缀。\n\n\n文件类型\n\n生成器插件将文件类型分为一下几类：\n\n * 文本文件：纯文本内容文件，可使用 handlebars 进行模板处理的文件。\n\n * 二进制文件：图片、音频、视频等文件\n\nWARNING\n\n使用变量的 jsx 或 tsx 文件为二进制文件，其语法与 handlebars 渲染冲突，会造成模板文件创建失败。\n\n * JSON 文件：JSON 格式的文件，例如 package.json、 tsconfig.json。\n\n * 文本列表文件：文件由行文本组成的文件，例如 .gitignore, .editorconfig, .npmrc。\n\n生成器插件的文件操作 API 将是针对这四种文件类型进行操作。\n\n其类型定义为：\n\nexport enum FileType {\n  Text = 'text',\n  Binary = 'binary',\n  Json = 'json',\n  TextRaw = 'textRaw',\n}\n","frontmatter":{"sidebar_position":1}},{"id":576,"title":"rmDir","routePath":"/guides/topic-detail/generator/plugin/api/file/rmDir","lang":"zh","toc":[{"id":"dirname","text":"dirName","depth":2}],"domain":"","content":"\n\n删除文件夹。该方法会递归的删除文件夹下的所有文件。\n\n该方法可用于任何文件类型。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\n  rmDir: (dirName: string) => Promise<void>;\n  ...\n};\n\n\n\ndirName\n\n需删除的文件夹名称或文件夹路径。","frontmatter":{"sidebar_position":10}},{"id":577,"title":"rmFile","routePath":"/guides/topic-detail/generator/plugin/api/file/rmFile","lang":"zh","toc":[{"id":"filename","text":"fileName","depth":2}],"domain":"","content":"\n\n删除文件。\n\n该方法可用于任何文件类型。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\n  rmFile: (fileName: string) => Promise<void>;\n  ...\n};\n\n\n\nfileName\n\n需删除的文件名称或文件路径。","frontmatter":{"sidebar_position":9}},{"id":578,"title":"updateJSONFile","routePath":"/guides/topic-detail/generator/plugin/api/file/updateJSONFile","lang":"zh","toc":[{"id":"filename","text":"fileName","depth":2},{"id":"updateinfo","text":"updateInfo","depth":2}],"domain":"","content":"\n\n更新 JSON 文件字段。\n\n该方法适用于 JSON 文件类型，可批量更新 JSON 文件中字段值。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\n  updateJSONFile: (\n    fileName: string,\n    updateInfo: Record<string, unknown>,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nfileName\n\nJSON 文件的文件名或者文件路径。\n\n\nupdateInfo\n\n字段更新信息。\n\n该信息使用 Record 形式表示。\n\n例如需要更新 name 字段：\n\napi.updateJSONFile(file, {\n  name: '新名称',\n});\n\n\n需更新嵌套字段：\n\napi.updateJSONFile(file, {\n  'dependencies.name': '新名称',\n});\n\n\nWARNING\n\n更新嵌套字段时注意字段名，如果不是全量更新，需将嵌套的 key 也写入字段名中。","frontmatter":{"sidebar_position":6}},{"id":579,"title":"updateModernConfig","routePath":"/guides/topic-detail/generator/plugin/api/file/updateModernConfig","lang":"zh","toc":[{"id":"updateinfo","text":"updateInfo","depth":2}],"domain":"","content":"\n\n更新 package.json 中 modernConfig 字段。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\n  updateModernConfig: (updateInfo: Record<string, any>) => Promise<void>;\n  ...\n};\n\n\n\nupdateInfo\n\n字段更新信息。\n\nINFO\n\n该函数为 updateJSONFile 的封装，将自动更新 package.json 的 modernConfig 字段 updateInfo 中只需填写相对于\nmodernConfig 的更新信息即可。","frontmatter":{"sidebar_position":8}},{"id":580,"title":"updateTextRawFile","routePath":"/guides/topic-detail/generator/plugin/api/file/updateTextRawFile","lang":"zh","toc":[{"id":"filename","text":"fileName","depth":2},{"id":"update","text":"update","depth":2}],"domain":"","content":"\n\n更新文本列表文件内容。\n\n该方法适用与文本列表文件类型。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport type ForgedAPI = {\nupdateTextRawFile: (\n    fileName: string,\n    update: (content: string[]) => string[],\n  ) => Promise<void>;\n  ...\n};\n\n\n\nfileName\n\n文本列表文件的文件名或者文件路径。\n\n\nupdate\n\n更新函数。\n\n该函数参数为当前文件内容，内容将以 '\\n' 分割，以数组的形式传入函数，函数的返回值也是数组，内部将自动以 '\\n' 合并，写入源文件。","frontmatter":{"sidebar_position":7}},{"id":581,"title":"gitAddAndCommit","routePath":"/guides/topic-detail/generator/plugin/api/git/gitAddAndCommit","lang":"zh","toc":[{"id":"commitmessage","text":"commitMessage","depth":2}],"domain":"","content":"\n\n提交当前仓库变更。\n\n其类型定义为：\n\nexport type AfterForgedAPI = {\n  gitAddAndCommit: (commitMessage: string) => Promise<void>;\n  ...\n};\n\n\n\ncommitMessage\n\n提交信息。","frontmatter":{"sidebar_position":3}},{"id":582,"title":"initGitRepo","routePath":"/guides/topic-detail/generator/plugin/api/git/initGitRepo","lang":"zh","toc":[],"domain":"","content":"\n\n初始化当前目录为 Git 仓库。\n\n其类型定义为：\n\nexport type AfterForgedAPI = {\n  initGitRepo: () => Promise<void>;\n  ...\n};\n","frontmatter":{"sidebar_position":2}},{"id":583,"title":"isInGitRepo","routePath":"/guides/topic-detail/generator/plugin/api/git/isInGitRepo","lang":"zh","toc":[],"domain":"","content":"\n\n判断当前项目是否为一个 Git 仓库。\n\n其类型定义为：\n\nexport type AfterForgedAPI = {\n  isInGitRepo: () => Promise<boolean>;\n  ...\n};\n","frontmatter":{"sidebar_position":1}},{"id":584,"title":"AfterForged","routePath":"/guides/topic-detail/generator/plugin/api/hook/afterForged","lang":"zh","toc":[{"id":"func","text":"func","depth":2},{"id":"api","text":"api","depth":3},{"id":"inputdata","text":"inputData","depth":3}],"domain":"","content":"\n\nafterForged 函数为生成器插件生命周期函数，其通常用于定义安装依赖、Git 等操作，这些操作将会在 onForged 函数执行完成后进行。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport type PluginAfterForgedFunc = (\n  api: AfterForgedAPI,\n  inputData: Record<string, unknown>,\n) => Promise<void>;\n\nexport interface IPluginContext {\n  afterForged: (func: PluginAfterForgedFunc) => void;\n  ...\n}\n\n\n\nfunc\n\nafterForged 参数是一个回调函数，函数参数为 api 和 inputData。\n\n\napi\n\n在 afterForged 生命周期中支持的函数列表，具体可查看 Git API 和 NPM API。\n\n\ninputData\n\n当前用户输入，可用于获取用户当前的输入信息及配置信息。","frontmatter":{"sidebar_position":2}},{"id":585,"title":"OnForged","routePath":"/guides/topic-detail/generator/plugin/api/hook/onForged","lang":"zh","toc":[{"id":"func","text":"func","depth":2},{"id":"api","text":"api","depth":3},{"id":"inputdata","text":"inputData","depth":3}],"domain":"","content":"\n\nonForged 函数为生成器插件生命周期函数，其通常用于定义文件类型操作，这些操作将在 base 的工程方案文件操作完成后进行。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport type PluginForgedFunc = (\n  api: ForgedAPI,\n  inputData: Record<string, unknown>,\n) => void | Promise<void>;\n\nexport interface IPluginContext {\n  onForged: (func: PluginForgedFunc) => void;\n  ...\n}\n\n\n\nfunc\n\nonForged 参数是一个回调函数，函数参数为 api 和 inputData。\n\n\napi\n\n在 onForged 生命周期中支持的函数列表，具体可查看文件操作 API 和启用功能 API。\n\n\ninputData\n\n当前用户输入，可用于获取用户当前的输入信息及配置信息。","frontmatter":{"sidebar_position":1}},{"id":586,"title":"isFileExit","routePath":"/guides/topic-detail/generator/plugin/api/info/isFileExit","lang":"zh","toc":[{"id":"filename","text":"fileName","depth":2}],"domain":"","content":"\n\n判断文件是否存在。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport interface IPluginContext {\n  isFileExit: (fileName: string) => Promise<boolean>;\n  ...\n}\n\n\n\nfileName\n\n需要判断的文件名或者文件路径，基于创建的项目的相对路径即可。","frontmatter":{"sidebar_position":2}},{"id":587,"title":"locale","routePath":"/guides/topic-detail/generator/plugin/api/info/locale","lang":"zh","toc":[],"domain":"","content":"\n\n当前语言。\n\n该变量可直接在 context 上获取。\n\n该字段存在两个值：\n\n * zh: 中文\n\n * en: 英文\n\n生成器插件中可根据该字段调整相关展示字段的值。","frontmatter":{"sidebar_position":1}},{"id":588,"title":"readDir","routePath":"/guides/topic-detail/generator/plugin/api/info/readDir","lang":"zh","toc":[{"id":"dir","text":"dir","depth":2}],"domain":"","content":"\n\n读取文件夹，获取文件列表。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport interface IPluginContext {\n  readDir: (dir: string) => Promise<string[]>;\n  ...\n}\n\n\n\ndir\n\n文件夹名称或路径，基于创建的项目的相对路径即可。","frontmatter":{"sidebar_position":3}},{"id":589,"title":"addInputAfter","routePath":"/guides/topic-detail/generator/plugin/api/input/addInputAfter","lang":"zh","toc":[{"id":"key","text":"key","depth":2},{"id":"input","text":"input","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n在默认输入后添加输入问题。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport interface IPluginContext {\n  addInputAfter: (key: string, input: Schema) => void;\n  ...\n}\n\n\n\nkey\n\nModern.js 工程方案的配置的问题关键字，具体配置可查看生成器配置。\n\n\ninput\n\n需要添加的问题，具体类型定义可查看自定义输入相关类型定义。\n\n\n示例\n\n在包管理工具后面添加输入：\n\ncontext.addInputAfter('packageManager', {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: '开发语言',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n});\n\n\nINFO\n\n注意事项\n\n 1. 添加问题的 key 不能和 Modern.js 提供的项目类型自身的问题的 key 重复\n\n 2. 添加问题 addInputAfter 的优先级高于 addInputBefore，当同时对一个 key 添加 After 问题和对其后一个 key 添加\n    Before 问题时，After 问题会在 Before 之前。\n\n 3. 当需要在相同 key 前面或者后面添加多个问题时，可多次调用该方法，问题的顺序会按照调用顺序进行排列。","frontmatter":{"sidebar_position":3}},{"id":590,"title":"addInputBefore","routePath":"/guides/topic-detail/generator/plugin/api/input/addInputBefore","lang":"zh","toc":[{"id":"key","text":"key","depth":2},{"id":"input","text":"input","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n在默认输入前添加输入问题。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport interface IPluginContext {\n  addInputBefore: (key: string, input: Schema) => void;\n  ...\n}\n\n\n\nkey\n\nModern.js 工程方案的配置的问题关键字，具体配置可查看生成器配置。\n\n\ninput\n\n需要添加的问题，具体类型定义可查看自定义输入相关类型定义。\n\n\n示例\n\n在包管理工具后面添加输入：\n\ncontext.addInputBefore('packageManager', {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: '开发语言',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n});\n\n\n注意事项\n\n 1. 添加问题的 key 不能和 Modern.js 提供的项目类型自身的问题的 key 重复\n\n 2. 添加问题 addInputAfter 的优先级高于 addInputBefore，当同时对一个 key 添加 After 问题和对其后一个 key 添加\n    Before 问题时，After 问题会在 Before 之前。\n\n 3. 当需要在相同 key 前面或者后面添加多个问题时，可多次调用该方法，问题的顺序会按照调用顺序进行排列。","frontmatter":{"sidebar_position":2}},{"id":591,"title":"setInput","routePath":"/guides/topic-detail/generator/plugin/api/input/setInput","lang":"zh","toc":[{"id":"key","text":"key","depth":2},{"id":"filed","text":"filed","depth":2},{"id":"value","text":"value","depth":2},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n设置问题属性。\n\n该方法可直接在 context 上获取。\n\n其类型定义为：\n\nexport interface IPluginContext {\n  setInput: (key: string, field: string, value: unknown) => void;\n  ...\n}\n\n\n\nkey\n\n问题关键字，可以为 Modern.js 工程方案的问题关键字，也可以为生成器插件中新增问题的关键字。\n\n\nfiled\n\n需设置的问题字段，可修改除了当前 Input 除 key 以外的其他字段，Input 具体类型定义可查看自定义输入相关类型定义。\n\n\nvalue\n\n需设置的问题字段值。value 支持函数，函数参数为当前字段值，返回值需要为完整的新的字段值。\n\nINFO\n\n对于 Modern.js 工程类型提供的输入选项，暂时只支持删除，不支持增加，增加会造成代码中的逻辑判断存在问题。\n\n\n示例\n\n修改 packageName 的展示名称\n\ncontext.setInput('packageName', 'title', '展示名称');\n","frontmatter":{"sidebar_position":4}},{"id":592,"title":"setInputValue","routePath":"/guides/topic-detail/generator/plugin/api/input/setInputValue","lang":"zh","toc":[{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n设置输入默认值。\n\n该方法可直接在 context 上获取。\n\nexport interface IPluginContext {\n    setInputValue: (value: Record<string, unknown>) => void;\n  ...\n}\n\n\n\n示例\n\ncontext.setInputValue({\n  moduleRunWay: 'no',\n});\n\n\nWARNING\n\n该方法只支持设置生成器插件集成的工程方案对应的配置参数值，不支持设置工程方案类型(solution)和项目场景(scenes)，这两个配置可以通过执行时的\n--config 参数设置默认值。","frontmatter":{"sidebar_position":7}},{"id":593,"title":"自定义输入相关类型定义","routePath":"/guides/topic-detail/generator/plugin/api/input/type","lang":"zh","toc":[{"id":"input","text":"Input","depth":2},{"id":"type","text":"type","depth":3},{"id":"name","text":"name","depth":3},{"id":"title","text":"title","depth":3},{"id":"default","text":"default","depth":3},{"id":"enum","text":"enum","depth":3},{"id":"x-validate","text":"x-validate","depth":3},{"id":"x-reactions","text":"x-reactions","depth":3},{"id":"properties","text":"properties","depth":3},{"id":"示例","text":"示例","depth":2}],"domain":"","content":"\n\n\nInput\n\nModern.js Input 输入类型采用了开源的 Formily Schema 结果，支持了部分其 Schema 字段。\n\n\ntype\n\nschema 类型，目前生成器插件输入支持的类型为 string、number 和 object 类型。其中 object 用于实现 schema 嵌套，需要和\nproperties 配合使用。\n\n\nname\n\nschema 的关键字。\n\n\ntitle\n\nschema 的展示名称。\n\n\ndefault\n\nschema 默认值。\n\n\nenum\n\nschema 如果为选择类型，该字段用于定义选项内容。\n\n每个选项支持两个字段：\n\n * value: 选项值。\n\n * label: 展示名称。\n\n\nx-validate\n\nschema 的验证规则。这里支持 Formily 的校验方式，具体可参考 Formily 表单校验。\n\n\nx-reactions\n\nschema 字段联动。这里支持 Formily 的联动方式，具体可参考 Formily 实现联动逻辑。\n\n\nproperties\n\n当 schema 类型为 object 时，定义其子表单。\n\n\n示例\n\nconst schema = {\n  type: 'object',\n  properties: {\n    language: {\n      type: 'string',\n      title: '开发语言',\n      enum: [\n        { label: 'TS', value: 'ts' },\n        { label: 'ES6+', value: 'js' },\n      ],\n    },\n  },\n};\n","frontmatter":{"sidebar_position":1}},{"id":594,"title":"介绍","routePath":"/guides/topic-detail/generator/plugin/api/introduce","lang":"zh","toc":[{"id":"生成器插件构成","text":"生成器插件构成","depth":2},{"id":"生成器插件分类","text":"生成器插件分类","depth":2},{"id":"类型定义","text":"类型定义","depth":3},{"id":"扩展工程方案","text":"扩展工程方案","depth":4},{"id":"创建工程方案场景","text":"创建工程方案场景","depth":4},{"id":"自定义custom类型","text":"自定义(custom)类型","depth":3}],"domain":"","content":"\n\nModern.js 支持通过生成器插件的方式对提供的工程方案进行定制化或针对工程方案进行特定场景的定制化。\n\n\n生成器插件构成\n\n生成器插件是一个模块，可以直接使用 Modern.js 的模块工程方案开发。当然，Modern.js\n也提供了对应的生成器插件(@modern-js/generator-plugin-plugin)直接新建生成器插件项目。\n\n一个生成器插件项目目录如下：\n\n.\n├── README.md\n├── package.json\n├── src\n│   ├── index.ts\n│   └── modern-app-env.d.ts\n├── templates\n└── tsconfig.json\n\n\nsrc/index.ts 中为源码目录，用于开发生成器插件逻辑。插件默认导出一个函数，函数参数为 context，context\n上提供一些方法可直接对当前项目进行操作，本章节后续将详细介绍这些方法。\n\ntemplates 目录为模板目录，用于存在生成器插件中需要使用的模板文件。\n\n\n生成器插件分类\n\n生成器插件分为两种：\n\n 1. 扩展工程方案：直接对默认提供的三大工程方案进行定制化\n\n 2. 创建工程方案场景：基于默认的三大工程方案创建对应的工程方案场景\n\n\n类型定义\n\n生成器插件的分类通过 package.json 中的 meta 信息提供。\n\n扩展工程方案\n\n{\n  \"meta\": {\n    \"extend\": \"mwa\"\n  }\n}\n\n\nextend 为扩展的工程方案名称，Modern.js 的工程方案名称分别为 mwa、module、 monorepo。\n\n创建工程方案场景\n\n{\n  \"meta\": {\n    \"key\": \"new_solution\",\n    \"name\": \"新工程方案\",\n    \"type\": \"mwa\"\n  }\n}\n\n\nkey 为场景方案名称，值为字符串。 name 为场景方案展示名称，用与使用时选项的展示，值为字符串。 type 为工程方案类型，除了和 extend\n一样支持三种工程方案之外，还支持自定义(custom)类型。\n\n\n自定义(custom)类型\n\n自定义类型提供了完全自定义工程方案的实现能力，当使用该类型新建工程方案场景时，只提供了少量的开发层面的最佳实践的代码，比如\n.gitignore、.editorConfig 等文件，具体为下方目录结构：\n\n.\n├── .editorconfig\n├── .gitignore\n├── .idea\n│   ├── codeStyles\n│   │   ├── Project.xml\n│   │   └── codeStyleConfig.xml\n│   ├── inspectionProfiles\n│   │   └── Project_Default.xml\n│   └── jsLinters\n│       └── eslint.xml\n├── .nvmrc\n└── .vscode\n    ├── extensions.json\n    └── settings.json\n\n\n自定义类型保证了可根据自身对工程方案的需求灵活进行配置。","frontmatter":{"sidebar_position":1}},{"id":595,"title":"createElement","routePath":"/guides/topic-detail/generator/plugin/api/new/createElement","lang":"zh","toc":[{"id":"element","text":"element","depth":2},{"id":"params","text":"params","depth":2}],"domain":"","content":"\n\n创建工程元素，只支持应用工程方案。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport enum ActionElement {\n  Entry = 'entry',\n  Server = 'server',\n}\nexport type ForgedAPI = {\n  createElement: (\n    element: ActionElement,\n    params: Record<string, unknown>,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nelement\n\n工程元素类型，支持 entry 和 server。\n\n\nparams\n\n创建元素的其他参数，详细参考应用 New 命令。","frontmatter":{"sidebar_position":2}},{"id":596,"title":"createSubProject","routePath":"/guides/topic-detail/generator/plugin/api/new/createSubProject","lang":"zh","toc":[{"id":"solution","text":"solution","depth":2},{"id":"params","text":"params","depth":2}],"domain":"","content":"\n\n创建子项目，只支持 Monorepo 工程方案。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport enum SubSolution {\n  MWA = 'mwa',\n  MWATest = 'mwa_test',\n  Module = 'module',\n  InnerModule = 'inner_module',\n}\nexport type ForgedAPI = {\n  createSubProject: (\n    solution: SubSolution,\n    params: Record<string, unknown>,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nsolution\n\n子项目工程方案名称。\n\n\nparams\n\n创建子项目的其他参数，详细参考Monorepo 创建子项目。","frontmatter":{"sidebar_position":4}},{"id":597,"title":"enableFunc","routePath":"/guides/topic-detail/generator/plugin/api/new/enableFunc","lang":"zh","toc":[{"id":"func","text":"func","depth":2},{"id":"params","text":"params","depth":2}],"domain":"","content":"\n\n启用功能，支持应用和模块工程方案。\n\n该方法可在 onForged 生命周期的 api 参数上获取。\n\n其类型定义为：\n\nexport enum ActionFunction {\n  UnBundle = 'unbundle',\n  TailwindCSS = 'tailwindcss',\n  BFF = 'bff',\n  MicroFrontend = 'micro_frontend',\n  I18n = 'i18n',\n  Test = 'test',\n  E2ETest = 'e2e_test',\n  Doc = 'doc',\n  Storybook = 'storybook',\n  RuntimeApi = 'runtimeApi',\n  SSG = 'ssg',\n  Polyfill = 'polyfill',\n  Deploy = 'deploy',\n}\nexport type ForgedAPI = {\n  enableFunc: (\n    func: ActionFunction,\n    params?: Record<string, unknown> | undefined,\n  ) => Promise<void>;\n  ...\n};\n\n\n\nfunc\n\n功能名称，根据不用的工程方案支持的功能进行传值。\n\n\nparams\n\n启用功能时其他参数，详细参考应用 New 命令和模块 New 命令。","frontmatter":{"sidebar_position":3}},{"id":598,"title":"介绍","routePath":"/guides/topic-detail/generator/plugin/api/new/introduce","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 提供的三个工程方案支持在项目中执行 new 命令创建元素和开启功能。在生成器插件中可直接调用相关 API 默认创建一些元素和开启支持的功能。\n\n不同的工程方案支持的 new 操作：\n\n * Web 应用\n\n * 模块\n\n * Monorepo","frontmatter":{"sidebar_position":1}},{"id":599,"title":"install","routePath":"/guides/topic-detail/generator/plugin/api/npm/install","lang":"zh","toc":[],"domain":"","content":"\n\n在项目根目录安装依赖。\n\ninstall 函数中将根据 packageManager 的值使用对应的包管理工具安装依赖。\n\nexport type AfterForgedAPI = {\n  install: () => Promise<void>;\n  ...\n};\n","frontmatter":{"sidebar_position":1}},{"id":600,"title":"如何开发生成器插件","routePath":"/guides/topic-detail/generator/plugin/develop","lang":"zh","toc":[{"id":"创建项目","text":"创建项目","depth":2},{"id":"扩展工程方案","text":"扩展工程方案","depth":3},{"id":"创建工程方案场景","text":"创建工程方案场景","depth":3},{"id":"开发插件逻辑","text":"开发插件逻辑","depth":2},{"id":"自定义输入","text":"自定义输入","depth":3},{"id":"onforged","text":"onForged","depth":3},{"id":"afterforged","text":"afterForged","depth":3}],"domain":"","content":"\n\n\n创建项目\n\nModern.js 提供了生成器插件用于创建开发项目，可直接执行以下命令创建:\n\nnpx @modern-js/create plugin --plugin @modern-js/generator-plugin-plugin\n\n\n插件类型不同，会提问不同的问题，可根据需求选择插件类型\n\n\n扩展工程方案\n\n? 请选择你想创建的工程类型 模块\n? 请选择项目场景 生成器插件\n? 插件包名 plugin\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 插件类型 扩展\n? 插件基础类型 应用\n\n\n\n创建工程方案场景\n\n? 请选择你想创建的工程类型 模块\n? 请选择项目场景 生成器插件\n? 插件包名 plugin\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n? 插件类型 自定义\n? 插件关键字 mobile-app\n? 插件展示名称 移动应用\n? 插件基础类型 应用\n\n\n创建项目命令执行完成后，会对应的生成一个开发生成器插件的项目，package.json 中也会根据你的选择对应的生成 meta 信息。\n\nINFO\n\n生成器插件开发可参考 @modern-js/generator-plugin-plugin 源码地址\n\n\n开发插件逻辑\n\n在 src/index.ts 中完成插件逻辑开发。\n\n插件默认导出一个函数，函数参数为 context，context 上提供一些方法可直接对当前项目进行操作。\n\n简单介绍一下提供的方法，完整的 API 列表可查看生成器插件 API。\n\n\n自定义输入\n\n * addInputBefore\n\n在默认的输入前添加输入，比如在选择包管理工具问题前添加问题，具体 Modern.js 每个问题的配置可查看工程方案配置。\n\ncontext.addInputBefore('input2', {\n  type: 'object',\n  properties: {\n    'input1.2': {\n      type: 'string',\n      title: 'input1.2',\n    },\n  },\n});\n\n\n * setInput\n\n设置已经存在问题的属性\n\ncontext.setInput('test', 'type', 'number');\ncontext.setInput('test', 'enum', [{ value: 'option1', label: '选项一' }]);\n\n\n\nonForged\n\n工程方案类型文件相关操作执行完成后钩子，多个扩展产检将按照 plugin 参数顺序依次执行其 onForged 函数。\n\nonForged 参数是一个回调函数，函数参数为 api 和 input。\n\napi 上会提供一些文件操作相关的方法，可在该钩子中对当前的模板文件进行操作。\n\ninput 为当前用户输入，可用于获取用户当前的输入信息及配置信息。\n\n当需要新的模板文件时，可直接在 templates 目录添加，在 onForged 函数中可直接对 templates 目录文件进行操作，比如下方的\naddFile 中 templateFile 参数就为 templates 目录下的文件。这里不需要显示的声明 templates，直接写相对于\ntemplates 的相对路径即可。\n\nonForged 中支持的 API 函数也可参考 生成器插件 API。\n\ncontext.onForged(async (api: ForgedAPI, input: Record<string, unknown>) => {\n  const { language } = input;\n  api.addFile({\n    type: FileType.Text,\n    file: `src/index.${language as string}`,\n    templateFile: `index.${language as string}.handlebars`,\n    force: true,\n  });\n});\n\n\n\nafterForged\n\nonForged 函数执行完成后钩子，这里主要可进行安装依赖，Git 操作等。\n\n如果你的工程方案是基于 Modern.js 提供的三种工程方案进行的，这个钩子函数是可以不需要的。默认的工程方案中会自动包含安装依赖、提交代码逻辑。\n\n生成器插件还支持了一种自定义的 custom 类型，这种类型只提供了少量的开发层面的最佳实践的代码，比如 .gitignore、.editorConfig\n等文件，这时则需要在 afterForged 函数中手动补充安装依赖和 Git 操作逻辑。\n\nafterForged 参数也是一个回调函数，函数参数为 api 和 input。\n\napi 上会提供一些 npm、Git 等方法，可在该钩子中进行安装依赖，Git 操作。\n\ninput 为当前用户输入，可用于获取用户当前的输入信息及配置信息。\n\nafterForged 中支持的 API 函数也可参考 生成器插件 API。","frontmatter":{"sidebar_position":3}},{"id":601,"title":"如何使用生成器插件","routePath":"/guides/topic-detail/generator/plugin/use","lang":"zh","toc":[{"id":"生成器插件分类","text":"生成器插件分类","depth":2},{"id":"类型定义","text":"类型定义","depth":3},{"id":"扩展工程方案","text":"扩展工程方案","depth":4},{"id":"创建工程方案场景","text":"创建工程方案场景","depth":4},{"id":"执行时机","text":"执行时机","depth":3},{"id":"扩展工程方案-1","text":"扩展工程方案","depth":4},{"id":"创建工程方案场景-1","text":"创建工程方案场景","depth":4}],"domain":"","content":"\n\n@modern-js/create 提供了 --plugin 参数用于声明使用的生成器插件。\n\n你可直接执行下面命令使用生成器插件：\n\nnpx @modern-js/create --plugin <pluginName>\n\n\nplugin 参数支持声明多次，代表同时使用多个生成器插件。\n\n\n生成器插件分类\n\n生成器插件分为两种：\n\n 1. 扩展工程方案：直接对默认提供的三大工程方案进行定制化。\n\n 2. 创建工程方案场景：基于默认的三大工程方案创建对应的工程方案场景。\n\n\n类型定义\n\n生成器插件的分类通过 package.json 中的 meta 信息提供。\n\n扩展工程方案\n\n{\n  \"meta\": {\n    \"extend\": \"mwa\" // 三个工程方案分别对应 mwa、module、 monorepo\n  }\n}\n\n\n创建工程方案场景\n\n{\n  \"meta\": {\n    \"key\": \"new_solution\",\n    \"name\": \"新工程方案\",\n    \"type\": \"mwa\" // 除了三大工程方案，这里类型还支持自定义(custom)类型，后面会详细介绍\n  }\n}\n\n\n\n执行时机\n\n不同类型的定制工程方案的执行时机是不同的。\n\n扩展工程方案\n\n扩展工程方案类型的生成器插件会在选择对应 extend 的工程方案后按照 plugin 参数的声明顺序依次执行。\n\n创建工程方案场景\n\n创建工程方案场景的生成器插件会在选择对应类型的工程方案之后出现选择场景的选项，选项列表包括当前默认的工程方案场景和插件定义的工程方案场景，选择对应的场景，将会执\n行对应的生成器插件。","frontmatter":{"sidebar_position":2}},{"id":602,"title":"项目生成器","routePath":"/guides/topic-detail/generator/project","lang":"zh","toc":[{"id":"使用","text":"使用","depth":2},{"id":"参数","text":"参数","depth":2},{"id":"projectdir","text":"[projectDir]","depth":3},{"id":"--version","text":"--version","depth":3},{"id":"--lang","text":"--lang","depth":3},{"id":"-c---config","text":"-c, --config","depth":3},{"id":"--no-need-install","text":"--no-need-install","depth":3},{"id":"--dist-tag-disttag","text":"--dist-tag <distTag>","depth":3},{"id":"--registry-registry","text":"--registry <registry/>","depth":3},{"id":"--debug","text":"--debug","depth":3},{"id":"--mwa","text":"--mwa","depth":3},{"id":"--module","text":"--module","depth":3},{"id":"--monorepo","text":"--monorepo","depth":3},{"id":"--plugin-plugin","text":"--plugin <plugin>","depth":3},{"id":"--generator-generator","text":"--generator <generator>","depth":3},{"id":"--packages-packages","text":"--packages <packages>","depth":3}],"domain":"","content":"\n\nModern.js 提供了 @modern-js/create 作为项目生成器用于进行 Modern.js 工程方案项目创建。\n\n\n使用\n\n不需要全局安装 @modern-js/create，直接使用 npx 执行该工具即可：\n\nnpx @modern-js/create [projectDir]\n\n\nINFO\n\n使用 npx 可以每次获取最新版本的 @modern-js/create。\n\n\n参数\n\n\n[projectDir]\n\n项目目录名称。\n\n执行上述命令时，默认会在当前目录创建 projectDir 文件夹，并在该文件夹下初始化项目。该参数为空时，将会在当前目录直接生成初始化项目。\n\n\n--version\n\n获取 @modern-js/create 工具版本。\n\n$ npx @modern-js/create --version\n\n[INFO] @modern-js/create v2.0.0\n\n\n\n--lang\n\n指定执行语言，支持 zh 和 en。\n\n默认情况下，@modern-js/create 会自动识别用户的系统语言，选择使用中文或者英文，如果识别失败或者想手动指定语言，可以使用该参数。\n\n\n-c, --config\n\n指定项目默认配置。\n\n默认情况下，@modern-js/create 在执行过程中会出现选择语言、包管理工具等交互问题，当需要提前指定这些配置内容时，可以通过该字段传入。\n\n该字段为 JSON 字符串，例如需执行包管理工具时：\n\nnpx @modern-js/create --config '{\"packageManager\": \"pnpm\"}'\n\n\n具体配置信息可查看工程方案配置。\n\n\n--no-need-install\n\n默认情况下，@modern-js/create 在创建项目完成后会自动安装依赖，使用该参数可以忽略安装依赖步骤。\n\n\n--dist-tag <distTag>\n\n指定生成器及 Modern.js 相关依赖版本。\n\n@modern-js/create 执行过程中会执行更小的微生成器，使用该参数可以执行执行的微生成器的版本号和对应的安装 Modern.js 相关依赖的版本号。\n\n\n--registry <registry/>\n\n执行获取生成器及 npm 包的 npm registry。\n\n\n--debug\n\n显示生成器执行过程中的调试日志信息。\n\n\n--mwa\n\n一键创建应用工程方案项目。\n\n使用该参数后，@modern-js/create 将会使用配置默认值创建应用项目。\n\n\n--module\n\n一键创建模块工程方案项目。\n\n使用该参数后，@modern-js/create 将会使用配置默认值创建模块项目。\n\n\n--monorepo\n\n一键创建 Monorepo 工程方案项目。\n\n使用该参数后，@modern-js/create 将会使用配置默认值创建 Monorepo 项目。\n\n\n--plugin <plugin>\n\n指定生成器插件。\n\nModern.js 支持使用生成器插件定制 Modern.js 默认的工程方案类型或者添加工程方案类型场景，该参数用户指定定制的生成器插件。\n\n关于定制生成器插件可以参考开发生成器插件。\n\n\n--generator <generator>\n\n指定微生成器。\n\n默认情况下 @modern-js/create 会执行 Modern.js 框架内置的微生成器，如果你需要执行定制的微生成器，又需要使用 npx\n@modern-js/create 的姿势，可直接使用该参数。\n\n关于定制微生成器可以参考开发微生成器。\n\n\n--packages <packages>\n\n创建项目是指定特定包版本依赖。\n\n在创建项目时如果有需要指定特定包版本，可以使用该参数。该参数会在项目根目录的 package.json 中配置 pnpm.overrides(包管理工具选择\npnpm) 或者 resolutions 锁定包版本号。\n\n该参数值为 JSON 字符串。","frontmatter":{"sidebar_position":2}},{"id":603,"title":"微前端介绍","routePath":"/guides/topic-detail/micro-frontend/c01-introduction","lang":"zh","toc":[{"id":"微前端关键词","text":"微前端关键词","depth":2},{"id":"功能简介","text":"功能简介","depth":2}],"domain":"","content":"\n\n微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来\n仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\n微前端关键词\n\n在微前端研发模式中，应用会被分成 主应用、和 子应用。\n\n * 主应用：微前端项目的基座工程，所有子应用都会由它来加载。\n * 子应用：独立开发、独立部署的应用，最终会被主应用加载。\n\n\n功能简介\n\n * 基于 Garfish\n * 生成器支持微前端应用\n * 支持 React 组件式引用微前端子应用\n * 支持 loading\n * 支持主应用线上、子应用线下调试模式\n\n可以在 体验微前端 一节学习如何开发微前端主子应用。","frontmatter":{"sidebar_position":1,"title":"微前端介绍"}},{"id":604,"title":"体验微前端","routePath":"/guides/topic-detail/micro-frontend/c02-development","lang":"zh","toc":[{"id":"创建应用","text":"创建应用","depth":2},{"id":"创建约定式路由主应用","text":"创建约定式路由主应用","depth":3},{"id":"加载约定式路由子应用","text":"加载约定式路由子应用","depth":4},{"id":"加载自控式路由子应用","text":"加载自控式路由子应用","depth":4},{"id":"路由跳转","text":"路由跳转","depth":4},{"id":"创建自控式路由主应用","text":"创建自控式路由主应用","depth":3},{"id":"加载子应用","text":"加载子应用","depth":4},{"id":"创建约定式路由子应用","text":"创建约定式路由子应用","depth":3},{"id":"创建自控式路由子应用","text":"创建自控式路由子应用","depth":3},{"id":"调试","text":"调试","depth":2},{"id":"modernjs-微前端和直接使用-garfish-的区别","text":"Modern.js 微前端和直接使用 Garfish 的区别","depth":2},{"id":"常见问题","text":"常见问题","depth":2}],"domain":"","content":"\n\n通过本章你可以了解到：\n\n * 如何创建微前端项目的主应用、子应用。\n * 微前端项目开发的基本流程。\n\n\n创建应用\n\n目前支持两种路由模式\n\n * 自控式路由\n * 约定式路由\n\n首先明确主应用的路由模式 创建约定式路由主应用 或 创建自控式路由主应用\n\n在本次体验中我们会为主应用创建两个子应用 Table 和 Dashboard (Table 为约定式路由，Dashboard 为自控式路由)\n\n\n创建约定式路由主应用\n\n通过命令行工具初始化项目：\n\nmkdir masterApp && cd masterApp\nnpx @modern-js/create\n\n\n? 请选择你想创建的工程类型 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n然后我们在 routes 文件夹下新建两个目录\n\n * table (用于加载约定式路由子应用)\n * dashboard (用于加载自控式路由子应用)\n\n在这两个目录下我们需要新建一个 $.tsx 文件作为主应用约定式路由的入口($ 代表模糊匹配，即 /table 和 /table/test 都会匹配到这个\n$.tsx 作为该路由的入口文件，这会保证在微前端场景下正确加载子应用路由)\n\n加载约定式路由子应用\n\n\n\nconst Index = () => {\n  const { Table } = useModuleApps();\n\n  return (\n    <div>\n      <Table />\n    </div>\n  )\n}\n\nexport default Index;\n\n\n加载自控式路由子应用\n\n\n\nconst Index = () => {\n  const { Dashboard } = useModuleApps();\n\n  return (\n    <div>\n      <Dashboard />\n    </div>\n  )\n}\n\nexport default Index;\n\n\n路由跳转\n\n此时主应用配置已经完成，通过路由即可加载子应用，修改主应用的 layout.tsx 来跳转路由\n\n\n\nconst Layout = () => (\n  <div>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </div>\n);\n\nexport default Layout;\n\n\n\n创建自控式路由主应用\n\n通过命令行工具初始化项目：\n\nmkdir masterApp && cd masterApp\nnpx @modern-js/create\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n由于是自控式路由，我们删除掉 routes 文件夹并在 src 目录下增加 App.tsx 文件，此处如果使用的 非 MApp 组件，需要通过 React\nRouter v6 的 createBrowserRouter API 来创建路由\n\n加载子应用\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </>\n)\n\nexport default () => {\n  const { apps, MApp, Table, Dashboard } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      <Route path=\"/\" element={<AppLayout />}>\n        <Route key={'table'} path={'table/*'} element={<Table />} />\n        <Route key={'dashboard'} path={'dashboard/*'} element={<Dashboard />} />\n      </Route>\n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // <BrowserRouter>\n    //   <MApp />\n    // </BrowserRouter>\n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      <RouterProvider router={router} />\n    </>\n  );\n};\n\n\n\n创建约定式路由子应用\n\n通过命令行工具初始化项目：\n\nmkdir table && cd table\nnpx @modern-js/create\n\n\n按照如下选择，生成项目：\n\n我们执行 pnpm run new 来开启 微前端 功能：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n\nexport default defineConfig({\n  dev: {\n    port: 8081\n  },\n  runtime: {\n    router: true,\n    state: true,\n  },\n  deploy: {\n    microFrontend: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n添加 src/routes/page.tsx 代码\n\nconst Index = () => {\n  return (\n    <div className=\"container-box\">subApp: 约定式路由的子应用的根路由</div>\n  )\n}\n\nexport default Index;\n\n\n\n创建自控式路由子应用\n\n通过命令行工具初始化项目：\n\nmkdir dashboard && cd dashboard\nnpx @modern-js/create\n\n\n按照如下选择，生成项目：\n\n我们执行 pnpm run new 来开启 微前端：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「微前端」模式\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n\nexport default defineConfig({\n  dev: {\n    port: 8082\n  },\n  runtime: {\n    router: true,\n    state: true,\n  },\n  deploy: {\n    microFrontend: true,\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n自控式路由需要删除掉 routes 文件夹并在 src 目录下新建 App.tsx\n\n并在 src/App.tsx 添加代码，注意需要从 props 中解析并传递 basename 给 BrowserRouter\n\n\n\nexport default (props: {basename: string}) => {\n  const { basename } = props;\n\n  return (\n    <BrowserRouter basename={basename}>\n      <Routes>\n        <Route index element={<div>自控式路由子应用根路由</div>} />\n        <Route path={'path'} element={<div>自控式路由子应用子路由</div>} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\n\n\n调试\n\n按顺序在目录执行 pnpm run dev 命令启动应用：\n\n * masterApp 主应用 http://localhost:8080\n * table 子应用(约定式路由) http://localhost:8081\n * dashboard 子应用(自控式路由) http://localhost:8082\n\n访问主应用地址 http://localhost:8080\n\n在完成了微前端整体开发流程的体验后，你可以进一步了解如何 开发主应用\n\n\nModern.js 微前端和直接使用 Garfish 的区别\n\n使用纯 Garfish API 开发微前端应用时\n\n * 主应用：\n   * 安装 Garfish 依赖并使用 Garfish.run 注册子应用 参考\n   * 提供一个常驻的 DOM 节点供子应用挂载 参考\n * 子应用：\n   * 导出 provider 参考\n   * 设置应用的 basename 参考\n\n区别于直接使用 Garfish 运行时 API 开发微前端项目，Modern.js 的微前端方案更加开箱即用。 使用 pnpm new 启用微前端模式后会自动在\nModern.js 应用中集成 Garfish 插件，在 Garfish 插件的加持下，你只需要\n\n * 主应用：\n   * 配置 runtime.masterApp.apps 参数注册子应用\n   * 使用 useModuleApps API 获取子应用实例并在组件中完成渲染\n * 子应用：\n   * 配置 deploy.microFrontend\n\n所以插件中为你做了如下事情\n\n * 帮助你通过 Garfish 运行时 API 自动注册子应用（主应用）\n * useModulesApps 函数的返回值提供了一个常驻的 DOM 节点供子应用挂载（主应用）\n * 帮助你正确导出了 provider（子应用）\n * 帮助你正确设置了 basename 给 Modern.js 运行时提供 Router 实例，如果是自控式路由或手动引入的 react-router-dom\n   那么需要从 App.tsx 的 props 中获取 basename 手动传递给引入的 Router 实例（子应用）\n\n\n常见问题\n\n自查手册: https://www.garfishjs.org/issues/","frontmatter":{"sidebar_position":2,"title":"体验微前端"}},{"id":605,"title":"开发主应用","routePath":"/guides/topic-detail/micro-frontend/c03-main-app","lang":"zh","toc":[{"id":"注册子应用信息","text":"注册子应用信息","depth":2},{"id":"直接注册子应用信息","text":"直接注册子应用信息","depth":3},{"id":"自定义远程应用列表","text":"自定义远程应用列表","depth":3},{"id":"渲染子应用","text":"渲染子应用","depth":2},{"id":"子应用组件","text":"子应用组件","depth":3},{"id":"集中式路由","text":"集中式路由","depth":3},{"id":"两种模式混用","text":"两种模式混用","depth":3},{"id":"添加-loading","text":"添加 loading","depth":3},{"id":"增加错误状态","text":"增加错误状态","depth":4},{"id":"避免-loading-闪退","text":"避免 loading 闪退","depth":4},{"id":"增加超时状态","text":"增加超时状态","depth":4}],"domain":"","content":"\n\n在上一章 体验微前端 通过一个示例演示了如何创建和配置微前端子应用，通过本章你可以进一步了解如何开发主应用，以及它的常见配置。\n\n在通过 @modern-js/create 命令创建应用工程后，可以在项目中执行 pnpm run new（实际执行了 modern new\n命令），在选择了「微前端」模式后，会安装微前端依赖依赖，只需手动注册插件即可。\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    masterApp: {\n      apps: [{\n        name: 'Table',\n        entry: 'http://localhost:8081',\n        // activeWhen: '/table'\n      }, {\n        name: 'Dashboard',\n        entry: 'http://localhost:8082'\n        // activeWhen: '/dashboard'\n      }]\n    },\n  },\n  plugins: [appTools(), garfishPlugin()],\n});\n\n\n\n\n注册子应用信息\n\n当在 masterApp 配置上提供了信息后，将会认为该应用为主应用，目前存在两种子应用信息的配置方式，这两种方式分别应用于不同的场景。\n\n\n直接注册子应用信息\n\n可以直接通过配置注册子应用信息：\n\n提示\n\n可以通过 API defineConfig 在运行时进行配置。 当参数为函数时无法被序列化到产物代码，所以在涉及到函数之类的配置时请通过\ndefineConfig 来进行配置\n\n\n\ndefineConfig(App, {\n  masterApp: {\n    apps: [{\n      name: 'Table',\n      entry: 'http://localhost:8001',\n      // activeWhen: '/table'\n    }, {\n      name: 'Dashboard',\n      entry: 'http://localhost:8002'\n      // activeWhen: '/dashboard'\n    }]\n  },\n});\n\n\n\n自定义远程应用列表\n\n通过该函数可以拉取远程的子应用列表，并将其注册至运行时框架：\n\ndefineConfig(App, {\n  masterApp: {\n    manifest: {\n      getAppList: async () => {\n        // 可以从其他远程接口获取\n        return [{\n          name: 'Table',\n          entry: 'http://localhost:8001',\n          // activeWhen: '/table'\n        }, {\n          name: 'Dashboard',\n          entry: 'http://localhost:8002'\n          // activeWhen: '/dashboard'\n        }];\n      },\n    },\n  },\n});\n\n\n\n渲染子应用\n\n在微前端中分为两种加载子应用的方式：\n\n 1. 子应用组件 获取到每个子应用的组件，之后就可以像使用普通的 React 组件一样渲染微前端的子应用。\n 2. 集中式路由 通过集中式的路由配置，自动根据当前页面 pathname 激活渲染对应的子应用。\n\n\n子应用组件\n\n开发者使用 useModuleApps 方法可以获取到各个子应用的组件。\n\n再通过 router 组件的结合运用，开发者可以自控式的根据不同的路由渲染不同的子应用。\n\n假设我们的子应用列表配置如下：\n\n编辑主应用 App.tsx 文件如下：\n\n\n\n\n\nconst AppLayout = () => (\n  <>\n    <div><Link to={'/table'}>加载约定式路由子应用</Link></div>\n    <div><Link to={'/dashboard'}>加载自控式路由子应用</Link></div>\n    <div><Link to={'/'}>卸载子应用</Link></div>\n    <Outlet />\n  </>\n)\n\nexport default () => {\n  const { apps, MApp } = useModuleApps();\n\n  // 使用的不是 MApp 组件，需要使用 createBrowserRouter 来创建路由\n  const router = createBrowserRouter(\n    createRoutesFromElements(\n      <Route path=\"/\" element={<AppLayout />}>\n        {apps.map(app => {\n          const { Component } = app;\n          // 模糊匹配，path 需要写成类似 abc/* 的模式\n          return (\n            <Route\n              key={app.name}\n              path={`${app.name.toLowerCase()}/*`}\n              element={\n              <Component\n                loadable={{\n                  loading: ({ pastDelay, error }: any) => {\n                    if (error) {\n                      return <div>error: {error?.message}</div>;\n                    } else if (pastDelay) {\n                      return <div>loading</div>;\n                    } else {\n                      return null;\n                    }\n                  },\n                }}\n              />\n              }\n            />\n          )\n        })}\n      </Route>\n    )\n  );\n\n  return (\n    // 方法一：使用 MApp 自动根据配置的 activeWhen 参数加载子应用(本项目配置在 modern.config.ts 中)\n    // <BrowserRouter>\n    //   <MApp />\n    // </BrowserRouter>\n\n    // 方法二：手动写 Route 组件方式加载子应用，方便于需要鉴权等需要前置操作的场景\n    <>\n      <RouterProvider router={router} />\n    </>\n  );\n};\n\n\n这里通过 Route 组件自定义了 Table 的激活路由为 /table， Dashboard 的激活路由为 /dashboard。\n\n\n集中式路由\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    <div>\n      <MApp />\n    </div>\n  );\n}\n\n\n这样启动应用后，访问 /table 路由，会渲染 Table 子应用，访问 /dashboard 路由，会渲染 Dashboard 子应用。\n\n\n两种模式混用\n\n当然 子应用组件 和 集中式路由 是可以混合使用的。\n\n * 一部分子应用作为 子应用组件 激活，另外一部分作为 集中式路由 激活。\n * 一部分子应用既可以作为 集中式路由 激活，也可以作为 子应用组件 激活。\n\n\n添加 loading\n\n通过配置 loadable 配置，可以为「集中式路由」、「子应用」添加 loading\n组件，并可以考虑错误、超时、闪烁等情况的出现，从而为用户提供更好的用户体验。该功能的设计与实现参考至 react-loadable，基本功能较为相似。\n\nfunction Loading() {\n  return <div>Loading...</div>;\n}\n\nfunction App(){\n  return <>\n    <Table\n      loadable={{\n        loading: Loading,\n      }}\n    />\n  <>\n}\n\n\n增加错误状态\n\n当微前端子应用加载失败或渲染失败时，loading component 将会接收 error 参数（若没有错误时 error 是 null）\n\nfunction Loading({ error }) {\n  if (error) {\n    return <div>Error msg {error?.message}</div>;\n  } else {\n    return <div>Loading...</div>;\n  }\n}\n\n\n避免 loading 闪退\n\n有时 loading 组件的显示时间可能小于 200ms，这个时候会出现 loading 组件闪退的情况。许多用户研究证明，loading\n闪退的情况会导致用户感知加载内容的耗时比实际耗时更长，在 loading 小于 200ms 时，不展示内容，用户会认为它更快。\n\n所以 loading 组件还提供了 pastDelay 参数，超过设置的延迟展示时才会为 true，可以通过 delay 参数设置延迟的时长\n\nfunction Loading({ error, pastDelay }) {\n  if (error) {\n    return <div>Error! {error?.message}</div>;\n  } else if (pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n\n\ndelay 的默认值为 200ms，可以通过 loadable 中的 delay 来设置延迟展示的时间\n\n\nfunction App(){\n  return <>\n    <Table\n      loadable={{\n        loading: Loading,\n        delay: 300 // 0.3 seconds\n      }}\n    />\n  <>\n}\n\n\n增加超时状态\n\n有时因为网络的原因，从而导致微前端子应用加载失败，从而导致一直展示 loading\n的状态，这对于用户而言非常糟糕，因为他们不知道合适才会获得具体的响应，他们是否需要刷新页面，通过增加超时状态可以很好的解决该问题。\n\nloading 组件在超时时会获得 timeOut 参数，当微前端应用加载超时时将会获得 timeOut 属性值为 true\n\nfunction Loading({ error, timeOut, pastDelay }) {\n  if (error) {\n    return <div>Error! {error?.message}</div>;\n  } else if (timeOut) {\n    return <div>Loading timed out, please refresh the page... </div>;\n  } else if (pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n\n\n超时状态是关闭的，可以通过在 loadable 中设置 timeout 参数开启\n\n\nfunction App(){\n  return <>\n    <Table\n      loadable={{\n        loading: Loading,\n        timeOut: 10000 // 10s\n      }}\n    />\n  <>\n}\n","frontmatter":{"sidebar_position":3,"title":"开发主应用"}},{"id":606,"title":"主子应用通信","routePath":"/guides/topic-detail/micro-frontend/c04-communicate","lang":"zh","toc":[{"id":"props-通信","text":"props 通信","depth":2},{"id":"channel-通信","text":"channel 通信","depth":2}],"domain":"","content":"\n\n\nprops 通信\n\nModern.js 中，会将子应用包裹成一个 React 组件，直接通过给 React 组件传递 props 即可实现主应用和子应用通信的目的。\n\nfunction App() {\n  const { MApp } = useModuleApps();\n\n  return (\n    <div>\n      <MApp count={100} />\n    </div>\n  );\n}\n\n\nfunction App(props) {\n  console.log(props);\n  return ...\n}\n\n\n子应用将会打印 {count: 0}，目前尚未支持子应用渲染响应式，及时在主应用上更改 count 的数据也不会触发视图更新\n\n\nchannel 通信\n\nGarfish.channel 用于应用间的通信。它是 EventEmitter2 的实例\n\n// 子应用监听登录事件\nconst App = () => {\n  const handleLogin = userInfo => {\n    console.log(`${userInfo.name} has login`);\n  };\n\n  useEffect(() => {\n    window?.Garfish.channel.on('login', handleLogin);\n    return () => {\n      window?.Garfish.channel.removeListener('login', handleLogin);\n    };\n  });\n};\n\n// 主应用触发监听事件\napi.getLoginInfo.then(res => {\n  if (res.code === 0) {\n    window.Garfish.channel.emit('login', res.data);\n  }\n});\n","frontmatter":{"sidebar_position":4,"title":"主子应用通信"}},{"id":607,"title":"混合技术栈","routePath":"/guides/topic-detail/micro-frontend/c05-mixed-stack","lang":"zh","toc":[{"id":"子应用是-modernjs","text":"子应用是 Modern.js","depth":2},{"id":"主应用是-modernjs","text":"主应用是 Modern.js","depth":2}],"domain":"","content":"\n\nModern.js 微前端方案是基于 Garfish 封装的，提供了一些更开箱即用的使用方式。\n\n当你的主应用和子应用不全是 Modern.js 应用的时候，可以参考这篇文档。\n\n 1. 子应用是 Modern.js，主应用使用的原生 Garfish 微前端。\n 2. 主应用是 Modern.js，子应用有的是其它技术栈。\n\n\n子应用是 Modern.js\n\nModern.js 子应用编译后会生成标准的 Garfish 子应用导出。 所以可以直接接入标准的微前端主应用。\n\nINFO\n\n子应用是 Modern.js，主应用使用的原生 Garfish 微前端时，子应用调试模式 不可用。\n\n\n主应用是 Modern.js\n\n主应用是 Modern.js，子应用用的其它技术栈。子应用按照 Garfish 子应用标准 开发即可。","frontmatter":{"sidebar_position":5,"title":"混合技术栈"}},{"id":608,"title":"自动生成 Actions","routePath":"/guides/topic-detail/model/auto-actions","lang":"zh","toc":[{"id":"原始数据类型","text":"原始数据类型","depth":2},{"id":"数组类型","text":"数组类型","depth":2},{"id":"简单对象类型","text":"简单对象类型","depth":2}],"domain":"","content":"\n\n在 快速上手 中，我们实现最简单的计数器 Model 也需要 10 行代码。 实际上，Modern.js 支持根据声明的 state 类型，自动生成常用的\nActions，从而简化模板代码量。当前支持的类型有：\n\n * 原始数据类型\n * 数组类型\n * 简单对象类型（Plain Object）\n\n\n原始数据类型\n\nconst countModel = model('count').define({ state: 1 });\n\n\n如上我们仅用一行就完成了一个简单的 countModel。使用 Model 的示例代码如下：\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    // 增加 1\n    actions.setState(state + 1);\n  }, []);\n}\n\n\n\n数组类型\n\n当 State 为数组类型时，自动生成 Actions 的示例代码如下：\n\nconst countModel = model('count').define({ state: [] });\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    actions.push(1);\n    actions.pop();\n    actions.shift();\n    actions.unshift(1);\n    actions.concat([1]);\n    actions.splice(0, 1, 2);\n    actions.filter(value => value > 1);\n  }, []);\n}\n\n\n我们可以使用 JavaScript Array 对象的方法，修改 State。\n\n\n简单对象类型\n\n当 State 为简单对象类型时，自动生成 Actions 的示例代码如下：\n\nconst countModel = model('count').define({\n  state: {\n    a: 1,\n    b: [],\n    c: {},\n  },\n});\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  useEffect(() => {\n    actions.setA(2);\n    actions.setB([1]);\n    actions.setC({ a: 1 });\n  }, []);\n}\n\n\n根据 a、b、c 三个不同的字段分别生成 setA、setB、setC 三个 Actions。\n\nINFO\n\n当用户自定义的 Action 和 Modern.js 自动生成的 Action 名字一致时，用户自定义的 Action 优先级更高。例如， 在\ncountModel 中已经自定义 setA 这个 Action，调用 actions.setA() 时，最终执行的是用户自定义的 setA。\n\n补充信息\n\n相关 API 的更多介绍，请参考这里。","frontmatter":{"sidebar_position":6,"title":"自动生成 Actions"}},{"id":609,"title":"衍生状态","routePath":"/guides/topic-detail/model/computed-state","lang":"zh","toc":[{"id":"只依赖自身的-state","text":"只依赖自身的 State","depth":2},{"id":"依赖其他-model-的-state","text":"依赖其他 Model 的 State","depth":2},{"id":"函数类型的衍生状态","text":"函数类型的衍生状态","depth":2}],"domain":"","content":"\n\n一些场景中，组件需要对 Model 中的 State 进行进一步计算，才能在组件中使用，这部分逻辑可以直接写在组件内部，也可以通过 Model 的衍生状态实现。\n衍生状态定义在 Model 中的 computed 字段下。根据依赖的 Model 的不同、返回类型的不同，衍生状态的定义方法可以分为以下 3 种。\n\n\n只依赖自身的 State\n\n衍生状态只依赖当前 Model 的 State，State 会作为第一个参数，传入衍生状态的定义函数中。\n\n例如， todo 应用的 State 有 items 和 filter，filter 用于过滤当前页面显示的 todo 项，所以我们定义了一个\nvisibleTodos 的衍生状态可以直接在组件中使用。示例代码如下：\n\n/**\n *  假设 todo item 结构如下：\n{\n    id: string;          // id\n    text: string;        // todo 事项\n    completed: boolean;  // 完成状态：0 代表未完成，1 代表完成\n}\n**/\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    filter: 'ALL', // ALL: 显示全部；COMPLETED：显示完成的事项；ACTIVE：显示未完成的事项\n  },\n  computed: {\n    visibleTodos: state => {\n      switch (state.filter) {\n        case 'ALL':\n          return state.items;\n        case 'COMPLETED':\n          return todos.filter(t => t.completed);\n        case 'ACTIVE':\n          return todos.filter(t => !t.completed);\n        default:\n          return [];\n      }\n    },\n  },\n});\n\n\n衍生状态最终会和 Model 的 State 进行合并，因此，可以通过 Model 的 State 对象访问到衍生状态，例如，visibleTodos\n在组件内的使用方式如下：\n\nfunction Todo() {\n  const [state, actions] = useModel(todoModel);\n\n  return (\n    <div>\n      <div>\n        {state.visibleTodos.map(item => (\n          <div key={item.id}>{item.text}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n\n\n依赖其他 Model 的 State\n\n除了依赖当前 Model 的 State，衍生状态还依赖其他 Model 的 State，这时候衍生状态的定义格式为：\n\n[stateKey]: [...depModels, (selfState, ...depModels) => computedState]\n\n\n下面的示例，演示了 barModel 的衍生状态 combinedValue 是如何依赖 fooModel 的 State 的。\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'foo',\n  },\n  computed: {\n    combinedValue: [\n      fooModel,\n      (state, fooState) => state.value + fooState.value,\n    ],\n  },\n});\n\n\n\n函数类型的衍生状态\n\n衍生状态还可以返回一个函数。这时候衍生状态的定义格式为：\n\n[stateKey]: (state) => (...args) => computedState    // 只依赖自身的 state\n[stateKey]: [...depModels, (selfState, ...depModels) => (...args) => computedState]  // 依赖其他 Model 的 state\n\n\n假设，todo 应用的 state 不存储 filter 状态，而是直接在组件中使用，那么 visibleTodos\n可以是一个函数类型的值，这个函数在组件中使用的时候，接收 filter 参数。如下所示：\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n  },\n  computed: {\n    visibleTodos: state => filter => {\n      switch (filter) {\n        case 'ALL':\n          return state.items;\n        case 'COMPLETED':\n          return todos.filter(t => t.completed);\n        case 'ACTIVE':\n          return todos.filter(t => !t.completed);\n        default:\n          return [];\n      }\n    },\n  },\n});\n\nfunction Todo(props) {\n  // filter 状态通过 props 传入\n  const { filter } = props;\n  const [state, actions] = useModel(todoModel);\n\n  // 计算得到最终要显示的 todos\n  const todos = state.visibleTodos(filter);\n\n  return (\n    <div>\n      <div>\n        {todos.map(item => (\n          <div key={item.id}>{item.text}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n\n更多参考\n\n使用 Model","frontmatter":{"sidebar_position":4,"title":"衍生状态"}},{"id":610,"title":"创建 Model","routePath":"/guides/topic-detail/model/define-model","lang":"zh","toc":[],"domain":"","content":"\n\n上一节的计数器应用中，我们简单演示了如何创建一个 Model。本节我们将详细介绍 Model 的创建方法。\n\n通过 model API 创建 Model，例如，model('foo') 表示要创建一个名为 foo 的 Model，通过调用 model('foo')\n返回的 define 函数，定义 Model 包含的 State、Actions 等：\n\n\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n  actions: {\n    setValue: (state, payload){\n      state.value = payload\n    }\n  }\n});\n\n\nINFO\n\n * Model 中的 Action 中不能包含有副作用的逻辑，如请求 HTTP 接口，访问 localStorage 等。\n * setValue 内部直接修改了入参 State，看起来是违反了纯函数的定义，实际上 Reduck 内部使用 immer\n   来修改不可变对象，保证了这种写法不会影响对象的不可变性，所以 setValue 仍然是一个纯函数。当然，你也可以直接在 Action\n   中返回一个新对象，不过这样的写法会更加复杂一些。\n\ndefine 接收的参数，只是对 Model 原始结构的描述：内部定义的 State、Actions 等。define 返回值 fooModel\n才是真正创建得到的 Model 对象。例如，虽然 setValue，有 2 个参数，但是当真正调用 setValue 这个 Action 时，我们只需要传入\npayload 一个参数，因为我们调用的是 fooModel 上的 Action 方法，而不是 Model 原始结构上描述的 Action 方法。详细参考使用\nModel。\n\ndefine 除了接收对象类型的参数，还可以接收函数类型的参数。例如：\n\n\n\nconst fooModel = model('foo').define((context, utils) => {\n  return {\n    state: {\n      value: 'foo',\n    },\n    actions: {\n      setValue: (state, payload){\n        state.value = payload\n      }\n    }\n  }\n});\n\n\n通过函数定义 Model 时，函数内部会自动传入 context、utils 2 个参数，context 是 Reduck 的上下文对象，可以获取到 store\n对象，utils 提供了一组工具函数，方便实现 Model 通信等复杂功能需求。\n\nModel 支持复制。例如：\n\nconst barModel = fooModel('bar');\n\n\nbarModel 是基于 fooModel 创建出一个的新的 Model 对象，类比面向对象编程语言中的概念，barModel 和 fooModel\n是基于同一个类（Class）创建出的 2 个实例对象。当两个模块的状态管理逻辑相同，例如一个页面中的两个 tab\n模块，使用的数据的结构和逻辑相同，区别只是从不同的接口获取数据，那么可以通过 Model 复制的方式，创建 2 个不同的 Model 对象。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","frontmatter":{"sidebar_position":2,"title":"创建 Model"}},{"id":611,"title":"常见问题","routePath":"/guides/topic-detail/model/faq","lang":"zh","toc":[{"id":"浏览器兼容性","text":"浏览器兼容性","depth":2},{"id":"微前端子应用-model-访问主应用-model","text":"微前端子应用 Model 访问主应用 Model","depth":2}],"domain":"","content":"\n\n\n浏览器兼容性\n\nReduck 的编译构建产物默认使用 ES6 语法，如果你需要支持更低版本的浏览器，请将 @modern-js-reduck\n命名空间下的所有包加入到应用的编译过程。\n\n补充信息\n\nReduck 使用的 @babel/preset-env 的详细配置。\n\n\n微前端子应用 Model 访问主应用 Model\n\n微前端子应用 Model 访问主应用 Model 时，如果该 Model 在主应用尚未挂载，会自动挂载到子应用上。\n\n示例：\n\n\n\n\nfunction SubModelApp() {\n  const [state, actions] = useModel(parentModel);\n\n  return <div>...</div>;\n}\n\n\n\n\n为了避免意外降级挂载，建议将主应用所需要共享的 Model 预先挂载：\n\n// App 是主应用的入口组件，sharedModel1、sharedModel2 是需要共享的 Model。\nApp.models = [sharedModel1, sharedModel2];\n","frontmatter":{"sidebar_position":13,"title":"常见问题"}},{"id":612,"title":"副作用管理","routePath":"/guides/topic-detail/model/manage-effects","lang":"zh","toc":[{"id":"副作用对-state-修改","text":"副作用对 State 修改","depth":2},{"id":"副作用不影响-state","text":"副作用不影响 state","depth":2},{"id":"副作用函数返回值","text":"副作用函数返回值","depth":2}],"domain":"","content":"\n\nModel 中的 Action 必须是一个纯函数，执行过程中不会产生任何副作用。但在真实的业务中，我们会遇到很多副作用场景，如：请求 HTTP\n接口获取状态数据，或者在更新状态的同时修改 localStorage、发送事件等。在 Reduck 中，是通过 Model 的 Effects\n函数管理副作用的。\n\n\n副作用对 State 修改\n\n副作用修改 State，最常见的场景就是请求 HTTP 接口，更新状态数据。\n\n我们以一个简单的 todoModel 为例。其有一个 load 的副作用函数，请求远端的 TODO 列表，请求成功之后更新 state.items 字段。\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    load: {\n      pending(state) {\n        state.loading = true;\n      },\n      fulfilled(state, items) {\n        state.items = items;\n        state.loading = false;\n      },\n      rejected(state, error) {\n        state.error = error;\n        state.loading = false;\n      },\n    },\n  },\n  effects: {\n    // Promise 副作用\n    async load() {\n      return new Promise(resolve => {\n        setTimeout(() => resolve(['Learn Modern.js']), 2000);\n      });\n    },\n  },\n});\n\n\n副作用函数统一定义在 effects 字段下。这里我们写了一个 load 函数，它返回一个 Promise，Promise 执行成功后，返回 TODO 列表\n[\"Lerna Modern.js\"]。\n\n副作用函数需要和 actions 配合使用，才能完成状态的修改。因此，我们在 actions 中定义了一个 load（命名需要和 effects\n下的副作用函数的名字保持一致）对象，包含 pending、fulfilled、rejected 3 个 action，分别是对副作用函数 load 返回的\nPromise 的三种状态（ pending、fulfilled、rejected ）的处理：\n\n * pending：接收当前状态 state 作为参数，新的状态中 loading 设为 true。\n * fulfilled：接收当前状态 state 和 Promise fulfilled 状态的值 items 为参数，新的状态中 items 等于参数\n   items、loading 设为 false。\n * rejected：接收当前状态 state 和 Promise rejected 状态的错误 error 为参数，新的状态中 error 等于参数\n   error、loading 设为 false。\n\n组件中如何调用 effects 函数呢？ effects 函数会被合并到 actions 对象上，因此可以通过 actions 对象调用 effects\n函数，如下所示：\n\nfunction Todo() {\n  const [state, actions] = useModel(todoModel);\n\n  useEffect(() => {\n    // 调用 effects 函数\n    actions.load();\n  }, []);\n\n  if (state.loading) {\n    return <div>loading....</div>;\n  }\n\n  return (\n    <div>\n      <div>\n        {state.items.map((item, index) => (\n          <div key={index}>{item}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n\n上面的示例中， pending、fulfilled、rejected 3 个 action，对于用于获取数据的 HTTP\n请求场景下，一般都是需要的。Reduck 提供了一个工具函数 handleEffect，用于简化这种场景下的 action 创建。\n\nhandleEffect 约定这种副作用场景下， Model 的 State 结构包含 result、error、pending 3 个字段，初始值为：\n\n{\n  result: null,\n  error: null,\n  pending: false，\n}\n\n\n调用 handleEffect 会返回如下数据结构:\n\n{\n  pending() { // ... },\n  fulfilled() { // ... },\n  rejected() { // ... }\n}\n\n\n这个数据结构和我们在 actions 下的 load 对象的数据结构是相同的。handleEffect 返回的对象，其实就是对应了 Effects 函数需要的\n3 个 action。\n\n利用 handleEffect，改写 todoModel：\n\nconst todoModel = model('todo').define({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    load: handleEffect({ result: 'items' }),\n  },\n  effects: {\n    // Promise 副作用\n    async load() {\n      return new Promise(resolve => {\n        setTimeout(() => resolve(['Learn Modern.js']), 2000);\n      });\n    },\n  },\n});\n\n\nhandleEffect 接收的参数对象，将 result 设置为 item。因为 todoModel 的 state，使用 items 作为 key 保存\ntodo 列表数据，而不是使用 handleEffect 默认的 result 作为 key，所以这里需要进行配置。\n\n明显可见，通过 handleEffect 实现的 todoModel 比之前的实现有了很大精简。\n\n如果不希望 pending、fulfilled、rejected 3 种状态都被 handleEffect 自动处理，例如 fulfilled\n需要手动处理较复杂的数据类型，但是 pending、rejected 依旧想进行自动化处理，可以参考如下写法：\n\n  actions: {\n    load: {\n      ...handleEffect(),\n      fulfilled(state, payload) {\n        // 手动处理\n      },\n    },\n  },\n\n\n补充信息\n\nhandleEffect API。\n\nEffects 函数中，也支持手动调用 Actions，例如：\n\nconst todoModel = model('todo').define((context, utils) => ({\n  state: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  actions: {\n    pending(state) {\n      state.loading = true;\n    },\n    fulfilled(state, items) {\n      state.items = items;\n      state.loading = false;\n    },\n  },\n  effects: {\n    async load() {\n      // 通过 utils.use 获取当前 Model 对象的 actions\n      const [, actions] = utils.use(todoModel);\n      // 手动调用 action\n      actions.pending();\n\n      return new Promise(resolve => {\n        setTimeout(() => {\n          const items = ['Learn Modern.js'];\n          // 手动调用 action\n          actions.fulfilled(items);\n          resolve(items);\n        }, 2000);\n      });\n    },\n  },\n}));\n\n\nINFO\n\n可以使用 use 函数加载其它 Model（包括 Model 自身），实现 Model 间通信。\n\n\n副作用不影响 state\n\n有些场景下，我们只需要读取 State，执行相关副作用逻辑，副作用不会修改 State。\n\n例如，存储某些 State 到 localStorage：\n\nconst fooModel = model('foo').define((context, utils) => ({\n  state: {\n    value: 'foo',\n  },\n  effects: {\n    setLocalStorage(key) {\n      const [state] = utils.use(fooModel);\n      localStorage.set(key, state.value);\n      return 'success';\n    },\n  },\n}));\n\n\n或者是向服务端发送数据：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 'foo',\n  },\n  effects: {\n    async sendData(data) {\n      const res = await fetch('url', {\n        method: 'POST',\n        body: data,\n      });\n      return res.json();\n    },\n  },\n});\n\n\n\n副作用函数返回值\n\n有时候，我们希望能根据副作用函数的执行结果，直接执行后续逻辑。这时候，就需要使用 Effects 函数的返回。\n\n例如，当点击发送按钮，发送数据成功后，立即关闭当前的弹窗；如果失败，显示错误信息。我们可以通过如下代码实现：\n\n// 代码仅做示意，不能执行\n// 组件内部 发送按钮 的响应函数\nconst handleClick = async () => {\n  // sendData 返回代表状态的字符串\n  const result = await actions.sendData('some data');\n  if (result === 'success') {\n    // 关闭弹窗\n    closeModal();\n  } else {\n    // 显示错误\n    showError(result);\n  }\n};\n\n\n补充信息\n\n示例代码","frontmatter":{"sidebar_position":5,"title":"副作用管理"}},{"id":613,"title":"Model 通信","routePath":"/guides/topic-detail/model/model-communicate","lang":"zh","toc":[{"id":"model-间通信","text":"Model 间通信","depth":2},{"id":"model-内通信","text":"Model 内通信","depth":2}],"domain":"","content":"\n\nModel 通信，既指不同 Model 间的通信，也指同一个 Model 内部 Effects、Actions 之间的通信。\n\n\nModel 间通信\n\nModel 之间不是孤立的，是可以进行通信的。主要分为两种场景：\n\n 1. 在 Model 中访问其它 Model 的 State 和 Actions。\n 2. 在 Model 中监听其它 Model 变化。\n\n这里将 快速上手 一节的简单计数器应用改造成一个可设置步频的计数器应用。可以通过设置步频，从而影响每次计数器增加的幅度。\n\n我们抽象出两个 Model，分别为 stepModel（步频）、counterModel（计数器）：\n\n\n\nconst stepModel = model('step').define({\n  state: 1,\n});\n\nconst counterModel = model('count').define((context, { use, onMount }) => {\n  const [, , subscribeStep] = use(stepModel);\n\n  onMount(() => {\n    return subscribeStep(() => {\n      console.log(\n        `Subscribe in counterModel: stepModel change to ${use(stepModel)[0]}`,\n      );\n    });\n  });\n\n  return {\n    state: {\n      value: 1,\n    },\n    actions: {\n      add(state) {\n        const step = use(stepModel)[0];\n        state.value += step;\n      },\n    },\n  };\n});\n\nexport { stepModel, counterModel };\n\n\nstepModel 只声明一个 state，初始值为 1。\n\ncounterModel 通过 use 函数加载 stepModel，拿到返回的 subscribeStep 函数，用来监听 stepModel 状态的变更。\nonMount 是 Model 挂载完成后的钩子函数，counterModel 挂载完成后开始订阅 stepModel 状态的变更，打印出 stepModel\n的最新值。\n\ncounterModel 通过 use 函数访问 stepModel，在 add 里可以获取到当前 stepModel 的值（步频），以此值来做自增。\n\n注意\n\n当需要访问其他 Model 的 State 时，必须要在当前 Actions 或 Effects 函数（本例中对应 add 函数 ）真正执行的阶段调用\nuse，以保证获取的 State 是最新值。因此，我们虽然在 define 的回调函数中也调用了 use(stepModel)，但是我们并没有解构\nstepModel 的 state 值，因为 define 的回调函数是在 Model 的挂载阶段执行的，这个时候获取到的 stepModel 的 state\n可能和 add 执行时获取到的值是不同的。\n\n修改 App.tsx\n\n\n\n\nfunction Counter() {\n  const [state, actions] = useModel(counterModel);\n  const [step, stepActions] = useModel(stepModel);\n\n  return (\n    <div>\n      <div>step: {step}</div>\n      <button onClick={() => stepActions.setState(step + 1)}>add step</button>\n      <div>counter: {state.value}</div>\n      <button onClick={() => actions.add()}>add counter</button>\n    </div>\n  );\n}\n\nexport default function App() {\n  return <Counter />;\n}\n\n\n补充信息\n\nModern.js 默认开启 自动生成 actions，所以 stepModel 中虽然没有手动定义 Actions，但可以使用自动生成的 setState。\n\n * 点击 add step 增加步频。\n * 点击 add counter 触发计数器增加。\n\n最终效果如下：\n\n\n\n补充信息\n\n * 本节完整的示例代码。\n * 相关 API 的更多介绍，请参考：model。\n\n前面 counterModel 的例子，我们是在 Actions 的函数内部调用 use 获取其他 Model 对象的。如果只需要调用其它 Model 的\nActions，因为 Actions 都是函数，不存在值过期问题，所以也可以在 define 的回调函数中调用 use 获取 Model 的\nActions。例如：\n\nconst barModel = model('bar').define({\n  // 省略\n});\n\nconst fooModel = model('foo').define((context, utils) => {\n  // 获取 barModel 的 actions\n  const [, actions] = utils.use(barModel);\n  return {\n    // 省略 state、actions\n    effects: {\n      async loadA() {\n        // 省略副作用逻辑\n        // 调用 barModel 的 action\n        barModel.actionA();\n      },\n      async loadB() {\n        // 省略副作用逻辑\n        // 调用 barModel 的 action\n        barModel.actionB();\n      },\n    },\n  };\n});\n\n\n这样，我们不需要在 loadA、loadB 中重复获取 barModel 对象，简化了代码逻辑。\n\n\nModel 内通信\n\nModel 内通信，也主要分为两种场景：\n\n 1. Effects 函数调用自身 Model 的 Actions 函数、或其他 Effects 函数。\n 2. Actions 函数调用自身 Model 的 其他 Actions 函数。\n\n在 副作用管理 一节，我们演示过 Effects 函数如何调用 Actions 函数。\n\n这里我们再来举一个例子：\n\nconst fooModel = model('foo').define((context, { use, onMount }) => ({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.a = payload;\n    },\n  },\n  effects: {\n    async loadA() {\n      // 通过 use 获取当前 Model 的 actions\n      const [, actions] = use(fooModel);\n      const res = await mockFetchA();\n      actions.setA(res);\n    },\n    async loadB() {\n      // 通过 use 获取当前 Model 的 actions\n      const [, actions] = use(fooModel);\n      const res = await mockFetchB();\n      actions.setB(res);\n    },\n  },\n}));\n\n\n这个例子中，fooModel 的两个 Effects 函数，需要调用自身的 Actions 函数。这里我们在每个 Effects 函数中，都调用了一次\nuse，为什么不能像 Model 间通信的例子中，在 define 的回调函数中，统一调用 use 获取 Model 自身的 Actions 呢？这是因为调用\nuse 获取 Model 时，会先检查这个 Model 是否已经挂载，如果还没有挂载，会先执行挂载逻辑，而 define 的回调函数又是在 Model\n的挂载阶段执行的，这样一来，在挂载阶段调用 use 获取 Model 自身，会出现死循环（代码实际执行过程会抛出错误）。所以，一定不能在 define\n的回调函数中，调用 use 获取 Model 自身对象。\n\n不过，我们可以利用 onMount 这个钩子函数，在 Model 挂载完成后，再通过 use 获取 Model 自身对象：\n\nconst fooModel = model('foo').define((context, { use, onMount }) => {\n  let actions;\n\n  onMount(() => {\n    // fooModel 挂载完成后，通过 use 获取当前 Model 的 actions\n    [, actions] = use(fooModel);\n  });\n\n  return {\n    state: {\n      a: '',\n      b: '',\n    },\n    actions: {\n      setA(state, payload) {\n        state.a = payload;\n      },\n      setB(state, payload) {\n        state.a = payload;\n      },\n    },\n    effects: {\n      async loadA() {\n        const res = await mockFetchA();\n        actions.setA(res);\n      },\n      async loadB() {\n        const res = await mockFetchB();\n        actions.setB(res);\n      },\n    },\n  };\n});\n\n\n这样，我们也可以实现代码的简化。","frontmatter":{"sidebar_position":7,"title":"Model 通信"}},{"id":614,"title":"性能优化","routePath":"/guides/topic-detail/model/performance","lang":"zh","toc":[{"id":"model-拆分","text":"Model 拆分","depth":2},{"id":"状态筛选","text":"状态筛选","depth":2},{"id":"衍生状态缓存","text":"衍生状态缓存","depth":2}],"domain":"","content":"\n\nReduck 内部已经做了大量性能优化工作，一般情况下不需要考虑性能问题。不过当对性能比较敏感、或者遇到了性能问题，可以考虑从以下 3\n个方面，进行更有针对性的性能优化。\n\n\nModel 拆分\n\n当 useModel 返回 Model 对象的完整 State 时，State 任意部分的变化都会导致调用了 useModel 的组件重新渲染。\n\n例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  const [state] = useModel(fooModel);\n\n  return <div>{state.a}</div>;\n}\n\n\n组件 ComponentA 虽然只需要使用 a 状态，但当 b 状态发送变化时， ComponentA 仍然会重新渲染。这种情况，我们可以考虑把\nfooModel 拆分，a、b 分别由不同的 Model 负责管理：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    b: '',\n  },\n  actions: {\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\n\n\n状态筛选\n\nuseModel 支持传入 selector 函数，对返回给组件的 State 和 Actions 做筛选。我们可以通过 selector\n函数，确保返回给组件的 State 是组件直接需要使用的，从而保证组件不会因为其他无关状态的变化而重新渲染。\n\n对于上面同样的例子，我们采用 selector 函数进行性能优化，代码如下：\n\nconst fooModel = model('foo').define({\n  state: {\n    a: '',\n    b: '',\n  },\n  actions: {\n    setA(state, payload) {\n      state.a = payload;\n    },\n    setB(state, payload) {\n      state.b = payload;\n    },\n  },\n});\n\nfunction ComponentA() {\n  // 通过传入 selector 函数，只返回 a 状态给组件\n  const [stateA] = useModel(fooModel, state => state.a);\n\n  return <div>{stateA}</div>;\n}\n\n\n\n衍生状态缓存\n\n当 Model 存在 computed 时，每次调用useModel 都会执行 computed 函数。\n\n考虑如下代码：\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  computed: {\n    combineA: [\n      fooModel, // fooModel 定义同上\n      (state, fooState) => {\n        return state + fooState.a;\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nfunction ComponentB() {\n  const [state, actions] = useModel(fooModel);\n  const [{ combineA }] = useModel(barModel);\n  // 省略\n}\n\n\nbarModel 的衍生状态 combineA 依赖 barModel 自身状态 和 fooModel 的状态 a，但是即使是 fooModel 的状态 b\n发生了变化，组件重新渲染时， combineA （更准确的说法是 combineA 的最后一个函数类型的元素 ）依然会被调用执行。\n\n一般情况下，computed 函数中的逻辑都是非常轻量的，但当 computed 函数逻辑比较复杂时，我们可以考虑对计算逻辑做缓存。例如，我们使用\nreselect 对 barModel 的 combineA 做缓存：\n\n\n\n// 创建缓存函数\nconst selectCombineA = createSelector(\n  (state) => state.bar.value,\n  (state) => state.foo.a,\n  (barState, fooState) => {\n    return barState + fooState;\n  }\n);\n\nconst barModel = model(\"bar\").define({\n  state: {\n    value: \"bar\",\n  },\n  computed: {\n    combineA: [\n      fooModel,\n      (state, fooState) => {\n        return selectCombineA({\n          foo: fooState,\n          bar: state,\n        });\n      },\n    ],\n  },\n  actions: {\n    setValue(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\n\n我们创建缓存函数 createSelector，仅当 barModel 的状态发生改变或 fooModel 的 a 状态发生改变时，才会重新计算\ncombineA 的值。\n\n补充信息\n\n本节完整的示例代码","frontmatter":{"sidebar_position":8,"title":"性能优化"}},{"id":615,"title":"快速上手","routePath":"/guides/topic-detail/model/quick-start","lang":"zh","toc":[{"id":"核心概念","text":"核心概念","depth":2},{"id":"基本用法","text":"基本用法","depth":2}],"domain":"","content":"\n\nReduck 是 Modern.js 团队开发的遵循 MVC 模式的状态管理库，底层状态存储基于 Redux 实现，同时提供更高层级的抽象，并完全兼容\nRedux 生态。\n\nReduck 的目标是以 MVC 模式组织 React 应用开发结构，将业务逻辑维护在 Model 层，业务逻辑与 UI\n解耦，让开发业务逻辑更集中、更简单，同时通过更高层级的抽象，减少重复工作（样板代码）。\n\nReduck 在 MVC 模式中，扮演 M(Model) 的角色，React UI Component 对应 V(View)，从 Reduck 中获取\nModel 并修改 Model 的 React Container Component 对应 C(View Controller/Container)。\n\nModern.js 的状态管理解决方案，是通过内置 Reduck 实现的。在 Modern.js 中使用 Reduck，不仅免去了手动集成的环节，而且所有\nReduck API 都可以从 Modern.js 的 Runtime 包中直接导入使用，具有更好的一致性体验。\n\nINFO\n\n 1. Modern.js 中使用 Reduck API，需要先设置 runtime.state 以启用状态管理插件。\n 2. Reduck 也可以脱离 Modern.js 作为状态管理库单独使用。\n\n\n核心概念\n\nReduck 中的核心概念只有 4 个： Model、State、Actions、Effects。\n\nModel: 对独立模块的逻辑和所需状态的封装，由 State、Actions、Effects 组成。\n\nState: Model 中保存的状态。\n\nActions: 用于修改 State 的纯函数，函数必须是同步的。\n\nEffects: 用于修改 State 的带有副作用的函数，函数可以是异步的。Effects 中可以调用自身或其他 Model 的 Actions 和\nEffects。\n\nReduck 数据流如下图所示：\n\n\n\n\n基本用法\n\n下来我们以一个简单的 计数器 应用为例，演示 Reduck 的基本用法。\n\n首先，我们定义一个名为 count 的 Model：\n\n\n\nconst countModel = model('count').define({\n  state: {\n    value: 1,\n  },\n});\n\nexport default countModel;\n\n\n我们使用 API model 创建 countModel，countModel 当前只包含存储计数器值的状态，即代码中的 value。\n\n我们定义一个 action，用于计算器自增加 1：\n\n\n\nconst countModel = model('count').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state.value += 1;\n    },\n  },\n});\n\nexport default countModel;\n\n\n在 add action 中，我们可以直接修改 state 的值，进行加 1 操作，而不需要把 state 作为不可变对象进行操作，这是因为 Reduck\n集成了 immer，可以直接修改原 state 对象。\n\n接下来，我们演示如何在组件中使用 Model。\n\n新建一个组件 Counter，在组件内通过 useModel API 使用 countModel：\n\n\n\n\nfunction Counter() {\n  const [state, actions] = useModel(countModel);\n\n  return (\n    <div>\n      <div>counter: {state.value}</div>\n      <button onClick={() => actions.add()}>add</button>\n    </div>\n  );\n}\n\n\nuseModel 获取 countModel 的 state 和 actions，组件展示当前计算器的值，点击 add 按钮，计数器自增 1。\n\nINFO\n\n由于使用的案例比较简单，这里并没有严格按照 MVC 模式进行分层，组件 Counter 同时起到了 V 和 C 两层的作用。\n\n最终演示效果如下：\n\n\n\n这样，我们就完了一个简单的计数器应用。本节完整的示例代码可以在这里查看。","frontmatter":{"sidebar_position":1,"title":"快速上手"}},{"id":616,"title":"Redux 生态集成","routePath":"/guides/topic-detail/model/redux-integration","lang":"zh","toc":[],"domain":"","content":"\n\nReduck 基于 Redux 实现，因此可以使用 Redux 生态的库，实现功能增强。通过 Provider 、createApp 和 createStore\n等 API ，可以设置使用 Redux 的 中间件 和 Store Enhancer；使用 createStore 还可以完全掌控 Store 的创建过程。\n\n例如，我们希望使用中间件 redux-logger，示例代码如下：\n\nReactDOM.render(\n  <Provider config={{ middlewares: [logger] }}>\n    // 通过 Provider 的 config 参数设置 中间件\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n\n\nCAUTION\n\nReduck 基于 Redux 底层 API 做了上层封装，屏蔽了 Redux 的一些底层概念，如 Reducer 等。Reduck 对于 Model\n是动态挂载的，而 Redux 是在 Store 创建时就会挂载应用所需的全部状态。基于这些实现上的差异，有些 Redux 生态的库是无法直接在 Reduck\n中使用的。","frontmatter":{"sidebar_position":11,"title":"Redux 生态集成"}},{"id":617,"title":"测试 Model","routePath":"/guides/topic-detail/model/test-model","lang":"zh","toc":[],"domain":"","content":"\n\n好的测试对代码的稳健性至关重要。下面以 快速上手 的 countModel 为例，演示在 Modern.js 中，如何对 Model 进行单元测试。\n\n使用测试功能，需要先开启该功能。在项目根目录下，执行 pnpm run new，进行如下选择：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用「单元测试 / 集成测试」功能\n\n\n即可开启测试功能支持。\n\n新增 count.test.ts 文件，代码如下：\n\n\n\n\ndescribe('test model', () => {\n  it('count value should plus one after add', () => {\n    const store = createStore();\n    const [state, { add }] = store.use(countModel);\n\n    expect(state).toEqual({ value: 1 });\n\n    add();\n\n    expect(store.use(countModel)[0]).toEqual({ value: 2 });\n  });\n});\n\n\nINFO\n\n这里使用的 createStore 是从 @modern-js/runtime/testing 导入的，内部会使用 runtime.state 的配置去创建\nstore。\n\n在测试用例里，我们新建一个 store 来挂载 countModel，通过 store.use 获取 countModel 的 State 和\nActions。然后调用 add Action 更新状态，并断言更新后的状态值。\n\n执行 pnpm run test 命令，触发测试用例的执行。","frontmatter":{"sidebar_position":9,"title":"测试 Model"}},{"id":618,"title":"TS 最佳实践","routePath":"/guides/topic-detail/model/typescript-best-practice","lang":"zh","toc":[{"id":"定义-model-的-state-类型","text":"定义 Model 的 State 类型","depth":2},{"id":"衍生状态的依赖类型","text":"衍生状态的依赖类型","depth":2},{"id":"获取-model-类型信息的-hooks","text":"获取 Model 类型信息的 Hooks","depth":2}],"domain":"","content":"\n\nReduck 对 TS 提供了良好的支持，大部分使用场景下，无需任何额外工作，就可以直接获得 API 的 TS\n类型提示。本节，将对其他的一些使用场景，做补充介绍。\n\n\n定义 Model 的 State 类型\n\n为 Model 的 State 声明类型信息，是在 TS 中使用 Reduck 的最佳实践。\n\ninterface State {\n  data: string;\n}\n\nexport const foo = model<State>('foo').define({\n  state: {\n    data: '',\n  },\n  computed: {\n    withSuffix: state => state.data + 'suffix',\n  },\n  actions: {\n    setData: (state, payload: string) => {\n      state.data = payload;\n    },\n  },\n});\n\n\n当为 Model 的 State 声明类型信息后，Model 的 computed、actions\n都能获取正确的类型信息。事实上，上面的示例代码中，即使我们不定义 State 类型信息，也会根据 state 的初始值信息自动推导出 State\n的类型信息。不过，仍然建议你在定义 Model 时，声明 State 的类型信息，因为根据 state 的初始值信息推导出的 State\n类型信息可能不完整(缺少字段或字段的类型信息缺少)，而且当使用函数类型定义 Model 时，State 的类型信息也是无法根据 state\n的初始值信息自动推导的。\n\n\n衍生状态的依赖类型\n\n当 Model 的衍生状态依赖其他 Model 时，需要手动指定其他 Model 的 State。\n\ninterface State {\n  data: string;\n}\n\nexport const bar = model<State>('bar').define({\n  state: {\n    data: '',\n  },\n  computed: {\n    // 为 fooState 指定类型\n    withFoo: [foo, (state, fooState: FooState) => state.data + fooState.data],\n  },\n});\n\n\n\n获取 Model 类型信息的 Hooks\n\nReduck 提供了一组用于获取 Model 类型信息的工具类型：\n\n * GetModelState： 获取 Model 的 State（包含衍生状态）类型信息。\n * GetModelActions：获取 Model 的 Actions（包含 Effects 函数）类型信息。\n\nexport const foo = model<State2>('foo').define({\n  // 省略\n});\n\n// 获取 foo 的 State 类型\nlet fooActions: GetModelActions<typeof foo>;\n// 获取 foo 的 Actions 类型\nlet fooState: GetModelState<typeof foo>;\n","frontmatter":{"sidebar_position":10,"title":"TS 最佳实践"}},{"id":619,"title":"使用 Model","routePath":"/guides/topic-detail/model/use-model","lang":"zh","toc":[{"id":"在组件内使用","text":"在组件内使用","depth":2},{"id":"作为全局状态使用","text":"作为全局状态使用","depth":3},{"id":"作为静态状态使用","text":"作为静态状态使用","depth":3},{"id":"作为局部状态使用","text":"作为局部状态使用","depth":3},{"id":"在组件外使用","text":"在组件外使用","depth":2}],"domain":"","content":"\n\n\n在组件内使用\n\n\n作为全局状态使用\n\n通过 useModel 可以获取 Model 的 State、Actions 等。当 Model 的 State 通过 Actions\n进行修改后，任何其他使用了该 Model 的组件，都会自动重新渲染。\n\n在 快速上手 的计数器案例中，我们已经演示了 useModel 的使用，不再重复。\n\nuseModel 支持传入多个 Model，多个 Model 的 State 和 Actions 会进行合并后作为返回结果。例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state += 1;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    title: 'bar',\n  },\n  actions: {\n    set(state, payload) {\n      state.title = payload;\n    },\n  },\n});\n\nconst [state, actions] = useModel([fooModel, barModel]);\n// 或\nconst [state, actions] = useModel(fooModel, barModel);\n\n\nstate 和 actions 的值分别为：\n\nstate = {\n  value: 1,\n  title: 'bar',\n};\n\nactions = {\n  add(state) {\n    state += 1;\n  },\n  set(state, payload) {\n    state.title = payload;\n  },\n};\n\n\nuseModel 还支持对 State 和 Actions 做 selector 操作，实现对 State 和 Actions 的筛选或重命名，例如：\n\nconst fooModel = model('foo').define({\n  state: {\n    value: 1,\n  },\n  actions: {\n    add(state) {\n      state += 1;\n    },\n  },\n});\n\nconst barModel = model('bar').define({\n  state: {\n    value: 'bar',\n  },\n  actions: {\n    set(state, payload) {\n      state.value = payload;\n    },\n  },\n});\n\nconst [state, actions] = useModel(\n  [fooModel, barModel],\n  (fooState, barState) => ({\n    fooValue: fooState.value,\n    barValue: barState.value,\n  }), // stateSelector\n  (fooActions, barActions) => ({ add: fooActions.add }), // actionsSelector\n);\n\n\n我们通过 stateSelector ，把 fooModel 和 barModel 中重名的状态做了命名修改，通过 actionsSelector ，过滤掉了\nbarModel 的 Actions。\n\n如果只需要设置 actionsSelector，可以把 stateSelector 设置为 undefined，作为参数占位。例如：\n\nconst [state, actions] = useModel(\n  [fooModel, barModel],\n  undefined,\n  (fooActions, barActions) => ({ add: fooActions.add }), // actionsSelector\n);\n\n\n\n作为静态状态使用\n\n通过 useStaticModel 获取 Model ，将 Model 中的状态作为静态状态使用。可以保证组件每次访问到的 Model 的 State\n都是最新值，但是 Model 的 State 的变化，并不会引起当前组件的重新渲染。\n\nINFO\n\nuseStaticModel 的使用方式和 useModel 完全一致。\n\n考虑下面一种场景，有一个组件 Input 负责用户输入，另外一个组件 Search\n负责根据用户的输入信息，在点击查询按钮后执行查询操作，我们不希望用户输入过程中的状态变化引起 Search 重新渲染，这时候就可以使用\nuseStaticModel：\n\n\n\nfunction Search() {\n  // 这里注意不要解构 state\n  const [state] = useStaticModel(searchModel);\n\n  return (\n    <div>\n      <button\n        onClick={async () => {\n          const result = await mockSearch(state.input);\n          console.log(result);\n        }}\n      >\n        Search\n      </button>\n    </div>\n  );\n}\n\n\n注意\n\n不要解构 useStaticModel 返回的 state，例如改成如下写法： const [{input}] =\nuseStaticModel(searchModel); 将始终获取到 Input 的初始值。\n\nuseStaticModel 还适合和 react-three-fiber 等动画库一起使用，因为在动画组件 UI\n里绑定会快速变化的状态，容易引起性能问题。这种情况就可以选择使用\nuseStaticModel，它只会订阅状态，但不会引起视图组件的重新渲染。下面是一个简化示例：\n\nfunction ThreeComponent() {\n  const [state, actions] = useStaticModel(modelA);\n\n  useFrame(() => {\n    state.value; // 假设初始化为 0\n    actions.setValue(1);\n    state.value; // 这里会得到1\n  });\n}\n\n\n使用 React 的 refs 也可以实现类似效果，其实 useStaticModel 内部也使用到了 refs。不过直接 useStaticModel\n有助于将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\n完整的示例代码可以在这里查看。\n\n\n作为局部状态使用\n\n通过 useLocalModel 获取 Model ，将 Model 中的状态作为局部状态使用。此时 Model State\n的变化，只会引起当前组件的重新渲染，但是不会引起其他使用了该 Model 的组件重新渲染。效果和通过 React 的 useState\n管理状态类似，但是可以将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\nINFO\n\nuseLocalModel 的使用方式和 useModel 完全一致。\n\n例如，我们修改计数器应用的代码，添加一个有局部状态的计数器组件 LocalCounter：\n\n\n\nfunction LocalCounter() {\n  const [state, actions] = useLocalModel(countModel);\n\n  return (\n    <div>\n      <div>local counter: {state.value}</div>\n      <button onClick={() => actions.add()}>add</button>\n    </div>\n  );\n}\n\n\n分别点击 Counter 和 LocalCounter 的 add 按钮，两者的状态互不影响：\n\n\n\n完整的示例代码可以在这里查看。\n\n\n在组件外使用\n\n在实际业务场景中，有时候我们需要在 React 组件外使用 Model，例如在工具函数中访问 State、执行 Actions 等。这个时候，我们就需要使用\nStore。 Store 是一个底层概念，一般情况下用户接触不到，它负责存储和管理整个应用的状态。Reduck 的 Store 基于 Redux 的 Store\n实现，增加了 Reduck 特有的 API，如 use 。\n\n首先，在组件内调用 useStore 获取当前应用使用的 store 对象，并挂载到组件外的变量上：\n\nlet store; // 组件外部 `store` 对象的引用\nfunction setStore(s) {\n  store = s;\n}\nfunction getStore() {\n  return store;\n}\n\nfunction Counter() {\n  const [state] = useModel(countModel);\n  const store = useStore();\n  // 通过 useMemo 避免不必要的重复设置\n  useMemo(() => {\n    setStore(store);\n  }, [store]);\n\n  return (\n    <div>\n      <div>counter: {state.value}</div>\n    </div>\n  );\n}\n\n\n通过 store.use 可以获取 Model 对象，store.use 的用法同 useModel 相同。以计数器应用为例，我们在组件树外，每 1s\n对计数器值 执行自增操作：\n\nsetInterval(() => {\n  const store = getStore();\n  const [, actions] = store.use(countModel);\n  actions.add();\n}, 1000);\n\n\n完整的示例代码可以在这里查看。\n\nINFO\n\n如果是通过 createStore 手动创建的 Store 对象，无需通过 useStore 在组件内获取，即可直接使用。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","frontmatter":{"sidebar_position":3,"title":"使用 Model"}},{"id":620,"title":"单独使用 Reduck","routePath":"/guides/topic-detail/model/use-out-of-modernjs","lang":"zh","toc":[],"domain":"","content":"\n\n在 Modern.js 以外，单独集成 Reduck 使用时，主要需要做以下修改：\n\n 1. 安装 Reduck 相关包\n\n在项目中安装 Reduck 包：@modern-js-reduck/react。\n\n 2. API 导入包名\n\n在 Modern.js 中使用时，Reduck 导出 API 的包名为：@modern-js/runtime/model。单独使用 Reduck\n时，导出包名为：@modern-js-reduck/react。\n\n 3. 包裹 Provider 组件\n\nModern.js 自动在应用的入口组件上，包裹了用于注入 Reduck 全局 Store 的 Provider 组件。单独使用 Reduck\n时，需要手动完成。\n\n示例：\n\n// 根组件\nconst Root = () => {\n  return (\n    <Provider>\n      {/* 应用入口组件 */}\n      <App />\n    </Provider>\n  );\n};\n\n\n 4. 功能配置\n\n在 Modern.js 中使用时，可以通过 runtime.state 对 Reduck 功能进行配置。单独使用时，需要通过 Provider 的 config\n或 store 参数配置。\n\n示例：\n\nconst Root = () => {\n  return (\n    {/* 关闭 Redux DevTools */}\n    <Provider config={{ devTools: false }}>\n      <App />\n    </Provider>\n  )\n}\n","frontmatter":{"sidebar_position":12,"title":"单独使用 Reduck"}},{"id":621,"title":"创建子项目","routePath":"/guides/topic-detail/monorepo/create-sub-project","lang":"zh","toc":[],"domain":"","content":"\n\n本章将要介绍如何在 Monorepo 工程下创建子项目。\n\n> Modern.js 支持使用 pnpm 和 Yarn 的 Monorepo，这里以使用 pnpm 为例。以下命令可以以同样方式使用 Yarn 来执行。\n\nModern.js 针对 Monorepo 工程提供了生成器功能，它用于在 Monorepo 工程下创建不同类型的 Monorepo\n子项目。在生成器中提供以下类型子项目的创建：\n\n * 「应用」类型\n * 「模块」类型\n\n要启动 Monorepo 的生成器功能，可以在 Monorepo 工程根目录下执行命令：\n\npnpm run new\n\n\n补充信息\n\n使用 Yarn 的方式：yarn new\n\n执行成功后，可以看到如下内容：\n\n? 请选择你想创建的工程类型 (Use arrow keys)\n❯ 应用\n  应用（测试）\n  模块\n  模块（内部）\n\n\nINFO\n\n「应用」与「应用（测试）」都是「应用」类型的项目，区别是「应用」类型的子项目会创建在 ./apps 目录下，而 「应用（测试）」类型的子项目会创建在\n./examples 目录下。\n\nINFO\n\n「模块」与「模块（内部）」都是「模块」类型的项目，区别之一是「模块」类型的子项目会创建在 ./packages 目录下，而「模块（内部）」类型的子项目会创建在\n./features 目录下。\n\n对于「模块」类型的子项目允许被发布到外部（例如\nnpm)，而对于「模块（内部）」的子项目则可以在应用项目中直接使用其源码（该特性是「模块」项目不具备的，应用项目对于「模块（内部）」子项目做了特殊处理），因此这\n类子项目不需要发布到外部。\n\n然后根据不同的需求选择对应的类型项目选项，选择之后便开始出现对应子项目类型的问题和选项。例如选择「应用」后会出现：\n\n? 请选择你想创建的工程类型 应用\n? 请填写子项目名称\n\n\n当完成所有生成器问题之后，便开始进行项目的创建和项目依赖的下载。当创建成功之后，可以看到类似以下内容：\n\n[INFO] 依赖自动安装成功\n[INFO] 创建成功！\n可在新项目的目录下运行以下命令：\npnpm run dev          # 按开发环境的要求，运行和调试项目\npnpm run build        # 按生产环境的要求，构建项目\npnpm run serve        # 按生产环境的要求，运行项目\npnpm run lint         # 检查和修复所有代码\npnpm run new          # 继续创建更多项目要素，比如应用入口\n","frontmatter":{"sidebar_position":2}},{"id":622,"title":"Monorepo 工程介绍","routePath":"/guides/topic-detail/monorepo/intro","lang":"zh","toc":[],"domain":"","content":"\n\nModern.js 提供了对于 Monorepo 工程方案的支持，其主要通过 @modern-js/monorepo-tools 来提供功能。\n\n该专题将从以下方面来讲解如何使用 Modern.js 对 Monorepo 进行管理：\n\n * 在 Monorepo 中创建子项目\n * Monorepo 下子项目之间的联调开发\n * 发布 Monorepo 的子项目\n * 部署 Monorepo 子项目","frontmatter":{"sidebar_position":1}},{"id":623,"title":"可复用模块的发布","routePath":"/guides/topic-detail/monorepo/publish","lang":"zh","toc":[{"id":"准备工作","text":"准备工作","depth":2},{"id":"生成变更记录","text":"生成变更记录","depth":2},{"id":"版本更新","text":"版本更新","depth":2},{"id":"发布","text":"发布","depth":2}],"domain":"","content":"\n\n在 Monorepo 中有时会需要把多个模块项目发布到 NPM 上，本章将要介绍如果在 Monorepo 中对子项目进行版本更新以及发布。\n\n\n准备工作\n\n接着 子项目联调 章节的例子，我们对 components 模块进行发布。\n\n\n生成变更记录\n\n在开发阶段，当某个模块的功能开完完成之后，一般需要提交代码（例如提交到 GitHub 上）并需要记录本次修改的内容。在 Modern.js 的 Monorepo\n工程中，我们可以在 monorepo 根目录执行命令：\n\npnpm run change\n\n\n然后根据提示选择变更或者将要发布的包以及选择包升级的版本，并填写变更信息。变更信息的内容可以包含此次开发的功能、修复的问题等。\n\n那么对于上面的例子，我们选择变更的项目为 components，并填写此次变更的内容：\n\n$ modern change\n🦋  Which packages would you like to include? · components\n🦋  Which packages should have a major bump? · No items were selected\n🦋  Which packages should have a minor bump? · components\n🦋  Please enter a summary for this change (this will be in the changelogs). Submit empty line to open external editor\n🦋  Summary · add features\n🦋  === Releasing the following packages ===\n🦋  [Minor]\n🦋    components\n🦋  ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n🦋  ║                                                      ========= NOTE ========                                                       ║\n🦋  ║All dependents of these packages that will be incompatible with the new version will be patch bumped when this changeset is applied.║\n🦋  ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n🦋  Is this your desired changeset? (Y/n) · true\n🦋  Changeset added! - you can now commit it\n🦋\n🦋  If you want to modify or expand on the changeset summary, you can find it here\n🦋  info /Users/demo/modern-js/official/monorepo-pnpm/.changeset/silent-tigers-run.md\n\n\n该命令完成后，在 .changeset 中会有新的 silent-tigers-run.md\n文件生成，其中包含了刚刚填写的信息，这些新生成的文件将用于后面发布流程中使用。因此在提交代码的时候，需要将.changeset 目录下的文件一并提交。\n\n\n版本更新\n\n在模块发布之前，还需要将模块的版本进行更新。。在 Modern.js 的 Monorepo 工程中，可以在 Monorepo 项目根目录下执行：\n\npnpm run bump\n\n\n该命令会根据之前生成在 .changeset 目录下的文件自动更新对应模块的版本号和 CHANGELOG 信息，执行成功后会看到：\n\n🦋  All files have been updated. Review them and commit at your leisure\n\n\n\n发布\n\n最后执行 pnpm run prepare --filter {./packages} && pnpm run release，便可以发布对应的模块了。\n\n补充信息\n\n在上面的命令中 --filter {./packages} 用于筛选位于 ./packages 目录下的子项目，可以通过 PNPM Filtering\n来了解更多它的使用。","frontmatter":{"sidebar_position":4}},{"id":624,"title":"子项目联调","routePath":"/guides/topic-detail/monorepo/sub-project-interface","lang":"zh","toc":[{"id":"准备工作","text":"准备工作","depth":2},{"id":"在使用-pnpm-的-monorepo-中进行项目联调","text":"在使用 pnpm 的 Monorepo 中进行项目联调","depth":2},{"id":"在使用-yarn-的-monorepo-中进行项目联调","text":"在使用 Yarn 的 Monorepo 中进行项目联调","depth":2}],"domain":"","content":"\n\n本章将要介绍如何在 Monorepo 下进行子项目之间的联调使用。\n\n\n准备工作\n\n按照 「创建子项目」 章节的介绍（如果还没有看过，可以先了解一下），我们首先创建以下三个子项目：\n\n * 一个「应用」子项目\n * 一个「模块（内部）」子项目\n * 一个「模块」子项目\n\n执行 pnpm run new，并按照如下进行选择：\n\n「应用」子项目：\n\n? 请选择你想创建的工程类型 应用\n? 请填写子项目名称 app\n? 请填写子项目目录名称 app\n? 请选择开发语言 TS\n\n\n「模块（内部）」子项目：\n\n? 请选择你想创建的工程类型 模块（内部）\n? 请填写子项目名称 internal-lib\n? 请填写子项目目录名称 internal-lib\n? 请选择开发语言 TS\n\n\n「模块」子项目：\n\n? 请选择你想创建的工程类型 模块\n? 请填写子项目名称 components\n? 请填写子项目目录名称 components\n? 请选择开发语言 TS\n\n\n创建成功后，会得到以下项目：\n\n * ./apps/app\n * ./packages/components\n * ./features/internal-lib\n\n然后修改一下默认的代码和新增文件：\n\n重命名 ./pakcages/components/src/index.tsx\n\nimport './index.css';\n\nexport default function ({ text }: { text: string }) {\n  return (\n    <div>\n      This is UI Components Log: <p className=\"log\">{text}</p>\n    </div>\n  );\n}\n\n\n新增 ./pakcages/components/src/index.css\n\n.log {\n  color: gray;\n}\n\n\n修改 ./features/internal-lib/src/index.ts\n\nexport default function (text: string) {\n  return text.toUpperCase();\n}\n\n\n修改 ./apps/app/src/App.tsx\n\n\n\n\n\nimport './App.css';\n\nconst App = () => (\n  <Switch>\n    <Route exact={true} path=\"/\">\n      <div className=\"container-box\">\n        <Comp text={formatString('hello world')} />\n        {/* 省略... */}\n      </div>\n    </Route>\n    <Route path=\"*\">\n      <div>404</div>\n    </Route>\n  </Switch>\n);\n\nexport default App;\n\n\n到此为止我们创建了一个可以被发布到外部的组件项目、一个转换字符串的内部模块项目以及一个使用组件和内部模块的应用项目，如果直接运行应用项目还暂时无法正常使用。接下\n来将要介绍如何让它们能够互相联调使用，成功的使应用子项目 apps/app 正常运行。\n\nINFO\n\n启动 apps/app 项目之前需要先构建（pnpm run build） packages/component。\n\n由于 Modern.js 支持 pnpm 与 Yarn 的 Monorepo 工程，接下来会从这两个方面分别介绍。\n\n\n在使用 pnpm 的 Monorepo 中进行项目联调\n\n在 pnpm 的 Monorepo 项目中，我们通过在 apps/app 子项目下分别执行：\n\npnpm add components\n\n\n以及\n\npnpm add internal-lib -D\n\n\nINFO\n\n注意这里将 internal-lib 作为 apps/app 项目的开发依赖，因为在构建环境会被打包到构建产物中。\n\n将 packages/components 与 features/internal-lib 子项目加入到应用的依赖列表当中。\n\n执行成功后，在 apps/app/package.json 会发生如下变化：\n\n{\n  \"dependencies\": {\n++  \"components\": \"workspace:^0.1.0\"\n  },\n  \"devDependencies\": {\n++  \"internal-lib\": \"workspace:^0.1.0\"\n  },\n}\n\n\n补充信息\n\nworkspace:^0.1.0 是一种 PNPM 提供的 Workspace 协议。\n\n当依赖安装成功之后，我们还需要将 packages/components 进行构建，因为需要使用其构建产物。\n\n到此为止，app/apps 应用子项目可以正常的运行了。在修改 features/internal-lib 的源码，或者修改\npackages/components 的源码并构建之后都会触发应用子项目的热更新。\n\n\n在使用 Yarn 的 Monorepo 中进行项目联调\n\n在 Yarn 的 Monorepo 项目中，默认情况下可以直接在 apps/app 应用项目中直接使用组件项目和内部模块项目。\n\n补充信息\n\n之所以可以直接在应用中使用使用组件项目和内部模块项目，是因为 Yarn 将这些子项目模块提升到了顶层的 node_modules内。\n\n但是由于组件 components 是非内部模块，因此建议在 apps/app/package.json 中进行依赖声明：\n\n{\n  \"dependencies\": {\n++  \"components\": \"0.1.0\"\n  },\n}\n","frontmatter":{"sidebar_position":3}},{"id":625,"title":"命令行问题","routePath":"/guides/troubleshooting/cli","lang":"zh","toc":[{"id":"使用-pnpm-时无法正确传递命令行参数","text":"使用 pnpm 时无法正确传递命令行参数？","depth":3}],"domain":"","content":"\n\n\n使用 pnpm 时无法正确传递命令行参数？\n\npnpm v6 和 pnpm v7 版本在执行命令时使用姿势不完全一致，需要注意以下事项：\n\npnpm v7：\n\n在使用 pnpm 调用 package.json 中的命令时，如果需要传递参数至 pnpm，需要将参数放到命令前。\n\n例如使用 pnpm --filter 参数执行 prepare 命令：\n\npnpm run --filter \"./packages/**\" prepare\n\n\n如果需要传递参数至命令，需要将参数放到命令后。\n\n例如，在如下 package.json 配置中：\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\n执行 command 命令时携带参数方式为：\n\npnpm run command --options\n\n\npnpm v6:\n\n在如下 package.json 配置中：\n\n{\n  \"scripts\": {\n    \"command\": \"modern command\"\n  }\n}\n\n\n当需要执行 modern command --option：\n\n使用 pnpm 时，需要执行 pnpm run command -- --option。\n\n这是因为 pnpm 对于命令参数的处理与 Yarn 并不相同，但是与 npm 类似：在不加 -- 字符串的时候，传递的是 pnpm 的参数；在使用 --\n字符串的时候，传递的是执行脚本的参数。\n\n在上述例子里参数 --option 传递给了 modern command。如果执行 pnpm run command --option，则参数\n--option 将传递给 pnpm。\n\n总结来说：\n\n在使用 pnpm v7 时，如果传递参数给 pnpm，需要将参数放置到命令前\n\n在使用 pnpm v6 时，如果传递的参数给 pnpm，不需要加 --；如果传递的参数是给脚本使用，需要增加 -- 字符串。","frontmatter":{"sidebar_position":2}},{"id":626,"title":"依赖安装问题","routePath":"/guides/troubleshooting/dependencies","lang":"zh","toc":[{"id":"如何查看项目里某个依赖实际安装的版本","text":"如何查看项目里某个依赖实际安装的版本？","depth":3},{"id":"安装依赖时提示-the-engine-node-is-incompatible","text":"安装依赖时提示 The engine \"node\" is incompatible？","depth":3},{"id":"升级依赖后出现-reactnode-类型错误","text":"升级依赖后出现 ReactNode 类型错误？","depth":3},{"id":"执行-pnpm-install-之后控制台出现-peer-dependencies-相关-warning","text":"执行 pnpm install 之后，控制台出现 peer dependencies 相关 warning？","depth":3}],"domain":"","content":"\n\n\n如何查看项目里某个依赖实际安装的版本？\n\n可以使用包管理器自带的 ls 命令来查看项目里依赖的版本。\n\n下面是一些基本的示例，详细用法请查看各个包管理器的文档。\n\nnpm / yarn\n\n对于使用 npm 或 yarn 的项目，可以使用 npm ls 命令。\n\n比如执行 npm ls @modern-js/core，可以看到如下结果：\n\nproject\n└─┬ @modern-js/app-tools@1.6.10\n  └── @modern-js/core@1.12.4\n\n\npnpm\n\n对于使用 pnpm 的项目，可以使用 pnpm ls 命令。\n\n比如执行 pnpm ls @modern-js/core --depth Infinity，可以看到如下结果：\n\ndevDependencies:\n@modern-js/app-tools 1.7.0\n└── @modern-js/core 1.13.0\n\n\n--------------------------------------------------------------------------------\n\n\n安装依赖时提示 The engine \"node\" is incompatible？\n\n安装依赖时如果出现以下报错提示，说明当前环境使用的 Node.js 版本过低，需要升级 Node.js 到更高版本。\n\nThe engine \"node\" is incompatible with this module.\n\nExpected version \">=14.17.6\". Got \"12.20.1\"\n\n\n使用 Modern.js 时，建议使用 Node.js 14.x 或 Node.js 16.x 的最新版本。\n\n如果当前环境的 Node.js 版本低于上述要求的版本，则可以使用 nvm 或 fnm 等工具进行版本切换。\n\n下面是使用 nvm 的示例：\n\n# 安装 Node.js v14\nnvm install 14\n\n# 切换到 Node 14\nnvm use 14\n\n# 将 Node 14 设置为默认版本\nnvm default 14\n\n\n在本地开发环境推荐使用 fnm，它的用法与 nvm 相似，但拥有比 nvm 更好的性能。\n\n--------------------------------------------------------------------------------\n\n\n升级依赖后出现 ReactNode 类型错误？\n\n升级项目的依赖后，如果出现以下类型报错，说明项目中安装了错误的 @types/react 版本。\n\nThe types returned by 'render()' are incompatible between these types.\nType 'React.ReactNode' is not assignable to type 'import(\"/node_modules/@types/react/index\").ReactNode'.\nType '{}' is not assignable to type 'ReactNode'.\n\n\n出现这个问题的原因是 React 18 与 React 16/17 中的 ReactNode 类型定义不同，如果项目中出现多个不同 @types/react\n版本，就会出现 ReactNode 类型冲突，导致以上报错。\n\n解决方法为将项目中的 @types/react 和 @types/react-dom 锁定在统一的版本上，比如 v17。\n\n{\n  \"@types/react\": \"^17\",\n  \"@types/react-dom\": \"^17\"\n}\n\n\n关于锁定依赖版本的方法，请参考上方的 如何锁定项目中的某个依赖版本？。\n\n--------------------------------------------------------------------------------\n\n\n执行 pnpm install 之后，控制台出现 peer dependencies 相关 warning？\n\n出现该警告的原因是，某些三方 npm 包声明的 peer dependencies 版本范围与 Modern.js 中安装的版本范围不一致。\n\n绝大多数情况下，peer dependencies 的警告不会影响项目运行，不需要额外进行处理，请忽略相关 warning。","frontmatter":{"sidebar_position":1}},{"id":628,"title":"创建项目","routePath":"/tutorials/first-app/c01-start","lang":"zh","toc":[{"id":"环境准备","text":"环境准备","depth":2},{"id":"nodejs","text":"Node.js","depth":3},{"id":"pnpm","text":"pnpm","depth":3},{"id":"初始化项目","text":"初始化项目","depth":2},{"id":"调试项目","text":"调试项目","depth":2},{"id":"修改代码","text":"修改代码","depth":2},{"id":"开启-ssr","text":"开启 SSR","depth":2}],"domain":"","content":"\n\n从这一章节开始，我们将进入实战教程部分。在实战教程中，我们将会从环境准备开始，从简单到复杂，一步一步搭建一个真实的项目。\n\n\n环境准备\n\n\nNode.js\n\n需要 Node.js LTS，并确保 Node 版本大于等于 v16.18.1。\n\nModern.js 推荐在开发环境里先安装 nvm，在 shell 里集成自动切换 node 版本的脚本。\n\n然后只要仓库根目录下有内容为 lts/gallium 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的 Node.js 版本。\n\n\npnpm\n\n推荐使用 pnpm 来管理依赖：\n\nnpm install -g pnpm\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n初始化项目\n\n我们创建新的目录，通过命令行工具初始化项目：\n\nmkdir myapp && cd myapp\nnpx @modern-js/create\n\n\nModern.js 生成器会提供一个可交互的问答界面，根据结果初始化项目，按照默认的选择进行初始化：\n\n? 请选择你想创建的工程类型 应用\n? 请选择开发语言 TS\n? 请选择包管理工具 pnpm\n\n\n在生成项目后，Modern.js 会自动安装依赖、创建 git 仓库。\n\n[INFO] 依赖自动安装成功\n[INFO] git 仓库初始化成功\n[INFO] 创建成功！\n可在新项目的目录下运行以下命令：\npnpm run dev          # 按开发环境的要求，运行和调试项目\npnpm run build        # 按生产环境的要求，构建项目\npnpm run serve        # 按生产环境的要求，运行项目\npnpm run lint         # 检查和修复所有代码\npnpm run new          # 继续创建更多项目要素，比如应用入口\n\n\nNOTE\n\nModern.js 生成器除了在项目初始化时工作外，也能在后续研发中生成项目各种粒度的模块，并非一用即抛开。\n\n现在，项目结构如下：\n\n.\n├── node_modules\n├── src\n│   ├── modern-app-env.d.ts\n│   └── routes\n│       ├── index.css\n│       ├── layout.tsx\n│       └── page.tsx\n├── modern.config.ts\n├── package.json\n├── pnpm-lock.yaml\n├── README.md\n└── tsconfig.json\n\n\n\n调试项目\n\n在项目中执行 pnpm run dev 即可启动项目：\n\n$ pnpm run dev\n\n> modern dev\n\ninfo    Starting dev server...\ninfo    App running at:\n\n  > Local:    http://localhost:8080/\n  > Network:  http://192.168.0.1:8080/\n\n Client ✔ done in 76.10ms\n\n\n在浏览器中打开 http://localhost:8000/，可以看到页面内容。\n\n\n修改代码\n\n我们将原本的示例代码删除，替换成一个简单的联系人列表：\n\nconst getAvatar = (users: Array<{ name: string; email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst mockData = getAvatar([\n  { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n  { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  { name: 'Bradley', email: 'd.wfovsqyo@gpkcjwjgb.fr' },\n  { name: 'Davis', email: '\"t.kqkoj@utlkwnpwk.nu' },\n]);\n\nfunction App() {\n  return (\n    <ul>\n      {mockData.map(({ name, avatar, email }) => (\n        <li key={name}>\n          <img src={avatar} width={60} height={60} /> ---\n          <span>{name}</span> ---\n          <span>{email}</span>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default App;\n\n\n删除多余的 css 文件，保持目录没有多余的文件：\n\nrm src/routes/index.css\n\n\n因为框架默认支持 HMR，可以看到 http://localhost:8080/ 里的内容会自动更新为：\n\n\n\n此刻的页面还没有样式。下一章节将展开这部分的内容。\n\n\n开启 SSR\n\n接下来，我们修改项目中的 modern.config.ts，开启 SSR 能力：\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools()],\n});\n\n\n重新执行 pnpm run dev，可以发现项目已经在服务端完成了页面渲染。","frontmatter":{"title":"创建项目"}},{"id":629,"title":"编写 UI 组件","routePath":"/tutorials/first-app/c02-component","lang":"zh","toc":[],"domain":"","content":"\n\n上一章节中，我们学习了如何初始化项目，并使用配置修改 Modern.js 的默认行为。\n\n这一章节中，我们继续沿用上一章节的项目代码，继续完善联系人列表。\n\n为了做更好的 UI 展示和交互，我们引入组件库 Antd 来开发，使用 <List> 组件来代替原始的列表。先添加依赖：\n\npnpm add antd\n\n\n修改 src/routes/page.tsx，在顶部导入组件：\n\n\n\n修改 <App> 组件的实现：\n\nfunction App() {\n  return (\n    <div>\n      <List\n        dataSource={mockData}\n        renderItem={({ name, email, avatar }) => (\n          <List.Item key={name}>\n            <List.Item.Meta\n              avatar={<img alt=\"avatar\" src={avatar} width={60} height={60} />}\n              title={name}\n              description={email}\n            />\n          </List.Item>\n        )}\n      />\n    </div>\n  );\n}\n\n\n执行 pnpm run dev，查看运行结果：\n\n\n\n可以看到 Ant Design 导出的组件，已经具备了完整的样式。\n\nINFO\n\nModern.js 会自动按需导入 Ant Design 组件需要的 CSS。\n\nNOTE\n\n我们也可以使用其他组件库来实现同样的功能，例如 Arco Design。","frontmatter":{"title":"编写 UI 组件"}},{"id":630,"title":"添加样式","routePath":"/tutorials/first-app/c03-css","lang":"zh","toc":[{"id":"使用-css-写-js-组件","text":"使用 CSS 写 JS 组件","depth":2},{"id":"使用-utility","text":"使用 Utility","depth":2},{"id":"自定义-utility-class","text":"自定义 Utility Class","depth":2}],"domain":"","content":"\n\n上一章节中，我们学习了如何使用使用三方库中的组件。\n\n这一章节中，我们将学习如何实现 UI 组件。\n\n\n使用 CSS 写 JS 组件\n\n首先我们希望自己控制联系人头像的展示，实现这种设计稿：\n\n\n\n假设没有现成的组件可以实现，那就需要自己写些 CSS 了，这里我们使用 styled-components，来实现类似的需求。Modern.js 开箱即用的支持\nstyled-components，既不需要安装依赖，也不需要做任何配置。\n\nstyled-components 通过模块化的方式，避免了传统 CSS 写法上的诸多问题。例如直接在元素的 style 属性上写样式，UI 视觉上的细节也会跟\nUI 结构上的细节和业务逻辑混在一起。或是 classname 需要避免全局空间重名，需要用到命名规范的问题。\n\n在 src/routes/page.tsx 里修改顶部的代码：\n\n\n\n添加以下代码：\n\nconst Avatar = styled.img`\n  width: 50px;\n  height: 50px;\n  border: 4px solid #0ef;\n  border-radius: 50%;\n`;\n\n\n修改 List.Item.Meta 的代码：\n\n<List.Item.Meta\n  avatar={<Avatar src={avatar} />}\n  title={name}\n  description={email}\n/>\n\n\n执行 pnpm run dev，可以看到预期的运行结果：\n\n\n\n接下来我们做一点重构，为了增强可读性，让代码更容易维护，可以把 Avatar 组件拆分出去。我们在终端执行以下命令，创建新的文件：\n\nmkdir -p src/components/Avatar\ntouch src/components/Avatar/index.tsx\n\n\nmkdir -p src/components/Avatar\nni src/components/Avatar/index.tsx\n\n\n把 src/routes/page.tsx 里的 <Avatar> 实现删掉，修改为：\n\n\n\nsrc/components/Avatar/index.tsx 的内容，修改为：\n\n\n\nconst Avatar = styled.img`\n  width: 50px;\n  height: 50px;\n  border: 4px solid #0ef;\n  border-radius: 50%;\n`;\n\nexport default Avatar;\n\n\n执行 pnpm run dev，运行结果应该是一样的。\n\nINFO\n\n采用目录形式 Avatar/index.tsx 而不是单文件形式 Avatar.tsx\n的原因是，之后可以方便的在目录内部增加子文件，包括专用的资源（图片等）、专用子组件、CSS 文件等。\n\n\n使用 Utility\n\n我们已经使用 style-components 实现 <Avatar> 组件，但当前的 UI\n仍然不能让人满意，缺乏专业感，例如列表项内部的布局有点粗糙，很多地方没对齐。\n\n现在，我们自己来实现一个更好的 Item 组件，实现这样的设计稿：\n\n\n\n这次要实现的 UI 更复杂，有内部结构，但另一方面，并没有 <Avatar> 组件的很粗的亮蓝色边框这样很特殊的\nUI，都是很常规的水平垂直布局、居中、字体样式等。这种情况下，其实根本没必要写 CSS，有更高效的、跟 styled-components\n互补的实现方式：Utility Class。\n\nModern.js 集成了主流、轻量、通用的 Utility Class 工具库 Tailwind CSS。\n\n执行 pnpm run new，进行如下选择，开启 Tailwind CSS：\n\n? 请选择你想要的操作 启用可选功能\n? 启用可选功能 启用 Tailwind CSS 支持\n\n\n在 modern.config.ts 中注册 Tailwind 插件:\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n  },\n  plugins: [appTools(), tailwindcssPlugin()],\n});\n\n\n在 src/routes/page.tsx 顶部引入 Tailwind CSS 的 css 文件，就可以开始快速实现专业的 UI：\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\n先创建 Item 组件：\n\nmkdir -p src/components/Item\ntouch src/components/Item/index.tsx\n\n\nmkdir -p src/components/Item\nni src/components/Item/index.tsx\n\n\n修改 src/routes/page.tsx，把 List 的 render 实现交给 Item 组件：\n\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\n\n\nconst getAvatar = (users: Array<{ name: string, email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst mockData = getAvatar([\n  { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n  { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  { name: 'Bradley', email: 'd.wfovsqyo@gpkcjwjgb.fr' },\n  { name: 'Davis', email: '\"t.kqkoj@utlkwnpwk.nu' },\n]);\n\nfunction Index() {\n  return (\n    <div className=\"container lg mx-auto\">\n      <List\n        dataSource={mockData}\n        renderItem={info => <Item key={info.name} info={info} />}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\n在父容器的上使用了 Utility Class ，快速实现了最基本的最大宽度、居中等样式。\n\n接下来实现 src/components/Item/index.tsx：\n\n\n\ntype InfoProps = {\n  avatar: string;\n  name: string;\n  email: string;\n  archived?: boolean;\n};\n\nconst Item = ({ info }: { info: InfoProps }) => {\n  const { avatar, name, email, archived } = info;\n  return (\n    <div className=\"flex p-4 items-center border-gray-200 border-b\">\n      <Avatar src={avatar} />\n      <div className=\"ml-4 flex-1 flex justify-between\">\n        <div className=\"flex-1\">\n          <p>{name}</p>\n          <p>{email}</p>\n        </div>\n        <button\n          type=\"button\"\n          disabled={archived}\n          className={`bg-blue-500  text-white font-bold\n            py-2 px-4 rounded-full hover:bg-blue-700`}\n        >\n          Archive\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Item;\n\n\n执行 pnpm run dev，可以看到预期的运行结果：\n\n\n\n我们只使用了少量 Utility Class，比如 Flex、Padding、Margin、Text、Font、Border，不写一行 CSS\n就实现了符合设计稿的专业 UI。\n\n\n自定义 Utility Class\n\n我们也可以自己实现新的 Utility Class，方便在代码间复用。\n\nUtility Class 本身也是一种面向组件的技术（将不同 class 用在一个组件上，等价于给这个组件设置了一些来自基类的属性），但 Utility\nClass 的 classname 是全局的（因为要用在任意组件/元素上），很适合用独立 CSS 文件来实现。\n\n创建一个新的 CSS 文件：\n\nmkdir -p src/styles\ntouch src/styles/utils.css\n\n\nmkdir -p src/styles\nni src/styles/utils.css\n\n\n在 src/routes/page.tsx 里导入 utils.css：\n\nimport '../styles/utils.css';\n\n\n在 src/routes/styles/utils.css 里实现一个名为 custom-text-gray 的 Utility Class。\n\n:root {\n  --custom-text-color: rgb(113, 128, 150);\n}\n\n.custom-text-gray {\n  color: var(--custom-text-color);\n}\n\n\nINFO\n\nModern.js 集成了 PostCSS，支持现代 CSS 语法特性，比如 custom properties。\n\n在 src/routes/components/Item/index.tsx 里使用，把：\n\n<div className=\"ml-4 flex-1 flex justify-between\">\n\n\n改成：\n\n<div className=\"ml-4 custom-text-gray flex-1 flex justify-between\">\n\n\n执行 pnpm run dev，可以看到字体颜色改变了：\n\n\n\nINFO\n\n此处只是为了演示 Utility Class 用法。真实项目中，在有 Tailwind CSS 的情况下，这种 Utility Class\n没什么价值，应该通过配置 Design System 的 theme 来增加字体颜色。\n\nutils.css 也可以写成 utils.scss 或 utils.less，Modern.js 对 SCSS 和 Less 同样提供开箱即用的支持。\n\n不过在 PostCSS 的支持下，现代 CSS 应该足以满足这些开发需求，性能相较于预处理器也更好，建议优先用 .css 文件。","frontmatter":{"title":"添加样式"}},{"id":631,"title":"添加客户端路由","routePath":"/tutorials/first-app/c04-routes","lang":"zh","toc":[],"domain":"","content":"\n\n上一章节中，我们学习了如何为创建 UI 组件，并添加样式。\n\n这一章节中，我们将会学习如何添加客户端路由。\n\n之前我们已经为联系人列表增加了 Archive 按钮，接下来我们添加一个客户端路由 /archives，访问这个路由时，只显示已存档的联系人，而原有的 /\n继续显示所有联系人。\n\n新建 src/routes/archives/page.tsx 文件：\n\nmkdir -p src/routes/archives\ntouch src/routes/archives/page.tsx\n\n\nmkdir -p src/routes/archives\nni src/routes/archives/page.tsx\n\n\n添加如下代码：\n\n\n\n\n\nconst getAvatar = (users: Array<{ name: string; email: string }>) =>\n  users.map(user => ({\n    ...user,\n    avatar: `https://avatars.dicebear.com/v2/identicon/${user.name}.svg`,\n  }));\n\nconst getMockArchivedData = () =>\n  getAvatar([\n    { name: 'Thomas', email: 'w.kccip@bllmfbgv.dm' },\n    { name: 'Chow', email: 'f.lfqljnlk@ywoefljhc.af' },\n  ]);\nfunction Index() {\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>Archives</title>\n      </Helmet>\n      <List\n        dataSource={getMockArchivedData()}\n        renderItem={info => <Item key={info.name} info={info} />}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\n这里使用了 React Helmet 的 Helmet 组件，在 src/routes/page.tsx 中也添加 Helmet 组件：\n\n\n\nfunction Index() {\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      ...\n    </div>\n  );\n}\n\n\nINFO\n\nModern.js 默认集成了 react-helmet，也可以结合 SSR 使用，满足 SEO 需求。\n\n因为现在有多个页面，都需要用到前面的 Utility Class，因此我们需要把样式文件移动到 src/routes/layout.tsx：\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\nimport '../styles/utils.css';\n\n\n执行 pnpm run dev，访问 http://localhost:8080，可以看到完整的联系人，页面的标题是 All：\n\n\n\n访问 http://localhost:8080/archives，只会看到已存档的联系人，页面的标题是 Archives：\n\n\n\n查看页面 HTML 源码，可以看到两个页面的内容是一样，是在客户端针对不同 URL 渲染不同内容。\n\n接下来我们增加一个简单的导航栏，让用户能在两个列表之间切换。\n\n打开 src/routes/layout.tsx，在顶部导入 Radio 组件：\n\n\n\n然后将 UI 最顶部进行修改，增加一组单选框\n\nexport default function Layout() {\n  return (\n    <div>\n      <div className=\"h-16 p-2 flex items-center justify-center\">\n        <Radio.Group onChange={handleSetList} value={currentList}>\n          <Radio value=\"/\">All</Radio>\n          <Radio value=\"/archives\">Archives</Radio>\n        </Radio.Group>\n      </div>\n      <Outlet />\n    </div>\n  );\n}\n\n\n然后我们来实现 currentList 和 handleSetList。\n\n引入三个 React Hook：useState 和 useNavigate 和 useParams，以及 Ant Design 的事件类型定义：\n\n\n\n\n\n\n最后在 Layout 组件里增加局部状态和相关逻辑：\n\nexport default function Layout() {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [currentList, setList] = useState(location.pathname || '/');\n  const handleSetList = (e: RadioChangeEvent) => {\n    const { value } = e.target;\n    setList(value);\n    navigate(value);\n  };\n  return (\n  ...\n}\n\n\n到这里就已经完成了页面导航栏实现，执行 pnpm run dev 查看效果：\n\n\n\n点击导航栏中 Archives，可以看到单选框的选中状态和 URL 都会变化，页面没有刷新，只发生了 CSR。\n\n通过 URL 访问两个页面，可以看到 HTML 内容是不同的，这是因为在 SSR 阶段页面就执行了客户端路由的逻辑，HTML 里已经包含了最终的渲染结果。","frontmatter":{"title":"添加客户端路由"}},{"id":632,"title":"添加 Loader","routePath":"/tutorials/first-app/c05-loader","lang":"zh","toc":[],"domain":"","content":"\n\n上一章节中，我们学习了如何添加客户端路由。\n\n这一章节中，我们将会学习如何为路由组件添加 Loader。\n\n到目前为止，我们都是通过硬编码的方式，为组件提供数据。如果要从远端获取数据，通常情况下会使用 useEffect 来做。但在启用 SSR\n的情况下，useEffect 是不会在服务端执行的，所以这种 SSR 只能渲染很有限的 UI。\n\nModern.js 为提供了 Data Loader 的能力，支持同构的在组件中获取数据，让 SSR 的价值最大化。\n\n下面我们演示如何为路由组件添加 Data Loader，并模拟远端数据获取。我们使用 faker 来 mock 需要的数据，首先安装依赖：\n\npnpm add faker@5\npnpm add @types/faker@5 -D\n\n\n创建 src/routes/page.loader.ts：\n\n\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport default async (): Promise<LoaderData> => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\n\nNOTE\n\nData Loader 并非只为 SSR 工作。在 CSR 项目中，Data Loader 也可以避免数据获取依赖 UI\n渲染，解决请求瀑布流的问题。未来，Modern.js 也会为这一特性添加更多能力，例如预获取、数据缓存等。\n\nModern.js 也提供了一个叫 useLoaderData 的 hooks API，我们修改 src/routes/page.tsx 导出的组件：\n\n\n\nfunction Index() {\n  const { data } = useLoaderData() as LoaderData;\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      <List\n        dataSource={data}\n        renderItem={info => <Item key={info.name} info={info} />}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\n{/* Todo 重新截图，SSR 内容 */}\n\n重新执行 pnpm run dev，查看 view-source:http://localhost:8080/，或在 devtools 的 Network\n面板里查看 HTML 请求的「 Preview 」，可以看到 SSR 渲染出来的 HTML 已经包含完整的 UI：\n\n","frontmatter":{"title":"添加 Loader"}},{"id":633,"title":"添加业务模型（状态管理）","routePath":"/tutorials/first-app/c06-model","lang":"zh","toc":[{"id":"实现-model","text":"实现 Model","depth":2},{"id":"使用-model","text":"使用 Model","depth":2}],"domain":"","content":"\n\n上一章节中，我们把硬编码的 mockData 改成从 Data Loader 中加载。\n\n这一章节中，我们会进一步实现项目的功能，例如实现 Archive 按钮的功能，把联系人归档。\n\n因此会开始编写一些跟 UI 完全无关的业务逻辑，如果继续写在组件代码中，会产生越来越多的面条式代码。为此，我们引入了一种叫做 业务模型（Model）\n的代码模块，将这些业务逻辑和 UI 解耦。\n\n注意\n\n使用状态管理相关 API，需要先启用配置项 runtime.state：\n\n\n\nexport default defineConfig({\n  runtime: {\n    state: true,\n  },\n});\n\n\n\n实现 Model\n\n创建一个完整的 Model 首先需要定义状态（state），包括状态中数据的名称和初始值。\n\n我们使用 Model 来管理联系人列表的数据，因此定义如下数据状态：\n\nconst state = {\n  items: [],\n};\n\n\n使用 TS 语法，可以定义更完整的类型信息，比如 items 里每个对象都应该有 name、email 字段。为了实现归档功能，还需要创建 archived\n字段保存这个联系人是否已被归档的状态。\n\n我们还需要一个字段用来访问所有已归档的联系人，可以定义 computed 类型的字段，对已有的数据做转换：\n\nconst computed = {\n  archived: ({ items }) => {\n    return items.filter(item => item.archived);\n  },\n};\n\n\ncomputed 类型字段的定义方式是函数，但使用时可以像普通字段一样通过 state 访问。\n\nINFO\n\nModern.js 集成了 Immer，能够像操作 JS 中常规的可变数据一样，去写这种状态转移的逻辑。\n\n实现 Archive 按钮时，我们需要一个 archive 函数，负责修改指定联系人的 archived 字段，我们把这种函数都叫作 action：\n\nconst actions = {\n  archive(draft, payload) {\n    const target = draft.items.find(item => item.email === payload);\n    if (target) {\n      target.archived = true;\n    }\n  },\n};\n\n\naction 函数是一种纯函数，确定的输入得到确定的输出（转移后的状态），不应该有任何副作用。\n\n函数的第一个参数是 Immer 提供的 Draft State，第二个参数是 action 被调用时传入的参数（后面会介绍怎么调用）。\n\n我们尝试完整实现它们：\n\nconst state = {\n  items: [],\n  pending: false,\n  error: null,\n};\n\nconst computed = {\n  archived: ({ items }) => {\n    return items.filter(item => item.archived);\n  },\n};\n\nconst actions = {\n  archive(draft, payload) {\n    const target = draft.items.find(item => item.email === payload);\n    if (target) {\n      target.archived = true;\n    }\n  },\n};\n\n\n接下来我们把上面的代码连起来，放在同一个 Model 文件里。首先执行以下命令，创建新的文件目录：\n\nmkdir -p src/models/\ntouch src/models/contacts.ts\n\n\n添加 src/models/contacts.ts 的内容：\n\n\n\ntype State = {\n  items: {\n    avatar: string;\n    name: string;\n    email: string;\n    archived?: boolean;\n  }[];\n  pending: boolean;\n  error: null | Error;\n};\n\nexport default model<State>('contacts').define({\n  state: {\n    items: [],\n    pending: false,\n    error: null,\n  },\n  computed: {\n    archived: ({ items }: State) => items.filter(item => item.archived),\n  },\n  actions: {\n    archive(draft, payload) {\n      const target = draft.items.find(item => item.email === payload)!;\n      if (target) {\n        target.archived = true;\n      }\n    },\n  },\n});\n\n\n我们把一个包含 state，action 等要素的 plain object 称作 Model Spec，Modern.js 提供了 Model\nAPI，可以根据 Model Spec 生成 Model。\n\n\n使用 Model\n\n现在我们直接使用这个 Model，把项目的逻辑补充起来。\n\n首先修改 src/components/Item/index.tsx，添加 Archive 按钮的 UI 和交互，内容如下：\n\n\n\ntype InfoProps = {\n  avatar: string;\n  name: string;\n  email: string;\n  archived?: boolean;\n};\n\nconst Item = ({\n  info,\n  onArchive,\n}: {\n  info: InfoProps;\n  onArchive?: () => void;\n}) => {\n  const { avatar, name, email, archived } = info;\n  return (\n    <div className=\"flex p-4 items-center border-gray-200 border-b\">\n      <Avatar src={avatar} />\n      <div className=\"ml-4 custom-text-gray flex-1 flex justify-between\">\n        <div className=\"flex-1\">\n          <p>{name}</p>\n          <p>{email}</p>\n        </div>\n        <button\n          type=\"button\"\n          disabled={archived}\n          onClick={onArchive}\n          className={`text-white font-bold py-2 px-4 rounded-full ${\n            archived\n              ? 'bg-gray-400 cursor-default'\n              : 'bg-blue-500 hover:bg-blue-700'\n          }`}\n        >\n          {archived ? 'Archived' : 'Archive'}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Item;\n\n\n接下来，我们修改 src/routes/page.tsx，为 <Item> 组件传递更多参数：\n\n\n\n\n\n\n\n\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport const loader = async (): Promise<LoaderData> => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n      archived: false,\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\nfunction Index() {\n  const { data } = useLoaderData() as LoaderData;\n  const [{ items }, { archive, setItems }] = useModel(contacts);\n  if (items.length === 0) {\n    setItems(data);\n  }\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      <List\n        dataSource={items}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\nuseModel 是 Modern.js 提供的 hooks API。可以在组件中提供 Model 中定义的 state，或通过 actions 调用\nModel 中定义的 side effect 与 action，从而改变 Model 的 state。\n\nModel 是业务逻辑，是计算过程，本身不创建也不持有状态。只有在被组件用 hooks API 使用后，才在指定的地方创建状态。\n\n执行 pnpm run dev，点击 Archive 按钮，可以看到页面 UI 发生了变化。\n\nNOTE\n\n上述例子中，useLoaderData 其实在每次切换路由时都会执行。因为我们在 Data Loader 里使用了 fake\n数据，每次返回的数据是不同的。但我们优先使用了 Model 中的数据，因此切换路由时数据没有发生改变。","frontmatter":{"title":"添加业务模型（状态管理）"}},{"id":634,"title":"添加容器组件","routePath":"/tutorials/first-app/c07-container","lang":"zh","toc":[{"id":"使用完整-model","text":"使用完整 Model","depth":2},{"id":"抽离容器组件","text":"抽离容器组件","depth":2}],"domain":"","content":"\n\n上一章节中，我们初步引入业务模型，从 UI 组件中拆分出这部分逻辑。page.tsx 中不再包含 UI 无关的业务逻辑实现细节，只需要使用\nModel，就能实现同样的功能。\n\n这一章节中，我们要进一步利用 Model 中实现的业务逻辑，让 page.tsx 和 archived/page.tsx 获取同一份数据。并实现 Archive\n按钮，点击按钮能把联系人归档，只显示在 Archives 列表里，不显示在 All 列表里。\n\n\n使用完整 Model\n\n因为两个页面需要共用同一套状态（联系人列表数据、联系人是否被归档），都需要包含加载初始数据的逻辑，因此我们需要在更上一层完成数据获取。\n\nModern.js 支持在 layout.tsx 通过 Data Loader 获取数据，我们先数据获取这部分代码移动到\nsrc/routes/layout.tsx 中：\n\n\nimport {\n  Outlet,\n  useLoaderData,\n  useLocation,\n  useNavigate,\n} from '@modern-js/runtime/router';\n\n\n\n\nimport 'tailwindcss/base.css';\nimport 'tailwindcss/components.css';\nimport 'tailwindcss/utilities.css';\nimport '../styles/utils.css';\n\ntype LoaderData = {\n  code: number;\n  data: {\n    name: string;\n    avatar: string;\n    email: string;\n  }[];\n};\n\nexport const loader = async (): Promise<LoaderData> => {\n  const data = new Array(20).fill(0).map(() => {\n    const firstName = name.firstName();\n    return {\n      name: firstName,\n      avatar: `https://avatars.dicebear.com/api/identicon/${firstName}.svg`,\n      email: internet.email(),\n    };\n  });\n\n  return {\n    code: 200,\n    data,\n  };\n};\n\nexport default function Layout() {\n  const { data } = useLoaderData() as LoaderData;\n  const [{ items }, { setItems }] = useModel(contacts);\n  if (items.length === 0) {\n    setItems(data);\n  }\n\n  const navigate = useNavigate();\n  ...\n}\n\n\n在 src/routes/page.tsx 中，直接使用 Model，获取数据：\n\n\n\n\n\n\n\nfunction Index() {\n  const [{ items }, { archive }] = useModel(contacts);\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>All</title>\n      </Helmet>\n      <List\n        dataSource={items}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\n同样在 archived/page.tsx 中，删除原本的 mockData 逻辑，使用 Model 中 computed 的 archived 值作为数据源：\n\n\n\n\n\n\n\nfunction Index() {\n  const [{ archived }, { archive }] = useModel(contacts);\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>Archives</title>\n      </Helmet>\n      <List\n        dataSource={archived}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Index;\n\n\n执行 pnpm run dev，访问 http://localhost:8080/，点击 Archive 按钮后，可以看到按钮置灰：\n\n\n\n接下来点击顶部导航，切换到 Archives 列表，可以发现刚才 Archive 的联系人已经出现在列表当中：\n\n\n\n\n抽离容器组件\n\n前面章节中，我们把项目中的业务逻辑拆分成了两个 layer，一个是视图组件，另一个是业务模块。前者负责 UI 展示、交互等，后者负责实现 UI\n无关的业务逻辑，专门管理状态。\n\n像 src/routes/page.tsx 和 src/routes/archives/page.tsx 这样使用了 useModel API 的组件，负责把\nView 和 Model 这两个 layer 连接起来，类似传统 MVC 架构中 Controller 的角色，在 Modern.js\n里我们沿用习惯，把它们称作容器组件（Container）。\n\n容器组件推荐放在专门的 containers/ 目录里，我们执行以下命令，创建新的文件：\n\nmkdir -p src/containers\ntouch src/containers/Contacts.tsx\n\n\nmkdir -p src/containers\nni src/containers/Contacts.tsx\n\n\n我们将原本两个 page.tsx 中公共的部分抽离出来，src/containers/Contacts.tsx 的代码如下：\n\n\n\n\n\n\n\n\n\n\n\nfunction Contacts({\n  title,\n  source,\n}: {\n  title: string;\n  source: 'items' | 'archived';\n}) {\n  const [state, { archive }] = useModel(contacts);\n\n  return (\n    <div className=\"container lg mx-auto\">\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n      <List\n        dataSource={state[source]}\n        renderItem={info => (\n          <Item\n            key={info.name}\n            info={info}\n            onArchive={() => {\n              archive(info.email);\n            }}\n          />\n        )}\n      />\n    </div>\n  );\n}\n\nexport default Contacts;\n\n\n修改 src/routes/page.tsx 和 src/routes/archives/page.tsx 的代码：\n\n\n\nfunction Index() {\n  return <Contacts title=\"All\" source=\"items\" />;\n}\n\nexport default Index;\n\n\n\n\nfunction Index() {\n  return <Contacts title=\"Archives\" source=\"archived\" />;\n}\n\nexport default Index;\n\n\n重构完成，现在的项目结构是：\n\n.\n├── README.md\n├── dist\n├── modern.config.ts\n├── node_modules\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── components\n│   │   ├── Avatar\n│   │   │   └── index.tsx\n│   │   └── Item\n│   │       └── index.tsx\n│   ├── containers\n│   │   └── Contacts.tsx\n│   ├── models\n│   │   └── contacts.ts\n│   ├── modern-app-env.d.ts\n│   ├── routes\n│   │   ├── archives\n│   │   │   └── page.tsx\n│   │   ├── layout.tsx\n│   │   └── page.tsx\n│   └── styles\n│       └── utils.css\n└── tsconfig.json\n\n\ncomponents/ 里的视图组件，都是目录形式，如 Avatar/index.tsx。而 containers/ 里的容器组件，都是单文件形式，如\ncontacts.tsx。这是我们推荐的一种最佳实践。\n\n在 添加 UI 组件（Component） 章节提到过，视图组件用目录形式，是因为视图组件负责实现 UI\n展示和交互细节，可以演变的复杂。用目录形式，可以方便增加子文件，包括专用的资源（图片等）、专用子组件、CSS\n文件等。在这个目录内部可以随意重构，只考虑最小局部。\n\n而容器组件只负责连接，是一个胶水层，复杂的业务逻辑和实现细节都交给 View 层和 Model\n层去实现。容器组件自己应该保持简单清晰，不应该包含复杂实现细节，所以不应该有内部结构。采用单文件形式不但更简洁，也能起到约束作用，提醒开发者不要把容器组件写复杂\n。","frontmatter":{"title":"添加容器组件"}},{"id":635,"title":"添加应用入口","routePath":"/tutorials/first-app/c08-entries","lang":"zh","toc":[{"id":"新建入口","text":"新建入口","depth":2},{"id":"按入口修改配置","text":"按入口修改配置","depth":2},{"id":"下一步","text":"下一步","depth":2}],"domain":"","content":"\n\n上一个章节中，我们基本完成了联系人列表应用的开发，介绍了 Modern.js 中部分功能的用法，以及推荐的最佳实践。\n\n这一章节中，我们将介绍如何为应用添加新的入口。\n\n\n新建入口\n\n一个完整的项目可能需要多个入口，Modern.js 支持自动创建新入口，前面的章节中提到过，pnpm run new 可以启用可选功能。\n\n我们也可以通过它来创建新的工程元素，在项目根目录下执行 pnpm run new：\n\n? 请选择你想要的操作 创建工程元素\n? 创建工程元素 新建「应用入口」\n? 请填写入口名称 (entry) landing-page\n\n\n创建完成，项目会变成这样：\n\n.\n├── README.md\n├── modern.config.ts\n├── node_modules\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── modern-app-env.d.ts\n│   ├── landing-page\n│   │   └── routes\n│   │       ├── index.css\n│   │       ├── layout.tsx\n│   │       └── page.tsx\n│   └── myapp\n│       ├── components\n│       │   ├── Avatar\n│       │   │   └── index.tsx\n│       │   └── Item\n│       │       └── index.tsx\n│       ├── containers\n│       │   └── Contacts.tsx\n│       ├── models\n│       │   └── contacts.ts\n│       ├── routes\n│       │   ├── archives\n│       │   │   └── page.tsx\n│       │   ├── layout.tsx\n│       │   └── page.tsx\n│       └── styles\n│           └── utils.css\n└── tsconfig.json\n\n\n可以看到联系人列表应用的文件，都被自动重构到 src/myapp/ 里。\n\n同时新建了一个 src/landing-page/，里面同样有 routes/*（pnpm run new\n命令只做了这些事，所以你也可以很容易的手动创建新入口或修改入口）\n\n执行 pnpm run dev，显示：\n\n\n\n访问 http://localhost:8080/，可以像之前一样看到应用程序。\n\n访问 http://localhost:8080/landing-page，可以看到刚创建的新入口 landing-page 的页面（Modern.js\n自动生成的默认页面）。\n\nModern.js 框架的设计原则之一是【约定优于配置（Convention over\nConfiguration）】，多数情况下可以按约定直接写代码，不需要做任何配置，这里 src/ 中的目录结构就是一种约定：\n\nsrc/myapp/ 和 src/landing-page/ 被自动识别为两个应用入口：myapp 和 landing-page。\n\n其中 src/myapp/ 的目录名跟项目名（package.json 里的 name）一致，会被认为是项目主入口，项目 URL 的根路径（开发环境里默认是\nhttp://localhost:8080/）会自动指向主入口。\n\n其他入口的 URL，是在根路径后追加入口名，比如 http://localhost:8080/landing-page。\n\n接下来，我们把 src/myapp/ 重命名为 src/contacts/：\n\nmv src/myapp src/contacts\n\n\n再次执行 pnpm run dev，结果变成：\n\n\n\n现在不再有主入口，联系人列表现在是一个普通入口，需要用 http://localhost:8080/contacts 访问。\n\n\n按入口修改配置\n\n我们可以在 Modern.js 配置文件里，自己写代码来控制项目的配置。\n\n现在，修改 modern.config.ts，添加内容：\n\n\n\n\nexport default defineConfig({\n  runtime: {\n    router: true,\n    state: true,\n  },\n  server: {\n    ssr: true,\n    ssrByEntries: {\n      'landing-page': false,\n    },\n  },\n  plugins: [appTools(), tailwindcssPlugin()],\n});\n\n\n执行 pnpm run dev，再用浏览器打开 view-source:http://localhost:8080/landing-page，可以看到\nlanding-page 网页内容是通过 js 动态加载的，且此页面的 SSR 功能被关闭。\n\n如果注释掉 ssrByEntries 和它的值，landing-page 的 SSR 功能就恢复开启了。\n\n还有一些时候，需要一些更复杂的逻辑来做设置，比如需要 JS 变量、表达式、导入模块等，例如在只在开发环境里开启 SSR：\n\nexport default defineConfig({\n  server: {\n    ssrByEntries: {\n      'landing-page': process.env.NODE_ENV !== 'production',\n    },\n  },\n};\n\n\n到底为止，我们的联系人列表应用的雏形就基本完成了 👏👏👏。\n\n\n下一步\n\n接下来你可以通过了解指南、配置 等更多教程，进一步完善你的应用。","frontmatter":{"title":"添加应用入口"}},{"id":636,"title":"介绍","routePath":"/tutorials/foundations/introduction","lang":"zh","toc":[{"id":"modernjs-是什么","text":"Modern.js 是什么","depth":2},{"id":"实战教程","text":"实战教程","depth":2}],"domain":"","content":"\n\n欢迎来到 Modern.js 教程！\n\n阅读本栏目后，你将初步理解 Modern.js，并使用 Modern.js 创建第一个应用。\n\n\nModern.js 是什么\n\n如果你对 Modern.js 还不了解，可以先阅读 Modern.js 介绍。\n\n\n实战教程\n\n我们准备了一个创建「联系人列表应用」的实战教程，你可以按照教程一步步创建一个应用，并了解到 Modern.js 中的以下实践：\n\n * 创建项目\n * 使用 antd 组件库\n * 集成 Tailwind CSS\n * 客户端路由\n * 数据获取\n * 状态管理\n * 容器组件\n * 新建入口\n * ...\n\n下面就让我们从 创建项目 开始吧！","frontmatter":{"title":"介绍","sidebar_position":1}}]