(()=>{var t={901:(t,e,r)=>{"use strict";const n=r(24);const i=r(928);const s=r(552).mkdirsSync;const c=r(213).utimesMillisSync;const o=r(0);function copySync(t,e,r){if(typeof r==="function"){r={filter:r}}r=r||{};r.clobber="clobber"in r?!!r.clobber:true;r.overwrite="overwrite"in r?!!r.overwrite:r.clobber;if(r.preserveTimestamps&&process.arch==="ia32"){process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n"+"\tsee https://github.com/jprichardson/node-fs-extra/issues/269","Warning","fs-extra-WARN0002")}const{srcStat:c,destStat:a}=o.checkPathsSync(t,e,"copy",r);o.checkParentPathsSync(t,c,e,"copy");if(r.filter&&!r.filter(t,e))return;const u=i.dirname(e);if(!n.existsSync(u))s(u);return getStats(a,t,e,r)}function getStats(t,e,r,i){const s=i.dereference?n.statSync:n.lstatSync;const c=s(e);if(c.isDirectory())return onDir(c,t,e,r,i);else if(c.isFile()||c.isCharacterDevice()||c.isBlockDevice())return onFile(c,t,e,r,i);else if(c.isSymbolicLink())return onLink(t,e,r,i);else if(c.isSocket())throw new Error(`Cannot copy a socket file: ${e}`);else if(c.isFIFO())throw new Error(`Cannot copy a FIFO pipe: ${e}`);throw new Error(`Unknown file: ${e}`)}function onFile(t,e,r,n,i){if(!e)return copyFile(t,r,n,i);return mayCopyFile(t,r,n,i)}function mayCopyFile(t,e,r,i){if(i.overwrite){n.unlinkSync(r);return copyFile(t,e,r,i)}else if(i.errorOnExist){throw new Error(`'${r}' already exists`)}}function copyFile(t,e,r,i){n.copyFileSync(e,r);if(i.preserveTimestamps)handleTimestamps(t.mode,e,r);return setDestMode(r,t.mode)}function handleTimestamps(t,e,r){if(fileIsNotWritable(t))makeFileWritable(r,t);return setDestTimestamps(e,r)}function fileIsNotWritable(t){return(t&128)===0}function makeFileWritable(t,e){return setDestMode(t,e|128)}function setDestMode(t,e){return n.chmodSync(t,e)}function setDestTimestamps(t,e){const r=n.statSync(t);return c(e,r.atime,r.mtime)}function onDir(t,e,r,n,i){if(!e)return mkDirAndCopy(t.mode,r,n,i);return copyDir(r,n,i)}function mkDirAndCopy(t,e,r,i){n.mkdirSync(r);copyDir(e,r,i);return setDestMode(r,t)}function copyDir(t,e,r){const i=n.opendirSync(t);try{let n;while((n=i.readSync())!==null){copyDirItem(n.name,t,e,r)}}finally{i.closeSync()}}function copyDirItem(t,e,r,n){const s=i.join(e,t);const c=i.join(r,t);if(n.filter&&!n.filter(s,c))return;const{destStat:a}=o.checkPathsSync(s,c,"copy",n);return getStats(a,s,c,n)}function onLink(t,e,r,s){let c=n.readlinkSync(e);if(s.dereference){c=i.resolve(process.cwd(),c)}if(!t){return n.symlinkSync(c,r)}else{let t;try{t=n.readlinkSync(r)}catch(t){if(t.code==="EINVAL"||t.code==="UNKNOWN")return n.symlinkSync(c,r);throw t}if(s.dereference){t=i.resolve(process.cwd(),t)}if(c!==t){if(o.isSrcSubdir(c,t)){throw new Error(`Cannot copy '${c}' to a subdirectory of itself, '${t}'.`)}if(o.isSrcSubdir(t,c)){throw new Error(`Cannot overwrite '${t}' with '${c}'.`)}}return copyLink(c,r)}}function copyLink(t,e){n.unlinkSync(e);return n.symlinkSync(t,e)}t.exports=copySync},600:(t,e,r)=>{"use strict";const n=r(423);const i=r(928);const{mkdirs:s}=r(552);const{pathExists:c}=r(170);const{utimesMillis:o}=r(213);const a=r(0);const{asyncIteratorConcurrentProcess:u}=r(768);async function copy(t,e,r={}){if(typeof r==="function"){r={filter:r}}r.clobber="clobber"in r?!!r.clobber:true;r.overwrite="overwrite"in r?!!r.overwrite:r.clobber;if(r.preserveTimestamps&&process.arch==="ia32"){process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n"+"\tsee https://github.com/jprichardson/node-fs-extra/issues/269","Warning","fs-extra-WARN0001")}const{srcStat:n,destStat:o}=await a.checkPaths(t,e,"copy",r);await a.checkParentPaths(t,n,e,"copy");const u=await runFilter(t,e,r);if(!u)return;const y=i.dirname(e);const l=await c(y);if(!l){await s(y)}await getStatsAndPerformCopy(o,t,e,r)}async function runFilter(t,e,r){if(!r.filter)return true;return r.filter(t,e)}async function getStatsAndPerformCopy(t,e,r,i){const s=i.dereference?n.stat:n.lstat;const c=await s(e);if(c.isDirectory())return onDir(c,t,e,r,i);if(c.isFile()||c.isCharacterDevice()||c.isBlockDevice())return onFile(c,t,e,r,i);if(c.isSymbolicLink())return onLink(t,e,r,i);if(c.isSocket())throw new Error(`Cannot copy a socket file: ${e}`);if(c.isFIFO())throw new Error(`Cannot copy a FIFO pipe: ${e}`);throw new Error(`Unknown file: ${e}`)}async function onFile(t,e,r,i,s){if(!e)return copyFile(t,r,i,s);if(s.overwrite){await n.unlink(i);return copyFile(t,r,i,s)}if(s.errorOnExist){throw new Error(`'${i}' already exists`)}}async function copyFile(t,e,r,i){await n.copyFile(e,r);if(i.preserveTimestamps){if(fileIsNotWritable(t.mode)){await makeFileWritable(r,t.mode)}const i=await n.stat(e);await o(r,i.atime,i.mtime)}return n.chmod(r,t.mode)}function fileIsNotWritable(t){return(t&128)===0}function makeFileWritable(t,e){return n.chmod(t,e|128)}async function onDir(t,e,r,s,c){if(!e){await n.mkdir(s)}await u(await n.opendir(r),(async t=>{const e=i.join(r,t.name);const n=i.join(s,t.name);const o=await runFilter(e,n,c);if(o){const{destStat:t}=await a.checkPaths(e,n,"copy",c);await getStatsAndPerformCopy(t,e,n,c)}}));if(!e){await n.chmod(s,t.mode)}}async function onLink(t,e,r,s){let c=await n.readlink(e);if(s.dereference){c=i.resolve(process.cwd(),c)}if(!t){return n.symlink(c,r)}let o=null;try{o=await n.readlink(r)}catch(t){if(t.code==="EINVAL"||t.code==="UNKNOWN")return n.symlink(c,r);throw t}if(s.dereference){o=i.resolve(process.cwd(),o)}if(c!==o){if(a.isSrcSubdir(c,o)){throw new Error(`Cannot copy '${c}' to a subdirectory of itself, '${o}'.`)}if(a.isSrcSubdir(o,c)){throw new Error(`Cannot overwrite '${o}' with '${c}'.`)}}await n.unlink(r);return n.symlink(c,r)}t.exports=copy},509:(t,e,r)=>{"use strict";const n=r(282).fromPromise;t.exports={copy:n(r(600)),copySync:r(901)}},817:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(423);const s=r(928);const c=r(552);const o=r(720);const a=n((async function emptyDir(t){let e;try{e=await i.readdir(t)}catch{return c.mkdirs(t)}return Promise.all(e.map((e=>o.remove(s.join(t,e)))))}));function emptyDirSync(t){let e;try{e=i.readdirSync(t)}catch{return c.mkdirsSync(t)}e.forEach((e=>{e=s.join(t,e);o.removeSync(e)}))}t.exports={emptyDirSync:emptyDirSync,emptydirSync:emptyDirSync,emptyDir:a,emptydir:a}},46:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(928);const s=r(423);const c=r(552);async function createFile(t){let e;try{e=await s.stat(t)}catch{}if(e&&e.isFile())return;const r=i.dirname(t);let n=null;try{n=await s.stat(r)}catch(e){if(e.code==="ENOENT"){await c.mkdirs(r);await s.writeFile(t,"");return}else{throw e}}if(n.isDirectory()){await s.writeFile(t,"")}else{await s.readdir(r)}}function createFileSync(t){let e;try{e=s.statSync(t)}catch{}if(e&&e.isFile())return;const r=i.dirname(t);try{if(!s.statSync(r).isDirectory()){s.readdirSync(r)}}catch(t){if(t&&t.code==="ENOENT")c.mkdirsSync(r);else throw t}s.writeFileSync(t,"")}t.exports={createFile:n(createFile),createFileSync:createFileSync}},58:(t,e,r)=>{"use strict";const{createFile:n,createFileSync:i}=r(46);const{createLink:s,createLinkSync:c}=r(196);const{createSymlink:o,createSymlinkSync:a}=r(933);t.exports={createFile:n,createFileSync:i,ensureFile:n,ensureFileSync:i,createLink:s,createLinkSync:c,ensureLink:s,ensureLinkSync:c,createSymlink:o,createSymlinkSync:a,ensureSymlink:o,ensureSymlinkSync:a}},196:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(928);const s=r(423);const c=r(552);const{pathExists:o}=r(170);const{areIdentical:a}=r(0);async function createLink(t,e){let r;try{r=await s.lstat(e)}catch{}let n;try{n=await s.lstat(t)}catch(t){t.message=t.message.replace("lstat","ensureLink");throw t}if(r&&a(n,r))return;const u=i.dirname(e);const y=await o(u);if(!y){await c.mkdirs(u)}await s.link(t,e)}function createLinkSync(t,e){let r;try{r=s.lstatSync(e)}catch{}try{const e=s.lstatSync(t);if(r&&a(e,r))return}catch(t){t.message=t.message.replace("lstat","ensureLink");throw t}const n=i.dirname(e);const o=s.existsSync(n);if(o)return s.linkSync(t,e);c.mkdirsSync(n);return s.linkSync(t,e)}t.exports={createLink:n(createLink),createLinkSync:createLinkSync}},492:(t,e,r)=>{"use strict";const n=r(928);const i=r(423);const{pathExists:s}=r(170);const c=r(282).fromPromise;async function symlinkPaths(t,e){if(n.isAbsolute(t)){try{await i.lstat(t)}catch(t){t.message=t.message.replace("lstat","ensureSymlink");throw t}return{toCwd:t,toDst:t}}const r=n.dirname(e);const c=n.join(r,t);const o=await s(c);if(o){return{toCwd:c,toDst:t}}try{await i.lstat(t)}catch(t){t.message=t.message.replace("lstat","ensureSymlink");throw t}return{toCwd:t,toDst:n.relative(r,t)}}function symlinkPathsSync(t,e){if(n.isAbsolute(t)){const e=i.existsSync(t);if(!e)throw new Error("absolute srcpath does not exist");return{toCwd:t,toDst:t}}const r=n.dirname(e);const s=n.join(r,t);const c=i.existsSync(s);if(c){return{toCwd:s,toDst:t}}const o=i.existsSync(t);if(!o)throw new Error("relative srcpath does not exist");return{toCwd:t,toDst:n.relative(r,t)}}t.exports={symlinkPaths:c(symlinkPaths),symlinkPathsSync:symlinkPathsSync}},126:(t,e,r)=>{"use strict";const n=r(423);const i=r(282).fromPromise;async function symlinkType(t,e){if(e)return e;let r;try{r=await n.lstat(t)}catch{return"file"}return r&&r.isDirectory()?"dir":"file"}function symlinkTypeSync(t,e){if(e)return e;let r;try{r=n.lstatSync(t)}catch{return"file"}return r&&r.isDirectory()?"dir":"file"}t.exports={symlinkType:i(symlinkType),symlinkTypeSync:symlinkTypeSync}},933:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(928);const s=r(423);const{mkdirs:c,mkdirsSync:o}=r(552);const{symlinkPaths:a,symlinkPathsSync:u}=r(492);const{symlinkType:y,symlinkTypeSync:l}=r(126);const{pathExists:f}=r(170);const{areIdentical:m}=r(0);async function createSymlink(t,e,r){let n;try{n=await s.lstat(e)}catch{}if(n&&n.isSymbolicLink()){const[r,n]=await Promise.all([s.stat(t),s.stat(e)]);if(m(r,n))return}const o=await a(t,e);t=o.toDst;const u=await y(o.toCwd,r);const l=i.dirname(e);if(!await f(l)){await c(l)}return s.symlink(t,e,u)}function createSymlinkSync(t,e,r){let n;try{n=s.lstatSync(e)}catch{}if(n&&n.isSymbolicLink()){const r=s.statSync(t);const n=s.statSync(e);if(m(r,n))return}const c=u(t,e);t=c.toDst;r=l(c.toCwd,r);const a=i.dirname(e);const y=s.existsSync(a);if(y)return s.symlinkSync(t,e,r);o(a);return s.symlinkSync(t,e,r)}t.exports={createSymlink:n(createSymlink),createSymlinkSync:createSymlinkSync}},423:(t,e,r)=>{"use strict";const n=r(282).fromCallback;const i=r(24);const s=["access","appendFile","chmod","chown","close","copyFile","cp","fchmod","fchown","fdatasync","fstat","fsync","ftruncate","futimes","glob","lchmod","lchown","lutimes","link","lstat","mkdir","mkdtemp","open","opendir","readdir","readFile","readlink","realpath","rename","rm","rmdir","stat","statfs","symlink","truncate","unlink","utimes","writeFile"].filter((t=>typeof i[t]==="function"));Object.assign(e,i);s.forEach((t=>{e[t]=n(i[t])}));e.exists=function(t,e){if(typeof e==="function"){return i.exists(t,e)}return new Promise((e=>i.exists(t,e)))};e.read=function(t,e,r,n,s,c){if(typeof c==="function"){return i.read(t,e,r,n,s,c)}return new Promise(((c,o)=>{i.read(t,e,r,n,s,((t,e,r)=>{if(t)return o(t);c({bytesRead:e,buffer:r})}))}))};e.write=function(t,e,...r){if(typeof r[r.length-1]==="function"){return i.write(t,e,...r)}return new Promise(((n,s)=>{i.write(t,e,...r,((t,e,r)=>{if(t)return s(t);n({bytesWritten:e,buffer:r})}))}))};e.readv=function(t,e,...r){if(typeof r[r.length-1]==="function"){return i.readv(t,e,...r)}return new Promise(((n,s)=>{i.readv(t,e,...r,((t,e,r)=>{if(t)return s(t);n({bytesRead:e,buffers:r})}))}))};e.writev=function(t,e,...r){if(typeof r[r.length-1]==="function"){return i.writev(t,e,...r)}return new Promise(((n,s)=>{i.writev(t,e,...r,((t,e,r)=>{if(t)return s(t);n({bytesWritten:e,buffers:r})}))}))};if(typeof i.realpath.native==="function"){e.realpath.native=n(i.realpath.native)}else{process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?","Warning","fs-extra-WARN0003")}},643:(t,e,r)=>{"use strict";t.exports={...r(423),...r(509),...r(817),...r(58),...r(342),...r(552),...r(29),...r(34),...r(170),...r(720)}},342:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(424);i.outputJson=n(r(472));i.outputJsonSync=r(618);i.outputJSON=i.outputJson;i.outputJSONSync=i.outputJsonSync;i.writeJSON=i.writeJson;i.writeJSONSync=i.writeJsonSync;i.readJSON=i.readJson;i.readJSONSync=i.readJsonSync;t.exports=i},424:(t,e,r)=>{"use strict";const n=r(395);t.exports={readJson:n.readFile,readJsonSync:n.readFileSync,writeJson:n.writeFile,writeJsonSync:n.writeFileSync}},618:(t,e,r)=>{"use strict";const{stringify:n}=r(366);const{outputFileSync:i}=r(34);function outputJsonSync(t,e,r){const s=n(e,r);i(t,s,r)}t.exports=outputJsonSync},472:(t,e,r)=>{"use strict";const{stringify:n}=r(366);const{outputFile:i}=r(34);async function outputJson(t,e,r={}){const s=n(e,r);await i(t,s,r)}t.exports=outputJson},552:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const{makeDir:i,makeDirSync:s}=r(974);const c=n(i);t.exports={mkdirs:c,mkdirsSync:s,mkdirp:c,mkdirpSync:s,ensureDir:c,ensureDirSync:s}},974:(t,e,r)=>{"use strict";const n=r(423);const{checkPath:i}=r(9);const getMode=t=>{const e={mode:511};if(typeof t==="number")return t;return{...e,...t}.mode};t.exports.makeDir=async(t,e)=>{i(t);return n.mkdir(t,{mode:getMode(e),recursive:true})};t.exports.makeDirSync=(t,e)=>{i(t);return n.mkdirSync(t,{mode:getMode(e),recursive:true})}},9:(t,e,r)=>{"use strict";const n=r(928);t.exports.checkPath=function checkPath(t){if(process.platform==="win32"){const e=/[<>:"|?*]/.test(t.replace(n.parse(t).root,""));if(e){const e=new Error(`Path contains invalid characters: ${t}`);e.code="EINVAL";throw e}}}},29:(t,e,r)=>{"use strict";const n=r(282).fromPromise;t.exports={move:n(r(816)),moveSync:r(610)}},610:(t,e,r)=>{"use strict";const n=r(24);const i=r(928);const s=r(509).copySync;const c=r(720).removeSync;const o=r(552).mkdirpSync;const a=r(0);function moveSync(t,e,r){r=r||{};const n=r.overwrite||r.clobber||false;const{srcStat:s,isChangingCase:c=false}=a.checkPathsSync(t,e,"move",r);a.checkParentPathsSync(t,s,e,"move");if(!isParentRoot(e))o(i.dirname(e));return doRename(t,e,n,c)}function isParentRoot(t){const e=i.dirname(t);const r=i.parse(e);return r.root===e}function doRename(t,e,r,i){if(i)return rename(t,e,r);if(r){c(e);return rename(t,e,r)}if(n.existsSync(e))throw new Error("dest already exists.");return rename(t,e,r)}function rename(t,e,r){try{n.renameSync(t,e)}catch(n){if(n.code!=="EXDEV")throw n;return moveAcrossDevice(t,e,r)}}function moveAcrossDevice(t,e,r){const n={overwrite:r,errorOnExist:true,preserveTimestamps:true};s(t,e,n);return c(t)}t.exports=moveSync},816:(t,e,r)=>{"use strict";const n=r(423);const i=r(928);const{copy:s}=r(509);const{remove:c}=r(720);const{mkdirp:o}=r(552);const{pathExists:a}=r(170);const u=r(0);async function move(t,e,r={}){const n=r.overwrite||r.clobber||false;const{srcStat:s,isChangingCase:c=false}=await u.checkPaths(t,e,"move",r);await u.checkParentPaths(t,s,e,"move");const a=i.dirname(e);const y=i.parse(a);if(y.root!==a){await o(a)}return doRename(t,e,n,c)}async function doRename(t,e,r,i){if(!i){if(r){await c(e)}else if(await a(e)){throw new Error("dest already exists.")}}try{await n.rename(t,e)}catch(n){if(n.code!=="EXDEV"){throw n}await moveAcrossDevice(t,e,r)}}async function moveAcrossDevice(t,e,r){const n={overwrite:r,errorOnExist:true,preserveTimestamps:true};await s(t,e,n);return c(t)}t.exports=move},34:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(423);const s=r(928);const c=r(552);const o=r(170).pathExists;async function outputFile(t,e,r="utf-8"){const n=s.dirname(t);if(!await o(n)){await c.mkdirs(n)}return i.writeFile(t,e,r)}function outputFileSync(t,...e){const r=s.dirname(t);if(!i.existsSync(r)){c.mkdirsSync(r)}i.writeFileSync(t,...e)}t.exports={outputFile:n(outputFile),outputFileSync:outputFileSync}},170:(t,e,r)=>{"use strict";const n=r(282).fromPromise;const i=r(423);function pathExists(t){return i.access(t).then((()=>true)).catch((()=>false))}t.exports={pathExists:n(pathExists),pathExistsSync:i.existsSync}},720:(t,e,r)=>{"use strict";const n=r(24);const i=r(282).fromCallback;function remove(t,e){n.rm(t,{recursive:true,force:true},e)}function removeSync(t){n.rmSync(t,{recursive:true,force:true})}t.exports={remove:i(remove),removeSync:removeSync}},768:t=>{"use strict";async function asyncIteratorConcurrentProcess(t,e){const r=[];for await(const n of t){r.push(e(n).then((()=>null),(t=>t??new Error("unknown error"))))}await Promise.all(r.map((t=>t.then((t=>{if(t!==null)throw t})))))}t.exports={asyncIteratorConcurrentProcess:asyncIteratorConcurrentProcess}},0:(t,e,r)=>{"use strict";const n=r(423);const i=r(928);const s=r(282).fromPromise;function getStats(t,e,r){const i=r.dereference?t=>n.stat(t,{bigint:true}):t=>n.lstat(t,{bigint:true});return Promise.all([i(t),i(e).catch((t=>{if(t.code==="ENOENT")return null;throw t}))]).then((([t,e])=>({srcStat:t,destStat:e})))}function getStatsSync(t,e,r){let i;const s=r.dereference?t=>n.statSync(t,{bigint:true}):t=>n.lstatSync(t,{bigint:true});const c=s(t);try{i=s(e)}catch(t){if(t.code==="ENOENT")return{srcStat:c,destStat:null};throw t}return{srcStat:c,destStat:i}}async function checkPaths(t,e,r,n){const{srcStat:s,destStat:c}=await getStats(t,e,n);if(c){if(areIdentical(s,c)){const n=i.basename(t);const o=i.basename(e);if(r==="move"&&n!==o&&n.toLowerCase()===o.toLowerCase()){return{srcStat:s,destStat:c,isChangingCase:true}}throw new Error("Source and destination must not be the same.")}if(s.isDirectory()&&!c.isDirectory()){throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`)}if(!s.isDirectory()&&c.isDirectory()){throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`)}}if(s.isDirectory()&&isSrcSubdir(t,e)){throw new Error(errMsg(t,e,r))}return{srcStat:s,destStat:c}}function checkPathsSync(t,e,r,n){const{srcStat:s,destStat:c}=getStatsSync(t,e,n);if(c){if(areIdentical(s,c)){const n=i.basename(t);const o=i.basename(e);if(r==="move"&&n!==o&&n.toLowerCase()===o.toLowerCase()){return{srcStat:s,destStat:c,isChangingCase:true}}throw new Error("Source and destination must not be the same.")}if(s.isDirectory()&&!c.isDirectory()){throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`)}if(!s.isDirectory()&&c.isDirectory()){throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`)}}if(s.isDirectory()&&isSrcSubdir(t,e)){throw new Error(errMsg(t,e,r))}return{srcStat:s,destStat:c}}async function checkParentPaths(t,e,r,s){const c=i.resolve(i.dirname(t));const o=i.resolve(i.dirname(r));if(o===c||o===i.parse(o).root)return;let a;try{a=await n.stat(o,{bigint:true})}catch(t){if(t.code==="ENOENT")return;throw t}if(areIdentical(e,a)){throw new Error(errMsg(t,r,s))}return checkParentPaths(t,e,o,s)}function checkParentPathsSync(t,e,r,s){const c=i.resolve(i.dirname(t));const o=i.resolve(i.dirname(r));if(o===c||o===i.parse(o).root)return;let a;try{a=n.statSync(o,{bigint:true})}catch(t){if(t.code==="ENOENT")return;throw t}if(areIdentical(e,a)){throw new Error(errMsg(t,r,s))}return checkParentPathsSync(t,e,o,s)}function areIdentical(t,e){return e.ino!==undefined&&e.dev!==undefined&&e.ino===t.ino&&e.dev===t.dev}function isSrcSubdir(t,e){const r=i.resolve(t).split(i.sep).filter((t=>t));const n=i.resolve(e).split(i.sep).filter((t=>t));return r.every(((t,e)=>n[e]===t))}function errMsg(t,e,r){return`Cannot ${r} '${t}' to a subdirectory of itself, '${e}'.`}t.exports={checkPaths:s(checkPaths),checkPathsSync:checkPathsSync,checkParentPaths:s(checkParentPaths),checkParentPathsSync:checkParentPathsSync,isSrcSubdir:isSrcSubdir,areIdentical:areIdentical}},213:(t,e,r)=>{"use strict";const n=r(423);const i=r(282).fromPromise;async function utimesMillis(t,e,r){const i=await n.open(t,"r+");let s=null;try{await n.futimes(i,e,r)}finally{try{await n.close(i)}catch(t){s=t}}if(s){throw s}}function utimesMillisSync(t,e,r){const i=n.openSync(t,"r+");n.futimesSync(i,e,r);return n.closeSync(i)}t.exports={utimesMillis:i(utimesMillis),utimesMillisSync:utimesMillisSync}},395:(t,e,r)=>{let n;try{n=r(24)}catch(t){n=r(896)}const i=r(282);const{stringify:s,stripBom:c}=r(366);async function _readFile(t,e={}){if(typeof e==="string"){e={encoding:e}}const r=e.fs||n;const s="throws"in e?e.throws:true;let o=await i.fromCallback(r.readFile)(t,e);o=c(o);let a;try{a=JSON.parse(o,e?e.reviver:null)}catch(e){if(s){e.message=`${t}: ${e.message}`;throw e}else{return null}}return a}const o=i.fromPromise(_readFile);function readFileSync(t,e={}){if(typeof e==="string"){e={encoding:e}}const r=e.fs||n;const i="throws"in e?e.throws:true;try{let n=r.readFileSync(t,e);n=c(n);return JSON.parse(n,e.reviver)}catch(e){if(i){e.message=`${t}: ${e.message}`;throw e}else{return null}}}async function _writeFile(t,e,r={}){const c=r.fs||n;const o=s(e,r);await i.fromCallback(c.writeFile)(t,o,r)}const a=i.fromPromise(_writeFile);function writeFileSync(t,e,r={}){const i=r.fs||n;const c=s(e,r);return i.writeFileSync(t,c,r)}t.exports={readFile:o,readFileSync:readFileSync,writeFile:a,writeFileSync:writeFileSync}},366:t=>{function stringify(t,{EOL:e="\n",finalEOL:r=true,replacer:n=null,spaces:i}={}){const s=r?e:"";const c=JSON.stringify(t,n,i);return c.replace(/\n/g,e)+s}function stripBom(t){if(Buffer.isBuffer(t))t=t.toString("utf8");return t.replace(/^\uFEFF/,"")}t.exports={stringify:stringify,stripBom:stripBom}},282:(t,e)=>{"use strict";e.fromCallback=function(t){return Object.defineProperty((function(...e){if(typeof e[e.length-1]==="function")t.apply(this,e);else{return new Promise(((r,n)=>{e.push(((t,e)=>t!=null?n(t):r(e)));t.apply(this,e)}))}}),"name",{value:t.name})};e.fromPromise=function(t){return Object.defineProperty((function(...e){const r=e[e.length-1];if(typeof r!=="function")return t.apply(this,e);else{e.pop();t.apply(this,e).then((t=>r(null,t)),r)}}),"name",{value:t.name})}},896:t=>{"use strict";t.exports=require("fs")},24:t=>{"use strict";t.exports=require("node:fs")},928:t=>{"use strict";t.exports=require("path")}};var e={};function __nccwpck_require__(r){var n=e[r];if(n!==undefined){return n.exports}var i=e[r]={exports:{}};var s=true;try{t[r](i,i.exports,__nccwpck_require__);s=false}finally{if(s)delete e[r]}return i.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var r=__nccwpck_require__(643);module.exports=r})();